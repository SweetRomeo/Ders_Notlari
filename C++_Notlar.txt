İçindekiler:
C++ Dilinin Genel Tanıtımı
✅ C++ dilinin tarihçesi
✅ C++ dili ve programlama paradigmaları
✅ C++ dili standartları
✅ C++98 – 03
✅ C++11
✅ C++14
✅ C++17
✅ C++20
✅ eski C++ ve modern C++

C Dili ve C++ İçindeki C Dili (C in C++)
✅ C dilinden C++ diline geçiş
✅ işlev bildirimleri ve tanımlamalarına ilişkin farklılıklar
✅ türlere ve tür dönüşümlerine ilişkin farklılıklar
✅ C’de geçerli C++’da geçersiz durumlar
✅ C99 ve C++

Temel Kavramlar (Basic Concepts)
✅ tamamlanmış ve eksik türler (complete & incomplete types)
✅ tek tanımlama kuralı (one definition rule)
✅ ifadelerin değer kategorileri (value categories)
✅ tanımsız davranış (undefined behavior)
✅ derleyiciye bağlı davranışlar. (implementation defined & implementaion specified)
✅ derleyici eklentileri (compiler extensions)
✅ kapsam (scope) ve isim arama (name lookup)
✅ erişim kontrolü (access control)
✅ çift anlamlılık hatası (ambiguity)

İlk Değer Verme (Initialization)
✅ eş biçimli ilk değer verme (uniform initialization)
✅ daraltıcı dönüşümler (narrowing conversions)
✅ most vexing parse
✅ doğrudan ilk değer verme (direct intialization)
✅ değerle başlatma value initialization
✅ kopyalama ile ilk değer verme (copy initialization)
✅ varsayılan ilk değer verme (default initialization)
✅ bileşiklere ilk değer verme (aggregate initialization)

Tür Çıkarımı (Type Deduction)
✅ auto belirteci ile tür çıkarımı (auto type deduction)
✅ decltype belirteci ile tür çıkarımı (decltype type deduction)
✅ sonradan gelen geri dönüş türü (trailing return type)
✅ auto geri dönüş değeri türü (auto return type)
✅ decltype auto tür çıkarımı (decltype auto)

kapsamlandırılmış enum türleri (scoped enums)
✅ geleneksel enum türleri (conventional enum types)
✅ baz tür seçimi (underlying type)
✅ tür dönüşümleri (type conversions)
✅ enum türleri kapsam (enum classes & scope)
✅ using enum declarations (C++20)

Sabit İfadeleri (Constant Expressions)
✅ const anahtar sözcüğü ve const semantiği (const keyword & const semantics)
✅ const nesneler (const objects)
✅ constexpr anahtar sözcüğü (constexpr keyword)
✅ constexpr işlevler (constexpr functions)
✅ consteval işlevler - C++20 (consteval functions - C++20)
✅ constinit anahtar sözcüğü - C++20

İşlevlerin Varsayılan Argüman Alması (Default Arguments)
Referans Semantiği (Reference Semantics)
✅ sol taraf referansları (L value references) int& l = x;
✅ sağ taraf referansları (R value references)  int&& r = 10;
✅ referanslar ve const semantiği (references & const semantics)
✅ referanslar ile göstericilerin (pointer) karşılaştırılması
✅ parametresi referans olan işlevler
✅ referans döndüren işlevler
✅ referanslar ve life extension

İşlev Yüklemesi (Function Overloading)
✅ genel kurallar
✅ yüklenmiş işlev çözümlenmesi (function overload resolution)
✅ const yüklemesi (const overloading)
✅ extern "C" bildirimi (extern C declarations)
✅ işlev yüklemesinde dikkat edilmesi gereken durumlar

Tür Dönüştürme Operatörleri (Type-cast Operators)
✅ static_cast<> operatörü
✅ const_cast<> operatörü
✅ reinterpret_cast<> operatörü
✅ dynamic_cast<> operatörü (kalıtım başlığı altında)

inline işlevler ve inline değişkenler
✅ inline işlevler (inline functions)
✅ inline değişkenler (C++17) (inline variables)

Sınıflara giriş (Introduction to Classes)
✅ sınıf kapsamı (class scope)
✅ sınıflar ve isim arama (name lookup)
✅ erişim kontrolü (access control) ve veri gizleme (data hiding)
    ❇️ public öğeler (public members)
    ❇️ private öğeler (private members)
    ❇️ protected öğeler (protected members)
✅ sınıfların öğeleri (class members)
    ❇️ sınıfların veri öğeleri (data members)
        ⦿ non-static veri öğeleri
        ⦿ mutable veri öğeleri
        ⦿ static veri öğeleri
    ❇️ sınıfların üye işlevleri
        ⦿ non-static üye işlevler
        ⦿ const üye işlevler
        ⦿ static üye işlevler
    ❇️ this göstericisi ve *this
    ❇️ sınıfların tür öğeleri (type members)
✅ sınıfların kurucu işlevleri (constructors)
    ❇️ kurucu işlev ilk değer verme listesi (constructor initializer list)
    ❇️ delege eden kurucu işlevler (delegating constructors)
    ❇️ explicit kurucu işlevler (explicit constructors)
✅ sınıfların sonlandırıcı işlevleri (destructors)
✅ üye işlevlerin çağrılması
✅ sınıflar ve const doğruluğu (classes & const correctness)
    ❇️ const sınıf nesneleri (const objects)
    ❇️ const üye fonksiyonlar (const member functions)
✅ geçici sınıf nesneleri (temporary objects)
✅ otomatik tür dönüşümleri (implicit type conversions)
✅ mutable anahtar sözcüğü
✅ friend bildirimi (friend declarations)
    ❇️ friend bildirimi ve veri gizleme
    ❇️ global işlevlere friend bildirimi
    ❇️ sınıfların üye işlevlerine friend bildirimi
    ❇️ sınıflara friend bildirimi
    ❇️ attorney client idiomu

Sınıfların Özel Üye İşlevleri ve Kopyalama İşlemleri (Special Member Functions & Copy Control)
✅ sınıfların özel işlevleri (special member functions)
    ❇️ default constructor (varsayılan kurucu işlev)
    ❇️ destructor (sonlandırıcı işlev)
    ❇️ copy constructor (kopyalayan kurucu işlev)
    ❇️ move constructor (taşıyan kurucu işlev)
    ❇️ copy assignment (kopyalayan atama işlevi)
    ❇️ move assignment (taşıyan atama işlevi)
✅ özel işlevlerin default edilmesi
✅ özel işlevlerin delete edilmesi
✅ sınıflar ve taşıma semantiği (move semantics)
✅ rule of zero
✅ rule of five
✅ kopyala takas et idiyomu (copy & swap idiom)
✅ kopyalamanın eliminasyonu (copy elision)
    ❇️ geçici nesneler yoluyla kopyalama eliminasyonu (copy elision by temporaries)
    ❇️ RVO (return value optimization)
    ❇️ NRVO (names return value optimization)
    ❇️ zorunlu kopyalama eliminasyonu (mandatory copy elision)

Operatör Yüklemesi (Operator Overloading)
✅ operatör yüklemesine ilişkin genel kurallar
✅ üye operatör fonksiyonları (member operator functions)
✅ global operatör fonksiyonları (global operator functions)
✅ aritmetik operatörlerin yüklenmesi
✅ karşılaştırma operatörlerinin yüklenmesi
✅ 3 yollu karşılaştırma operatörü (3-way comparision operator) C++20
✅ "++" ve "--" operatörlerinin yüklenmesi
✅ ok operatörü ve içerik operatörlerinin yüklenmesi (overloading of arrow and dereferencing operators)
✅ [] operatörünün yüklenmesi (overloading of subscript operator)
✅ fonksiyon çağrı operatörünün yüklenmesi (overloading of function call operator)
✅ tür dönüştürme operatör fonksiyonları (type-cast operator functions)
✅ programcının tanımladığı sabitler (user-defined literals)

Dinamik Ömürlü Nesneler (Dynamic Objects)
✅ new ve delete ifadeleri (new & delete expressions)
✅ new[] ve delete [] ifadeleri
✅ operator new işlevleri
✅ operator delete işlevleri
✅ operator new ve operator delete işlevlerinin yüklenmesi
✅ std::bad_alloc
✅ std::set_new_handler ve std::get_new_handler işlevleri
✅ placement new operatörleri
✅ nothrow new

Tür Eş İsimleri (Type Alias)
✅ typedef bildirimleri
✅ using bildirimleri

İsim Alanları (Namespaces)
✅ isim alanlarının oluşturulması
✅ isim alanları ve isim arama (namespaces & name lookup)
✅ çözünürlük operatörü ve isim alanları (scope resoşution operator & namespaces)
✅ using bildirimi (using declaration)
✅ using namespace direktifi (using namespace directive)
✅ argümana bağlı isim arama (argument dependent lookup)
✅ isimsiz isim alanı (unnamed namespace)
✅ içsel isim alanları (nested namespaces)
✅ inline isim alanları (inline namespaces)
✅ isim alanı eş ismi (namespace alias)
✅ işlev yüklemesi ve isim alanları (function overloading & namespaces)

Sınıflar ve Kalıtım (Classes & Inheritance)
✅ nesne yönelimli programlama ve kalıtım (OOP & inheritance)
✅ public kalıtımı (public inheritance)
✅ çalışma zamanı çok biçimliliği (runtime polymorphism)
    ❇️ dinamik ve statik tür bilgisi (static & dynamic type)
    ❇️ sanal işlevler (virtual function)
    ❇️ saf sanal işlevler (pure virtual function)
    ❇️ sanal sonlandırıcı işlev (virtual destructor)
    ❇️ sanal kurucu işlev idiyomu (virtual constructor idiom)
    ❇️ override bağlamsal anahtar sözcüğü
    ❇️ sanal gönderim mekanizmasının implementasyonu (implementation of virtual dispatch mechanism)
    ❇️ nesne dilimlenmesi (object slicing)
    ❇️ sanal olmayan arayüz idiyomu (non-virtual interface idiom)
✅ final bağlamsal anahtar sözcüğü (final contextual keyword)
    ❇️ final sınıflar (final classes)
    ❇️ final override
✅ çoklu kalıtım (multiple inheritance)
    ❇️ çoklu kalıtımda kapsam ve isim arama_(multiple inheritance & name lookup)_
    ❇️ çoklu kalıtımda sınıfın özel işlevleri
    ❇️ elmas formasyonu (diamond formation)
    ❇️ sanal kalıtım (virtual inheritance)
    ❇️ çoklu kalıtım ve kalıtımla alınan kurucu işlevler
    ❇️ çoklu kalıtımda kopyalama ve taşıma işlemleri
✅ private kalıtımı (private inheritance)
    ❇️ implementaion inheritance
    ❇️ empty base optimization
✅ protected kalıtımı (protected inheritance)
✅ sınıf içi using bildirimi
✅ kalıtımla alınan kurucu işlevler (inherited constructors)
✅ mixin sınıflar (mixin classes)

Olağan Dışı Durumların İşlenmesi (Exception Handling)
✅ exception güvenliği (exception safety)
✅ hata nesnelerinin gönderilmesi (throwing exception objects)
    ❇️ throw deyimi (throw statement)
    ❇️ rethrow deyimi (rethrow statement)
✅ try blokları
✅ catch blokları
    ❇️ catch all
✅ yakalanamayan hata nesnesi (uncaught exception)
✅ std::terminate ve std::set_terminate işlevleri
✅ hata nesnesinin yeniden gönderilmesi (rethrow statement)
✅ yığının geri sarımı (stack unwinding)
✅ kurucu işlevlerden exception gönderimi
✅ sonlandırıcı işlevler ve hata gönderimi
✅ exception handling ve kalıtım (exception handling & inheritance)
✅ exception handling ve dinamik ömürlü sınıf nesneleri (eception handling & dynamic objects)
✅ exception güvenliği için akıllı göstericilerin kullanımı (eception handling & smart pointers)
✅ işlev try blokları (function try block)
✅ noexcept belirleyicisi (noexcept specifier)
✅ beklenmeyen hata nesnesi (unexpected excetion)
✅ std::unexpected_exception
✅ std::exception sınıfı ve hiyerarşisi
    ❇️ std::exception sınıfı ve what sanal fonksiyonu
    ❇️ std::logic_error
        ⦿ std::invalid_argument, std::domain_error, std::length_error<, std::out_of_range, std::future_error sınıfları
    ❇️ std::runtime_error
        ⦿ std::range_error, std::overflow_error, std::underflow_error sınıfları
    ❇️ std::system_error
    ❇️ std::regex_error
    ❇️ std::bad_alloc
    ❇️ std::bad_typeid
    ❇️ std::bad_cast
    ❇️ std::bad_exception
    ❇️ std::bad_weak_ptr
    ❇️ std::bad_function_call
✅ kendi hata sınıflarımızı oluşturmak (custom exception classes)
✅ exception garantileri (eception guarantees)
    ❇️ basic exception guarantee
    ❇️ strong exception guarantee
    ❇️ no throw guarantee
✅ std::current_exception
✅ std::exception_ptr
✅ std::rethrow_exception

Çalışma Zamanında Tür Belirlenmesi (RTTI)
✅ dynamic_cast operatörü
✅ typeid operatörü
✅ std::typeinfo sınıfı
✅ std::bad_typeid

std::string sınıfı
✅ genel kavramlar
✅ string::size_type
✅ string::npos
✅ arama işlevleri
✅ set işlemleri
✅ erişim işlemleri
✅ karşılaştırma işlevleri (comparision functions)
✅ sayısal dönüşüm işlevleri (numeric conversions)
✅ küçük string optimizasyonu (small string optimization)
✅ bir STL kabı olaral string sınıfı (string class as STL container)

Bileşik Nesneler (Composition)
✅ öğe olan nesneler ve özel işlevler, kopyalama kontrolü.
✅ öğe olan nesneler ve erişim kontrolü
✅ bileşik nesnelerin kullanıldığı temalar

İçsel türler (Type Members)
✅ sınıf içinde yapılan eş isim bildirimleri
✅ içsel sınıflar (nested classes)
    ❇️ erişim kontrolü (access control)
    ❇️ pimpl idiyomu (pimpl idiom)

Şablonlar (Templates)
✅ şablon tür parametreleri (template type parameters)
✅ şablon sabit parametreleri (template non-type parameters)
✅ şablon şablon parametreleri (template template parameters)
✅ şablon argümanları (template arguments)
    ❇️ belirtilmiş template argümanları (explicit template arguments)
    ❇️ varsayılan template argümanları (default template arguments)
✅ şablonlardan kod üretimi (template instantiation)
✅ fonksiyon şablonları (function templates)
    ❇️ fonksiyon şablonlarında tür çıkarımı (function template argument deduction)
    ❇️ fonksiyon şablonlarının yüklenmesi (function template overloading)
✅ sınıf şablonları (class templates)
✅ kurucu işlev ile tür çıkarımı (CTAD) (C++17)
✅ üye şablonlar (member templates)
✅ şablonların özelleştirilmesi (template specialization)
    ❇️ tam özelleştirme (explicit/full specialization)
    ❇️ kısmi özelleştirme (partial specialization)
✅ sfinae
✅ değişken sayıda parametreli şablonlar (variadic templates)
✅ mükemmel gönderim (perfect forwarding)
✅ katlama ifadeleri(C++17) (fold expressions)
✅ if constexpr
✅ değişken şablonları (variable templates)
✅ eş isim şablonları (alias templates)

İteratörler (Iterators)
✅ aralık kavramı (ranges)
✅ iteratörlerin kategorileri (iterator categories)
    ❇️ input iterator
    ❇️ output iterator
    ❇️ forward iterator
    ❇️ bidirectional iterator
    ❇️ random access iterator
✅ kapların begin ve end işlevleri
✅ global begin ve end işlevleri
✅ iterator işlevleri
    ❇️ std::next
    ❇️ std::prev
    ❇️ std::iter_swap
    ❇️ std::advance
    ❇️ std::distance
✅ iterator uyumlandırıcıları (iterator adaptors)
    ❇️ akım iteratörleri (stream iterators)
        ⦿ istream_iterator
        ⦿ ostream_iterator
        ⦿ istreambuf_iterator
        ⦿ ostreambuf_iterator
    ❇️ reverse iterators
    ❇️ move iterators
    ❇️ insert iterators
        ⦿ back_insert_iterator
        ⦿ front_insert_iterator
        ⦿ insert_iterator
✅ iterator traits

Kaplar (Containers)
✅ STL kapları ve veri yapıları (STL containers & data structures)
✅ sıralı kaplar (sequence containers)
    ❇️ std::vector
    ❇️ std::deque
    ❇️ std::string
    ❇️ std::array
    ❇️ std::list
    ❇️ std::forward_list
✅ ilişkisel kaplar (associative containers)
    ❇️ std::set
    ❇️ std::multiset
    ❇️ std::map
    ❇️ std::multimap
✅ sırasız ilişkisel kaplar (unordered containers)
    ❇️ std::unordered_set
    ❇️ std::unordered_multiset
    ❇️ std::unordered_map
    ❇️ std::unordered_multimap
✅ kapların tür öğeleri (type members of containers)
✅ kapların emplace işlevleri

Kap Uyumlandırıcıları (Container Adaptors)
✅ std::stack
✅ std::queue
✅ std::priority_queue

Algoritmalar (Algorithms)
✅ algoritmaların temel özellikleri ve genel ilkeler
✅ salt okuyan algoritmalar non-modifying algorithms)
✅ kap öğelerini değiştiren algoritmalar (modifying algorithms)
✅ kap öğelerini konumlandıran algoritmalar (mutating algorithms)
✅ sıralama ile ilgili algoritmalar (sorting algorithms)
✅ sıralanmış aralıklar üzerinde koşturulan algoritmalar (sorted range algorithms)
✅ nümerik algoritmalar (numeric algorithms)
✅ algoritmaların lambda ifadelerini kullanması

Lambda İfadeleri (Lambda Expressions)
✅ kapanış türleri ve kapanış nesneleri (closure types and closure objects)
✅ lambda ifadeleri ve tür çıkarımı (lambda expressions and type deduction)
✅ lambda yakalama ifadeleri (lambda captures)
✅ lambda init capture
✅ capture this
✅ capture *this
✅ mutable lambdalar
✅ trailing return type
✅ genelleştirilmiş lambda ifadeleri (generalized lambda expressions)
✅ algoritmalarda lambda ifadelerinin kullanımı
✅ lambda ifadeleri C++11/14/17/20
✅ lambda idiyomları (lambda idioms)

Akıllı Gösterici Sınıfları (Standard Smart Pointer Classes)
✅ std::unique_ptr sınıfı
    ❇️ std::make_unique işlev şablonu
    ❇️ std::default_delete ve custom deleters
    ❇️ tipik hatalar
✅ std::shared_ptr sınıfı
    ❇️ referans sayımı (reference counting)
    ❇️ std::make_shared işlev şablonu
    ❇️ std::weak_ptr sınıfı


Standart Giriş Çıkış Kütüphanesi (iostream Library)
✅ giriş çıkış akımlarına ilişkin standart sınıflar (standard stream classes)
✅ global akım nesneleri (global stream objects)
✅ formatlı giriş çıkış işlemleri (formatted input output)
✅ << ve >> operatörlerinin yüklenmesi (inserter & extractors)
✅ formatlama ve formatlama işlemleri (formatting)
✅ manipülatörler (manipulators)
✅ akımın durumu (condition states)
✅ string akımları (string streams)
✅ dosya işlemleri (file operations)
✅ formatsız giriş ve çıkış işlemleri (unformatted input output)
✅ bellek üstünde yapılan giriş çıkış işlemleri (in-memory input output operations)

Bazı önemli STL Öğelerinin Tanıtımı
✅ std::pair
✅ std::tuple
✅ std::initializer_list
✅ std::bitset
✅ std::regex
✅ type_traits kütüphanesi
✅ std::allocator
✅ std::ratio
✅ std::chrono
✅ standart random kütüphanesi
✅ std::string_view sınıfı (C++17)
✅ std::optional sınıfı (C++17)
✅ std::variant sınıfı (C++17)
✅ std::any sınıfı (C++17)
✅ std::byte (C++17)
✅ std::invoke
✅ std::apply

Tamamlayıcı Araçlar ve Sentaks Öğeleri
✅ aralık tabanlı for döngüleri (range based for loops)
✅ ilk değer vermeli if ve switch deyimleri (if/switch with initializers)
✅ static_assert
✅ decltype(auto) tür çıkarımı
✅ std::declval
✅ üye fonksiyon göstericileri (member function pointers)
✅ ham string sabitleri (raw string literals)
✅ ikilik sayı sisteminde yazılan sabitler (binary literals)
✅ basamak ayırıcısı (digit seperator)
✅ ilk değer vermeli if deyimi (C++17) (if with initializer)
✅ ilk değer vermeli switch deyimi (C++17) (switch with initializer)
✅ alignas belirteci (alignas specifier)
✅ alignof operatörü (alignof operator)
✅ yapısal bağlama (C++17)(structural binding)
✅ attribute’lar (attributes)

Concurrency
✅ memory model
✅ thread’ler ve thread yönetimi
✅ std::this_thread isim alanı
✅ data race kavramı ve data_race’den kaçınma
✅ standart mutex sınıfları ve mutex işlemleri
✅ lock_guard ve unique_lock sınıfları
✅ std::condition_variable sınıfı
✅ std::future ve std::promise sınıfları
✅ std::async işlevi
✅ atomik türler (atomic types)
✅ görev tabanlı (task based) programlama
✅ std::packaged_task sınıfı
✅ paralel STL algoritmaları

Giriş:

C++ Dilinin Tarihsel gelişimi
C++, 1979 yılında Bell Labs'ta Bjarne Stroustrup tarafından geliştirilen, yüksek seviyeli,
genel amaçlı bir programlama dili. C programlama dili ile object-oriented ve generic programlama
özellikleri eklenerek geliştirilmiştir.
İlk olarak "Sınıflar ile C(C with classes)" olarak adlandırılan C++, başlangıçta sistem ve
uygulama programlama için kullanılmak üzere tasarlandı. 1983 yılında ise adı C++ olarak değiştirildi
ve ilk ticari sürümü 1985 yılında yayınlandı.
Yıllar içinde, C++ ISO tarafından birçok standartlaştırma girişimine tabi tutuldu ve sistem programlama,
oyun geliştirme ve bilimsel hesaplama gibi çeşitli uygulamalar için yaygın olarak kullanılmaya devam etti.
Son yıllarda, yeni kütüphaneler ve çerçevelerin geliştirilmesi ve yüksek performanslı hesaplamalarda ve
oyun geliştirme içinde kullanımının sürdürülmesi, C++'ın popülaritesinin artmasına neden oldu.
Bugün, C++ dünya çapında en yaygın kullanılan programlama dillerinden biridir ve büyük ve aktif
bir geliştirici topluluğu tarafından desteklenmektedir.

C++, 1983 yılından bu yana çeşitli standartlaştırma süreçlerine tabi tutulmuştur.
Bu süreçler, dildeki özelliklerin ve performansın geliştirilmesine yönelik çalışmaları içermiştir.

1998 yılında, C++'ın ilk resmi standartı ISO C++98 yayınlandı. Bu standart, nesne-yönelimli programlama,
sınıflar, fonksiyonlar, kalıtım ve polymorphism gibi özellikleri içermiştir.

2003 yılında, ISO C++03 standartı yayınlandı. Bu standart, daha önce yayınlanan ISO C++98 standartının güncellenmiş
bir versiyonudur ve dilde bug fixes ve özelliklerin eklenmesini içermiştir.

2011 yılında, ISO C++11 standartı yayınlandı. Bu standart, C++ dünyası için çok önemli bir dönüm noktasıdır
ve dildeki özelliklerin ciddi bir şekilde geliştirilmesini içermiştir. Örneğin, C++11 ile birlikte lambda fonksiyonları,
threading, unordered_map ve unique_ptr gibi özellikler eklenmiştir.

2014 yılında, ISO C++14 standartı yayınlandı. Bu standart, C++11 standartının bir güncellemesidir ve dildeki
performans ve kullanım kolaylığını artırmak amacıyla yapılan çalışmaları içermiştir.

2017 yılında, ISO C++17 standartı yayınlandı. Bu standart, C++14 standartının bir güncellemesidir ve dildeki
özelliklerin daha da geliştirilmesini içermiştir. Örneğin, C++17 ile birlikte structured bindings, if ve switch
statements için initializer ifadeleri, nested namespace gibi özellikler eklenmiştir.

2020 yılında, ISO C++20 standartı yayınlandı. Bu standart, C++17 standartının bir güncellemesidir ve dildeki
özelliklerin ve performansın daha da geliştirilmesini içermiştir. Örneğin, C++20 ile birlikte
concepts, coroutines ve modules gibi özellikler eklenmiştir.
/*-----------------------------------------------------
C ile C++ arasında const anahtar sözcüğü ile ilgili
farklar:
-C++'da const anahtar sözcüğü ile tanımlanmış bir değişkene
ilk değer atanması zorunludur aksi durumda error oluşur.
-const anahtar sözcüğü ile tanımlanan bir değişken
C de external linkage yani dışsal bağlantıya sahipken
C++ da internal linkage a aittir.
-----------------------------------------------------*/

int main(void)
{
    const int x;//error
}
/*------------------------------------------------------
C++'da C'de olduğu gibi printf fonksiyonuyla yazma yapılabilir.
Buna ek olarak iostream dosyası include edilerek cout fonksiyonu
da çağrılarak yazma yapılabilir ancak bu yapı olarak printf'ten
farklıdır. cout'tan sonra bitsel sola kaydırma operatörü << gibi
görünen bir işaret kullanılmaktadır.
------------------------------------------------------*/
#include <iostream>

int main()
{
    cout << "Hello World";
}
/*-------------------------------------------------------
function overloading ve ilerde ele alıcağımız member function overloading
C++ dilinin ve aynı zamanda nesne yönelimli programlamanın
en temel durumlarından biri olup C++ dilinde geçerlidir.(C'de geçersiz)
Metot ve fonksiyonların imzalarının farkı olması şartı bulunmaktadır.
Bu durumlar ileride ele alınacaktır.
------------------------------------------------------*/

int func(int a){ //geçerli

//code...

}

int func(void){ //geçerli

//code..

}

/*--------------------------------------------------------
auto anahtar sözcüğü ile ilgili farklar:
auto anahtar sözcüğü C programlama dilinde oldukça kullanımdan
düşmüş bir anahtar sözcük olmasıyla beraber C++ dilinde
oldukça sık kullanılan bir anahtar sözcüktür. auto anahtar
sözcüğünün C'deki anlamıyla C++'daki anlamı birbirinden çok
farklıdır. Bu anahtar sözcük C'de  bir nesnenin otomatik
ömürlü olduğunu belirtmek için kullanırken C++'da bu değişkenin
türünün ona ilk değer verilen sabitin durumuna bağlı olarak
belirlenmesini sağlar. Örneğin siz aşağıdaki gibi bir atama
yaptığınızda a'nın türü int iken b'nin türü double olur.
-------------------------------------------------------*/
#include<iostream>

int main(){

    auto a = 10;//a'nın türü int
    auto b = 20.4;//b'nın türü double
}

/*--------------------------------------------------------
C'de geçerli olan bir string literalinin char* türüne atanması
C++ dilinde geçersizdir.Çünkü C++'da string literallerinin
türü char[] değil const char[] olduğundan array decay kuralı
uygulanamamaktadır. Bu sebepten bunun için const char* türü
veya string sınıfı kullanılmalıdır.
-------------------------------------------------------*/
#include<iostream>

int main(){

    char*str="Ankara";//error
}

/*--------------------------------------------------------
malloc calloc gibi dinamik bellek yönetimi fonksiyonlarıyla
ilgili farklar:
-malloc ve calloc fonksiyonlarının geri dönüş değer türü
void* türü olduğundan C'de diğer pointer türlerine doğrudan
atama geçerlidir ancak C++'da bu syntax olarak yanlıştır.
Bu kod type casting operatörleri ile geçerli hale getirilebilir.
-------------------------------------------------------*/
#include<iostream>
#define SIZE 20

int main(){

    int*arr=malloc(SIZE*sizeof(int));//error
}

/*--------------------------------------------------------
C++ dilinde C'deki NULL macrosu yerine nullptr anahtar sözcüğü
kullanılmaktadır. NULL macrosu gibi makrolar C++'ta pek
istenmiyor çünkü bunlar yerine C++ dilinin modern araçları
kullanılmaktadır.
-------------------------------------------------------*/
/*--------------------------------------------------------
C++ dilinde enum türlerinin C dilinden farklı olarak
tür bildirimiyle birlikte kullanımı mümkündür ancak
sadece bir tamsayı türü olabilir bir gerçek sayı
türü olması syntax hatasına sebep olur.

enum Color : unsigned {Red,Blue,Black};

enum TrafficLight : unsigned char{Red,Green,Yellow};

bunun en önemli avantajı küçük tamsayı sabitleri için
bellekten tasarruf sağlar. Ya da int türünün tutamayacağı sabitleri
tutmamızı sağlar.
-------------------------------------------------------*/
/*--------------------------------------------------------
scoped enums(farklı faaliyet alanlı enumlar):Bunlara enum class da denir
ama normal classlarla karıştırılmamalıdır. Bu tür enumların aynı elemanlara sahip
olması durumunda bunlara kolon(scope resolution operator)(::) karakterleriyle erişilmelidir.
Aksi durumda error oluşur.
-------------------------------------------------------*/
enum class Color{Red,Blue,Black};

enum class TrafficLight{Red,Green,Yellow};

int main(){

    Color cx=Blue;//error
    Color cy=Color::Blue;//geçerli ve yapılması gereken!
}
/*--------------------------------------------------------
C++'ta değer verme biçimleri:
1-)Copy initialization
    int a=10;
2-)Direct initialization
    int a(10);
3-)Uniform initialization
    int a{10};
direct conversion ve uniform conversion en önemli
farkı uniformda narrowing conversion durumunda syntax hatası
olur.
Narrowing Conversion(Daraltıcı dönüşüm):byte olarak
büyük olan bir primitive(temel) türden küçük bir
temel türe yapılan atamalar buna örnektir.
ÖRNEK: double->int
int x{};//x burda 0
int y;//y burda çöp değer
-------------------------------------------------------*/
/*--------------------------------------------------------
dizileri aşağıdaki gibi tanımlamak geçerlidir:
int a[]{1,2,3,4,5};
int a[10]{};//C'de geçersiz C++ geçerli
-------------------------------------------------------*/
/*--------------------------------------------------------
type deduction(tür çıkarımı)
bunlardan iki en önemlisi: auto ve decltype
auto a=10;//auto otomatik tür olarak belirleyicidir yani
autonun yerine gelen tür int olur.
-------------------------------------------------------*/
/*--------------------------------------------------------
default arguments(varsayılan argüman):Bazen 3 parametreli
bir fonksiyona 2 parametreyi bir çağrı yapabiliriz bu
durumun geçerli olması için fonksiyona gönderilmeyen
argümanın varsayılan argüman yapılması gerekmektedir.
Aşağıdaki örnekte bu açıklanmak istenmiştir.
-------------------------------------------------------*/
void func(int,int,int=0);

int main()
{
    func(1,5,8);
    func(1,5);//böyle çağırmakla func(1,5,0) böyle çağırmak arasında bir fark yoktur.
    return 0;
}

/*--------------------------------------------------------
Son parametre varsayılan argüman almadığı sürece diğer parametrelerin
de varsayılan argüman alması mümkün değildir. Bu
sebepten aşağıdaki kod geçersizdir.
-------------------------------------------------------*/
void func(int=10,int,int=0);//error
void func(int,int=20,int);//error
void func(int=30,int=10,int=25);//geçerli
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>

int x=10;

void foo(int a=x++){

    std::cout << "a=" << a << std::endl;
}

int main() {
    foo();
    foo();
    foo();
    return 0;
}

/*--------------------------------------------------------
in parametre:fonksiyon gönderilen bir değişkenin adresini
bir const olan bir pointer değişkenle tutup o değişkeni
kullandığı ancak set etmediği parametrelere verilen isimdir.
ÖR:void func(...,const T* p);
out parametre:fonksiyona gönderilen değişken adresini gönderip
o parametreyi set eden fonksiyonun bu parametresine out parametre
adı verilir.
ÖR:void func(...,T* p);
-------------------------------------------------------*/
/*--------------------------------------------------------
Aşağıdaki örnek local x değişkeni global x değişkenini
maskelemektedir.
-------------------------------------------------------*/
int x=10;

int main(){

    int x=20;
    x=5;//local x e atama yapılır.
    ::x=10;//global x e atama yapılır.

}
/*--------------------------------------------------------

-------------------------------------------------------*/
/*--------------------------------------------------------


-------------------------------------------------------*/
/*--------------------------------------------------------

-------------------------------------------------------*/
/*--------------------------------------------------------

-------------------------------------------------------*/
/*--------------------------------------------------------
Aşağıdaki örnekteki kod C'de geçerliyken C++'da syntax
hatasıdır bunun nedeni C++ dilinin yazının sonunda
bulunmayan NULL karakterden dolayı programcının başına gelebilecek
tehlikelere karşı korunmasını sağlamaktır.
-------------------------------------------------------*/

int main(){

    char str[4]="mert";
}
/*--------------------------------------------------------


-------------------------------------------------------*/
/*--------------------------------------------------------

-------------------------------------------------------*/
/*--------------------------------------------------------

-------------------------------------------------------*/
/*--------------------------------------------------------
Pointer C++'da gerekli mi?
pointer C++ da kısmen gerekli olarak görülmektedir çünkü
pointerların işini referans dediğimiz özel değişkenlerle
de yapabiliriz.
-------------------------------------------------------*/
/*--------------------------------------------------------
C++'da referans semantiği:Assembly düzeyinde bir fark
olmasa da pointerlar C++'ın modern araçlarına uymamasından
dolayı referans semantiği C++'a eklenmiştir.
L value reference

R value reference
    taşıma semantiği
    lambda ifadeleri
    mükemmel gönderim
Aşağıdaki örneği reference semantiğiyle yazmak isterseniz:
int a=10;
int& r= a;
https://godbolt.org/(compiler explorer)
C'deki heap = free store
-------------------------------------------------------*/
int main(){
    int a=10;
    int*p=&a;
}
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
int main()
{
    int x = 10;
    int y = 45;
    int& r = x;//
    int* ptr = &x;//* burda bir operatör değil bir deklaratör
    r++;//x++
    r = y;//x=y
}

/*--------------------------------------------------------
referanslara rvalue expr. atanması gereksizdir.
-------------------------------------------------------*/
int main(){

   int& r=10;//error

}
/*--------------------------------------------------------
R value referencelara ilk değer vermek zorunludur.
-------------------------------------------------------*/
int main()
{

   int& r;//error

}
/*--------------------------------------------------------

-------------------------------------------------------*/
int main(){
    int x=10;
    int*p{&x};
    int*& r=p;
    ++*r;//++x
}
/*--------------------------------------------------------
Bir diziye referans oluşturmak:
r[2] -> *(r + 2) -> *(2 + r)
-------------------------------------------------------*/
#include <iostream>

int main() {
    int arr[]{1,2,3,4};
    int(&r)[4] = arr;
    r[2] = 35;//arr[2]=35
    int*p = r;//array decay
    std::cout<<"x : "<< x <<'\n';
    return 0;
}
/*--------------------------------------------------------
Aşağıdaki örnekte C dili için foo fonksiyonu call by value
olduğu için görülmesine gerek dahi olmadan x'in değerinin
değişmeyeceği net olarak bilinebilir. Ancak C++ dili
kurallarına göre foo fonksiyonunun görülmesi gerekir.
-------------------------------------------------------*/

void foo(int* r){

}

int main(void)
{
    int x=10;

    foo(&x);
    //x = ?
}
/*--------------------------------------------------------
Swap fonksiyonu referans semantiği ve pointer semantiğiyle
yazılabilir.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

void swap(int& r,int& q){
    int temp=r;
    r=q;
    q=temp;
}

int main(){
    int a=10;
    int b=34;
    cout<<"a:"<<a<<"  b:"<<b<<'\n';
    swap(a,b);
    cout<<"a:"<<a<<"  b:"<<b<<'\n';
}

/*--------------------------------------------------------

-------------------------------------------------------*/
int g=10;

int& foo(){

    //code
    return g;

}
int main(){

    int x=foo();//x demek g demek değil çünkü x reference değil!!
}
/*--------------------------------------------------------
pointers vs references
1-)pointer to pointer var ancak reference to reference diye
bir şey yok
2-)Pointer dizileri var ancak referans dizileri yoktur.
3-)referaslar rebindable değildir yani tekrardan başka nesneye
bağlanması söz konusu değil. Pointerlar başka nesnelere bağlanabilir.
int &const r=x;
demek anlamsızdır çünkü x tekrardan başka bir nesneye zaten
bağlanamaz. const anahtar sözcüğü anlamsızdır.
4-)NULL pointer var ama null referans yok. Referans illa
bir nesneye bağlanmak zorunda!!
-------------------------------------------------------*/
/*--------------------------------------------------------
değişken isimlerinin oluşturduğu ifadeler lvalue expression'dır.
rvalue referansa değişken ifadesiyle ilk değer verme durumu bu yüzden
geçersizdir.
-------------------------------------------------------*/

int main(){
    int x=10;
    int&& r=x;//geçersiz.
}
/*--------------------------------------------------------
a-)static ömürlü bir nesneye referans dönebilir.
    1-)Global değişkenler
    2-)Statik yerel değişkenler
    3-)String literalleri
b-)Dinamik ömürlü bir nesneye referans dönebilir
c-)Çağıran koddan aldığı nesneye referans dönebilir.
-------------------------------------------------------*/
/*--------------------------------------------------------
void foo(T &);

foo sadece L value expression ifadeler ile çağrılabilir.

void bar(const T &);

bar ise hem L value hem de R value kategorisindeki ifadeler ile çağrılabilir.

Değer kategorileri(Value category)
-PR value
-L value
-X value
Bazı ifadelerin değer kategorileri:
-Değişken ifadeleri her zaman L valuedur.
-Sabit ifadeleri her zaman PR valuedur.
-Aritmetik operatörlerle oluşturulan ifadeler PR valuedur.
-++ ve -- operatörlerinde ise durum postfix(ilk ek) ve
prefix(son ek) kullanımına bağlı olarak değişmektedir.
ilk ek ise ifade L value, son ek ise PR value olucaktır.
-Virgül operatörünün ürettiği değer L value olacaktır.
- = operatörünün ürettiği değer L olacaktır.
- işlemli atama operatörlerinin ürettiği değerler
L value expression olacaktır.
-int türden geri dönüş değerine sabit bir fonksiyon
int türden bir sabit döndüreceği için PR value expression
olacaktır. Bu durum int& türünden bir fonksiyon için
L value olurken, int&& türü için ise X value expression
olacaktır.
-int&& türünden bir değişkenin değer kategorisi L valuedur.
-bir fonksiyon adresi L value expressiondır.
-nullptr nullptr_t türünden bir sabit olduğu için diğer
sabit ifadelerinde olduğu gibi o da PR value expressiondır.
-------------------------------------------------------*/
/*--------------------------------------------------------
auto type deduction:auto bir anahtar sözcüktür. type deduction yani
tür çıkarımı yapar.
auto x = 12;//auto yerine gelen tür int
auto y = 2.3;//auto yerine gelen tür double
auto z = 3.4L;//auto yerine gelen tür long double
auto v = 'A';//auto yerine gelen tür char(C'de int)
auto k = nullptr;//auto yerine gelen tür nullptr_t
auto l = 10 > 6;//auto yerine gelen tür bool
Not:Bir değişken auto anahtar sözcüğü ile bildirildiğinde
ilk değer vermek zorunludur.
auto x;//syntax error
auto x1=expr;
auto x2=expr;
auto&& x3=expr; //forwarding reference
-------------------------------------------------------*/
#include <iostream>

int main() {
    char ch='A';
    auto x1=ch;//x1'in türü char
    auto x2=+ch;//x2'nin türü int
    std::cout << x2;
    printf("%d",x2);
    return 0;
}

/*--------------------------------------------------------
auto anahtar sözcüğünün referanslarda kullanımında referanslık
düşer!!
-------------------------------------------------------*/

int main() {
    int x=10;
    int &r=x;
    auto a=r;//a'nın türü int(referanslık düşer!!)
}
/*--------------------------------------------------------
const bir değişkenin auto ile başka bir değişkene atanması
durumunda constluk düşer!!
-------------------------------------------------------*/


int main() {
    const int x=10;
    auto a=x;
}
/*--------------------------------------------------------
Eğer değişken hem const hem de referans türünden ise
bu durumda ikisi de düşer ve aşağıdaki örnek için tür
çıkarımı int olarak yapılır.
-------------------------------------------------------*/
int main() {
    int x=10;
    const int &r=x;
    auto a=r;//a'nın türü int(referanslık da constluk da düşer!!)
}
/*--------------------------------------------------------
Aşağıdaki örnekte x'in türü int*'dır.
-------------------------------------------------------*/
int main() {
    int arr[]{1,2,3};
    auto x=arr;
}
/*--------------------------------------------------------
Aşağıdaki örnekte x'in türü const int*'dır. Bu bir
dizi olduğu için durum normal bir değişkenle aynı değildir.
-------------------------------------------------------*/
int main() {
    const int arr[]{1,2,3};
    auto x=arr;
}
/*--------------------------------------------------------
Aşağıdaki örnekte str'nin türü const char*'dır.
Array decay kuralından dolayı C++ dilinde stringlerin
türü const char[] dir. bu atama sırasında da array decay gerçekleşir.
Buna göre tür çıkarımı const char* olarak yapılır.
-------------------------------------------------------*/
int main()
{
    auto str="berke";
}

/*--------------------------------------------------------
Aşağıdaki örnekte x'in türü int(*)[20]'dir. Bunun nedeni
m'nin atanırken ilk elemanının adresi olarak ele alındığı
için 20 elemanlı int* türünden bir pointer dizisi elde edilir.
-------------------------------------------------------*/
int main() {
    int m[10][20];
    auto x=m;
}
/*--------------------------------------------------------
Aşağıdaki örnekte auto'nun karşılığı çıkarım yapılan tür int[10]
Bu durumda x değişkeni int(&x)[10] türündendir.
-------------------------------------------------------*/
int main(){

    int a[10]{};
    auto &x = a;
}
/*--------------------------------------------------------
Aşağıdaki örnekte autoya karşılık gelen ifade const char[6]
r'nin türüyse const char& [6] yani yorum satırında gösterildiği
gibi yazmak yerine auto kullanmak çok daha mantıklı bir
yaklaşım olacaktır.
-------------------------------------------------------*/
int main(){

    auto& r="berke";
    //const char (&r) [6]="berke";

}
/*--------------------------------------------------------
Aşağıdaki örnekte const ile auto anahtar sözcüğü
 birlikte kullanılmıştır. Bu durumda y'nin türü
 const int olucaktır.
-------------------------------------------------------*/
int main(){

    int x=34;
    const auto y=x;
}
/*--------------------------------------------------------
Aşağıdaki örnekte y'nin int* const(high veya top level const) iken z'nin türü
 const int*(low level const) olacaktır. Yani birinde y değiştiremezken
 diğerinde *z değiştirelemez olacaktır.
-------------------------------------------------------*/
int main()
{
    int x=34;
    const auto y=&x;
    const auto*z=&x;
}

/*--------------------------------------------------------
constexpr anahtar sözcüğü
1-)const türün bir parçası iken constexpr'nin türle herhangi bir
alakası yoktur.Bir değişken türü const int olabilirken constexpr int olamaz.
2-)constexpr değişkenler sabit ifadesi gereken her yerde
kullanımına izin vermektedir. Örneğin otomatik ömürlü bir nesnenin
adresi sabit ifade olmadığı için syntax hatasına sebep olur.
Aşağıdaki örnekteki kod geçerlidir
çünkü ilk ifadenin karşılığı aslında şu şekildedir:
int* const ptr=10;
-------------------------------------------------------*/
/*--------------------------------------------------------
Aşağıdaki örnekteki kod geçerlidir çünkü ptr bir high level
consttur. Yani bu durumda ptr başka bir adresi gösteremezken
*ptr'nin değeri değiştirebilir.
-------------------------------------------------------*/
int g=10;

int main(){
    constexpr int*ptr=10;
    *ptr=20;
}
/*--------------------------------------------------------
Aşağıdaki örnekte hem ptr const hem de *ptr consttur.
Burdan da anlaşılabileceği gibi constexpr değişkenin
kendisini const yapmaktadır. Bizim babadan kalma const
anahtar sözcüğümüz ise *ptr ifadesini const yapmaktadır.
Buna göre aşağıdaki kod geçersizdir.
-------------------------------------------------------*/
int g=10;

int main(){
    constexpr const int*ptr=10;
    *ptr=20;
}
/*--------------------------------------------------------
constexpr bir fonksiyona yapılan çağrılarda tüm parametrelere
sabit ifade gönderilmesi durumunda fonksiyonun geri dönüş değeri
runtimeda değil compile-time içerisinde hesaplanır bu da
verim açısından çok iyidir.
-------------------------------------------------------*/
constexpr int func(int x,int y){

    return x*x+y*y;
}

int main(){
    func(10,20);

}
/*--------------------------------------------------------
Aşağıdaki örnek C de geçerli olup C++ da geçersizdir.
-------------------------------------------------------*/
int main(){
    for(int i = 0;i<10;++i){
        int i = 99;
    }

}

/*--------------------------------------------------------
Function Overloading(Fonksiyon Yüklenmesi):
1-)Overloading var mı yok mu?
2-)Overloading var ama hangi fonksiyon çağrılır.
Overloading olma kuralları:
-Overloading olması için öncelikle fonksiyonların kesinlikle
aynı isme sahip gereklidir.
-Fonksiyonların imzaları(signature) birbirinden farklı olmalıdır.
imza:Fonksiyonların geri dönüş değeri dışındaki parametrik yapısı
Örneğin aşağıdaki durum bir function overloading değildir:
int foo(int,int);
void foo(int,int);
Ancak aşağıdaki durumda foo'nun 5 adet overloadı vardır:
void foo(double);
void foo(int,int);
void foo(int);
void foo(float);
void foo(const int*);
-Fonksiyonların farklı faaliyet alanlarında(scope) yer almaları
durumunda Overloading den söz edilemez çünkü farklı scopelarda
aynı isimli fonksiyonlar birbirini gizler buna name hiding denir.
name hiding
name masking
name shadowing
Anahtar Notlar: Function Overloading ne işe yarıyor?
Programcının işini kolaylaştırıyor örneğin C de bir swap
fonksiyonu yazılırken int_swap,double_swap gibi birden
çok isimli değişik parametreli aynı işi yapan fonksiyonlar
aynı isim alamıyor ancak C++ için birden fazla swap isimli fonksiyon
yazıp parametrelerine bağlı olarak hangisinin çağrılıcağını
derleyici bırakmak çok daha iyi bir tekniktir.
-------------------------------------------------------*/
/*--------------------------------------------------------
Aşağıdaki örnekte syntax hatasının nedeni aynı isimde
farklı geri dönüş değerine sahip fonksiyon bildirimi yapılmasıdır.
-------------------------------------------------------*/
int foo(int);
double foo(int);//geçersiz
/*--------------------------------------------------------
Aşağıdaki örnekte ise bir error söz konusu değildir burda
ikinci foo bir redeclaration olarak kabul edilir. Overloading
söz konusu değildir.
-------------------------------------------------------*/
int foo(int);
int foo(int);
/*--------------------------------------------------------
Aşağıdaki örnekte yine bir redeclaration söz konusudur.
tür eş ismi kullanılması Word ifadesinin int anlamına geldiği
gerçeğini değiştirmez.
-------------------------------------------------------*/
typedef int Word;

int foo(int);
int foo(Word);

typedef int WORD;

int func(int){}
int func(WORD){}

/*--------------------------------------------------------
Aşağıdaki örnekte 3 tane overloading söz konusudur.
-------------------------------------------------------*/
void foo(char);
void foo(unsigned char);
void foo(signed char);
/*--------------------------------------------------------
fonksiyonu varsayılan argüman alması imzasının farklılaşmasına
engel değildir. Bu yüzden aşağıdaki örnek function overloading'tir.
-------------------------------------------------------*/
void func(int x,int y=5);
void func(int x);
/*--------------------------------------------------------
Aşağıdaki örnek overloading değil redeclarationdır.
-------------------------------------------------------*/
void bar(int x);
void bar(const int x);
/*--------------------------------------------------------
Aşağıdaki örnekte overloading söz konusudur.
Buna const overloading de denilmektedir ve oldukça yaygın
olarak kullanılmaktadır.
-------------------------------------------------------*/
void tar(int*ptr);
void tar(const int*ptr);
/*--------------------------------------------------------
Sondaki iki fonksiyon birbirinin redeclaration'ınıdır.
Bu sebepten burda yalnızca iki tane overloading söz konusudur.
-------------------------------------------------------*/
void zar(const int* ptr);
void zar(int* const ptr);
void zar(int* ptr);
/*--------------------------------------------------------
Aşağıdaki örnekte overloading söz konusudur.
Bu duruma const overloading ismi verilir.
-------------------------------------------------------*/
void tar(int& r);
void tar(const int& r);
/*--------------------------------------------------------
Aşağıdaki örneğin overload olup olmaması derleyiciye bağlıdır
çünkü int32_t bir tür değildir,bir tür eş ismidir.
-------------------------------------------------------*/
void func(int32_t);
void func(int);
/*--------------------------------------------------------
Ancak bu örnek yukarıdakinin aksine overloadingtir.
aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
void foo(int32_t);
void foo(int64_t);

int main(){
    int a=10;
    foo(a);
    return 0;
}
/*--------------------------------------------------------
Anahtar Notlar
Farklı scope'a sahip aynı isimli fonksiyonlar birbirinin
overload'ı değildir.Bu durumda overloadingten bahsedilemez.

Fonksiyonun geri dönüş değeri türü veya geri dönüş değeri
olup olmaması fonksiyonun imzasını etkilemez.

redeclaration ile overloading karıştırılmamalıdır. Bunu
anlamanın en kolay yolu iki fonksiyona da gövde yazıp
programı derlemeye çalışarak yapılır. Eğer derleyici syntax
hatası veriyorsa bu bir redeclarationdır. aksi halde
burda overloading vardır.Aşağıdaki örnekte bir overloading
söz konusu değildir çünkü bu durumda derleyici syntax hatası
vermektedir.

Function overloading'in programın çalışma zamanına herhangi
bir maliyeti yoktur. Overload resolution'a göre aday metotlara
bakılıp uygun fonksiyon çağrılır. Eğer fonksiyonların ikisi
de
-------------------------------------------------------*/
/*--------------------------------------------------------
Hangi fonksiyonun çağrılacağına aşağıdaki adımlara göre karar
verilir ve çağrılır birden çok uygun fonksiyon varsa
ambiguity(iki anlamlılık) oluşur:
1-)aday fonksiyonlar incelenir.(candiate functions)
Not:Aday olma şartı sadece istenen isme sahip olmasıdır.
2-)aday fonksiyonlar arasından function overload resolution
a göre uygun fonksiyon seçilir veya fonksiyonlar (viable functions) seçilir.
Eğer hiçbir uygun fonksiyon yoksa syntax hatası oluşur. Bu durumu
No match adı verilir.
 bunların arasından da function overload resolution kurallarına göre
uygun fonksiyon seçilir ve çağrılır bu uygun fonksiyon birden fazlaysa bu durumda
ambiguity(iki anlamlılık) oluşur.
Function Overload resolution kuralları:
1-)exact match(Tam uyum):Fonksiyona gönderilen argümanlar ile
fonksiyonun parametre değişkenlerinin türlerinin aynı olması
durumuna verilen isimdir.
2-)promotion(yükseltme):bool,short gibi int altı türlerin
int türüne yükseltilmesi ile veya float türünün double türüne
yükseltilmesine dayalı durumlara promotion denir.
bool,short => int(integral promotion)
float => double
3-)standart conversion:yukarıdaki iki durum dışında kalan
herhangi iki tür arası atama durumları için standart conversion
ifadesi kullanılır.
4-) Dönüşümlerde variadic parametreli fonksiyonlar en
zayıf olarak kabul edilir sonra user-defined conversion
en güçlüsü de standart conversion olarak kabul edilir.
-------------------------------------------------------*/
/*--------------------------------------------------------
Aşağıdaki örnekteki kodda ambiguity kaynaklı bir syntax hatası vardır.
Bunun sebebi 2.5 sabitinin double türden olması ve long double
ve char türlerine standart conversion olmasıdır. Bu durumda
aday metotlar yarışta eşit olduğundan bir seçim yapılamaz ve
ambiguity oluşur.
-------------------------------------------------------*/
void foo(long double);
void foo(char);

int main()
{
    foo(2.5);
}
/*--------------------------------------------------------
Aşağıdaki örnekte 1 nolu func çağrısı int parametreli
func için exact match olduğu için o çağrılır.
2 Nolu çağrıda ise promotion söz konusudur. float türü
double türüne yükseltilir bu durumda double parametreli fonksiyon
çağrılır. 3 Nolu func çağrısı ise ambiguity ile sonuçlanır
çünkü bu durumda bütün fonksiyonlar standart conversion
olduğundan fonksiyonlardan herhangi biri diğerine üstünlük sağlayamaz.
-------------------------------------------------------*/
void func(int);
void func(double);
void func(char);

int main(){
    func(12);//1
    func(3.4f);//2
    func(12u);//3
}

/*--------------------------------------------------------
Aşağıdaki örnekte ise 10 > 5 ifadesinin türü bool olduğu için
tabi ki exact match olarak bool parametreli fonksiyon çağrılır.
-------------------------------------------------------*/
void func(bool);
void func(int);
void func(double);

int main(){
    func(10 > 5);
}
/*--------------------------------------------------------
Aşağıdaki örnekte exact matchte int parametreli func çağrılırdı.
Ancak o fonksiyon olmasaydı ambiguity söz konusu olurdu çünkü
iki durum da standart conversion olurdu. Bunun sebebi de
0 ın NULL pointerın karşılığı olmasıdır.
-------------------------------------------------------*/
void func(double);
void func(int *);

int main()
{
    func(0);
}
/*--------------------------------------------------------
Aşağıdaki örnekte int parametreli fonksiyon exact matchi
sağladığından dolayı onun çağrılması daha uygundur.
--------------------------------------------------------*/
#include <iostream>

void foo(int){
    std::cout<<"1"<<'\n';
}
void foo(int &){
    std::cout<<"2"<<'\n';
}

int main(){
    foo(10);
}
/*--------------------------------------------------------
Ancak Aşağıdaki örnekte durum ambiguity ile sonuçlanır.
Bu durumda iki durum da exact match olarak değerlendirilmektedir.
--------------------------------------------------------*/
#include <iostream>

void foo(int){
    std::cout<<"1"<<'\n';

}
void foo(int &){
    std::cout<<"2"<<'\n';

}

int main(){
    int x =10;
    foo(x);

}
/*--------------------------------------------------------
Aşağıdaki örnekte de bir ambiguity söz konusudur çünkü
const int& de int de burda exact match olarak kabul edilir.
-------------------------------------------------------*/
#include <iostream>

void foo(int){
    std::cout<<"1"<<'\n';

}
void foo(const int &){
    std::cout<<"2"<<'\n';

}

int main()
{
    foo(12);
}
/*--------------------------------------------------------
1 nolu foo çağrısında int& türü diğerlerine üstünlük sağladığı
için overload resolutionda o seçilir.
2 nolu foo çağrısı ise const int türden bir değişkenle
çağrıldığı için const int& parametreli fonksiyon çağrılır.
3 nolu foo çağrısında ise sabit ifadesinin sağ taraf referansıyla
çağrılması diğerlerinden üstün olduğundan int && parametreli
fonksiyon çağrılır.
--------------------------------------------------------*/
#include <iostream>

void foo(int&){
    std::cout<<"1"<<'\n';

}
void foo(const int &){
    std::cout<<"2"<<'\n';

}
void foo(int &&){
    std::cout<<"3"<<'\n';
}

int main(){
    int x = 10;
    const int y= 56;
    foo(x);//1
    foo(y);//2
    foo(12);//3
}
/*--------------------------------------------------------

-------------------------------------------------------*/
/*--------------------------------------------------------
type conversion operators:
1-)reinterpret_cast:farklı türden adresler arası atama
söz konusuysa kullanılır.
2-)static_cast:pointer değişkenler dışında türler arası
atama durumları için kullanılan type casting operatörüdür.
3-)const_cast:herhangi bir değişkenin kendi türünden bir
const değişkene atanmasına verilen isimdir.
4-)dynamic_cast(downcasing durumu için)
-------------------------------------------------------*/
/*--------------------------------------------------------
Aşağıdaki örnekte örnekte C'den gelen type casting operatörü
 yerine C++'ın static_cast operatörü kullanılmalıdır.
-------------------------------------------------------*/
#include <iostream>


int main(){
   int x = 10;
   int y = 3;
   double result=(double) x/y;
   std::cout<<"result:"<<result<<'\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte örnekte C'den gelen type casting operatörü
 yerine C++'ın const_cast operatörü kullanılmalıdır.Ancak
 dönüşüm gerçekleştirilse daha *ptr'nin değerinin değiştirilmesi
 tanımsız davranışa(undefined behavior) neden olur.
-------------------------------------------------------*/
#include <iostream>


int main(){
   const int x = 10;
   int*ptr=(int*)&x;
   *ptr=99;
}
/*--------------------------------------------------------
Benzer şekilde aşağıdaki örnekte de string literalinin
 değiştirilmesi tanımsız davranıştır. Burda diğer önemli bir nokta ise
 yazıların C++ dilinde const char[] türünden olmasıdır.
 Bu durumda yine C++'ın const_cast operatörü kullanılmalıdır.
-------------------------------------------------------*/
#include <iostream>


int main(){
   char* str=(char*)"Berke";
   *str='K';
}
/*--------------------------------------------------------
 Aşağıdaki örnekte C'den gelen type casting operatörü
 yerine reinterpret_cast operatörü kullanılmalıdır.
-------------------------------------------------------*/
#include <iostream>

struct Data{
    int a,b,c;
};

int main(){

    struct Data mydata= {1,54,6};

    char*p=(char*)&mydata;
}
/*--------------------------------------------------------
Aşağıdaki örnekte örnekte C'den gelen type casting operatörü
 yerine C++'ın static_cast operatörü kullanılması durumu
-------------------------------------------------------*/
#include <iostream>


int main(){
    int x = 10;
    int y = 3;
    double result= static_cast<double>(x)/y;
    std::cout<<"result:"<<result<<'\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte örnekte C'den gelen type casting operatörü
 yerine C++'ın const_cast operatörü kullanılması durumu.
-------------------------------------------------------*/
#include <iostream>


int main(){
    const int x = 10;
    int*ptr=const_cast<int*>(&x);
    *ptr=99;
}
/*--------------------------------------------------------
Aşağıdaki örnekte örnekte C'den gelen type casting operatörü
 yerine C++'ın const_cast operatörü kullanılması durumu.
-------------------------------------------------------*/
#include <iostream>

int main(){
    char* str=const_cast<char*>("Berke");
    *str='K';
}
/*--------------------------------------------------------
 Aşağıdaki örnekte C'den gelen type casting operatörü
 yerine reinterpret_cast operatörü kullanılmalıdır.
-------------------------------------------------------*/
#include <iostream>

struct Data{
    int a,b,c;
};

int main(){

    struct Data mydata= {1,54,6};

    char*p=reinterpret_cast<char*>(&mydata);
}
/*--------------------------------------------------------------
Anahtar Not: Malloc,calloc ve realloc gibi bellek yönetim
fonksiyonları için doğrudan tür dönüşümü C'deki gibi legal olmamasının
yanı sıra hem static_cast hem de reinterpret_cast ile yapılabilmektedir.
---------------------------------------------------------------*/
#include <iostream>
#include <cstdlib>

int main(){

    size_t size=100;
    int*arr1=static_cast<int*>(std::malloc(size*sizeof(int)));
    int*arr2=reinterpret_cast<int*>(std::malloc(size*sizeof(int)));
}
//enum kısmı eklenecek
/*--------------------------------------------------------
underlying type:Default olarak inttir ancak kolon(:) atomuyla
underlying type programcının istediği gibi seçilebilir. Ancak
verilen değerlerin int türü sıralarında çıkmasıyla bu durum
değişebilir ve long,long long türü olabilir ancak daima
tamsayı türü olur. Kolon karakteriyle bile gerçek sayı
türlerin bir enum bildirimi geçersizdir.
enum Color:double {Red,Blue,Green};//error
-------------------------------------------------------*/
/*--------------------------------------------------------
Aşağıdaki örnekte syntax hatasının nedeni farklı enum türlerinin
birbirine atanmasını geçersiz olmasıdır.
-------------------------------------------------------*/

enum Color {Red, Blue, Green};
enum Font{Arial, Verdana, Calibri};

int main()
{
    Color mycolor=Red;
    Font myfont=Arial;
    myfont=mycolor;//error

}
/*--------------------------------------------------------
Aşağıdaki örnekte syntax hatasının nedeni aynı isimde
sabitlerin enum içerisinde kullanılamamasıdır. Problemin
çözümü için kapsamlandırılmış enum türü kullanılabilir.
-------------------------------------------------------*/
enum Color{Red,Blue,Magenta,Black};
enum TrafficLight{Red,Yellow,Green};
/*--------------------------------------------------------
Yukarıdaki örnekteki syntax hatası aşağıdaki gibi giderilebilir.
Not:enum classlar her ne kadar class anahtar sözcüğüyle
kullanılsalarda aslında bir sınıf değildir!!
-------------------------------------------------------*/
enum class Color:char{Red,Blue,Purple};
enum class TrafficLight{Red,Yellow,Green};


int main(){

    Color c=Color::Red;

}
/*--------------------------------------------------------
using bildirimiyle :: operatörü kullanılmadan Color için
tüm elemanlar elde edilebilir.
-------------------------------------------------------*/
enum class Color:char{Red,Blue,Purple};
enum class TrafficLight{Red,Yellow,Green};


int main(){
    using enum Color;
    Color c=Red;

}
/*--------------------------------------------------------
Aşağıdaki örnekte x'in türü Color türü olacaktır.
-------------------------------------------------------*/
enum class Color:unsigned char{Red,Blue,Purple,Magenta,Brown};


int main(){

    auto x=Color::Red;

}
/*--------------------------------------------------------
decltype bildirimi:type declaration ile ilgili tıpkı auto gibi
ancak autodan farklıdır genel syntax:
decltype(<ifade>) x=10; gibi
ifade üzerinden bir tür çıkarımı söz konusudur.
ifade türü neyse ona göre bir type deduction söz konusudur.
decltype'ın autodan farkı constluk ve referanslık asla düşmez
ve ifadenin türü neyse o alınır.
-------------------------------------------------------*/
/*--------------------------------------------------------
Aşağıdaki örnekte syntax hatasının nedeni tür çıkarımının
const int olarak yapılıp const bir değişkene ilk verilmemesinden
kaynaklanmaktadır.
-------------------------------------------------------*/
int x=10;
const int cx=20;
int* ptr=&x;
int& r = x;

int main(){
    decltype(cx) a;

}
/*--------------------------------------------------------
Aşağıdaki örnekte tür çıkarımı int [3] şeklinde yapılır.
array decay söz konusu değildir.
-------------------------------------------------------*/

int main(){
    int a[]={ 1 , 2 , 3 };
    decltype(a) x;


/*--------------------------------------------------------
Aşağıdaki örnekte tür çıkarımı double şeklinde yapılır.
-------------------------------------------------------*/

int main(){
    int x =10;
    double dval=20.5;
    decltype(x+dval) y;

}
/*--------------------------------------------------------
Aşağıdaki örnekte tür çıkarımı int& şeklinde yapılır.
-------------------------------------------------------*/

int main(){
    int x = 10;
    int* ptr =&x;
    decltype(*ptr) y=x;

}
/*--------------------------------------------------------
Aşağıdaki örnekte yine tür çıkarımı int& şeklinde yapılır.
-------------------------------------------------------*/

int main(){
    int a[5]{};
    int y{};
    decltype(a[2]) x=y;

}
/*--------------------------------------------------------
Aşağıdaki örnekte a ifadesinin tür çıkarımı int olurken
(a) ifadesinin tür çıkarımı int& olarak yapılır.
-------------------------------------------------------*/

int main(){
    int a = 5;
    int b = 6;
    decltype(a) x = b;
    decltype((a)) y = b;
}
/*--------------------------------------------------------
decltype ile elde edilen tür operandları::

pr value ===> T
l value ===> T&
x value ===> T&&
-------------------------------------------------------*/

int main(){
    int a = 5;
    int b = 6;
    decltype(a) x = b;
    decltype((a)) y = b;
}
/*--------------------------------------------------------
Aşağıdaki örnekte ++a ifadesi a değişkeninin değerini
değiştirmez yani bir yan etkisi(side-effect) yoktur.
Bu durumda ekran çıktısı 450 ve 10 şeklinde olacaktır.
-------------------------------------------------------*/
#include <iostream>

int main(){
    int a = 10;
    int y = 45;

    decltype(++a) x = y;
    x *= 10;

    std::cout<<"y = "<<y<<'\n';
    std::cout<<"a = "<<a<<'\n';

}
/*--------------------------------------------------------
Aşağıdaki örnekte her ne kadar 1 nolu func çağrılacak gibi
görünse de 2 nolu fonksiyon çağrılır. Bunun nedeni
r değişkeninin türünün l value expression olmasından kaynaklı
olarak 1. fonksiyon viable bile olmaz yani sadece 1. nolu
fonksiyon yazılı olsa bile syntax hatası oluşurdu.
-------------------------------------------------------*/
#include <iostream>

void func(int&&){

    std::cout<<"1";
}
void func(int&){

    std::cout<<"2";
}



int main(){
    int&& r= 10;
    func(r);
}
//Extern C bildirimi eklenecek
/*--------------------------------------------------------
Sınıflar(classes):
no-modifier fonksiyonlar ve veri elemanları default olarak
C++'da private özelliğe sahiptir.
access modifiers(erişim belirleyiciler):
1-)private sadece class içerisinde erişime izin verilen
member functions veya veri elemanları anlamına gelmektedir.
2-)no-modifier:hiçbir şey yazılmaması anlamına gelir bu
durumda C++ da bu nesneler otomatik private kabul edilir.
structurelarda bu durum
3-)public:Her yerden erişimine izin verilen nesneler
anlamını taşır.
4-)protected:nesnelerin bir parent class a sahip bir class
içerisinde parents class tarafından public görülmesi sağlayan
anahtar sözcüktür ancak bu nesneler parent class hariç private
konumundadır.
-------------------------------------------------------*/
/*--------------------------------------------------------
Sınıf ismi ne konuda kod yazılıyorsa onla uyumlu olması
gerekmektedir.Örneğin:
class Fighter{};
class Customer{};
class Employee{};
sınıf elemanları(class members):
1-)Veri elemanları(Data Members)
2-)Üye Fonksiyonlar(Member functions)
3-)Tür elemanları(Type members)
Sınıf elemanlarının dışında kalan fonksiyonlara C++
terminolojisine göre global function, free function veya
stand alone function denir.
Bir sınıfta eğer elemanların erişim belirleyicileri aynı
ise her eleman için ayrı ayrı erişim bildirim yapmaya gerek
yoktur. Sınıf içerisine bir erişim belirleyici anahtar sözcüğü
yazıldığında o erişim belirleyici başka bir erişim
belirleyici görmez ise sınıfın sonuna kadar tüm elemanları
kapsar. Yani aşağıdaki örnekte iki kod aynı anlama gelir:
class Myclass{
public:
    int x=10;
public:
    void foo();
}

class Myclass{
public:
    int x=10;
    void foo();
}
-------------------------------------------------------*/
/*--------------------------------------------------------
C++'ta isim arama kuralları:
Programlamada buna name lookup denilir ve aşağıdaki
adımlarla gerçekleştirilir:

1-)İsim arama(dil tarafından belirlenen) bir sıraya göre yapılır.
2-)isim arama aranan ismin bulunmasıyla sona erer ve bir daha başlamaz
isim aramanın bitmesiyle context control başlar. bulunan isimdeki
veri elemanı internal veya external linkage'a sahip olabilir. Bunu ilerde
inceliycez.

isim aramanın sırasıyla yapıldığı scopelar:
1-)Function scope
2-)Function prototype scope
3-)Block scope
4-)File scope

İsim arama sırasında oluşabilecek syntax error durumları:
1-)Aranan isim bulunamaz syntax error oluşur.
2-)Birden fazla isim bulunur ancak dilin kuralları bu
bildirimlerden hangisinin seçileceğine karar veremez ve
bu durumda ambiguity(çift anlamlılık) oluşur.
-------------------------------------------------------*/
/*--------------------------------------------------------
Aşağıdaki örnekte x denilince öncelikle main function
içerisinde x değişkeni anlaşılır. Global isim alanındaki
x i elde etmek için
-------------------------------------------------------*/
int x = 34;

int main(){
    int x = 12;

    x++;
    ::x++;
}
/*--------------------------------------------------------
Aşağıdaki örnekte syntax hatasının nedeni nesne yaratılmamasıdır.
non-static üye fonksiyonlar için daima nesne yaratmak gerekir.
-------------------------------------------------------*/
class Myclass{
public:
    int x;
}

int main(){

    Myclass::x=10;
}
/*--------------------------------------------------------
Aşağıdaki örnekte syntax hatasının nedeni Myclass'ın x veri
elemanının private erişim belirleyiciye sahip olmasıdır.
Çünkü no-modifier C++'ta her zaman private anlamına gelmektedir.
-------------------------------------------------------*/
class Myclass{
    int x;
}

int main(){

    Myclass m;

    m.x = 12;

}
/*--------------------------------------------------------
Kullanılan bir veri elemanı için uygulanan işlemler:
1-)isim arama(name lookup)
2-)bağlama kontrol(context control)(internal -external linkage)
3-)Erişim belirleyici kontrolü(access control)
Aşağıdaki m.func çağrısı aslında arka planda fonksiyon gizli
parametrelesine m sınıf nesnesinin adresini argüman olarak geçer.
-------------------------------------------------------*/
class Myclass{
public:
    void func(int);
    void foo(int,int);
private:
    int mx,my;
};

int main(){

    Myclass m;

    m.func(10);
    //func(&m,10);
}
/*--------------------------------------------------------
Bir sınıf içerisinde redeclaration yapılması geçersizdir.
-------------------------------------------------------*/
class Myclass{
private:
public:
    void func(int);
    void func(int);
};

/*--------------------------------------------------------
Aşağıdaki örnekte syntax hatasının nedeni int parametreli
func fonksiyonunun private access sahibi olmasından
kaynaklıdır. double parametreli func fonksiyonunun
seçilmemesinin sebebi ilk olarak isim aramanın yapılması ve
int parametreli olarak bulunması access control'ün ise
son olarak yapılmasından kaynaklıdır.
-------------------------------------------------------*/
class Myclass{
private:
    void func(int);
public:
    void func(double);
};
int main()
{
    Myclass m;

    m.func(12);

}

/*--------------------------------------------------------
Aşağıdaki örnekte double parametreli dahi olsa Myclass'ın
foo fonksiyonu çağrılır bunun nedeni isim aramanın öncelikle
class scopeta yapılmasıdır.
-------------------------------------------------------*/
class Myclass{
public:
    void func(double);
    void foo(double);
};

void foo(int){

}

void Myclass::func(double d)
{
    foo(12);
}
/*--------------------------------------------------------
Aşağıdaki örnekte recursive bir çağrı söz konusunun bunun
nedeni önceki örnekte olduğu gibi isim aramının öncelikle
class scope içerisinde yapılmasından kaynaklıdır.
-------------------------------------------------------*/
class Myclass{
public:
    void func(double);
};
void func(int x){


}

void Myclass::func(double d)
{
    func(12);
}
/*--------------------------------------------------------
Aşağıdaki örnekte ise int parametreli func double parametreli
func fonksiyonunu çağırmaktadır.
-------------------------------------------------------*/
class Myclass{
public:
    void func(double);
    void func(int);
};

void Myclass::func(int x){

    func(1.23);
}
/*--------------------------------------------------------
Aşağıdaki örnekte syntax hatasının nedeni func fonksiyonu
static olmadığı halde nesne yaratımı olmadan çağrılma,
girişiminden kaynaklıdır.
-------------------------------------------------------*/
class Myclass{
public:
    void func(double x);
}
int main(){

    Myclass::func(1.23);

}
/*--------------------------------------------------------
this pointerı aşağıdaki örnekte Myclass* türünden
bir pointerı ifade etmektedir. arrow(ok) operatörüyle
(*Myclass).mx demekle this->mx demek arasında bir fark yoktur.
-------------------------------------------------------*/
class Myclass{
private:
    int mx;
    void foo();
public:
    void func(int);
}

void Myclass::func(int x){

    mx = x;
    this->mx=x;

}
/*--------------------------------------------------------
Aşağıdaki örnekte 1 nolu ifade yazılmasaydı diğer bütün
deyimlerin anlamları aynı olurdu 1 nolu deyimin yazılmasıyla
sadece mx = x ifadesinin değeri yerel mx ifadesine
atama yapılıyor şekilde ele alınacaktır. Ancak diğer deyimlerde
private mx nesnesine atama yapılmaktadır.
-------------------------------------------------------*/
class Myclass{
private:
    int mx;
    void foo();
public:
    void func(int);
}

void Myclass::func(int x){
    int mx{};//1
    mx = x;
    this->mx=x;
    (*this).mx = x;
    Myclass::mx = x;
}
/*--------------------------------------------------------
this pointerının bir kullanımı
Not:Aşağıdaki örnek için this pointerını kullanmaktan başka
çare yoktur.
-------------------------------------------------------*/
class Myclass{
public:
    void func(int);
}

void f(Myclass*);
void g(Myclass &);

void Myclass::func(int x){
    f(this);
    g(*this);
}

int main(){

    Myclass m;

    m.func(12);

}
/*--------------------------------------------------------
sınıf nesnesi türünden geri dönüş değerine sahip bir
fonksiyon için gene this pointerını kullanmak şarttır.
-------------------------------------------------------*/
#include <iostream>

class Myclass{
public:
    Myclass* func();
    Myclass* bar();
};

Myclass* Myclass::func()
{
    std::cout << "Myclass::func\n";
    return this;
}
Myclass* Myclass::bar()
{
    std::cout << "Myclass::bar\n";
    return this;
}
int main()
{
    Myclass m;
    Myclass* p{ &m };

    p->foo()->bar()->func();

}
/*--------------------------------------------------------
Aşağıdaki örnekte syntax hatasının nedeni this pointerının
l value expression olmamasından kaynaklanmaktadır.
-------------------------------------------------------*/
class Myclass{
public:
    void func();
}

void Myclass::func()
{
    Myclass m;
    this = &m;//syntax error
}
/*--------------------------------------------------------
Yukarıdaki örnekte syntax hatası olan durum *this ifadesinin
m'ye atanması durumunda geçerlidir. Bunun nedeni *this
ifadesinin bir L value expression oluşturmasından kaynaklanır.
-------------------------------------------------------*/
class Myclass{
public:
    void func();
}

void Myclass::func()
{
    Myclass m;
    this = &m;//syntax error
    *this = m; //1
}
/*--------------------------------------------------------
const üye fonksiyonlar
Bir const üye fonksiyon fonksiyonun parametre parantezinden
sonra const anahtar sözcüğünün kullanılmasıyla bildirilirler.
-------------------------------------------------------*/
class Myclass{
public:
    void func(int,int);//non-const member function
    void foo(int)const;//const member function
}
/*--------------------------------------------------------
const üye fonksiyonun özelliği veri elemanlarının bu fonksiyon
içerisinde değiştirilmesi derleyici tarafından syntax hatası olarak
değerlendirilmektedir. Bu yüzden 1 ve 2 nolu satırlar geçersizdir.
Bu durumda eğer fonksiyon bu nesnelerde bir değişiklik yapmıyorsa
aynı const olan nesnelerde olduğu gibi fonksiyonu const
yapmak da okunabilirliği arttırmaktadır.
-------------------------------------------------------*/
class Myclass{
public:
    void foo()const;
private:
    int mx;
};

void Myclass::foo()const
{
    mx = 45; //1
    this -> mx = 45;//2

}
int main(){


}
/*--------------------------------------------------------
static fonksiyonların const olması C++ dili için geçersizdir.
Sadece non-static fonksiyonlar const olabilir!!
-------------------------------------------------------*/
class Myclass{
public:
    static void foo()const;//error
private:
    int mx;
};

/*--------------------------------------------------------
fonksiyon içerisinde nesne yaratımı söz konusu olduğu
takdirde mx değişkenine aşağıdaki örnekteki gibi bir
atama yapılabilir.
-------------------------------------------------------*/
class Myclass{
public:
    void foo()const;
private:
    int mx;
};

void Myclass::foo()const
{
    Myclass m;

    m.mx = 20;

}
int main(){


}
/*--------------------------------------------------------
const bir üye fonksiyonun const olmayan bir üye fonksiyonu
çağırması C++ dilinin kurallarına göre syntax error olarak
değerlendirilir.
-------------------------------------------------------*/
class Myclass{
public:
    void foo()const;
    void func();
private:
    int mx;
};

void Myclass::foo()const
{
    func();//error

}
int main(){


}
/*--------------------------------------------------------
Ancak tersi durum non-const üye fonksiyon const üye fonksiyonu
çağırırsa bu durumda syntax hatası oluşmaz.
-------------------------------------------------------*/
class Myclass{
public:
    void foo()const;
    void func();
private:
    int mx;
};

void Myclass::func()
{
    foo();

}
int main(){


}
/*--------------------------------------------------------
Eğer iki fonksiyonda const ise herhangi bir sorun oluşmaz.
-------------------------------------------------------*/
class Myclass{
public:
    void foo()const;
    void func()const;
private:
    int mx;
};

void Myclass::foo()const
{
    func();

}
int main(){


}
/*--------------------------------------------------------
const üye fonksiyonlar accessor yani elemanlara sadece salt
okuma amaçlı erişime izin veren fonksiyonlarken non-const üye
fonksiyonlar ise setter yani değişiklik yapan anlamına gelen
bir ifadeyle isimlendirilebilir.
-------------------------------------------------------*/
class Myclass{
public:
    void accessor()const;
    void setter();
private:
    int mx;
}
/*--------------------------------------------------------
Aşağıdaki örnekte anlatılmak istenen bir const sınıf nesnesiyle
ancak bir const üye fonksiyonun kullanılabileceğidir. non-const
bir üye fonksiyon ile kullanımını syntax hatasına neden olur.
-------------------------------------------------------*/
class Myclass{
public:
    void accessor()const;
    void setter();
private:
    int mx;
}
int main(){

    const Myclass cm;

    cm.accessor();//okay
    cm.setter();//error
}
/*--------------------------------------------------------
Aşağıdaki örnekte syntax hatasının nedeni *this ifadesinin
const Myclass& türünden olmasından kaynaklıdır. const Myclass&
türünden Myclass& türüne doğrudan dönüşüm olmamasından dolayı
syntax hatası oluşur.
-------------------------------------------------------*/
class Myclass{
public:
    Myclass& foo()const;
}

Myclass& Myclass::foo()const
{
    //code
    return *this;

}
/*--------------------------------------------------------
Yukarıdaki problemin çözümü aşağıdaki gibidir.
-------------------------------------------------------*/
class Myclass{
public:
    const Myclass& foo()const;
}

const Myclass& Myclass::foo()const
{
    //code
    return *this;

}
/*--------------------------------------------------------
const üye fonksiyonlarla this ve *this ifadesinin kullanımı
-------------------------------------------------------*/
class Myclass{
public:
    const Myclass& foo()const;
    const Myclass* func()const;
};

const Myclass* Myclass::func()const
{
    //code
    return this;

}

const Myclass& Myclass::foo()const
{
    //code
    return *this;

}
//ekleme yapılacak
/*--------------------------------------------------------
Anahtar Notlar:

Sınıfın non-const üye fonksiyonu sınıfın const üye fonksiyonlarını çağırabilir.
Sınıfın const üye fonksiyonu sınıfın non-const üye fonksiyonunun çağıramaz.

const bir sınıf nesnesi için yalnızca const üye işlev çağrılabilir.
const bir sınıf nesnesi için sınıfın non-const üye işlevlerini çağıramayız.

öyle üye fonksiyonlar var ki bu fonksiyonlar sınıf nesnesinin problem domainindeki
algılanan değerini durumunu değiştirmiyor.
Bu nedenle semantik açıdan const üye fonksiyon olması gerekiyor.
-------------------------------------------------------*/
/*--------------------------------------------------------
Aşağıdaki örnekte vector sınıfı için const bir sınıf nesnesi
yaratılması durumunda vector sınıfının front ve back fonksiyonları
çağrılarak elemanlarının değiştirilmesi syntax hatasına neden olur.
-------------------------------------------------------*/
#include <iostream>
#include <vector>

int main()
{
    const std::vector<int> ivec{1,2,3,5,7};

    ivec.front()=99;
    ivec.back()=333;

    for (auto val:ivec) {
        std::cout<< val << ' ';
    }
}
/*--------------------------------------------------------
one definition rule: Başka .cpp dosyalarında başlık dosyasında
bulunan fonksiyonların birden fazla bildirilmemesi kuralına
one definition denilmektedir.
-------------------------------------------------------*/
/*--------------------------------------------------------
inline fonksiyonlar
-Bir fonksiyon inline olarak belirtildiği halde inline ext.
yapılmayabilir. Aynı şekilde inline olarak belirtirilmediği
halde inline ext. yapılabilir ancak inline anahtar sözcüğünün
en önemli görevi one definition rule'un ihlal edilmemesini
sağlamasıdır. Örneğin aşağıdaki örnek için inline anahtar ,
sözcüğü kullanılmaması durumunda tanımsız davranış oluşur.

Anahtar Notlar:C++ dilinde const ve constexpr fonksiyonlar
implicitly inlinedır.
-------------------------------------------------------*/

class Myclass{
public:
    void foo();
    void func();
}
inline void Myclass::foo(){
 //code
}

/*--------------------------------------------------------
Sınıfların kurucu ve yıkıcı işlevleri:
1-)constructor(kurucu işlev)
2-)destructor(yıkıcı işlev)
Bu işlemler eğer programcı yazmaz ve belirli koşullar sağlanırsa
derleyince tarafından(default) yazılmaktadır.
constructor terimine kısaca ctor, destructor'a ise
kısaca dtor olarak ifade edilmektedir.

Constructor:Bir sınıf nesnesi her yaratıldığı çağrılan
sınıfın geri dönüş değeri kavramı olmayan(geri dönüş
değeri olmamasıyla geri dönüş değeri kavramı olmaması
aynı şey değildir.) non-static fonksiyonuna constructor denir
ismi yapmak kurmak anlamına gelir.

Anahtar Notlar: Programcı ctor'ın kodunu yazmasa bile
derleyici tarafından default ctor yine de yazılır.
Ancak yazılması durumunda artık ctor programcının sorumluğundadır.

Anahtar Notlar: Ctor overload edilebilir. Ancak herhangi
bir parametreli ctor yazıldığı takdirde default ctor yazılmaz.

Anahtar Not 1: Bu fonksiyonların deri dönüş değeri kavramları
yoktur ve bu fonksiyonlar daima non-static olmalıdır. Ayrıca
isimleri sınıfın ismiyle aynı olması şarttır.

Önemli Not: Bir fonksiyonun geri dönüş değeri olmamasıyla
geri dönüş değeri kavramının olmaması aynı anlama gelmez.

Anahtar Not 2:ctorlar overload edilebilirken dtorlar overload
edilemez. Bu fonksiyonlar public,protected veya private olabilir.
-------------------------------------------------------*/
class Myclass{
public:
    Myclass();//default ctor
    ~Myclass();//default dtor
}
/*----------------------------------------------------------
Aşağıdaki örnekte programcı int parametreli ctoru yazdığı için
derleyici default ctoru bu durumda yazmaz. Eğer m nesnesi
default ctor çağrıcak şekilde hayata gelseydi syntax hatası oluşurdu.
-----------------------------------------------------------*/
#include <iostream>


class Myclass{
public:
    Myclass(int){
      std::cout<<"Myclass(int) ctor"<<'\n';
    };
    ~Myclass(){
        std::cout<<"~Myclass() dtor"<<'\n';

    }
};

int main()
{
    Myclass m{10};
}
/*--------------------------------------------------------
Aşağıdaki örnekte func 3 kere çağrılmasına karşın ctor ve dtor
birer defa çağrılmıştır bunun nedeni sınıf nesnesinin static olmasıdır.
eğer otomatik ömürlü bir nesne olsaydı bu durumda 3 kere ctor,
3 kere de dtor çağrılacaktı.
-------------------------------------------------------*/
#include <iostream>


class Myclass{
public:
    Myclass(){
      std::cout<<"Myclass constructor"<<'\n';
    };
    ~Myclass(){
        std::cout<<"Myclass destructor"<<'\n';

    }
};
void func()
{
    static int count = 0;
    std::cout << "func'a yapilan " <<++count << ".cagri\n";
    static Myclass m;
}
int main()
{
    std::cout<<"main basladi"<<'\n';
    func();
    func();
    func();
    std::cout<<"main sona erdi"<<'\n';
}
/*--------------------------------------------------------
Bir sınıf içerisinde ctor,dtor fark etmeksizin tüm this pointerları
bu örnek için Myclass sınıfının adresini tutmaktadır.
-------------------------------------------------------*/
#include <iostream>


class Myclass{
public:
    Myclass(){
      std::cout<<"Myclass constructor this:"<< this <<'\n';
    };
    void bar()
    {
        std::cout<<"Myclass::bar() this:"<< this <<'\n';
    }
    ~Myclass(){
        std::cout<<"Myclass destructor this:"<<this<<'\n';

    }
};

int main()
{
    std::cout<<"main basladi"<<'\n';
    {
        Myclass m;
        std::cout<<"&m:"<<&m<<'\n';
        m.bar();
    }
    std::cout<<"main sona erdi"<<'\n';
}
/*--------------------------------------------------------
Aşağıdaki örnek için yalnızca bir defa ctor ve dtor çağrılır
o da m nesnesi için çağrılır.
-------------------------------------------------------*/
#include <iostream>


class Myclass{
public:
    Myclass(){
      std::cout<<"Myclass constructor this:"<< this <<'\n';
    };
    void bar()
    {
        std::cout<<"Myclass::bar() this:"<< this <<'\n';
    }
    ~Myclass(){
        std::cout<<"Myclass destructor this:"<<this<<'\n';

    }
};

int main()
{
        Myclass m;
        Myclass& r1= m;
        Myclass& r2= r1;
        Myclass*p = &m;
}
/*--------------------------------------------------------
Mülakat sorusu:Ekrana 0 den 100 kadar olan sayıları for
döngüsü kullanmadan yazınız.
-------------------------------------------------------*/
#include <iostream>


class Myclass {
public:
    Myclass() {
        static int x;
        std::cout << x << ' ';
        ++x;
    }
};
int main()
{
    Myclass m_arr[100];

}
/*--------------------------------------------------------
Aşağıdaki örnekte x3 için syntax hatası oluşur.
-------------------------------------------------------*/
#include <iostream>


class Myclass {
public:
    Myclass() {
        std::cout << "Myclass default ctor"<<'\n';
    }
    Myclass(int){
        std::cout << "Myclass(int) ctor"<<'\n';
    }
};
int main()
{
    Myclass x1(5);//direct init
    Myclass x2 = 7.6;//copy init
    Myclass x3{9.7}; //direct list init
}
/*--------------------------------------------------------
constructor initializer list:
ctor çağrılması sırasında sınıf elemanlarına ctor ile initialization
işleminin yapılmasını sağlayan listeye constructor initializer list denir.
-------------------------------------------------------*/
class Myclass {
public:
    Myclass() : mx(0),my(0){}
private:
    int mx,my;
}
/*--------------------------------------------------------
Bir değişkeni ctor içerisinde initialize etmek ile ctor
initializer list kullanmak arasında bir fark yoktur ancak
bu araç okunabilirlik anlaşılabilirlik açısından çok daha
kullanışlıdır.
-------------------------------------------------------*/
/*--------------------------------------------------------
Aşağıdaki örnekte tanımsız davranış(undefined behavior) olmasının
nedeni değişkenlerin hataya gelme sırasının sınıf içesinde
tanımlanma sırasına göre olmasından kaynaklanmaktadır.
Constructor initializer list içerisinde bu sıranın değişmesi
bir şey ifade etmez!!
-------------------------------------------------------*/
#include <iostream>

class Myclass {
public:
    Myclass():my(5.),mx(my / 3) { //ub
    }
private:
    double mx,my;
};
int main()
{
    Myclass m;
}
/*--------------------------------------------------------
const bir nesneye ilk verilmesi zorunluluğu aşağıdaki örnekte
ihlal edilmemiştir yani kod legaldir.
-------------------------------------------------------*/

class Myclass {
public:
    Myclass():my(5.),mx(7.9) {
    }
private:
    const double mx,my;
};
int main()
{
    Myclass m;
}
/*--------------------------------------------------------
const nesnelerde olduğu gibi referanslarda da ilk değer
verme kuralı yine ihlal edilmemiştir.
-------------------------------------------------------*/

int g{2};

class Myclass {
public:
    Myclass():r{g} {
    }
private:
    int& r;
};
int main()
{
    Myclass m;
}
/*--------------------------------------------------------
Aşağıdaki örnekte default ctor çağrılması durumda my ve mz
sınıf nesneleri hayata 0 değerleri ile gelecekken int,int
parametreli ctor çağrısında parametre değişkenlerine argüman
olarak geçilen değerlerle init edilecektir.
-------------------------------------------------------*/
#include <iostream>

class Myclass {
public:
    Myclass():my{0},mz{0} {}
    Myclass(int a,int b):my{a},mz{b}{}
    void print()const
    {
        std::cout << mx << " " << my << " " << mz << "\n";
    }
private:
    //int mx = 10;
    //int mx(10); //geçersiz
    int mx = 0;
    int my,mz;
};
int main()
{
    Myclass m1;
    m1.print();
    Myclass m2{10,20};
    m2.print();
}
/*--------------------------------------------------------
Özel üye fonksiyonlar(special member functions):
1-)default ctor(varsayılan kurucu işlev)
2-)copy ctor(sonlandırıcı işlev)
3-)move ctor(kopyalayan kurucu işlev)
4-)copy assignment(kopyalayan atama işlevi)
5-)move assignment(taşıyıcı atama işlevi)
6-)destructor(sonlandırıcı işlev)
bir sınıfın sadece özel üye fonksiyonları default init.
edilebilir. Örnek:
class Myclass{
   public:
         Myclass()=default;
}
bu ifade derleyiciye emrediyorum bu ctoru default olarak yaz
demek gibi düşünülebilir.
Bir fonksiyonun delete edilmesi:
Bu işlem aynı defaultta olduğu gibi bir fonksiyonun
=delete yapılmasıyla mümkün olabilir. Bu durumda
fonksiyon vardır ancak delete edilmiştir yani bir
çağrı durumunda fonksiyon yok hatası değil fonksiyon delete
edildi hatası meydana gelir. Örneğin aşağıdaki örnekte
syntax hatasının nedeni delete edilmiş bu fonksiyon çağrı girişimi
hatasıdır. bizde double yok delete edilmiş int verelim gibi
bir durum söz konusu değildir.
-------------------------------------------------------*/
void func(char);
void func(int);
void func(double)=delete;
void func(long);

int main(){
    func(7.9);
}
/*--------------------------------------------------------
Aşağıdaki örnekte m2 nesnesi için default ctor çağrısı söz konusudur.
default ctor delete edildiği için syntax hatası oluşur.
-------------------------------------------------------*/
class Myclass{
public:
    Myclass() = delete;
    Myclass(int);
}

int main(){

    Myclass m1(123);
    Myclass m2;//error
}
/*--------------------------------------------------------
Programcının hiçbir ctor yazmaması durumunda derleyici sınıfın içerisine
non-static public inline bir default ctor yazar. Derleyicinin yazdığı bu
default ctor sınıfın tüm veri elemanlarını default init eder.

Eğer derleyici sınıfın bir üye fonksiyonunu default ederken herhangi bir
nedenle geçersiz bir durum oluşursa derleyici syntax hatası vermez ancak
default etmesi gereken özel üye fonksiyonu kendisi delete eder!!

Örneğin aşağıdaki örnek için syntax hatasının nedeni const olan
mx nesnesinin initialize edilmemesinden dolayı değil default ctorun
delete edilmesinden kaynaklanmaktadır.
-------------------------------------------------------*/
class Myclass {
public:

private:
    const int mx ;
};
int main()
{
    Myclass m;
}
/*--------------------------------------------------------
Aşağıdaki örnek B sınıfının default ctoru her ne kadar
default olarak bildiriliyormuş gibi görünse de burda delete
edilmiştir. Bu yüzden B bx ifadesi delete edilmiş bir fonksiyona
çağrı yapılma girişiminden kaynaklı olarak syntax hatasına neden olur.
-------------------------------------------------------*/
class A{
private:
    A(int);

};

class B{
public:
    B()=default;
private:
    A ax;
};


int main(){
    B bx;
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>

class A{
public:
    void print()const
    {
        std::cout<<"mx = " << mx << " my = "<< my << '\n';
    }
private:
    int mx = 10;
    int my = 20;
};



int main()
{
    A a;
    a.print();
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>

class A{
public:
    A() : mx(mx),my(my){};
    void print()const
    {
        std::cout<<"mx = " << mx << " my = "<< my << '\n';
    }
private:
    int mx;
    int my;
};



int main()
{
    A a;
    a.print();
}
/*--------------------------------------------------------
C++ dilinde bir sınıf nesnesi hayata aynı türden bir başka
sınıf nesnesinin değerini alarak getirilmek istendiğinde
sınıfın özel üye fonksiyonu olan copy ctor çağrılır.

implicity declared copy ctor

sınıfın non-static public inline fonksiyonu

Myclass(const Myclass&);

Myclass m2 = m1;
-------------------------------------------------------*/
class Myclass{

}

int main()
{
    Myclass m1;
    Myclass m2 = m1;//m2 için copy ctor çağrılacak.
}

/*--------------------------------------------------------
Sınıfın özel üye fonksiyonları default init için aşağıdaki gibidir.
Bazı özel durumlar için bu fonksiyonlar programcı tarafından yazılabilir
eğer yazılmaz ise belirli koşullar sağlandığında derleyici tarafından da
yazılabilir. Aşağıdaki örnekte tüm özel üye fonksiyonların çağrılması için
gerekli koşullar sağlanmıştır.
-------------------------------------------------------*/
#include <iostream>

class Myclass{
public:
    Myclass(){
        std::cout<<"Myclass default costructor"<<'\n';
    };
    ~Myclass(){
        std::cout<<"Myclass destructor"<<'\n';
    };
    Myclass(const Myclass&){
        std::cout<<"Myclass copy constructor"<<'\n';
    };
    Myclass(Myclass&&){
        std::cout<<"Myclass move constructor"<<'\n';
    };
    Myclass& operator=(const Myclass&){
        std::cout<< "Myclass copy assignment" <<'\n';
    };
    Myclass& operator=(Myclass&&){
        std::cout<< "Myclass move assignment" <<'\n';
    };
};



int main()
{
    Myclass m1;
    Myclass m2 = m1;//copy ctor called
    Myclass m3;
    m3 = m1;//copy assignment called
    Myclass m4=std::move(m2);//move ctor called
    Myclass m5;
    m5 = std::move(m3);//move assignment called
}
/*--------------------------------------------------------
Taşıma semantiği(Move semantics): Taşıma semantiği bir nesnenin
başka bir nesnenin kaynağını çalmasıyla yapılmaktadır. std::move
fonksiyonu yardımıyla yapılır ancak std::move fonksiyonu
tek başına taşıma yapar ifadesi doğru bir ifade değildir.
std::move fonksiyonunun aslında yaptığı l value expression
olan bir nesneyi r value expression haline getirir.

Anahtar Notlar:
Kaynağı çalınan nesnenin ömrü bitmez ancak yeni değeri hakkında
net bir bilgi yoktur bu sebeple o değişkene atama yapmak anlamsız
değilken o değişkenin değerinin bir başka değişkene atanması
tanımsız davranışla sonuçlanabilir.

Aşağıdaki örnekte referans semantiği ile taşıma semantiği
bir arada kullanılmıştır. Bu durumda taşıma semantiği optimizasyon
açısından oldukça hızlıdır. Bu yüzden syntax ve semantik açıdan
doğru olduğu müddetçe tercih edilmesi gerekmektedir.
-------------------------------------------------------*/
void swap(int& r1,int& r2){
    int temp = std::move(r1);
    r1 = std::move(r2);
    r2 = std::move(temp);
}


int main()
{
    int x=34,y=10;
    std::cout << "x: "<< x << " y: " << y << '\n';
    swap(x,y);
    std::cout << "x: "<< x << " y: " << y << '\n';
}
/*--------------------------------------------------------
Aşağıdaki maddelerde programcı tarafından yazılan üye fonksiyona göre
diğer üye fonksiyonların derleyici tarafından yazılıp yazılmayacağı
veya delete edilip edilmeyeceği verilmiştir:

1-)Eğer programcı hiçbir özel üye fonksiyon yazmazsa derleyici tarafından default olarak
tüm özel üye fonksiyonlar yazılır.

2-)Herhangi bir parametreye sahip bir constructor yazılırsa default ctor not declared duruma
gelirken diğer özel üye fonksiyonlar derleyici tarafından yazılır.

3-)Eğer programcı bir destructor yazarsa bu durumda move özel üye fonksiyonları not declared duruma
gelir diğer özel üye fonksiyon ise default olarak derleyici tarafından yazılır.

4-)Eğer programcı copy constructor'ı yazarsa hem move özel üye fonksiyonları hem default ctor
not declared duruma gelir diğer fonksiyonlar ise default olarak derleyici tarafından yazılır.

5-)Eğer programcı bir copy assignment fonksiyonu yazarsa bu durumda move özel üye fonksiyonları not declared duruma
gelir diğer özel üye fonksiyon ise default olarak derleyici tarafından yazılır.

6-)Eğer programcı move constructor fonksiyonunu kendi yazarsa copy fonksiyonları delete edilir.
default ctor ise not declared duruma gelir.

7-)Eğer programcı move assignment fonksiyonunu kendi yazarsa copy fonksiyonları delete edilir.
-------------------------------------------------------*/
//ekleme yapılacak!!
/*--------------------------------------------------------
Geçici nesne kullanımı
Normalde int türünden Myclass türüne otomatik dönüşüm olmamasına karşın
aşağıdaki örnekte bu atama arka planda bir geçici nesne kullanarak
yapılmıştır. Aslında aşağıdaki örnekte sorum satırında belirtilen durum
gibi bir geçici temp nesnesi kullanılmıştır. Bu temp nesnesi kullanımından
sonra temp nesnesi için destructor çağrısı yapılmıştır.
-------------------------------------------------------*/
#include <iostream>

class Myclass{
public:
    Myclass()=default;
    Myclass(int);

};


int main()
{
    Myclass x;
    x = 5;
    /*
     Myclass temp(5);
     x = temp;
     temp.~Myclass();
     */
}

/*--------------------------------------------------------
Aşağıdaki örnekte getchar çağrısından önce geçici nesne için
destructor çağrıldığı görülmektedir.
-------------------------------------------------------*/
#include <iostream>

class Myclass{
public:
    Myclass() = default;
    ~Myclass()
    {
        std::cout << "Myclass destructor this:" << this << '\n';
    }
    Myclass(int x)
    {
        std::cout << "Myclass(int x) x ="<< x << " this:" << this << '\n';
    }
};


int main()
{
    Myclass x;
    x = 5;

    (void)getchar();
    /*
     Myclass temp(5);
     x = temp;
     temp.~Myclass();
     */
}
/*--------------------------------------------------------
explicit keyword(explicit anahtar sözcüğü):
explicit anahtar sözcüğü bir sınıf türünden bir değişkene
başka türden bir değişkenin explicit/standard conversion(doğrudan dönüşüm)
yapmaya kapatmak anlamına gelmektedir. Bu durumda aşağıdaki
kodda syntax hatasının nedeni Counter sınıfının int parametreli ctor
elemanının explicit yapılmasından kaynaklanmaktadır. Bu durumda
explicit fonksiyon viable olarak da kabul edilmek ve uygun fonksiyon
bulunamadığı için syntax hatası oluşur.

Anahtar Notlar: explicit anahtar sözcüğü sadece bir sınıfın üye
fonksiyonlarıyla birlikte kullanılabilir.
-------------------------------------------------------*/
#include <iostream>

class Counter{
public:
   explicit Counter(int);
};


int main()
{
    Counter c;

    c = 45;

}
/*--------------------------------------------------------
Aşağıdaki örnekte syntax hatasının nedeni long ve double parametreli
ctorların ikisinin de int türünden standart conversiona sahip olmasından
dolayı olarak oluşan bir ambiguity söz konusudur. explicit fonksiyonlar
overload resolutiona dahil edilmemektedir yani long veya double paramtereli
fonksiyonların birinin silinmesi durumunda syntax hatası ortadan kalkar.
-------------------------------------------------------*/
#include <iostream>

class Counter{
public:
   explicit Counter(int);
   Counter(long);
   Counter(double);
};


int main()
{
    Counter c = 45;

}
/*--------------------------------------------------------
Aşağıdaki örnekte bir narrowing conversion söz konusudur
çünkü 4.54 bir double sabitiyken ctorun parametresi inttir.
-------------------------------------------------------*/
class Myclass{
public:
    Myclass(int);
}
int main()
{
    Myclass mx(12);

    mx = 4.54;//user-defined conversion

}
/*--------------------------------------------------------
Bir sınıfa ait ctor elemanının parametre değişkeni başka bir
sınıf türünden olabilir bu durumda bu ctorlara conversion ctor
adı verilir. Aşağıdaki örnekteki syntax hatası ifadenin
tekrardan static cast ile C türüne dönüştürülmesiyle giderilebilir.
-------------------------------------------------------*/
class A{
public:
    A() = default;
};
class B{
public:
    B(){};
    B(A);//conversion ctor
};
class C{
public:
    C(){};
    explicit C(B);
};

int main()
{
    A ax;
    B bx;
    C cx;
    cx=static_cast<B>(ax);//syntax hatası
}
/*--------------------------------------------------------
Lifetime extension

eğer bir geçici nesneyi bir referansa bağlarsak referans olan
ismin kapsamının sonuna kadar o geçici nesnenin hayatı devam eder.

geçici nesne oluşturan ifadeler

    PR value expression

dolaysıyla bir L value referans bir geçici nesne ifadesine bağlanamaz.
ancak bir const L value reference ya da bir R value reference ya da
bir R value reference bir geçici nesne ifadesine bağlanamaz.
-------------------------------------------------------*/
class Myclass
{
//...
};

int main()
{
    Myclass& r1 = Myclass();//geçersiz
    const Myclass& r2 = Myclass(); //geçerli ve life extension
}
/*--------------------------------------------------------
Aşağıdaki swap algoritması kopyalama semantiği kullanılarak
yapılmıştır.
-------------------------------------------------------*/
class Biggie{
public:
    //copy ctor
    //copy assignment
    //move ctor
    //move assignment
}
void bswap(Biggie& b1,Biggie& b2)
{
    Biggie temp = b1; //copy ctor
    Biggie = b2; //copy assignment
    b2 = temp; //copy assignment
}
int main()
{
    Biggie x,y;

    bswap(x,y);

}
/*--------------------------------------------------------
Aşağıdaki swap algoritması taşıma semantiği kullanılarak
yapılmıştır.
-------------------------------------------------------*/
class Biggie{
public:
    //copy ctor
    //copy assignment
    //move ctor
    //move assignment
}
void bswap(Biggie& b1,Biggie& b2)
{
    Biggie temp = std::move(b1); //move ctor
    Biggie = std::move(b2); //move assignment
    b2 = std::move(temp); //move assignment
}
int main()
{
    Biggie x,y;

    bswap(x,y);

}
/*--------------------------------------------------------
Mandatory copy elision

Eğer bir fonksiyonun parametre değişkeni bir sınıf türünden ise
ve bu fonksiyon argüman olarak bir R value expression olan sınıf
nesnesi ile çağrılırsa kopyalama elimine edilir.(mandatory copy elision)
-------------------------------------------------------*/
/*--------------------------------------------------------
Örneğin aşağıdaki örnekte bir copy elision söz konusudur
çünkü burda yukarıda belirtilen durumlar sağlanmıştır. Bu durumda
kopyalama elimine edilir ve sadece sınıfın default ctoru çağrılır,
copy ctoru çağrılmaz!!
-------------------------------------------------------*/
#include <iostream>

class Myclass{
public:
    Myclass()
    {
        std::cout << "Myclass default ctor called"<<'\n';
    }
    Myclass(const Myclass&)
    {
        std::cout << "Myclass copy ctor called" <<'\n';
    }
};
void func(Myclass)
{
 //code
}
int main()
{
    func(Myclass{});

}
/*--------------------------------------------------------
2 farklı senaryoda copy ctor delete edilse dahi syntax hatası oluşmayacak:
1-)fonksiyonun parametresi bir sınıf türünden ve fonksiyona PR value expression
ile çağrı yapılıyorsa
2-)Fonksşyonun geri dönüş değeri sınıf türünden ve return ifadesi
bir PR value expression olduğunu zaman
Aşağıdaki örnekte de 2 nolu durum söz konusudur. Bu durumda
sadece default ctor çağrılacaktır. Ayrıca bu örnekte RVO akronimi
yani açılımıyla Return Value Optimization söz konusudur.
NRVO(named return value optimization)
-------------------------------------------------------*/
#include <iostream>

class Myclass{
public:
    Myclass()
    {
        std::cout << "Myclass default ctor called"<<'\n';
    }
    Myclass(const Myclass&)
    {
        std::cout << "Myclass copy ctor called" <<'\n';
    }
};
Myclass foo()
{
    //code
    return Myclass{};
}
int main()
{
    Myclass m = foo();

}
/*--------------------------------------------------------
//ekleme yapılacak
-------------------------------------------------------*/

/*--------------------------------------------------------
nesnelerin ömürleri:
1-)otomatik ömürlü nesneler:
2-)static ömürlü nesneler:
3-)dinamik ömürlü nesneler:
-------------------------------------------------------*/
/*--------------------------------------------------------
Dinamik ömürlü nesneler:Dinamik ömürlü nesneler new operatörüyle
hayata başlayıp delete operatörüyle hayatı biten nesnelerdir.
Bu nesne programcı tarafından istenildiği zaman var edilip programcı
istediği zaman da yok edilirler aynı dinamik bellek fonksiyonları
gibi ancak dinamik bellek fonksiyonlarından malloc başarısızlık durumunda
NULL pointer(C++ daki adıyla nullptr_t türünden nullptr) döndürürken
new operatörü başarısızlık durumların std::bad_alloc sınıf türünden
exception throw ediyor. Bu başarısızlık durumları genellikle
belleğin yetersiz olmasından kaynaklansa dahi bazen başka
hata durumları da olabilir.
Anahtar Notlar:
1-)new operatörünü modern C++'ta neredeyse hiç kullanmıyoruz.
2-)new operatörünü kullanan fonksiyonlara çağrı yapıyoruz.
3-)new operatörüyle oluşturulan dinamik ömürlü nesneleri
değişkenlerle kullanmak yerine smart pointerlarla kullanmak
daha mantıklı olur.
4-)operator new ve new operatörü aynı şey değildir. operator new
ctor çağrısı yapmaz aynı durum delete ve operator delete için de
destructor için geçerlidir delete operatörü destructor çağrısı
yaparken operator delete yapmaz!!
5-)Mümkün olduğu kadar dinamik ömürlü nesne kullanmaktan kaçınılmalıdır
çünkü dinamik ömürlü nesnelerinin maliyetleri ciddi anlamda
yüksektir ancak başka bir çare olmadığı durumlar için dinamik
elbette kullanmalıdır.
Aşağıdaki örnekte delete operatörünün arka planda yaptığı iş yorum
satırında gösterilmiştir.
-------------------------------------------------------*/
class Myclass{
public:
    Myclass()
    {
        std::cout << "Myclass default ctor called"<<'\n';
    }
    Myclass(const Myclass&)
    {
        std::cout << "Myclass copy ctor called" <<'\n';
    }
    ~Myclass()
    {
        std::cout << "Myclass destructor" << '\n';
    }
};

int main()
{
    Myclass* p = new Myclass;

    delete p;
    /*
    p->~Myclass();
    operator delete(p);
    */
}
/*--------------------------------------------------------
void* operator new(size_t n); //malloc
void operator delete(void* vp);//free

new Myclass     operator new(sizeof(Myclass)+ Myclass::Myclass()
delete p        p->~Myclass()  operator delete(p)
-------------------------------------------------------*/
#include <iostream>

class Myclass{
public:
    Myclass()
    {
        std::cout << "Myclass default ctor called"<<'\n';
    }
    Myclass(const Myclass&)
    {
        std::cout << "Myclass copy ctor called" <<'\n';
    }
    Myclass(int x,int y)
    {
        std::cout << "Myclass(int x,int y) x = " << x << " y = "<< y << '\n';
    }
    ~Myclass()
    {
        std::cout << "Myclass destructor" << '\n';
    }
};

int main()
{
    Myclass* p1 = new const Myclass{4,6};//geçersiz const cast gerekli
    const Myclass* p2 = new const Myclass{4,6}; //geçerli
    auto p3= new const Myclass{4,6}; //geçerli
}
/*--------------------------------------------------------
Dinamik ömürlü nesneler hangi durumlarda kullanılmalıdır?
Öyle durumlar vardır ki:
1-)Hayata getirilecek nesnenin türü programın çalışma zamanında
belli oluyor olabilir bu durumda dinamik ömürlü nesne kullanmak
mecburidir.
2-)Hayata getiiricek nesne sayısı programın çalışma zamanında
belli oluyor olabilir bu durumda dinamik ömürlü nesne kullanmak
mecburidir.
3-)Bir fonksiyonun bir nesneye hayata getirmesi ve bu nesneyi
çağıran koda iletmesi fakat hayata getirilen nesnenin fonksiyonu
çağıran kod tarafından kullanılması ve hayatının çağıran kod
tarafından sonlandırılması durumunda dinamik ömürlü nesne kullanmak
mecburidir.
-------------------------------------------------------*/
/*--------------------------------------------------------
Aşağıdaki örnekte delete operatörü çağrıldıktan sonra
p pointerı artık bir dangling pointer olduğundan dolayı
2. p->print(); çağrısı bir tanımsız davranışa neden olur.
-------------------------------------------------------*/
#include <iostream>

class Myclass{
public:
    Myclass()
    {
        std::cout << "Myclass default ctor called"<<'\n';
    }
    Myclass(const Myclass&)
    {
        std::cout << "Myclass copy ctor called" <<'\n';
    }
    Myclass(int x,int y)
    {
        std::cout << "Myclass(int x,int y) x = " << x << " y = "<< y << '\n';
    }
    Myclass(int x) : mx{x}
    {
        std::cout << "Myclass(int x) x = " << x << '\n';
    }
    ~Myclass()
    {
        std::cout << "Myclass destructor" << '\n';
    }
    void print()
    {
        std::cout << "mx : " << mx << '\n';
    }
private:
    int mx;
};

int main()
{
    Myclass *p = new Myclass(100);

    p->print();

    delete p;

    p->print();//Undefined behavior
}
/*--------------------------------------------------------
Aşağıdaki örnekte hem p1 hem de p2 aynı nesneyi gösterdiğinden
dolayı birini delete operatörünün operandı yapmak demek aynı
nesne için kaynak geri verildiğinden dolayı p1 nesnesiyle
beraber p2 nesnesi de dangling pointer haline geldiği için
tekrardan p2 pointerının delete operatörünün operandı yapılması
tanımsız davranışa sebep olur.
-------------------------------------------------------*/
#include <iostream>

class Myclass{
public:
    Myclass()
    {
        std::cout << "Myclass default ctor called"<<'\n';
    }
    Myclass(const Myclass&)
    {
        std::cout << "Myclass copy ctor called" <<'\n';
    }
    Myclass(int x,int y)
    {
        std::cout << "Myclass(int x,int y) x = " << x << " y = "<< y << '\n';
    }
    Myclass(int x) : mx{x}
    {
        std::cout << "Myclass(int x) x = " << x << '\n';
    }
    ~Myclass()
    {
        std::cout << "Myclass destructor" << '\n';
    }
    void print()
    {
        std::cout << "mx : " << mx << '\n';
    }
private:
    int mx;
};

int main()
{
    Myclass *p1 = new Myclass(100);

    auto p2 = p1;

    delete p1;

    delete p2;//Undefined behavior

}
/*--------------------------------------------------------
new operatörüyle oluşturulan bir nesneyi delete operatörüyle
delete etmezsek ne olur?

operator new işleviyle sizeof T kadar bir bellek bloğu edinilmiş oldu
delete etmezsek operator delete işlevi çağrılmayacak sizeof(T) kadar
bellek bloğu sızdırılacak.

delete etmediğimiz için T sınıfının destructor'u çağrılmayacak
bu durumda eğer dinamik ömürlü nesneyi hayata getiren ctor kaynaklar
edinilmiş ise destructor çağrıldığı için bu kaynaklar geri verilecek.

memory leak(bellek sızıntısı)
resource leak(kaynak sızıntısı):edinilen kaynağın geri verilmemesi durumunda
gerçekleşir.
bir dosyayı açtınız ancak kapatmadınız.
Anahtar notlar:
Her memory leak bir resource leak ancak tersi olarak
he resource leak bir memory leak değildir.
new operator=malloc(tek farkı bellek yetersizse exception fırlatıyor.)
delete operator=free
free store=heap
-------------------------------------------------------*/
/*--------------------------------------------------------
Aşağıdaki örnekte buffer nesnesi için ayrılacak bellek bloğunun
büyüklüğü compile timeda bilindiği için bu bellek bloğu zaten
static olarak elde edilip programın sonunda steak bellek
alanından atılacaktır bu yüzden bu senaryo için delete operatörünü
çağırmak mantıklı yalnızca nesnenin destroy edilmesi için
destructor çağrısı yapılmalıdır.
-------------------------------------------------------*/
#include <iostream>

class Myclass{
public:
    Myclass()
    {
        std::cout << "Myclass default ctor called"<<'\n';
    }
    Myclass(const Myclass&)
    {
        std::cout << "Myclass copy ctor called" <<'\n';
    }
    Myclass(int x,int y)
    {
        std::cout << "Myclass(int x,int y) x = " << x << " y = "<< y << '\n';
    }
    Myclass(int x) : mx{x}
    {
        std::cout << "Myclass(int x) x = " << x << '\n';
    }
    ~Myclass()
    {
        std::cout << "Myclass destructor" << '\n';
    }
    void print()
    {
        std::cout << "mx : " << mx << '\n';
    }
private:
    int mx;
};

int main()
{
    char buffer[sizeof(Myclass)];

    std::cout << (void*) buffer << '\n';
    auto p = new(buffer)Myclass;

    p->~Myclass();

}
/*--------------------------------------------------------
Sınıfların static veri elemanları(static data members):
(global değişkenlerin) dik katmanında dilin diğer araçlarıyla
uyumlu hale getirilmiş biçimi
-------------------------------------------------------*/
Ders 11'in Sonu
Ders 12
/*--------------------------------------------------------
Başlık dosyasında static bir veri elemanı için static anahtar
sözcüğü yer alırken .cpp dosyasında tanımlarken static anahtar
sözcüğü yer almaz. Karışıklığı öneme için boş bir static makrosu
tanımlamak ayırt etmek için iyi bir teknik olabilir.
-------------------------------------------------------*/
//myclass.h
class Myclass{
public:
    static int x;
}
//Myclass.cpp

int Myclass::x(77);
/*--------------------------------------------------------
const olmayan static veri elemanları tanımlandığı yer initialize
edilemez bu syntax hatasına neden olur.
-------------------------------------------------------*/
class Myclass
{
public:
    static int x = 10;//error
};

#include <iostream>

int main()
{
    std::cout << Myclass::x << '\n';
}
/*--------------------------------------------------------
Ancak static veri elemanı const olursa herhangi şekilde bir
syntax hatası oluşmaz.
-------------------------------------------------------*/
class Myclass
{
public:
    const static int x = 10;//geçerli
};

#include <iostream>

int main()
{
    std::cout << Myclass::x << '\n';
}
/*--------------------------------------------------------
static veri elemanları için dizi boyutu belirtmek şart değildir
örnekte olduğu gibi başlık dosyasında tanımlanıp .cpp dosyasında
uzunluğu belirtilebilir.
-------------------------------------------------------*/
//Myclass.h
class Myclass
{
public:
    static int a[];
};
//Myclass.cpp

int Myclass::a[10];
/*--------------------------------------------------------
Sınıfın kendi türünden bir non-static veri elemanı olamaz aynı
C'deki structların kendi türünden bir elemanı olamaması gibi.
Ancak bu durum static veri elemanları için farklıdır.
static veri elemanları incomplete type olabilmektedir.
-------------------------------------------------------*/
class Myclass
{
public:
    static Myclass m;
}
/*--------------------------------------------------------
Ancak Aşağıdaki görüldüğü gibi non-static bir veri elemanının
incomplete type olması syntax hatasına neden olur.
-------------------------------------------------------*/
class Ber;

class Myclass
{
public:
    static int a[];
    static Myclass m;
    Ber bx; //error
};

/*--------------------------------------------------------
incomplete type ile yapılabilecek bazı şeyler aşağıda
gösterilmiştir.
-------------------------------------------------------*/
class Ber;
extern Ber bx;

typedef Ber* NecPtr;
typedef Ber& NecRef;

Ber& f1(Ber*);
Ber& f2(Ber&);
Ber& f3(Ber);
Ber& foo();
void func(Ber&);

int main()
{
    Ber* p = nullptr;
    f1(p);
    Ber& n = foo();
    func(n);
}
/*--------------------------------------------------------
non-static veri elemanları nesne yaratımı olmadan kullanılamaz.
-------------------------------------------------------*/
class Myclass
{
public:
    int x;
}

int main()
{
    auto y = Myclass::x; //error
}
/*--------------------------------------------------------
static veri elemanları non-static miş gibi kullanılabilirler
ancak bu kesinlikle iyi bir teknik değildir.
-------------------------------------------------------*/

class Myclass{
public:
    static int x;
};

int main()
{
    Myclass m;
    Myclass* p{&m};
    m.x = 10;
    p->x = 20;
}
/*--------------------------------------------------------
static üye fonksiyonların genel özellikleri:
1-)this pointer'ına sahip değillerdir.
2-) bir instance için çağrılmayacaklar
3-) class scope içindeler
4-) sınıfın member'ı oldukları için sınıfın private bölümünü erişebiliyorlar.
5-)intance için değil sınıf için bir iş yapıyorlar
6-)erişim kontrolüne sahipler.
7-)global fonksiyonlara çoğu zaman daha iyi bir seçenek oluşturuyorlar.
-------------------------------------------------------*/
/*--------------------------------------------------------
Bir static üye fonksiyonu const yapmak syntax hatasına neden olur.
-------------------------------------------------------*/
class Myclass
{
public:
    static int foo()const;
}
/*--------------------------------------------------------
sınıfın static üye fonksiyonu sınıfın non-static veri elemanlarına
doğrudan erişemez bunun sebebi this pointerına sahip
olmamasından kaynaklanmaktadır.
-------------------------------------------------------*/

class Myclass{
public:
    static int foo()
    {
        mx = 10;
    }
private:
    int mx,my;
};

/*--------------------------------------------------------
Aşağıdaki örnekte foo fonksiyonunun parametre değişkeni
Myclass türünden olduğu için m. diyerek non-static veri
elemanların erişim sağlanabilir.
-------------------------------------------------------*/
class Myclass{
public:
    static int foo(Myclass m)
    {
        auto result = m.mx + m.my;
    }
private:
    int mx,my;
};
/*--------------------------------------------------------
Aşağıdaki örnekteki kod geçerlidir çünkü sınıfın kendi elemanları
private bölüme erişebilir.
-------------------------------------------------------*/
class Myclass{
public:
    static void foo()
    {
        Myclass m;
    }
private:
    Myclass();
};
/*--------------------------------------------------------
non-static veri elemanlarının ctor init. listte belirtilebilirken
static veri elemanlarının bildirilmesi syntax hatasına neden olur.
-------------------------------------------------------*/
class Myclass{
public:
    Myclass() : x{10} {}//error
private:
    static int x;
};
/*--------------------------------------------------------
Sınıfın veri elemanları main başlamadan hayata geldiği
için aşağıdaki örnekte ekran çıktısı foo cagrildi ve
sonrasında main başladı olacaktır.
Anahtar Notlar:static veri elemanlarını init etmek için
aşağıdaki örnekte inline anahtar sözcüğü kullanılmıştır.
Anahtar Notlar:Sınıfın const olan static tamsayı türlerinden
veri elemanlarına sabit ifadesiyle sınıf içinde ilk değer
verilebilir.
-------------------------------------------------------*/
#include <iostream>

int foo()
{
    std::cout << "foo cagrildi" << '\n';
    return 5;
}

class Myclass{
    inline static int x = foo();
};
int main()
{
    std::cout << "main basladi" << '\n';
}
/*--------------------------------------------------------
Sınıfın static üye fonskiyonları sınıfın static veri elemanlarına
doğrudan erişebilir.
-------------------------------------------------------*/
class Myclass{
public:
    static void foo()
    {
    //x = 10;
    }
private:
    static int x;
};

/*--------------------------------------------------------
Aşağıdaki örnek x değişkeninin değerini değiştirme opsiyonu
foo fonksiyonuna aittir.
-------------------------------------------------------*/
#include <iostream>

class Myclass{
public:
    static int getx()
    {
        return x;
    }
    static void foo()
    {
        x = 10;
    }
private:
    inline static int x{};
};
int main()
{
    Myclass::foo();

    std::cout << Myclass::getx() << '\n';
}
/*--------------------------------------------------------
Sınıfların non-static üye fonksiyonları static veri
elemanlarına erişebilir.
Sınıfların static üye fonksiyonları non-static veri elemanlarına
erişemez.
Örneğin aşağıdaki örnekte error'ün sebebi foo fonksiyonunun
non-static func fonksiyonunun static olmasından kaynaklanmaktadır.
-------------------------------------------------------*/
#include <iostream>

class Myclass{
public:
    void foo()
    {

    }
    static void func()
    {
     foo();//error
    }
};
/*--------------------------------------------------------
Aşağıdaki örnekteki kod geçerlidir.
-------------------------------------------------------*/
class Myclass{
public:
    void foo()
    {
    func();
    }
    static void func()
    {

    }
};
int main()
{

}
/*--------------------------------------------------------
Aşağıdaki örnekte f fonksiyonu ilk durumda double parametreli
funcı çağrırken ikinci durumda int parametreli funcı çağırır
fonksiyonun static veya non-static olması overload resolution
kurallarını etkilemez.
Anahtar Notlar:Eğer f fonksiyonu static olsaydı bu durumda
func(5) çağrısı syntax hatası olacaktı.
-------------------------------------------------------*/
#include <iostream>

class Myclass{
public:
    void func(int)
    {
        std::cout << "func(int)" << '\n';
    }
    static void func(double)
    {
        std::cout << "static func(double)" << '\n';
    }
    void f()
    {
        func(3.4);
        func(5);
    }
};
int main()
{
    Myclass m;
    m.f();
}
/*--------------------------------------------------------
İsim arama aşağıdaki örnek için öncelikle class scope içerisinde
yapılıp ardından gloabal isim alanında yapılmaktadır ancak
class scopeta isim bulunduğu için isim arama biter ve class
içerisindeki foo fonksiyonu çağrılır.
Sınıfın static veri elemanlarına ilk değer veren ifadelerdeki
nitelenmemiş isimler önce class scope'ta bulunamazsa ise namespace
scope'ta aranacaktır.
-------------------------------------------------------*/
int foo()
{
    return 1;
}

class Nec{
public:
    static int x;
private:
    static int foo()
    {
        return 2;
    }
};

int Nec::x = foo();

int main()
{
    std::cout << Nec::x << '\n';
}
/*--------------------------------------------------------
const üye fonksiyonlar sınıfın non-static veri elemanlarını
değiştiremez ancak sınıfın static veri elemanları için bu durum
geçerli değildir. Bu durumda aşağıdaki örnekteki kod geçerlidir.
-------------------------------------------------------*/
class Myclass{

    void func()const
    {
        x = 34;
    }
    inline static int x = 10;
};
int main()
{

}
/*--------------------------------------------------------
static üye fonksiyonlar non-static üye fonksiyonmuş gibi
çağrılabilir ancak bunu yapmak anlamlı değildir.
-------------------------------------------------------*/
class Myclass{
public:
    void foo();
    static void func();
};

int main()
{
    Myclass m;

    m.foo();
    m.func();

}
/*--------------------------------------------------------
non-static üye fonksiyonlar staticmiş gibi çağrılamaz.
-------------------------------------------------------*/
class Myclass{
public:
    void foo();
    static void func();
};

int main()
{
    Myclass::foo();//error
    Myclass::func();

}
/*--------------------------------------------------------
Bir prototip Complex sınıfı
-------------------------------------------------------*/
class Complex{
private:
    Complex(double a,double d,int dummy);
    Complex(double r,double i);
public:
    static Complex create_polar(double a,double d)
    {
        return Complex{a,d,0};
    }
    static Complex create_cartasian(double r,double i)
    {
            return Complex{ r,1 };
    }
}

int main()
{
    auto c1 = Complex::create_polar(1.2,4.5);
    auto c2 = Complex::create_cartasian(3.,3.4);
}
//ekleme yapılacak
//Ders 12'nin sonu
//Ders 13
/*--------------------------------------------------------
Friend bildirimi(friend declaration)
1-)Bir global fonksiyona(namespace içinde bildirilen bir fonksiyona)
arkadaşlık verilebilir.
2-)Bir sınıfın bir üye fonksiyonuna arkadaşlık verilebilir.
3-)Bir sınıfa arkadaşlık verilebilir.
Örneğin aşağıdaki örnekte foo global fonksiyonu Myclass
sınıfının arkadaşı olduğundan private bölümüne erişim hakkı vardır.
Anahta Notlar:friend bildiriminin sınıfın neresinde yapıldığının
hiçbir önemi yoktur.(hangi erişim belirleyici bölümünde yapılırsa
yapılsın aynı anlama gelmektedir.)
-------------------------------------------------------*/
class Myclass{
friend void foo(int);//
}
int main()
{

}
/*--------------------------------------------------------
Aşağıdaki örnekte anlatılmak istenen foo fonksiyonuna arkadaşlık
verildiği için sınıfın private bölümüne erişebildiği göstermektir.
Diğer taraftan g fonksiyonu yine foo gibi bir global fonksiyon
olmasının yanı sıra arkadaşlık verilmediği için sınıfın private
bölümüne erişme girişimi syntax hatasına sebep olmaktadır.
-------------------------------------------------------*/
class Myclass{
private:
    friend void foo(Myclass);
    void func();
    int mx;
};

Myclass g;

void foo(Myclass)
{
    Myclass m;
    m.mx = 10;
    m.func();
    g.func();
}
void g()
{
    Myclass m;
    m.mx = 10;
    m.func();
}
int main()
{

}
/*--------------------------------------------------------
Başka bir sınıfın üye fonksiyonuna arkadaşlık verme durumu aşağıdaki
örnekte gösterilmiştir. Bu durumda sadece o sınıfın belirtilen
o üye fonksiyonu sınıfın private bölümüne erişebilecektir.
-------------------------------------------------------*/
class Neco{
public:
    void foo();
};

class Myclass{
private:
    friend void Neco::foo();
    void func();
    int mx;
}
int main()
{

}
/*--------------------------------------------------------
Görüldüğü gibi sadece Neco sınıfının foo fonksiyonuna arkadaşlık
verildiği için sınıfın bar fonksiyonunun Myclass sınıfının
private bölümüne erişme girişimi syntax hatası olarak değerlendirilir.
-------------------------------------------------------*/
class Neco{
public:
    Neco();
    void foo();
    void bar();
};

class Myclass{
private:
    friend void Neco::foo();
    void func();
    int mx;
}
void Neco::foo()
{
    Myclass m;

    m.func();//geçerli
}
void Neco::bar()
{
    Myclass m;

    m.func();//geçersiz
}
int main()
{

}
/*--------------------------------------------------------
Aşağıdaki örnekte ise bar bu sefer global fonksiyon olarak
arkadaş bildirimiyle tanımlanmıştır.
-------------------------------------------------------*/
class Myclass{
private:
    static void func();
    static int mx;
    friend void bar();
};

void bar()
{
    Myclass::mx = 10;
    Myclass::func();
}
/*--------------------------------------------------------
Aşağıdaki Neco sınıfının tamamına arkadaşlık verildiği için
Neco sınıfının tamamı Myclass sınıfının private bölümüne erişebilir.
-------------------------------------------------------*/
class Myclass{
private:
    int mx;
    void foo();
    friend class Neco;
    //Neco sınıfının tanımı görünmüyor olsa bile geçerli
};

class Neco{

    void fnec()
    {
        Myclass m;
        m.mx = 10;
        m.foo();//geçerli
    }

    void f()
    {
        Myclass m;
        m.mx = 10;
        m.foo();//geçerli
    }
};
/*--------------------------------------------------------
Operator Overloading:
neden bu dilde overloading var?
ne faydası var?
runtime (ilave) maliyeti var mı?
i1+i2
i1.add(i2)
genel kurallar
-operator overloading sınıf türleri ve numarandırma türleri için
oluşturulmuş bir araç eğer unary bir operatörün operandı aritmetik
türlerden ise ya da binary bir operatörün her iki operandı da aritmetik
türlerden ise

Bu amaçla kullanılan fonksiyonlar
1-)free function
2-)non-static member function
Dikkat
-static member function olamaz.
-her operatör overload edilemez.
Overload edilemeyen operatörler:
:: scope resolution
.  member selection
sizeof
.*
? : ternary operator(koşul operatörü)
typeid

Yukarıda belirtilen operatörler dışındaki tüm operatörler
overload edilebilirler.

Bazı operatörler için yalnızca member operator function tanımlanabilir.
[]
()
->
type cast

-isimlendir keyfi olamaz!!

operator=
operator!
operator<<
operator=
Aşağıdaki örnekte operator<< overload edilmiştir.
-------------------------------------------------------*/
#include <iostream>

int main()
{
    using namespace std;
    int val{2};
    cout << ival;
    cout.operator<<(ival);
}
/*--------------------------------------------------------
tek operand alan operatörler

a-)Üye operatör fonksiyonu olarak overload edildiklerinde parametre değişkenine
sahip olmayacak(parametresiz) olacak
b-)Global operatör fonksiyonu olarak overload edildiklerinde tek bir parametre
değişkenine sahip olacak.
-------------------------------------------------------*/
class Nec{
public:
    Nec operator+(); //işaret +
    Nec operator-(); //işaret -
    Nec operator+(Nec); //toplama
    Nec operaror-(Nec); //çıkarma
    Nec& operator*(); //derefencing(içerik operatörü)
    Nec operator*(Nec); //çarpım
    Nec& operator++(); //prefix
    Nec operator++(int); //postfix
};

/*--------------------------------------------------------
Aşağıdaki örnekte bir operatör overloading örneği gösterilmiştir.
-------------------------------------------------------*/
class Nec{
public:
    Nec operator>>(int);
    Nec operator*(const Nec&);
    Nec operator+(const Nec&);
    bool operator>(const Nec&);
};

int main()
{
    Nec n1,n2,n3,n4;

    //n1 + n2 * n3 > n4 >> 5;
    //(n1 + (n2 * n3)) > (n4 >> 5);

    n1.operator+(n2.operator*(n3)).operator>(n4.operator>>(5));
}
//buradan devam et
/*--------------------------------------------------------
prefix ++ operatörünün ürettiği değer L value expressiondır.
Bu sebepten fonksiyonun geri dönüş değeri sınıf türünden son taraf
referansı olacaktır.
postfix ++ operatörünün ürettiği değer ise R value expressiondır.
-------------------------------------------------------*/
class Nec{
public:
    Nec& operator++();//prefix
    Nec operator++();//postfix
};

int main()
{
    //++x       L value expression
    //x++       R value expression
}
/*--------------------------------------------------------
[] operatörünün overload edilmesi
-------------------------------------------------------*/
class Array{
public:
    Array(int);
    int& operator[](int);
};

int main()
{
    Array a(10);

    a[5] = 20;
    a.operator[](5) = 20;
}
/*--------------------------------------------------------
iki matris için toplama yapan operatörün overload edilmesi
-------------------------------------------------------*/
class Matrix
{
public:
    Matrix& operator+=(const Matrix&);
};

int main()
{
    Matrix m1,m2;

    //m1 += m2
    m1.operator+=(m2);
}
/*--------------------------------------------------------
Mint sınıfı
-------------------------------------------------------*/
class Mint{
public:
    explicit Mint(int = 0);
    friend std::ostream& operator<<(std::ostream&, const Mint&);
    friend std::istream& operator>>(std::istream&, Mint&);

    Mint operator+()const;
    Mint operator-()const;

    Mint& operator++();//prefix
    Mint& operator--();//prefix
    Mint operator++(int);//postfix
    Mint operator--(int);//postfix

    Mint& operator+=(const Mint&);
    Mint& operator-=(const Mint&);
    Mint& operator*=(const Mint&);
    Mint& operator/=(const Mint&);
    Mint& operator%=(const Mint&);
private:
    int mval;
};
/*--------------------------------------------------------
coutta kullanılan operator<< ve operator>> lerin overloadları
-------------------------------------------------------*/

std::ostream& operator<<(std::ostream& os, const Mint& x)
{
    return os << '(' << x.mval << ')';
}

//extractor fonksiyonları iostream kütüphanesine öğrendikten
//sonra tekrar ele alıcaz

std::ostream& operator>>(std::ostream& is, Mint& x)
{
    return is >> x;
}

/*--------------------------------------------------------
Karşılaştırma operatörlerinin overloadları
-------------------------------------------------------*/
bool operator==(const Mint& lhs,const Mint& rhs)
{
    return lhs.mval == rhs.mval;
}
bool operator!=(const Mint& lhs,const Mint& rhs)
{
    return !(lhs == rhs);
}
bool operator<(const Mint& lhs,const Mint& rhs)
{
    return lhs.mval < rhs.mval;
}
bool operator>(const Mint& lhs,const Mint& rhs)
{
    return rhs < lhs;
}
bool operator>=(const Mint& lhs,const Mint& rhs)
{
    return !(lhs < rhs);
}
bool operator<=(const Mint& lhs,const Mint& rhs)
{
    return !(rhs < lhs);
}
/*--------------------------------------------------------
işaret + ve - operatörleri
-------------------------------------------------------*/
Mint operator+()const
{
    return *this;
}
Mint operator-()const
{
    return Mint{-mval};
}
/*--------------------------------------------------------
işlemli atama operatörleri
-------------------------------------------------------*/
Mint& operator+=(const Mint& other)
{
    mval += other.mval
    return *this;
}
Mint& operator-=(const Mint& other)
{
    mval -= other.mval
    return *this;
}
Mint& operator*=(const Mint& other)
{
    mval *= other.mval
    return *this;
}
Mint& operator/=(const Mint& other)
{
    mval /= other.mval
    return *this;
}
Mint& operator%=(const Mint& other)
{
    mval %= other.mval
    return *this;
}
/*--------------------------------------------------------
postfix ve prefix ++ operatörleri
-------------------------------------------------------*/
Mint& operator++()
{
    ++mval;
    return *this;
}
Mint operator++(int)
{
    Mint ret{*this};
    ++*this;
    return ret;
}
/*--------------------------------------------------------
postfix ve prefix -- operatörleri
-------------------------------------------------------*/
Mint& operator--()
{
    --mval;
    return *this;
}
Mint operator--(int)
{
    Mint ret{*this};
    --*this;
    return ret;
}
/*--------------------------------------------------------
IntArray sınıfı
-------------------------------------------------------*/
class IntArray{
public:
    IntArray(std::size_t n) :msize {n},mp{new int [n] {}}
    {

    }
    ~IntArray()
    {
    delete [] mp;
    }
    int& operator[](std::size_t idx)
    {
        return mp[idx];
    }
    const int& operator[](std::size_t idx)const
    {
        return mp[idx];
    }
   std::size size()const
   {
        return msize;
   }
   std::size_t size()const
   {
        return msize;
   }
private:
    std::size_t msize;
    int* mp;
};
/*--------------------------------------------------------
pointer-like
iterator
smart-pointer
pointer
-raw pointer
-naked pointer
smart pointer
dereferencing operatörü ve ok operatörünün overload edilmesi
-------------------------------------------------------*/
class NecPtr{
public:
    NecPtr(Nec* p) : mp{p}{}
    ~ÑecPtr()
    {
        delete mp;
    }
    Nec& operator*()
    {
        return *mp;
    }
    Nec* operator->()
    {
        return mp;
    }
private:
    Nec* mp;
};
int main()
{
    {
        std::unique_ptr<Nec> pnec(new Nec{ 1234 });

        std::cout << *pnec << '\n';
        pnec->set(3);
        std::cout << *pnec << '\n';
    }
    std::cout << "main devam ediyor"<<'\n';
}

/*--------------------------------------------------------
Fonksiyon çağrı operatörü:
func();
func.operator()();

a-)fonksiyon
b-)fonksiyon pointer
c-)bir sınıf nesnesi
d-)closure object
e-)std::bind

-Herhangi bir parametrik yapıda olabilir.
-Parametreleri varsayılan argüman alabilir.
Aşağıdaki örnekte bir fonksiyon çağrı operatör örneği verilmiştir.
-------------------------------------------------------*/
#include <vector>
#include <string>
#include <iostream>
#include <algorithm>


class LenPred{
public:
    LenPred(std::size_t len) : mlen(len){}
    bool operator()(const std::string&)
    {
        return s.length() == mlen;
    }
private:
    std::size_t mlen;
};

int main()
{
    using namespace std;

    vector<string> svec;
    rfill(svec, 1000 , rname);

    size_t len;
    std::cout << "uzunlugu kac olan isimler sayilsin";
    cin >> len;

    cout << count_if(svec.begin(),svec.end(),LenPred{ len }) << '\n';
}
/*--------------------------------------------------------
Myclass sınıfı
-------------------------------------------------------*/
class Myclass{
public:
     Myclass(int val) : mval{val} {}
     operator bool() const
     {
        return mval != 0;
     }
private:
    int mval;
};

int main()
{
    Myclass m1{ 7 }, m2 { 12 };

    auto x = m1.operator bool() + m2.operator bool();
    std::cout << "x:" << x << '\n';
}
Ders 15 in Sonu
Ders 16
/*--------------------------------------------------------
namespaces(isim alanları):Javadaki paketlere benzetilebilir.
-------------------------------------------------------*/
/*--------------------------------------------------------
Aşağıdaki örnekte arama önce blok scope içerisinde yapılıp
bulunamamıştır ardından global isim alanında aranmıştır
orda da bulunamayınca syntax hatası oluşmuştur.
-------------------------------------------------------*/
namespace Nec{
    int x{};

    class Myclass{

    };
}

int main()
{
    x = 5;
}

/*--------------------------------------------------------
Yukarıdaki problem aşağıdaki gibi çözülebilir. Artık burda
bildirilen Nec isim alanına ait x'tir.
-------------------------------------------------------*/
namespace Nec{
    int x{};

    class Myclass{

    };
}

int main()
{
    Nec::x = 5;
}
/*--------------------------------------------------------
Aşağıdaki örnekteki kod geçerlidir(C++ 17)
Bu durumda mesut tek bir isim alanıdır ve üstüne ekleme
yapılıyormuş gibi düşünülebilir.Yani :
namespace mesut{
 int a,b;
}
ifadesiyle aşağıdaki kod aynı anlamdadır.
-------------------------------------------------------*/
namespace mesut{
    int a;
}
namespace mesut{
    int b;
}
/*--------------------------------------------------------
namespace'in içerisinde bulunan bir sınıfın üye fonksiyonu
erişim için hem namespace hem de sınıf bildirilmelidir.
-------------------------------------------------------*/
namespace Pro{
    class Myclass{
    public:
        void func();
    };
}

void Pro::Myclass::func()
{

}
/*--------------------------------------------------------
using bildirimi:Bu bildirim ile bir namespace elemanı,
enum elemanı veya bir sınıf elemanı bu bildirim sayesinde
doğrudan kullanılabilir.
-------------------------------------------------------*/
namespace pro{
    int a,b;
}

using pro::a;

void foo()
{
    a = 5;
}
void bar()
{
    a = 7;
}
/*--------------------------------------------------------
Aşağıdaki örnekte ise bildirim yukarıdaki gibi global isim
alanında yapılmadığı için barın içinde a değişkenine yapılan
atama syntax hatasına neden olur.
-------------------------------------------------------*/
namespace pro{
    int a,b;
}



void foo()
{
    using pro::a;
    a = 5;
}
void bar()
{
    a = 7;//error
}
/*--------------------------------------------------------
Aşağıdaki örnekte veli isim alanı içerisinde using bildirimi
yapılmıştır bu sebeple main de velinin x elemanı gibi kullanımı
geçerlidir.
-------------------------------------------------------*/
namespace ali{
    int x = 4;
}
namespace veli{
    using ali::x;
}

int main()
{
    veli::x = 5;
}
/*--------------------------------------------------------
Aşağıdaki örnek main içerisinde 45 değeri atanan x ifadesi ali
namespace ine ait olan x değeridir bunun nedeni isim aramanın
öncelikle blok scopeta yapılmasından kaynaklanmaktadır.
-------------------------------------------------------*/
#include <iostream>

namespace ali{
    int x = 5;
}

int x = 10;

int main()
{
    using ali::x;

    x = 45;

    std::cout << "ali::x = "<< ali::x << '\n';
}
/*--------------------------------------------------------
using bildirimi ile tek seferde birden fazla bildirim yapılabilir
bu bildirimler virgülle ayrılır.
-------------------------------------------------------*/
namespace ali
{
    int a=10;
}
namespace mert
 {
    int b = 34;
 }
 using ali::a,mert::b; //geçerli
/*--------------------------------------------------------
using namespace bildirimi:
using bildiriminden farklı olarak bu bildirimde bildirilen
bir namespace elemanı değil kendisidir yani bu bildirimle
bu namespace içerisindeki tüm elemanlar visible hale gelir.

Anahtar Notlar:using bildirimindeki gibi tek seferde birden
fazla bildirim yapılamaz. Örneğin aşağıdaki örnekteki kod
geçersizdir.
-------------------------------------------------------*/

namespace ali{}
namespace veli{}
namespace naz{}

using namespace ali,veli,naz;//geçersiz

int main()
{

}
/*--------------------------------------------------------
Aşağıdaki örnek geçerlidir.
-------------------------------------------------------*/
#include <iostream>


int main(){
    using namespace std;

    int cout =5; //geçerli
}
/*--------------------------------------------------------
Aşağıdaki örnek geçersizdir.
-------------------------------------------------------*/
#include <iostream>


int main(){
    using std::cout;

    int cout =5;//geçersiz
}
/*--------------------------------------------------------
Aşağıdaki örnek geçerlidir. Çünkü ikinci durum std::cout
çağrılmaktadır.
-------------------------------------------------------*/
#include <iostream>


int main(){
    using namespace std;

    int cout =5;

    cout << "berke";
}
/*--------------------------------------------------------
Bu örnekte ise durum bambaşkadır cout değişkeni 2 basamak sola
kaydırılmıştır.
-------------------------------------------------------*/
#include <iostream>


int main(){
    using namespace std;

    int cout =5;

    cout << 2;
}
/*--------------------------------------------------------
namespace bildirimi main fonksiyonunun altında yapıldığı için
aşağıdaki kod geçersizdir.
-------------------------------------------------------*/
#include <iostream>


int main(){

    cout << 5;
}
using namespace std;
/*--------------------------------------------------------
Aşağıdaki örnekte main fonksiyon içerisinde yapılan x = 2.3
ataması bir ambiguityye neden olur çünkü isim arama sırasında
2 tane x değişkeni bulunur.Ancak using bildiriminde direk x
değişkeni direk olarak blok scope içerisinde visible hale
geldiğinden isim arama sırasında bir ambiguity oluşmaz.
-------------------------------------------------------*/
namespace ali{
    double x = 4.5;
}

int x = 10;

int main()
{
    using namespace ali;

    x = 2.3;
}
/*--------------------------------------------------------
Aşağıdaki örnekte syntax hatasının nedeni x'in hem
namespace içerisinde hem de global alanda bulunmasından
dolayı iki anlamlılık(ambiguity) oluşur.
-------------------------------------------------------*/
namespace nec{
    double x=4.5;
}
int x=10;

int main(){

    using namespace nec;

    x=20.4;//ambiguity

}
/*--------------------------------------------------------
Aşağıdaki örnekte ise bir syntax hatası söz konusu değildir.
çünkü 10 değeri atanan main içerisinde bulunan yerel x nesnesidir.
-------------------------------------------------------*/
namespace ali{
    double x = 4.5;
}

int x = 10;

int main()
{
    using namespace ali;

    int x;
    x = 10;
}
/*--------------------------------------------------------
Aşağıdaki örnekte veli isim alanının double parametreli func
fonksiyonu çağrılır çünkü o visible durumdadır overloading
söz konusu değildir.
-------------------------------------------------------*/
#include <iostream>

namespace ali{
    void func(int)
    {
    std::cout << "ali::func(int)" <<'\n';
    }
}
namespace veli{
    void func(double)
    {
        std::cout << "veli::func(double)" << '\n';
    }
}

using namespace veli;

int main()
{
    func(12);
}
/*--------------------------------------------------------
Ancak aşağıdaki gibi ali isim alanı için de using namespace
bildirimi yapıldığı için overloading söz konusudur. Bu durumda
tabi ki ali::func(int) fonksiyonu çağrılır.
-------------------------------------------------------*/
#include <iostream>

namespace ali{
    void func(int)
    {
        std::cout << "ali::func(int)" <<'\n';
    }
}
namespace veli{
    void func(double)
    {
        std::cout << "veli::func(double)" << '\n';
    }
}

using namespace veli;
using namespace ali;

int main()
{
    func(12);
}
/*--------------------------------------------------------
Aşağıdaki durumda da gene ali'nin func fonksiyonu çağrılacaktır.
-------------------------------------------------------*/
#include <iostream>

namespace ali{
    void func(int)
    {
        std::cout << "ali::func(int)" <<'\n';
    }
}

    void func(double)
    {
        std::cout << "func(double)" << '\n';
    }



using namespace ali;

int main()
{
    func(12);
}
/*--------------------------------------------------------
Aşağıdaki örnekte ADL(Argument Depended Look-up) söz konusudur.
Yani isim arama sadece block scope içerisinde değil ona
ek olarak isim alanında da yapılmaktadır. Yani global isim alanında
başka bir func fonksiyonu olması durumunda syntax hatası oluşurdu.
-------------------------------------------------------*/
namespace ali{
    class nec{

    };
    void func(nec);
}

int main()
{
    ali::nec mynec;
    func(mynec);
}
/*--------------------------------------------------------
Aşağıdaki örnekteki kod geçerlidir.
-------------------------------------------------------*/
#include <iostream>

int main()
{
    endl(std::cout);
}
/*--------------------------------------------------------
Aşağıdaki örnekte bir ambiguity söz konusudur.
-------------------------------------------------------*/
namespace nec{
    class A{
        //...
    };
    void func(A);
}

void func(nec::A);

int main()
{
    nec::A ax;
    func(ax);
}
/*--------------------------------------------------------
Yukarıdaki problemin çözümü aşağıdaki gibidir.
-------------------------------------------------------*/
namespace nec{
    class A{
        //...
    };
    void func(A);
}

void func(nec::A);

int main()
{
    nec::A ax;
    ::func(ax);
    nec::func(ax);
}
/*--------------------------------------------------------
nested namespaceler için aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
namespace nec{
    namespace proj{
        int x;
        class Myclass{
            void func(int);
        };
    }
}

void nec::proj::Myclass::func(int x)
{

}
int main()
{
    nec::proj::x = 10;
}
/*--------------------------------------------------------
nested namespaceler aşağıdaki gibi de nitelenebilir
-------------------------------------------------------*/
namespace A{
    int x;
}
namespace A::B{
    int y;
}
namespace A::B::C{
    int z;
}

int main()
{
    A::B::y = 5;
    A::B::C::x = 15;
}
/*--------------------------------------------------------
inline namespacelerin elemanlar söz konusu blok içerisinde
herhangi bir bildirimsiz visible durumdadır. Örneğin aşağıdaki
örnek geçerlidir.
-------------------------------------------------------*/
namespace nec{
    inline namespace proj{
        int a,b,c;
    }

}

int main()
{
    nec::x = 10;
}
/*--------------------------------------------------------
Aşağıdaki örnek için Ver1 namespace ine ait olan Myclass sınıfı
için nesne yaratımı söz konusudur. Eğer inline anahtar sözcüğü
Ver2 isim alanının Myclass sınıfında olsaydı o zaman Ver2 isim
alanına ait olan Myclass sınıfı için nesne yaratımı söz konusu
olacaktı.
-------------------------------------------------------*/
namespace nec{
    inline namespace Ver1{
        class Myclass{

        };
    }
    namespace Ver2{
        class Myclass{

        };
    }

}

int main()
{
    nec::Myclass m;
}
/*--------------------------------------------------------
isimsiz isim alanı(unnamed namespace): isimsiz isim alanlarında
bulunan değişkenler globalmiş gibi kullanılabilir. Global
değişkenlerden en önemli farkı one definition rule a sadık kalınması
açısından unnamed namespaceler daha avantajlıdır.
-------------------------------------------------------*/
namespace {
    int x;
}
/*--------------------------------------------------------
nested namespacelerle alakalı aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/

namespace c_system_prog{
    namespace projects{

        namespace details{
            int a,b,c;
        }
    }

}

int main()
{
    namespace details = c_system_prog::projects::details;

    details::a = 10;

}

/*--------------------------------------------------------
namespace içerisinde namespace bildirimiyle ilgili aşağıdaki
örneği inceleyiniz.
-------------------------------------------------------*/

namespace Std{
    namespace Ranges{
        namespace Views{
            int x;
        }
    }
    namespace Views = Ranges::Views;
}

int main()
{
    Std::Ranges::Views::x = 10;
    Std::Views::x = 10;
}
/*--------------------------------------------------------
Aşağıdaki örnekte namespace bildirimi Nec::Ver2 için yapıldığından
dolayı Ver2 için bir Myclass nesnesi yaratılmıştır.
-------------------------------------------------------*/

namespace Nec{
    namespace Ver1{
        class Myclass {};
    }
    namespace Ver2{
        class Myclass {};
    }
}
namespace Cur = Nec::Ver2;

int main()
{
    Cur::Myclass x;
    //code
}
Ders 16'nın Sonu
Ders 17
/*--------------------------------------------------------

-------------------------------------------------------*/
class Myclass{
private:
    class Nested{
        //...
    };
public:
    static Nested func();
};

int main()
{
    auto x = Myclass::func(); //geçerli
    Myclass::Nested x = Myclass::func(); //geçersiz
}
/*--------------------------------------------------------
Aşağıdaki örnekte Myclass sınıfının Nested türünden veri elemanı
typedef bildirimindeki Nested yani inttir.
-------------------------------------------------------*/
typedef int Nested;

namespace Nec{
    Nested mx;//geçerli int mx

    namespace Nested{

    }
}

/*--------------------------------------------------------
Aşağıdaki örnekte görüldüğü gibi Nested A sınıfı içerisindeki
private bölümde bulunan func foo tarafından erişimlemeyecek durumdadır.
Bu yüzden aşağıdaki kodda error oluşur.
-------------------------------------------------------*/
class Nec{
public:
    class A{
    private:
        void func();
    };
    void foo()
    {
        A ax;
        ax.func(); //error
    }
}
/*--------------------------------------------------------
Ancak tersi durumda Sınıfın içinde bildirilen bir nested class
içinde bulunduğu sınıfın private bölümüne erişebilir yani
aşağıdaki kodda hiçbir syntax hatası yoktur.
-------------------------------------------------------*/
class Nec{
private:
    static int x;
    static void foo();
    void func();

    class A{
        void func()
        {
            x = 10; //gecerli
            foo();
            Nec n;
            n.func();
        }
        };
}
/*--------------------------------------------------------
sıfırın private bölümünde bulunan bir nested class için
bir üye fonksiyon içerisinde nesne yaratımı geçerlidir.
-------------------------------------------------------*/
class Nec{

    void foo()
    {
        A ax;
    }
    class A{
        //...
    };
}
/*--------------------------------------------------------
using bildirimiyle function pointer bildirilmesi typedef ile
bildirilmesinden daha anlaşılır olduğu için mümkün mertebe
bu durumlarda using bildirimi tercih edilmelidir. Ancak
örneğin C'de using anahtar sözcüğü olmadığı için typedef
kullanmaktan başka bir çare yoktur.
-------------------------------------------------------*/

using fptr = int (*)(int);
typedef int (*fptr)(int);

/*--------------------------------------------------------
Composition ilişkisi:Kısaca bir sınıfın elemanının başka bir
sınıf türünden olması durumuna verilen isimdir. Bu duruma
genel olarak programlamada has a ilişkisi denir. Örneğin
aşağıdaki örnekte Car has an Engine örneği için bir koddur.
-------------------------------------------------------*/
class Engine{
    //....
};

class Car {
private:
    Engine m_engine
};
/*--------------------------------------------------------
Aşağıdaki örnekte anlatılmak istenen compositon ilişkisiyle
başka bir sınıfı eleman olarak alan sınıf eleman olarak aldığı
sınıfın private bölümüne erişim hakkı olmamasıdır bu yüzden
private bölüme erişme girişimi aşağıdaki örnekteki gibi syntax hatasıdır.
-------------------------------------------------------*/
class A{
public:
    void pubfoo();
private:
    void prifunc();
};

class B{
public:
    void f()
    {
        ax.pubfoo();
        ax.prifunc(); //error
    }
private:
    A ax;
};
/*--------------------------------------------------------
AşağıdaKi örnekte Car sınıfıyla Engine sınıfı arasında
composition ilişkisi söz konusudur. Bu durumda engine
Car sınıfının bir veri elemanı olduğundan dolayı
önce engine sınıfının ctoru sonra car sınıfının ctoru çağrılır.
kurallara göre önce hayata gelen en son yok edildiği için destructor
engine nesnesi için en son çağrılacaktır.
-------------------------------------------------------*/
#include <iostream>

class Engine
{
public:
    Engine()
    {
        std::cout << "Engine ctor" << '\n';
    }

    void start_engine()
    {
        std::cout << "Engine started" << '\n';
    }
    ~Engine()
    {
        std::cout << "Engine dtor" << '\n';
    }
};
class Car{
public:
    Car()
    {
        std::cout << "Car ctor" << '\n';
    }


    void start_car()
    {
        e.start_engine();
    }
    ~Car()
    {
        std::cout << "Car dtor" << '\n';
    }
private:
    Engine e;
};

int main()
{
    Car c;
}
/*--------------------------------------------------------
Aşağıdaki örnekte Member sınıfının int parametreli ctoru
programcı tarafından yazıldığından Member sınıfının default constructor
özel üye fonksiyonu derleyici tarafından yazılmamıştır.
main içerisinde bir Myclass nesnesi yaratılması durumunda
Memberın default ctoruna bir çağrı söz konusudur. Derleyici
Bu sebepten Member sınıfının default constructor özel üye
fonksiyonunu delete eder.
-------------------------------------------------------*/
class Member{
public:
    Member(int);
};

class Myclass{
    Member mx;
};

int main()
{
    Myclass m;//delete edilmiş fonksiyona çağrı hatası
}
/*--------------------------------------------------------
default ctorun private olması durumunda da ctor yine
yukarıdaki senaryodaki gibi delete edilir.
-------------------------------------------------------*/
class Member{
private:
    Member();
};

class Myclass{
    Member mx;
};

int main()
{
    Myclass m;//delete edilmiş fonksiyona çağrı hatası
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <string>

class Person{
public:
    Person(const char* p){

    }
private:
    std::string mname;
};

int main()
{
    Person p = "Gökhan Acer";
}
Ders 17'nin sonu
Ders 18
/*--------------------------------------------------------
Date ve Person sınıfları arası Composition ilişkisi örneği
-------------------------------------------------------*/
#include <string>

class Date{
public:
    Date(int day,int mount,int year);
    Date(const char*);
    Date();
    //...
};

class Person{
public:
    Date BirthDate()const
    {
        return mbdate;
    }
    std::string Name()const
    {
        return mname;
    }
private:
    std::string mname;
    Date mbdate;
};

int main()
{
    Person per;

    auto bdate = per.BirthDate();
    auto name = per.Name();
}

/*--------------------------------------------------------
non copyable-moveable
copyable - not moveable
non copyable - not moveable
copyable - moveable
Aşağıdaki örnekte Member sınıfının copy ctor fonksiyonu çağrılmıştır.
-------------------------------------------------------*/
#include <iostream>

class Member{
public:
    Member() = default;
    Member(const Member &)
    {
        std::cout << "Member copy ctor\n";
    }
};

class Owner{
public:
    //..
private:
    Member mx;
};

int main()
{
    Owner x1;
    Owner x2(x1);
}
/*--------------------------------------------------------
Ekran çıktısında da anlaşılabileceği gibi aşağıdaki kodda
hem Member sınıfı için hem de Owner sınıfı için ayrı ayrı
copy ctor fonksiyonu çağrısı söz konusudur.
-------------------------------------------------------*/
#include <iostream>

class Member{
public:
    Member() = default;
    Member(const Member &)
    {
        std::cout << "Member copy ctor\n";
    }
};

class Owner{
public:
    Owner()=default;
    Owner(const Owner& other) : mx(other.mx)
    {
        std::cout << "Owner copy ctor\n";
    }
private:
    Member mx;
};

int main()
{
    Owner x1;
    Owner x2(x1);
}
/*--------------------------------------------------------
Ancak aşağıdaki durumda Member sınıfının copy ctor fonksiyonu
çağrılmaz bunun nedeni eğer sınıfa bir copy ctor programcı
tarafından yazılırsa elemanların copy construct edilmesinden
artık programcı sorumludur. Eğer elemanlardan biri copy
construct edilmezse derleyici default ctoru çağırır.
-------------------------------------------------------*/
#include <iostream>

class Member{
public:
    Member() = default;
    Member(const Member &)
    {
        std::cout << "Member copy ctor\n";
    }
};

class Owner{
public:
    Owner()=default;
    Owner(const Owner& other)
    {
        std::cout << "Owner copy ctor\n";
    }
private:
    Member mx;
};

int main()
{
    Owner x1;
    Owner x2(x1);
}

/*--------------------------------------------------------
String Sınıfı:
dinamik dizide son olmayan bir konumdan(ortadan) ekleme
ya da silme işlemi yapmak O(n) karmaşıklığında gerçekleşir.
değerli erişimde reallocation'dan kaçınmalısınız.
en tipik dinamik dizi hatalarından biri small buffer optimization
string::size_type (size_t)
1-)Yazının uzunluğunun türü
2-)kapasite değerinin türü
3-)index türü
    Dikkat C'den farklı olarak C++ string sınıfının arama fonksiyonları
    bize index döndürürler
4-)Bazı fonksiyonların bir parametresi tane - adet değeri
5-)Bazı fonksiyonlar bizden bir adres ve bir tamsayı istiyorlar
    o adresten başlayarak o kadar tane karakter
-------------------------------------------------------*/
/*--------------------------------------------------------
Aşağıdaki örnekte bir tanımsız davranış söz konusudur çünkü
3. elemandan sonraki karakterlerin ne olduğu anca cenabı Allah
bilir.
-------------------------------------------------------*/
#include <iostream>
#include <vector>

using namespace std;

int main()
{
    char str[10];

    str[0] = 'A';
    str[1] = 'L';
    str[2] = 'P';

    string s{ str };//ub
}
/*--------------------------------------------------------
Bazı string sınıfı örnekleri
-------------------------------------------------------*/
#include <iostream>
#include <vector>

using namespace std;

int main()
{
    char str[] = "Mesut Topuzlu";

    string s1(str);//cstring ctor
    cout << "|" << s1 << "|" << '\n';
    string s2(str,5); //data param
    cout << "|" << s2 << "|" << '\n';
    string s3(str + 6, 5); //data param
    cout << "|" << s3 << "|" << '\n';
    string s4(str, str + 3); //rangeparam
    cout << "|" << s4 << "|" << '\n';

}
/*--------------------------------------------------------
init list: auto type deduction ile {}(süslü parantez içine yazılan)
elemanalar otomatik olarak init list olarak kabul edilir.
init list i doğrudan kullanmak için aşağıdaki gibi
init_list kütüphanesi include edilmelidir.
-------------------------------------------------------*/
#include <initializer_list>
#include <iostream>


using namespace std;

int main()
{
    initializer_list<int> x{12,34,56};

    cout << x.size() <<'\n';
}

/*--------------------------------------------------------
init list türünden container mantığıyla yazma yapmak
-------------------------------------------------------*/
#include <initializer_list>
#include <iostream>


using namespace std;

int main()
{
    initializer_list<int> x{1, 4, 7, 9, 32, 3};

    auto iter_beg =x.begin();
    auto iter_end = x.end();

    while(iter_beg != iter_end){
        cout << *iter_beg << ' ';
        iter_beg++;
    }
}

/*--------------------------------------------------------
Aşağıdaki örnekte = operatörü kullanılırsa auto ile tür çıkarımı
init_list olarak yapılırken = operatörü kullanmadan yapıldığı durumda ise
int türünden tür çıkarımı yapılacaktır.
-------------------------------------------------------*/

int main()
{
    auto x = {45};//init_list
    auto x{45};//int
}
/*--------------------------------------------------------
init_list 'in bir kullanımı
Bu kullanımda vector containerının uzunluğu 100 iken
init_listin söz konusu containera atanmasıyla artık size
değeri 3 olur.
-------------------------------------------------------*/
#include <initializer_list>
#include <iostream>
#include <vector>

using namespace std;

int main()
{
    vector<int> ivec(100);
    int x{13},y{5},z{45};

    ivec = {x,y,z};
    cout << ivec.size() <<'\n';
}
/*--------------------------------------------------------
init_listin başka bir kullanımı ancak şüphesiz bu işlem
doğrudan can stringini söz konusu stringe ekleyerek de
yapılabilirlerdi.
-------------------------------------------------------*/
#include <initializer_list>
#include <iostream>
#include <string>

using namespace std;

int main()
{
   string str{"ali"};
   str+= {'c','a','n'};
   cout << str << '\n';
}

/*--------------------------------------------------------
Aşağıdaki örnekte 3 farklı init biçiminin bazı durumlarda aynı
anlama gelmediği anlatılmak istenmiş bu örnekte uniform init
yapılırken diğerlerinden farklı olarak init list parametreli
parametreli ctor çağrılır.
-------------------------------------------------------*/
#include <initializer_list>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

class Nec{
public:
    Nec(int)
    {
        cout << "Nec(int)\n";
    }
    Nec(std::initializer_list<int>)
    {
        cout << "Nec(init_list)" << '\n';
    }
};

int main()
{
   Nec x = 10;
   Nec y(10);
   Nec z{9};
}

/*--------------------------------------------------------
size,length ve empty fonksiyonlarının bir kullanımı
-------------------------------------------------------*/
#include <initializer_list>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main()
{
  string s1;
  cout << "s1.size() = " << s1.size() <<'\n';
  cout << "s1.length() = " << s1.length() <<'\n';
  cout << boolalpha << s1.empty() <<'\n';
}

/*--------------------------------------------------------

-------------------------------------------------------*/
#include <initializer_list>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main()
{
    char str[100];

    str[0] = 'A';

    string s{str};

    cout << "s.size()" << s.size() << '\n';
    cout << "|" << s << '|'<<'\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte taşıma semantiğinin kullanılmasının sebebi
100000 karakter için kopyalama maliyetinin ciddi anlamda
fazla olmasından kaynaklıdır. ancak bu gibi durumlarda sonrasında
taşınan nesneyi kullanma girişimi tanımsız davranışa sebep olur.
-------------------------------------------------------*/
#include <initializer_list>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main()
{
    string s(100'000, 'A');
    //s nesnesini kullanmak istemiyorum taşıma yapıyorum
    string str = std::move(s);
}
/*--------------------------------------------------------
string sınıfının char parametreli ctoru yoktur.
-------------------------------------------------------*/
#include <initializer_list>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main()
{
    string str('A');//geçersiz
}
/*--------------------------------------------------------
Aşağıdaki örnekte str1 değeri s+3 ten başlayıp tüm karakterleri
alır bu yüzden üretilen yazı "han Sancar" yazısı olur.
str2 için baştan başlayıp yazının ilk 6 karakterini alacaktır bu
durumda yazı Gurhan olarak elde edilir. str3 içinse s+7 den
başlayarak taşma olsa dahi diğer bütün karakterleri alacaktır.
-------------------------------------------------------*/
#include <initializer_list>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main()
{
    char s[]="Gurhan Sancar";

    string str1(s+3);
    string str2(s,6);
    string str3(s + 7,10);

    cout << "|" << "str1:"<< str1 << "|" << '\n';
    cout << "|" << "str2:"<< str2 << "|" << '\n';
    cout << "|" << "str3:"<< str3 << "|" << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte ekran çıktısı Gur olacaktır.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main()
{
    char s[]="Gurhan Sancar";

    string str1{s,3};


    cout << "|" << "str1:"<< str1 << "|" << '\n';

}
/*--------------------------------------------------------
push_back find_last_of ve compare fonksiyonlarının birer
kullanımları
-------------------------------------------------------*/
#include <string>
#include <iostream>

int main()
{
    using namespace std;

    string str{"Ankar"};
    str.push_back('a');
    auto idx=str.find_last_of('a');
    if(!str.compare("Ankar"))
        cout << "Yazilar ayni";
    cout << str << '\n';
    cout << idx << '\n';

}
/*--------------------------------------------------------
erase fonksiyonu karakter silmeye yarayan bir fonksiyondur.
-------------------------------------------------------*/
#include <string>
#include <iostream>

int main()
{
    using namespace std;

    string str;
    cout << "Bir yazi giriniz?\n";
    getline(cin,str);
    if(auto idx = str.find('a') ; idx != string::npos){
        str.erase(idx,1);
    }
    cout << "str:" << str << '\n';
    operator+(str,"can");
    str+="can";

}
/*--------------------------------------------------------
Örnek Soru:Klayveden bir yazı alıp o yazıda bulunan son
a karakterini siliniz.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main()
{
    string str;
    cout << "Bir yazi giriniz?\n";
    getline(cin,str);
    if(auto idx = str.rfind('a');idx != string::npos){
        str.erase(idx,1);
    }
    cout << str;

}
/*--------------------------------------------------------
Aşağıdaki örnekte 3.karakterden başlayıp 3 karakter elde
edilmiştir bu sebeple elde edilen yazı "sel" yazısı olacaktır.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main()
{
    string s{"Veysel Aksoy"};

    string str{s,3,3};

    cout << "|" << str << "|" <<'\n';

}
/*--------------------------------------------------------
Aşağıdaki örnekte ise 3.karakterden başlayarak tüm karakterler
alınmaktadır. değerin taşma yapması durumu değiştirmez!!
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main()
{
    string s{"Veysel Aksoy"};

    string str{s,3,9897};

    cout << "|" << str << "|" <<'\n';

}
/*--------------------------------------------------------
Arama fonksiyonları:
1-)find
2-)rfind
3-)find_first_of
4-)find_first_not_of
5-)find_last_of
6-)find_last_not_of
sınıfın arama fonksiyonları aranan bulunamaz ise string::npos
bulunursa index döndürüyor
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main()
{
    string str;
    cout << "Bir yazi giriniz?\n";
    getline(cin,str);
    cout << str << '\n';

    if(string::size_type idx = str.find('u');idx != string::npos)
        cout << "Bulundu idx: " << idx << '\n';
    else
        cout << "Bulunamadi";

}
/*--------------------------------------------------------
Aşağıdaki örnekte bir tanımsız davranış söz konusudur.
çünkü puts fonksiyonu yazının sonunda null karakter olduğuna
güvenerek çalışmaktadır. stringlerin sonunda null karakter yoktur!
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main()
{
    string str{"Ahmet Aksoy"};

    char* p = str.data();
    puts(p);

    str += "Bugun istanbul'a geldi";
    puts(p); //ub

}
/*--------------------------------------------------------
reallocation'ın nasıl gerçekleştiğini anlatan bir örnek
Ekran çıktısı:
1.reallocation!! size = 16new cap is30

2.reallocation!! size = 31new cap is60

3.reallocation!! size = 61new cap is120

4.reallocation!! size = 121new cap is240

5.reallocation!! size = 241new cap is480
-------------------------------------------------------*/

#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main()
{
    string str;
    auto cap = str.capacity();
    int cnt{};

    for(int i = 0;i < 100'000;++i){
        str.push_back(static_cast<char>(rand() % 26 + 'A'));
        if(str.capacity() > cap ){
            cout << ++cnt << ".reallocation!! size = " << str.size() << "new cap is" << str.capacity() << '\n';
            cap = str.capacity();
            (void) getchar();
        }

    }

}
/*--------------------------------------------------------
shrink_to_fit fonksiyonu capacity değerini düşürmek
için kullanılabilir normal durumda stringin uzunluğu azalsa
bile capacity değeri azalmadığı için bunu yapmak bir nevi gerekliliktir.
-------------------------------------------------------*/

#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main()
{
    string str(1000'000,'A');

    cout << "str.size()" << str.size() << '\n';
    cout << "str.capacity()" << str.capacity() << '\n';
    str.erase(5);
    str.shrink_to_fit();
    cout << "str.size()" << str.size() << '\n';
    cout << "str.capacity()" << str.capacity() << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte taşıma semantiğini kullanmak çok daha iyi bir
tekniktir.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main()
{
    string s1 (10'000, 'A');
    string s2 (10'000, 'B');

    string temp{ s1 };
    s1 = s2;
    s2 = temp;
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main()
{
    string str{"alican efendioglu"};
    str.find('A', 10);
}
/*--------------------------------------------------------
Örnek Soru:Klavyeden girilen yazıda bulunan ilk "kan" yazısını
siliniz.
-------------------------------------------------------*/

#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main()
{
    string str;
    cout << "Bir yazi giriniz?\n";
    getline(cin,str);

    if(auto idx=str.find("kan");idx != string::npos){
        str.erase(idx,3);
    }
    else{
        cout << "Bulunamadi" << "\n";
    }
    cout << str;
}
/*--------------------------------------------------------
Örnek Soru: Klavyeden girilen yazıda bulunan bütün 'a' karakterlerini
silin.
-------------------------------------------------------*/

#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main()
{
    string str;
    cout << "Bir yazi giriniz?\n";
    getline(cin,str);

    for(;;){
        auto idx = str.find('a');
        if(idx == string::npos)
            break;
        str.erase(idx,1);
    }
    cout << str;
}
Ders 19 un sonu
Ders 20
/*--------------------------------------------------------
Ek Not:Bir dizinin ilk elemanının adresiyle dizinin kendi adresi
farklı türden adreslerdir. Ancak sayısal olarak aynı adrestir.
-------------------------------------------------------*/

int main()
{
    int a[] = { 1,2,3,4 };
    int* p = a;
    //deltype(a)=> int [4]
    //a => &a[0] => int*
    //&a int(*)[4]

    cout << "a : " << a << '\n';//array decay
    cout << "&a :" << &a <<'\n';
}
/*--------------------------------------------------------
iki string == operatörüyle karşılaştırılabilir const char*
veya char* türlerindeki gibi bir adres karşılaştırması söz konusu değildir.
Yazılar aynı ise 1 değeri üretilirken farklıysa 0 değeri üretilir.
-------------------------------------------------------*/

#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main()
{
    string s1{"ali"},s2{"veli"};

    auto b = s1 == s2;
    cout << b;

}
/*--------------------------------------------------------
string sınıfının compare fonksiyonu.
Aşağıdaki örnek için 0 değeri üretilecektir çünkü
3 indeksli karakterden başlanarak 3 karakter "han" yazısıyla
karşılaştırılmıştır. Aynı olduğu görülünce aynı strcmp'de olduğu
gibi 0 değeri üretilecektir.
-------------------------------------------------------*/

#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main()
{
    string str{"gokhan acer"};

    cout << str.compare(3,3,"han") << '\n';

}
/*--------------------------------------------------------
string sınıfının assign fonksiyonunun bazı kullanımları
-------------------------------------------------------*/

#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main()
{
    char str[] = "Bugun hava cok guzel bu guzel havada ders mi yapilir.";

    string s;

    s.assign(str + 6,5);

    cout << '|' << s << '|' << '\n';

    s.assign(str + 10, str + 15);
    cout << '|' << s << '|' <<'\n';

    s.assign(10,'E');
    cout << '|' << s << '|' <<'\n';
}
/*--------------------------------------------------------
Bir string'i boşaltmanın bazı yöntemleri
-------------------------------------------------------*/

#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main()
{
    string str = "Bugun hava cok guzel bu guzel havada ders mi yapilir.";

    str ={};
    str.clear();
    str = "";
    str.erase();
    str = string{};
    str.assign("");
    str.assign(0,'A');
    str.resize(0);


}
/*--------------------------------------------------------
Aşağıdaki örnekte ekran çıktısı aşağıdaki gibi olacaktır:
str.length(): 7
str.length(): 20
|mustafa||||||||||||||
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main()
{
    string str{"mustafa"};

    cout << "str.length(): " << str.length() << '\n';

    str.resize(20,'|');//20 ye uzat ve o kısımları '|' karakteriyle besle

    cout << "str.length(): " << str.length() << '\n';

    cout << '|' << str << "|\n";

}
/*--------------------------------------------------------
Aşağıdaki örnekte sondan bir karakter sile sile ekrana yazı yazdıran
bir işlem yapılmaktadır.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main()
{
    string str;
    cout << "Bir yazi giriniz?" << '\n';
    getline(cin,str);

    while(!str.empty()){
        str.erase(str.size() - 1,1);
        cout << str << '\n';
    }

}
/*--------------------------------------------------------
Örnek Soru:Klavyeden girilen bir yazı için aşağıdaki yazıyı
yazdırınız.
Örnek giriş:java
Çıkış:
j
ja
jav
java
-------------------------------------------------------*/
/*--------------------------------------------------------
string sınıfının pop_back fonksiyonu
-------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

int main()
{
    string str;

    cout << "Bir yazi giriniz?\n";
    getline(cin,str);

    while(!str.empty()){
        cout << str <<'\n';
        str.pop_back();
    }
}
/*--------------------------------------------------------
C++20 ile gelen erase kullanımı bu durumda
erase fonksiyonu söz konusu tüm karakterleri çıkarır.
-------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main()
{
    string str;

    cout << "Bir yazi giriniz?\n";
    getline(cin,str);

    erase(str,'a');

    cout << str;
}
/*--------------------------------------------------------
append fonksiyonuyla stringler birletirilebilir.
-------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main()
{
    string s1{"Berke"};
    string s2{"Sertel"};

    s1.append(s2);

    cout << s1 << '\n';

}
/*--------------------------------------------------------
append fonksiyonunun bir başka kullanımı
-------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main()
{
    string s{"Berke"};
    char str[] = "0123456789ABCDEF";

    s.append(10,'.');

    cout << s << '\n';

    s.append(str,5);

    cout << s << '\n';

}
/*--------------------------------------------------------
insert fonksiyonu karakter silmeden sadece indexe bağlı karakter
ekler.
-------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

int main()
{
    string s{"Berke"};

    s.insert(0,1,'[');
    cout << s << '\n';
    s.insert(3,"MURAT");
    cout << s << '\n';

}
/*--------------------------------------------------------
Aşağıdaki örnekte MURAT yazısı doğrudan ilk stringin başına
eklenir.
-------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

int main()
{
    string s{"Berke"};

    s.insert(s.length(),"MURAT");
    cout << s << '\n';

}

/*--------------------------------------------------------
replace fonksiyonu adından da anlaşılabileceği gibi stringleri
override eder. ilk parametre başlangıç indisini ikinci parametre
ise o indisten sonra kaç adet elemanın yerine geleceğini belirtmektedir.
-------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main()
{
    string s{"Berke"};

    s.replace(2,3,"MURAT");
    cout << s << '\n';

}
/*--------------------------------------------------------
stringleri cstring yani C'de kullanılan stringler haline getiren
bazı yöntemler
-------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main()
{
    string s{"Berke"};

    puts(s.data());
    puts(s.c_str());
    puts(&s[0]);
    puts(&*s.begin());
}
/*--------------------------------------------------------
operator+ kullanılarak stringlere yazı eklenebilir.
-------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

int main()
{
    string s{"Berke"};
    string str = "glu";

    s = operator+(operator+(operator+(s,"can"),'o'),str);
    cout << s << '\n';

}

/*--------------------------------------------------------
stoi kullanılarak bir string int türüne dönüştürülebilir.
ancak bu durumda tabi ki yalnızca sayı kısmını alır.
araya tek bir harf bile karışsa gerisini dikkate almaz.
-------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

int main()
{
    string str{"87291murat"};

    auto ival = stoi(str);

    cout << "ival" << ival << '\n';
}
/*--------------------------------------------------------
Ekran çıktısına göre örneği inceleyiniz:
idx:5
ival:87291
-------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

int main()
{
    string str{"87291murat"};
    size_t idx;
    auto ival = stoi(str,&idx);

    cout << "idx:" << idx << '\n';

    cout << "ival:" << ival << '\n';
}
/*--------------------------------------------------------
3 parametreye bağlı olarak başka sayı sistemlerinden 10 luk
sistem geçiş yapılabilir. Örneğin aşağıdaki örnekte string
16 lık yani hexadecimal sistemde ele alınmıştır.
-------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

int main()
{
    string str{"12aE"};
    size_t idx;
    auto ival = stoi(str,&idx,16);

    cout << "idx:" << idx << '\n';

    cout << "ival:" << ival << '\n';
}
//Ders 20 nin sonu
//Ders 21
/*--------------------------------------------------------
Kalıtım(Inheritance):Bir sınıftan başka bir sınıf türetilmesi durumuna
kalıtım denir. Bu durum genel olarak nesne yönelimli programlamada
is a ilişkisi olarak isimlendirilir. Örneğin BMW is a Car
Cat is an Animal gibi benzeri pek çok örnek verilebilir.
Türetme yapılan sınıfa Base class, Parent class veya super class
denilirken bu sınıftan türetilen sınıfa ise Derived class, Child
class veya subclass denilebilir. Türetme yapıldıktan sonra
bir taban sınıf nesnesi main içerisinde yaratılıp(static veri
elemanıysa doğrudan) türemiş sınıfın public erişim
belirleyiciye sahip elemanlarına erişilebilir. Örneğin
aşağıdaki örnekte hiçbir syntax hatası yoktur.
Anahtar Notlar:C++ dilinde hiçbir şey yazmamak demek
sınıflar için private anlamına gelmektedir. public
inheritance yapmak mümkün mertebe public anahtar sözcüğü
koyulmalıdır.
-------------------------------------------------------*/
class Base{
public:
    void foo();
    void func();
    int mx;
    static int s;
    class Nested{
        //
    };
};

class Der : public Base{

};

int main()
{
   Der myder;
   myder.func();
   myder.foo();
   myder.mx = 10;
   Der::mx;
}
/*--------------------------------------------------------
Kalıtım olabilmesi için hem taban sınıf hem de türemiş
sınıf complete type olmak zorundadır aksi durumda error oluşur.
-------------------------------------------------------*/
class Base;

class Der : public Base{ //error

};
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>

using namespace std;

class A{
    class B{
        int x,y;
    };
    int a,b;

    B bx;
};

int main()
{
    cout << "sizeof(A)" << sizeof(A) << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte bir overloading söz konusu değildir.
double parametreli foo çağrılır çünkü nesne türemiş sınıf nesnesi
olduğu için önce türemiş sınıfta aranır ve bulunur. Ancak
Der sınıfı içerisinde bulunamadıysa taban sınıf içerisinde
arama söz konusu olurdu.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

class Base{
public:
    void foo(int)
    {
        cout << "Base::foo(int)" << '\n';
    }
};

class Der : public Base{
public:
    void foo(double)
    {
        cout << "Der::foo(double)" << '\n';
    }
};

int main()
{
   Der myder;
   myder.foo(12);
}
/*--------------------------------------------------------
Aşağıdaki örnekte ise syntax hatası oluşur çünkü gene foo
türemiş sınıf içerisinde bulunur ve too many argument isimli
syntax hatasını verir.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

class Base{
public:
    void foo(int,int)
    {
        cout << "Base::foo(int)" << '\n';
    }
};

class Der : public Base{
public:
    void foo(double)
    {
        cout << "Der::foo(double)" << '\n';
    }
};

int main()
{
   Der myder;
   myder.foo(12,34);//error
}
/*--------------------------------------------------------
Ancak aşağıdaki gibi çağrılsa elbette bir problem olmazdı
-------------------------------------------------------*/
#include <iostream>

using namespace std;

class Base{
public:
    void foo(int,int)
    {
        cout << "Base::foo(int)" << '\n';
    }
};

class Der : public Base{
public:
    void foo(double)
    {
        cout << "Der::foo(double)" << '\n';
    }
};

int main()
{
   Der myder;
   myder.Base::foo(12,34);
   myder.Der::foo(20.6);
}
/*--------------------------------------------------------
isim türemiş sınıf ile nitelenirse

der.x
derptr->x
Der::x

türemiş sınıfın üye fonksiyonu içinde nitelenmeden kullanılan
isim

blok içerisinde aranır bulunamazsa
sonra kapsayan blok içerisinde aranır bulunamazsa
sonra türemiş sınıf içerisinde aranır bulunamazsa
sonra taban sınıf içerisinde aranır bulunamazsa
namespace içerisinde aranır bulunamazsa
global namespace içerisinde aranır.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

int x = 10;

class Base{
public:
    void foo(int,int)
    {
        cout << "Base::foo(int)" << '\n';
    }
    int x = 34;
};

class Der : public Base{
public:
    void foo(double)
    {
        cout << "Der::foo(double)" << '\n';
    }
    int x = 99;
};

int main()
{
    int x = 45;

    cout << x; //local x
    cout << this->x;//Der::x
    cout << Der::x; // Der::x
    cout << Base::x; //Base::x
    cout << ::x; //x
}
/*--------------------------------------------------------
Aşağıdaki örnekte foo fonksiyonu kendinisi çağırmaktadır
buna recursive çağrı adı verilir.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

class Base{
public:
    void foo(int)
    {
        cout << "Base::foo(int)" << '\n';
    }
};

class Der : public Base{
public:
    void foo(double)
    {
        cout << "Der::foo(double)" << '\n';
        foo(10);
    }
};

int main()
{
    Der myder;
    myder.foo(12);

}
/*--------------------------------------------------------
Aşağıdaki örnekte türemiş sınıfın foo fonksiyonu private olduğundan
dolayı syntax hatası oluşur. Bizde public yok taban sınıftan verelim
gibi mantık yoktur.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

class Base{
public:
    void foo(int)
    {
        cout << "Base::foo(int)" << '\n';
    }
};

class Der : public Base{
private:
    void foo(double)
    {
        cout << "Der::foo(double)" << '\n';
    }
};

int main()
{
    Der myder;
    myder.foo(12);
}
/*--------------------------------------------------------
Türemiş sınıf taban sınıfın protected bölümüne erişebilir
-------------------------------------------------------*/
#include <iostream>

using namespace std;

class Base{
protected:
    void func(int)
    {
        cout << "Base::func(int)" << '\n';
    }
};

class Der : public Base{
public:
    void foo(double)
    {
        cout << "Der::foo(double)" << '\n';
        Base::func(12);
    }
};

int main()
{
    Der myder;
    myder.foo(12);
}
/*--------------------------------------------------------
türemiş sınıf içerisinde using bildirimi yapıldığı takdirde
aşağıdaki örnekte bir overloading söz konusudur. bu durumda
double türden argüman için Der::func ve int türden argüman için
Base::func çağrısı söz konusudur.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

class Base{
protected:
    void func(int)
    {
        cout << "Base::func(int)" << '\n';
    }
};

class Der : public Base{
public:
    using Base::func;
    void func(double)
    {
        cout << "Der::foo(double)" << '\n';
    }
};

int main()
{
    Der myder;
    myder.func(12);
    myder.func(2.3);
}
/*--------------------------------------------------------
Aşağıdaki örnekte bir syntax hatası söz konusu değildir ve
Der::foo çağrılır.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

class Base{
public:
    void func(int)
    {
        cout << "Base::func(int)" << '\n';
    }
};

class Der : public Base{
public:
    using Base::func;
    void func(int)
    {
        cout << "Der::foo(int)" << '\n';
    }
};

int main()
{
    Der myder;
    myder.func(12);
}
/*--------------------------------------------------------
Taban sınıf türünden pointer ve referanslar türemiş sınıf türünden
nesneler atanabilir.
-------------------------------------------------------*/
class Base{
//......
}

class Der : public Base{


}

int main()
{
    Der myder;

    Base* baseptr = &myder; //geçerli
    Base& baseref= myder; //geçerli
}
/*--------------------------------------------------------

-------------------------------------------------------*/
class Base{
//......
}

class Der : public Base{


}

void func(Base* p);
void foo(Base& r);

int main()
{
    Der myder;

    Base* baseptr = &myder; //geçerli
    Base& baseref= myder; //geçerli
    Base mybase = myder; //geçerli ancak object slicing söz konusu
}
/*--------------------------------------------------------
Aşağıdaki örnekten anlaşılabileceği gibi öncelikle taban sınıfın
ctoru çağrıldı ardından türemiş sınıfın ctoru önce hayata gelen
en son hayata veda eder felsefesine göre de taban sınıfın
dtoru en son çağrılacaktır.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

class Base{
public:
    Base()
    {
        cout << "Base constructor" << '\n';
    }
    ~Base()
    {
        cout << "Base destructor" << '\n';
    }
};

class Der : public Base{
public:
    Der()
    {
        cout << "Der constructor" << '\n';
    }
    ~Der()
    {
        cout << "Der destructor" << '\n';
    }
};

int main()
{
    cout << "main Basladi" << '\n';
    Der myder;
}
/*--------------------------------------------------------
Türemiş sınıfın ctoru içerisinde Base sınıfının ctoruna
çağrı yapılmaktadır. Bu çağrı programcı tarafından aşağıdaki
gibi yapılabilir.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

class Base{
public:
    Base(int x)
    {
        cout << "Base(int) constructor" << '\n';
    }
    Base(double x)
    {
        cout << "Base(double) constructor" << '\n';
    }
    Base(int a,int b)
    {
        cout << "Base(int,int) constructor" << '\n';
    }
};

class Der : public Base{
public:
    Der(): Base(10,20)
    {
        cout << "Der constructor" << '\n';
    }

};

int main()
{
    Der myder;
}
/*--------------------------------------------------------
Multi-level inheritance: Bu durumda bir sınıftan başka bir
sınıf türetilir ancak buna ek olarak o türetilen sınıftan
da başka bir sınıf türetilir. Örneğin Car is a Vehicle
and BMW is a Car bunun en tipik örneklerinden biridir.
Bir multi level inheritance örneği
-------------------------------------------------------*/
#include <iostream>

using namespace std;

class Vehicle{
public:

    Vehicle()
    {
        cout << "Vehicle constructor" << '\n';
    }
    ~Vehicle()
    {
        cout << "Vehicle destructor" << '\n';
    }
};

class Car : public Vehicle{
public:
    Car()
    {
        cout << "Car constructor" << '\n';
    }
    ~Car()
    {
        cout << "Car destructor" << '\n';
    }
};

class BMW : public Car {
public:
    BMW()
    {
        cout << "BMW constructor" << '\n';
    }
    ~BMW()
    {
        cout << "BMW destructor" << '\n';
    }

};

int main()
{
    BMW bmw;
}
/*--------------------------------------------------------
Aşağıdaki örnekte Base sınıfının copy ctoru çağrılmaktadır.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

class Base{
public:
    Base()
    {
        cout << "Base default constructor" << '\n';
    }
    Base(const Base&)
    {
        cout << "Base copy ctor" <<'\n';
    }

};

class Der : public Base{
public:
    Der()
    {
        cout << "Der constructor" << '\n';
    }

};

int main()
{
    Der x;
    Der y = x;
}
/*--------------------------------------------------------
Ancak bu örnek için sadece Derin default ctoru çağrılır.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

class Base{
public:
    Base()
    {
        cout << "Base default constructor" << '\n';
    }
    Base(const Base&)
    {
        cout << "Base copy ctor" <<'\n';
    }

};

class Der : public Base{
public:
    Der()
    {
        cout << "Der constructor" << '\n';
    }
    Der(const Der&)
    {
        cout << "Der copy ctor" << '\n';
    }
};

int main()
{
    Der x;
    Der y = x;
}
/*--------------------------------------------------------
Base ctorun çağrılması için aşağıdaki kod yazılabilir.
Burası kesin bir daha izle.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

class Base{
public:
    Base()
    {
        cout << "Base default constructor" << '\n';
    }
    Base(const Base&)
    {
        cout << "Base copy ctor" <<'\n';
    }

};

class Der : public Base{
public:
    Der()
    {
        cout << "Der constructor" << '\n';
    }
    Der(const Der& other): Base(other)
    {
        cout << "Der copy ctor" << '\n';
    }
};

int main()
{
    Der x;
    Der y = x;
}
/*--------------------------------------------------------
Aşağıdaki örnekte ise Base'in move ctoru çağrılmamaktadır.
Neden?
-------------------------------------------------------*/
#include <iostream>

using namespace std;

class Base{
public:
    Base()
    {
        cout << "Base default constructor" << '\n';
    }
    Base(const Base&)
    {
        cout << "Base copy ctor" <<'\n';
    }
    Base(Base&&)
    {
        cout << "Base move ctor" <<'\n';
    }

};

class Der : public Base{
public:
    Der()
    {
        cout << "Der constructor" << '\n';
    }
    Der(const Der& other): Base(std::move(other))
    {
        cout << "Der copy ctor" << '\n';
    }
};

int main()
{
    Der x;
    Der y = x;
}
/*--------------------------------------------------------
Function Overriding(fonksiyon yüklemesi):Eğer hem taban sınıf
hem de türemiş sınıf içerisinde aynı isimde ve parametrik
yapıda iki tane farklı iş yapan fonksiyon bulunuyorsa bu
üye fonksiyonlar bazı syntax özellikleri kullanılarak override
edilebilirler. fonksiyonların override edilmesiyle oluşan
mekanizmaya virtual dispatch(sanallık mekanizması) denir.
bunun için gerekli olan durumlar override edilmek istenen
fonksiyon virtual anahtar sözcüğü ile bildirilmesi
diğer fonksiyonda parametre parantezinin sonuna override
anahtar sözcüğünün konulmasına dayanmaktadır. override anahta sözcüğü
C++ 20 ile dile eklenmiştir. iki tip sanal fonksiyon
vardır. biri sanal fonksiyon diğeri sapsanal(pure virtual)
fonksiyon. Sanal fonksiyon override edilmek zorunda değilken
sapsanal fonksiyon override edilmek zorundadır. Runtime
Polymorphism(çalışma zamanı çok biçimliliği) fonksiyonların
override edilmesi ile gerçekleşmektedir. Eğer sınıfın en az
bir sanal fonksiyonu varsa bu sınıflara polimorfik sınıf
adı verilir.
Anahtar Notlar:static fonksiyonlar override edilemez.
interface + implementation
interface(implementasyon)

class AirPlane

Eğer bir sınıfın en az bir sanal fonksiyonu var ise bu sınıflara
polimorfik sınıf adı verilir.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

class Airplane{
public:
    void fly();
    virtual void takeoff();//virtual function (sanal fonksiyon)
    //istesek override edebiliriz ancak zorunda değiliz
    virtual void land() = 0; //pure virtual function(sabsanal fonksiyon)
    //override etmek zorundayız
};

class Boeing : public Airplane{
    //code
};

int main()
{

}

/*--------------------------------------------------------
Aşağıdaki örnekte görüldüğü gibi nesne bağlı olarak eat fonksiyonları
nesneye özgü olarak çağrıldı ve runtime polimorfzim gerçekleşti.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

class Animal{
public:
    virtual void eat()
    {
        cout << "Animal is eating..." << '\n';
    }
};
class Cat : public Animal{
public:
    void eat()override
    {
        cout << "Cat is eating..." << '\n';
    }
};
class Tiger : public Animal{
public:
    void eat()override
    {
        cout << "Tiger is eating..." << '\n';
    }
};
class Dog : public Animal{
public:
    void eat()override
    {
        cout << "Dog is eating..." << '\n';
    }
};

int main()
{
    Cat mycat;
    Tiger mytiger;
    Dog mydog;
    mycat.eat();
    mytiger.eat();
    mydog.eat();
}
/*--------------------------------------------------------
Override edilen fonksiyonların farklı geri dönüş değer türüne
sahip olmaları geçersizdir.
-------------------------------------------------------*/
#include <iostream>

class Base{
public:
    virtual void func(int,int)
    {
        std::cout << "Base::func(int,int)" <<'\n';
    }
};
class Der : public Base {
public:
    int func(int,int);//error
};
/*--------------------------------------------------------
override anahtar sözcüğü C++20 ile geldiğinden dolayı değişken
ismi olarak kullanımı geçerlidir. Buna contextual keyword adı verilir.
-------------------------------------------------------*/

int main()
{
    int override = 10;//geçerli
}
/*--------------------------------------------------------
Override edilen fonksiyonların parametre değişkenleri birbirinden
farklı olması durumu syntax hatasına neden olur.
-------------------------------------------------------*/
#include <iostream>

class Base{
public:
    virtual void func(int,unsigned int)
    {
        std::cout << "Base::func(int,int)" <<'\n';
    }
};
class Der : public Base {
public:
    void func(int,int)override;//error
};
/*--------------------------------------------------------
Override kullanılarak yapılmış basit bir araba oyunu
-------------------------------------------------------*/
#include <iostream>

using namespace std;

class Car{
public:
    virtual void run()=0;
};

class BMW : public Car{
public:
    void run()override
    {
        cout << "BMW is running" << '\n';
    }
};

class Audi: public Car{
public:
    void run()override
    {
        cout << "Audi is running" << '\n';
    }
};

class Skoda :public Car{
public:
    void run()override
    {
        cout << "Skoda is running" << '\n';
    }
};

void carGame(Car* c)
{
    c->run();
}

int main()
{
    BMW bmw;
    Audi audi;
    Skoda skoda;

    carGame(&bmw);
    carGame(&audi);
    carGame(&skoda);
    Car& c = skoda;
    c.run();


}
/*--------------------------------------------------------
Söz konusu sınıfa bir veya birden fazla sanal fonksiyon eklenmesi
o sınıfın sizeof değerini pointer sizeof u kadar arttırmaktadır.
Ancak burda dikkat edilmesi gereken en önemli durum ister 1 tane
sanal fonksiyon olsun ister 100 tane sizeof değeri gene aynı kalacaktır.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

class Base {
private:
    int x,y;
public:
    virtual void f1() {}
    virtual void f2() {}
};

class Der :public  Base{

};


int main()
{
    cout << "sizeof(Base)" << sizeof(Base) << '\n';
    cout << "sizeof(Der)" << sizeof(Der) << '\n';


}
Ders 22 nin Sonu
Ders 23
/*--------------------------------------------------------
Erişim kontrolü statik türe ilişkindir.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

class Base {
public:
    virtual void vfunc()
    {
        cout << "Base::vfunc\n";
    }
};

class Der :public  Base{
private:
    void vfunc()override
    {
        cout << "Der::vfunc" <<'\n';
    }

};

void foo(Base& baseref)
{
    baseref.vfunc();
}


int main()
{
    Der myder;
    foo(myder);
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>

using namespace std;

class Base {
public:
    virtual void vfunc()
    {
        cout << "Base::vfunc\n";
    }
};

class Der :public  Base{
private:
    void vfunc()override
    {
        cout << "Der::vfunc" <<'\n';
    }

};

void foo(Base& baseref)
{
    baseref.vfunc();
}


int main()
{
    Der myder;
    foo(myder);
}
/*--------------------------------------------------------
Aşağıdaki örnekte varsayalın argüman 99 olarak elde edilir ancak
diğer taraftan Der::vfunc çağrısı gerçekleşir bunun nedeni varsayılan
argümanların tamamen compile timela alakalı olmasından kaynaklıdır.
Oyna virtual dispatch mekanizması tamamen runtime ile alakalıdır.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

class Base {
public:
    virtual void vfunc(int x = 99)
    {
        cout << "Base::vfunc" << " x:" << x << '\n';
    }
};

class Der :public  Base{
private:
    void vfunc(int x = 11)override
    {
        cout << "Der::vfunc" <<" x:" << x <<'\n';
    }

};

void foo(Base& baseref)
{
    baseref.vfunc();
}


int main()
{
    Der myder;
    foo(myder);
}
/*--------------------------------------------------------
Aşağıdaki örnekte func çağrısı türemiş sınıfa(child/sub-class)
 ait olduğundan dolayı bu örnek için virtual dispatch mekanizması
 devreye giren ve sonuç olarak Der sınıfının vfunc fonksiyonu
 çağrılır.
-------------------------------------------------------*/
#include <iostream>

class Base{
public:
    void func()
    {
        vfunc();
    }

private:
    virtual void vfunc()
    {
        std::cout << "Base::vfunc\n";
    }
};

class Der : public Base{
public:
    virtual void vfunc()override
    {
        std::cout << "Der::vfunc\n";
    }
};

int main()
{
    Der myder;
    myder.func();
    return 0;
}
/*--------------------------------------------------------
Aşağıdaki örnekte çağrının parent class(taban sınıf) ctor
içerisinde yapılması durumunda virtual dispacth mekanizması
kesinlikle devreye girmez bu kurala çok dikkat edilmesi gerekmektedir.
Bu yüzden Der nesnesi için dahi Base sınıfının vfunc fonksiyonu
çağrılır.
-------------------------------------------------------*/
#include <iostream>

class Base{
public:
    Base()
    {
        vfunc();//Warning:Do not invoke virtual member functions from constructor
    }

private:
    virtual void vfunc()
    {
        std::cout << "Base::vfunc\n";
    }
};

class Der : public Base{
public:
    virtual void vfunc()override
    {
        std::cout << "Der::vfunc\n";
    }
};

int main()
{
    Der myder;
    return 0;
}
/*--------------------------------------------------------
class invariants

1-) eski kodların (daha sonradan yazılacak) yeni kodları kullanmasını
sağlamak yani değişikliğin (eski) kodu değiştirerek değil programa
kod ekleyerek yapılmasını sağlamak OCP

2-) Üst katmandaki kodlar alt katmanlardaki somut sınıflara (implementasyon)
hem üst katmandaki hem de alt katmanlardaki kodları soyutlamalara bağlı olmalı(DIP)

class FileApplication{
    void func()
    {
        File ???

        f.open();
        f.print();
    }
}
-------------------------------------------------------*/
/*--------------------------------------------------------
Aşağıdaki örnekteki kod geçerlidir çünkü taban sınıf türünden
bir pointera new operatörüyle türemiş sınıf türünden bir nesne atanmıştır
bu durum herhangi bir şekilde syntax hatasına neden olmaz ancak
bu nesne ile çağrılma durumunda tabi ki taban sınıfın vfunc
fonksiyonu çağrılır.
-------------------------------------------------------*/
#include <iostream>

class Base{
public:
    virtual void vfunc()
    {
        std::cout << "Base::vfunc\n";
    }
    ~Base()
    {
        std::cout << "Base destructor\n";
    }
};

class Der : public Base{
public:
    virtual void vfunc()override
    {
        std::cout << "Der::vfunc\n";
    }
    ~Der()
    {
        std::cout << "Der destructor\n";
    }
};

int main()
{
   Base* p = new Der;

   p->vfunc();

   delete p;
}
/*--------------------------------------------------------
Aşağıdaki örnekte önce türemiş sınıfın destructoru sonra sonra
taban sınıfın destructoru çağrılmaktadır.
-------------------------------------------------------*/
#include <iostream>

class Base{
public:
    virtual void vfunc()
    {
        std::cout << "Base::vfunc\n";
    }
    ~Base()
    {
        std::cout << "Base destructor\n";
    }
};

class Der : public Base{
public:
    virtual void vfunc()override
    {
        std::cout << "Der::vfunc\n";
    }
    ~Der()
    {
        std::cout << "Der destructor\n";
        //taban sınıfın destructoru çağrılıyor
    }
};

int main()
{
   Der myder;


}
/*--------------------------------------------------------
Not:sınıfın constructor ve destructor elemanları virtual yapılamaz.
a-) static initialization
    zero initialization
b-) dynamic initialization
    constructor initialization

eğer bir nesneyi bir sabit ifadesiyle initialize edersek
o nesne için dynamic initialization yapılmaz!

constexpr int x = sabit ifadesi ile ilk değer vermek zorunlu

Dikkat!
farklı translation unitler içerisinde tanımlanmış global
değişkenlerin dinamik init sırası dil tarafından belirli değildir.

buna güvenerek kod yazma durumunda static initialization order fiasco
oluşabilir.

asla asla
bir global değişkenin ctor'ı içerisinde (belgelenmiş bir garanti olmadan)
bir başka global değişkeni kullanmayın!
kod yazarken global değişkenlerle ilgili:
1-)Mümkünse hiç global değişken kullanma
2-)Global değişkenlerin hepsi immutable olsun ve sabit ifadeleriyle init edilsinler
3-)Mutable olsun ama sabit ifadesiyle değerini alsın.

constinit anahtar sözcüğü C++20 ile gelen bir anahtar sözcüktür.
constinit anahtar sözcüğü sadece global değişkenler için kullanılabilir.
constinit anahtar sözcüğüyle tanımlanan değişkenler için dynamic
init. yapılamaz sadece static init. yapılabilir.
-------------------------------------------------------*/
#include <iostream>

class Myclass{
public:
    constexpr Myclass(int val) : mx{val} {}
    void set(int a);
private:
    int mx;
};

constinit Myclass m(12);

int main()
{
    m.set(20);
}

/*--------------------------------------------------------
constexpr fonksiyonlar eğer sabit ifadesiyle çağrılırlarsa
değeri compile time içerisinde hesaplarlar. bu yüzden aşağıdaki
kod geçerlidir.
-------------------------------------------------------*/
#include <iostream>

constexpr int foo(int x)
{
    return x * 5;
}

int main()
{
    int x = 45;

    int a[foo(10)];
}
/*--------------------------------------------------------
consteval anahtar sözcüğü
-------------------------------------------------------*/
#include <iostream>

consteval int foo(int x)
{
    return x * 5;
}

int main()
{
    int x = 45;

    foo(10);
}
/*--------------------------------------------------------
global değişken kullanırken önem sırasına göre dikkat edilmesi
gerekenler:
1-)kullanabilirsen constexpr kullan
2-)1.seçenek uygun değilse kullanabilirsen constinit kullan
3-)2.seçenek uygun değilse lazy initialization yapabiliyorsan yap
4-)3.seçenek uygun değilse nifty-counter kullan
-------------------------------------------------------*/
/*--------------------------------------------------------
multiple inheritance ve multi-level inheritance
Bu iki kavram pek çok programcı için aynı sanılsa da birbirinden
tamamen farklı kavramlardır multiple inheritance durumu bir türemiş
sınıfın birden fazla birden fazla taban sınıfa sahip olmasına verilen
isimdir. Ancak multi-level inheritance için durum bir taban sınıfın
bir türemiş sınıfa o türemiş sınıfın da başka bir türemiş sınıfa sahip olması
olarak açıklanabilir. Örneğin aşağıdaki örnekte bir multi-level
inheritance söz konusudur.
-------------------------------------------------------*/
#include <iostream>

class Car {
public:
    void accerate_engine();
    void start_engine();
    void stop_engine();
};

class BMW : public Car{

};

class BMWCoupe : public BMW{

};

int main()
{

}
/*--------------------------------------------------------
Bir multiple inheritance örneği
Not: aradaki virgülden sonra mutlaka ikinci taban sınıf için de
erişim belirleyici bilgisi mutlaka verilmelidir ancak default durumda
private olduğundan eğer verilmezse her ne kadar private inheritance
nerdeyse hiç kullanılmasa da bu kural böyledir.
Not 2: multiable inheritance durumunda iki adet taban sınıfta sahip
olan Der sınıfı bu taban sınıfların tüm elemanlarının miras alır.
-------------------------------------------------------*/
#include <iostream>

class Base1{
public:
    void foo()
    {
        std::cout << "foo called" <<'\n';
    }
};

class Base2{
public:
    void func()
    {
        std::cout << "func called" <<'\n';
    }
};


class Der : public Base1,public Base2{
public:
    void f()
    {
        std::cout << "f called" <<'\n';
    }
};

int main()
{
    Der myder;
    myder.foo();
    myder.func();
    myder.f();
}
/*--------------------------------------------------------
Aşağıdaki örnekte mmder nesnesinin taban sınıfları türünden bir
referanslara bağlanmıştır ve adresi taban sınıfları türünden pointer
değişkenlerine atanmıştır. Bu gayet doğal bir durumdur.
-------------------------------------------------------*/
#include <iostream>

class Base1{
public:
    void foo()
    {
        std::cout << "foo called" <<'\n';
    }
};

class Base2{
public:
    void func()
    {
        std::cout << "func called" <<'\n';
    }
};


class Der : public Base1,public Base2{
public:
    void f()
    {
        std::cout << "f called" <<'\n';
    }
};

int main()
{
    Der myder;
    Base1 &rb1 = myder;
    Base1* pb1 = &myder;
    Base2 &rb2 = myder;
    Base2* pb2 = &myder;
    myder.foo();
    myder.func();
    myder.f();
}
/*--------------------------------------------------------
Multiable inheritance ile function overriding kullanımı
-------------------------------------------------------*/
#include <iostream>


class Base1{
public:
    virtual void foo()
    {
        std::cout << "Base1::foo called" <<'\n';
    }
};

class Base2{
public:
    virtual void func()
    {
        std::cout << "Base2::func called" <<'\n';
    }
};


class Der : public Base1,public Base2{
public:
    void foo()override
    {
        std::cout << "Der::foo called" <<'\n';
    }
    void func()override
    {
        std::cout << "Der::func called" <<'\n';
    }
    void f()
    {
        std::cout << "f called" <<'\n';
    }
};

int main()
{
    Der myder;
    myder.foo();
    myder.func();
    myder.f();
}
/*--------------------------------------------------------
Aşağıdaki örnekte bir iki anlamlılık yani ambiguity söz konusudur.
-------------------------------------------------------*/
#include <iostream>


class A{
public:
    void func(int);
};

class B{
public:
    void func(int,int);
};

class C : public A,public B {

};

int main()
{
    C cx;
    cx.func(12);
    cx.func(34,56);
}
/*--------------------------------------------------------
Yukarıdaki durum aşağıdaki örnek için de geçerlidir.
-------------------------------------------------------*/
#include <iostream>


class A{
public:
    int func;
};

class B{
public:
    void func(int,int);
};

class C : public A,public B {

};

int main()
{
    C cx;
    cx.func(34,56);
}
/*--------------------------------------------------------
Yukarıdaki problemin çözümü aşağıdaki gibi yapılabilir.
-------------------------------------------------------*/
#include <iostream>


class A{
public:
    void func(int);
};

class B{
public:
    void func(int,int);
};

class C : public A,public B {

};

int main()
{
    C cx;
    cx.A::func(28);
    cx.B::func(34,56);
}
/*--------------------------------------------------------
Aşağıdaki örnekte double parametreli func çağrılcakmış gibi görünse de
bu örnek için int parametreli yani türemiş sınıfa ait func çağrılır
bunun nedeni isim aramanın öncelikle nesnenin yaratıldığı sınıf
içerisinde yapılmasından kaynaklanmaktadır.
-------------------------------------------------------*/
#include <iostream>

class A{
public:
    void func(long)
    {
        std::cout << "func(long)"<<'\n';
    }
};

class B{
public:
    void func(double)
    {
        std::cout << "func(double)"<<'\n';
    }
};

class C : public A,public B {
public:
    void func(int)
    {
        std::cout << "func(int)"<<'\n';
    }
};

int main()
{
    C cx;
    cx.func(2.3);
}
/*--------------------------------------------------------
Aşağıdaki örnekte bir ambiguity söz konusudur.
-------------------------------------------------------*/
#include <iostream>

class A{
public:

};

class B{
public:

};

class C : public A,public B {
public:

};

void func(A&);
void func(B&);

int main()
{
    C cx;

    func(cx);
}
/*--------------------------------------------------------
Yukarıdaki problem static_cast operatörü kullanılarak çözülebilir.
-------------------------------------------------------*/
#include <iostream>

class A{
public:

};

class B{
public:

};

class C : public A,public B {
public:

};

void func(A&)
{
    std::cout << "func(A&)" << '\n';
}
void func(B&)
{
    std::cout << "func(B&)" << '\n';
}

int main()
{
    C cx;

    func(static_cast<A&>(cx));
    func(static_cast<B&>(cx));
}
/*--------------------------------------------------------
Aşağıdaki örnekte bir ambiguity söz konusudur. Bunun sebebi
Der1 türemiş sınıfın miras aldığı func fonksiyonu ve Der2 türemiş sınıfının
miras aldığı func fonksiyonundan farklıdır bu sebepten bir iki
anlamlılık söz konusudur.
-------------------------------------------------------*/
#include <iostream>

class Base{
public:
    void func();
};

class Der1 : public Base {

};

class Der2 : public Base {

};

class Mder : public Der1, public Der2 {

};

int main()
{
    Mder md;

    md.func();
}
/*--------------------------------------------------------
Aşağıdaki örnekte yukarıdaki problemin çözümü gösterilmiştir.
-------------------------------------------------------*/
#include <iostream>

class Base{
public:
    void func();
};

class Der1 : public Base {

};

class Der2 : public Base {

};

class Mder : public Der1, public Der2 {
    void f()
    {
        Der1::func();
        Der2::func();
    }
};

int main()
{
    Mder md;

    md.Der1::func();//geçerli
    md.Der2::func();//geçerli
}
/*--------------------------------------------------------
Aşağıdaki örnekte foo ve func çağrıları için ambiguity söz konusudur.
Bunun nedeni hem Der1 sınıfı içerisinde hem de Der2 sınıfı
içerisinde iki farklı func fonksiyonu bulunmaktadır. foo çağrısı
içinse Base Der1 e mi yoksa Der2 ye ait bir taban sınıf mı çıkarımı
yapılamadığından ambiguity oluşur. Hüseyin hocaya sor!!
-------------------------------------------------------*/
#include <iostream>

class Base{
public:
    void func();
};

class Der1 : public Base {

};

class Der2 : public Base {

};

class Mder : public Der1, public Der2 {
    void f()
    {

    }
};

void foo(Base& p);

int main()
{
    Mder md;
    md.func();
    foo(md);
}
/*--------------------------------------------------------
Aşağıdaki örnekte syntax hatasının Base sınıfının Mder sınıfının
bir direkt taban sınıfı olmamasından kaynaklanmaktadır. Ancak
Der1 ve Der2 için bu durum farklıdır o yüzden bu ctorlar
için herhangi bir şekilde bir syntax hatası oluşmaz.
-------------------------------------------------------*/
#include <iostream>
#include <string>

class Base{
public:
    Base(std::string x)
    {
        std::cout << "Base(std::string)" << x << '\n';
    }
};

class Der1 : public Base {
public:
    Der1() : Base("Der1") {}
};

class Der2 : public Base {
public:
    Der2() : Base("Der2") {}
};

class Mder : public Der1, public Der2 {
public:
    Mder() : Base("Mder"){} //error
};


int main()
{

}
/*--------------------------------------------------------
Aşağıdaki durum içinse Mder sınıfının ctoru dışında A ve B
sınıflarının ctorları için de bir syntax hatası söz konusudur.
-------------------------------------------------------*/
#include <iostream>
#include <string>

class Base{
public:
    Base(std::string x)
    {
        std::cout << "Base(std::string)" << x << '\n';
    }
};

class Der1 : public Base {
public:
    Der1() : Base("Der1") {}
};

class Der2 : public Base {
public:
    Der2() : Base("Der2") {}
};

class Mder : public Der1, public Der2 {
public:
    Mder() : Base("Mder"){}
};
class A : public Mder{
public:
    A() : Base("A"){}
};
class B : public Mder{
public:
    B() : Base("B") {}
};
/*--------------------------------------------------------
final anahtar sözcüğü:final anahtar sözcüğü için iki farklı
kullanım vardır. Biri sınıfların final olma durumu diğeri ise
fonksiyonların final olma durumu Javadaki gibi değişkenler için
kullanılan final anahtar sözcüğü tamamen bambaşka bir anahtar
sözcüktür.
-------------------------------------------------------*/
/*--------------------------------------------------------
final anahtar sözcüğü bir sınıf bildirimde kullanılıyor ise
o sınıftan artık türetme yapılamaz örneğin aşağıdaki örnekte
syntax hatasının nedeni final bir sınıfa türetme girişimidir
bu yüzden syntax hatasıdır.
-------------------------------------------------------*/
class Base {

};

class Der final : public Base{

};
class Nec : public Der{

};

/*--------------------------------------------------------
Fonksiyonlar için final anahtar sözcüğünün kullanımı:
final anahtar sözcüğüyle bildirilen fonksiyonlar için o adımdan sonra
başka bir override yazılamaz bu syntax hatasına neden olur.
bir fonksiyonu ilk defa yazarken virtual anahtar sözcüğü kullanılmayıp
final anahtar sözcüğü kullanılırsa bu gene syntax hatası olarak değerlendirilir.
-------------------------------------------------------*/
class Base {
public:
    virtual void foo();
};

class Der : public Base{
public:
    virtual void foo()final override;
    void bar()final; //error
};
class Nec : public Der{
public:
    void foo()override; //error
};

/*--------------------------------------------------------
dynamic_cast tür dönüştürme operatörünün kullanımı:
dynamic cast operatörü taban sınıf nesnesinin türemiş sınıf
türünden nesnelere atanmasının gönül rahatlığı ile yapılmasını
sağlar.
-------------------------------------------------------*/
#include <iostream>
#include <string>

class Car{
public:
    void run()
    {
        std::cout <<  "Car is running" << '\n';
    }
    void start()
    {
        std::cout << "Car has just started" << '\n';
    }
    void stop()
    {
        std::cout << "Car stopped" << '\n';
    }
};

class BMW : public Car{
public:
    void open_sunroof()
    {
        std::cout << "BMW sunroof opened" << '\n';
    }
};

void car_game(Car& p)
{
    std::cout << *p << '\n';
    p->start();
    p->run();

    if(BMW* bp = dynamic_cast<BMW*>(p))
        bp->open_sunroof();
    p->stop();
    (void)getchar();
}

int main()
{
    BMW bmw = new BMW;
    car_game(dynamic_cast<Car*>(&bmw));

    delete(bmw);
}
//--------------------------------------------------------
#include <iostream>
#include <string>

class Car{
public:
    void run()
    {
        std::cout <<  "Car is running" << '\n';
    }
    void start()
    {
        std::cout << "Car has just started" << '\n';
    }
    void stop()
    {
        std::cout << "Car stopped" << '\n';
    }
};

class BMW : public Car{
public:
    void open_sunroof()
    {
        std::cout << "BMW sunroof opened" << '\n';
    }
};

void car_game(Car &car)
{
    std::cout << car << '\n';
    car.start();
    car.run();

    dynamic_cast<BMW&>(car).open_sunroof();
    car.stop();
    (void)getchar();
}

int main()
{
    BMW mycar;

    car_game(mycar);
}
/*--------------------------------------------------------
typeid operatörünün kullanımı
-------------------------------------------------------*/
#include <iostream>


int main()
{
    int x = 10;

    std::cout << typeid(x).name() << '\n';
}

/*--------------------------------------------------------
Aşağıdaki örnekte kodun ifin false bölümüne girmesi *baseptr
ifadesinin Base türünden Der ifadesinin ise Der türünden olmasından kaynaklıdır.
-------------------------------------------------------*/
#include <iostream>

class Base{

};

class Der : public Base {

};

int main()
{
    Der myder;
    Base* baseptr = &myder;

    std::cout << typeid(*baseptr).name() << '\n';
    std::cout << typeid(Der).name() << '\n';

    if(typeid(*baseptr) == typeid(Der))
        std::cout << "evet dogru\n";
    else
        std::cout << "hayir yanlis\n";
}

/*--------------------------------------------------------
private inheritance: Bu durum public inheritance a göre
nerdeyse hiç kullanılmamaktadır. Aslında bu durum Aggregation
yani has a ilişkisine bir alternatif olarak görülebilir. Bu
durumda tabi ki türemiş sınıf taban sınıfın veri elemanlarına erişemez.
private kalıtımı kullanılarak yapılan polimorfzim e restricted polymorphism
denir.
-------------------------------------------------------*/
#include <iostream>

class Base{
public:
    void func();
    void foo();
};

class Der : private Base {

};

int main()
{
    Der myder;
    myder.foo(); //error
}
/*--------------------------------------------------------
Base Der için erişilebilir(accessable) olmadığından dolayı
Base* ve Base& türüne myder i bağlamak syntax hatasına neden
olur.
-------------------------------------------------------*/
#include <iostream>

class Base{
public:
    void foo();
    void f();
};

class Der : Base {
public:
    void func()
    {
        f();
        foo();
    }
};

int main()
{
    Der myder;
    Base*ptr = &myder;
    Base& ref = myder;
}
/*--------------------------------------------------------
private kalıtımında client kodlar için is a ilişkisi söz konusu
değildir. Yani türemiş sınıftan taban sınıfa bir implicit conversion
yoktur.

Türemiş sınıfın üye fonksiyonları içinde ve türemiş sınıfın friend
fonksiyonları içinde is a ilişkisi korunur ve otomatik dönüşüm(standard conversion)
Mümkündür.

Bundan dolayı aşağıdaki kod için herhangi şekilde bir syntax hatası yoktur.
-------------------------------------------------------*/

#include <iostream>

class Base{
public:
    void foo();
    void f();
};

class Der : Base {
public:
    void func()
    {
        f();
        foo();
    }
    void bar()
    {
        Der myder;
        Base*ptr = &myder;
        Base& ref = myder;
    }
    friend void neco();
};

void neco()
{
    Der myder;
    Base*ptr = &myder;
    Base& ref = myder;
}
int main()
{

}
/*--------------------------------------------------------
X sınıfının Y sınıfı türünden bir elemanı olacak
X sınıfı Y sınıfından private kalıtımıyla elde edilecek
-------------------------------------------------------*/
#include <iostream>

class Y{
public:
    void yfunc()
    {
        std::cout << "Y::yfunc()" << '\n';
    }
};

class X {
private:
    Y yx;
};

class Y{
public:
    void yfunc()
    {
        std::cout << "Y::yfunc()" << '\n';
    }
};

class X : private Y{
public:
    using Y::yfunc;
private:
};

int main()
{
    X myx;
    myx.yfunc();
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>


class Empty{
public:
    void ef1();
    void ef2();
};

class Myclass{
public:
private:
    Empty e1;
    int x;
};


int main()
{
    std::cout << "sizeof(Empty) = " << sizeof(Empty) << '\n';
    std::cout << "sizeof(Myclass) = " << sizeof(Myclass) << '\n';
}
/*--------------------------------------------------------
Exception Handling:Exception durumu programın çalışma zamanında
meydana gelen hatalara verilen isimdir. Bu exceptionlar hata verilen
duruma göre değişiklik gösterir. Bu exceptionları bulup bu
durumda programın çökmesi yerine başka işlemler yapma mekanizmasına
exception handling denir. Bir exception handle edilirken
try bloğu adı verilen bloğa hatanın oluşması muhtemel kod
yazılırken bu oluşan hatasının yakalanması muhtemel bloklarına
ise catch bloğu adı verilir.

Not:throw edilen exception için uygun catch bloğu illa olmak zorunda
değildir.

Not 2:Exception'ı neden yakalayım sorusu aslında oldukça saçma
bir sorudur. Programcı bu soruyu soruyorsa zaten o exception'ın
yakalanmaya ihtiyacı yoktur gibi düşünülebilir.

throw statement(throw deyimi):throw deyimi bir ifade ile kullanılıp
bir exception fırlatmak için kullanılır.

try block
catch block(s)

throw
try
catch

exception throw

to throw an exception

falanca fonksiyonu bu durumda bir exception throw eder
falanca fonksiyonu bu durumda bir hata nesnesi gönderir.

try{
    //eğer bu blok içerisinde çalışan kodlardan bir hata nesnesi
    //gönderilirse bu hatayı yakalamaya adayım
}
-------------------------------------------------------*/
#include <iostream>

void f3()
{
    std::cout << "f3 cagrildi\n";
    throw 1;
    std::cout << "f3 sona erdi\n";
}
void f2(){
    std::cout << "f2 cagrildi\n";
    f3();
    std::cout << "f2 sona erdi\n";
}
void f1(){
    std::cout << "f1 cagrildi\n";
    f2();
    std::cout << "f1 sona erdi\n";
}


int main()
{
    try {
        f1();
    }
    catch(int x){
        std::cout << "hata yakalandi......catch(int) x = " << x << '\n';
    }

    std::cout << "main devam ediyor\n";
}
/*--------------------------------------------------------
2 nolu catch bloğu aşağıdaki durumda exception ı yakalar.
-------------------------------------------------------*/
#include <iostream>

class Base {

};

class Der : public Base {

};

class Sder : public Der {

};

void f3()
{
    std::cout << "f3 cagrildi\n";
    throw Sder{};
    std::cout << "f3 sona erdi\n";
}
void f2(){
    std::cout << "f2 cagrildi\n";
    f3();
    std::cout << "f2 sona erdi\n";
}
void f1(){
    std::cout << "f1 cagrildi\n";
    f2();
    std::cout << "f1 sona erdi\n";
}


int main()
{
    try {
        f1();
    }
    catch(int x){ //1
        std::cout << "hata yakalandi......catch(int) x = " << x << '\n';
    }
    catch(Base &x){ //2
        std::cout << "hata yakalandi......catch(Base &) x  "<< '\n';
    }


    std::cout << "main devam ediyor\n";
}
/*--------------------------------------------------------
hata ile ilgili bilgi yukarıdaki kodlara 2 ayrı şekilde iletilebilir.

-gönderilen hata nesnesinin türü

class FileError{

};

class FileReadError : public FileError {

};

class FileWriteError : public FileError {

};

throw FileReadError();
-------------------------------------------------------*/
/*--------------------------------------------------------
Eğer her durumda exception yakalanmak isteniyorsa aşağıdaki
koddaki gibi bir catch bloğu yazılabilir.
-------------------------------------------------------*/
#include <iostream>

int main()
{
    try{

    }
    catch(const std::exception& ex){
        std::cout << "hata yakalandi\n";
    }
}

/*--------------------------------------------------------
Aşağıdaki örnek için string literalinin olmayan bir elemanı
elde edilmeye çalışılmıştır. Bu sebepten exception yakalanmıştır.
-------------------------------------------------------*/
#include <iostream>

int main()
{
    std::string str{"alican"};
    try{
        auto c = str.at(34); //out_of_range
    }
    catch(const std::exception& ex){
        std::cout << "hata yakalandi\n" << ex.what() << '\n';
    }
}
/*--------------------------------------------------------
Aşağıdaki örnekte Mercedes dynamic cast sırasında bad cast
exception fırlatımı gerçekleşir ve bu catch bloğu tarafından
yakalanır.
-------------------------------------------------------*/
#include <iostream>
#include "Car.h"

void game(Car& car)
{
    auto& r = dynamic_cast<Volkswagen&>(car);
}

int main()
{
    try{
        Mercedes m;
        game(m);
    }
    catch(const std::exception& ex){
        std::cout << "exception caught:" << ex.what() << '\n';
    }
}

/*--------------------------------------------------------
terminative(sonlandırmaya yönelik)

resumptive
    hata gönderilmiş ve yakalanmış olmasına rağmen hiçbir kaynak
    sızıntısı olmaz.
Aşağıdaki örnekte foo fonksiyonu hatayı fırlattıktan sonra hata
catch bloğu tarafından yakalanamıycak bu sebepten termination
gerçekleşicek.
-------------------------------------------------------*/
#include <iostream>


void foo()
{
    throw std::out_of_range{"hata hata..."};
}

int main()
{
    try {
        foo();
    }
    catch (const std::runtime_error &ex){
        std::cout << "exception caught:" << ex.what() << '\n';
    }

}
/*--------------------------------------------------------
Aşağıdaki örnekte görüldüğü gibi catch bloğu içerisine ...(üç nokta)
konulması durumunda herhangi bir exception fırlatılması durumunda
o catch bloğu tarafından excepiton yakalanır.
-------------------------------------------------------*/
#include <iostream>

void foo()
{
    throw std::out_of_range{"hata hata..."};
}

int main()
{
    try {
        foo();
    }
    catch (...){
        std::cout << "exception caught" << '\n';
    }

}
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
#include <iostream>


void foo()
{
    throw std::out_of_range{"hata hata..."};
}

int main()
{
    try {
        foo();
    }
    catch (const std::out_of_range& ex){
        std::cout << ex.what() << '\n';
    }
    catch (const std::logic_error& ex){
        std::cout << ex.what() << '\n';
    }
    catch (const std::exception& ex ){
        std::cout << ex.what() << '\n';
    }
    catch (...){
        std::cout << "bilinmeyen hata nesnesi yakalandı." << '\n';
    }

}
/*--------------------------------------------------------
Aşağıdaki örnekte throw çağrıldığı zaman Myclass sınıfının
copy constructorı çağrılacaktır. Sonrasında exception yakalanıp
Myclass sınıfı için destructor çağrılacaktır.
Bu durumda ekran çıktısı aşağıdaki gibi olacaktır:
Myclass copy ctor
Myclass destructor
exception caught
Myclass destructor
main devam ediyor
-------------------------------------------------------*/
#include <iostream>


class Myclass{
public:
    Myclass() = default;
    Myclass(const Myclass&)
    {
        std::cout << "Myclass copy ctor" << '\n';
    }
    ~Myclass()
    {
        std::cout << "Myclass destructor" << '\n';
    }
};


void func()
{
    Myclass m;
    throw m;
}

int main()
{
    try {
        func();
    }
    catch (Myclass &){
        std::cout << "exception caught" << '\n';
    }
    std::cout << "main devam ediyor\n";
}

/*--------------------------------------------------------
Ekran çıktısı:
&m = 0xb7049ffa0f
Myclass copy ctor this = 0x1c9427b5c10
Myclass copy ctor &r = 0xb7049ffa0f
Myclass destructor this = 0xb7049ffa0f
exception caught
Myclass destructor this = 0x1c9427b5c10
main devam ediyor
-------------------------------------------------------*/
#include <iostream>


class Myclass{
public:
    Myclass() = default;
    Myclass(const Myclass& r)
    {
        std::cout << "Myclass copy ctor this = " << this << '\n';
        std::cout << "Myclass copy ctor &r = " << &r << '\n';
    }
    ~Myclass()
    {
        std::cout << "Myclass destructor this = " << this << '\n';
    }
};


void func()
{
    Myclass m;
    std::cout << "&m = " << &m << '\n';
    throw m;
}

int main()
{
    try {
        func();
    }
    catch (Myclass &){
        std::cout << "exception caught" << '\n';
    }
    std::cout << "main devam ediyor\n";
}

/*--------------------------------------------------------
Aşağıdaki örnekte herhangi bir şekilde bir kaynağın edilinip
geri verilememesi durumunda nasıl bir durum oluşacağı anlatılmak
istenmiştir.
-------------------------------------------------------*/
#include <iostream>

int create_resource()
{
    std::cout << "kaynak edinildi.\n";
}

void destroy_resource(int)
{
    std::cout << "kaynak geri verildi\n";
}

void foo()
{
    int handle = create_resource();

    throw 1;

    destroy_resource(handle);
}

int main()
{
    try {
        foo();
    }
    catch (int){
        std::cout << "exception caught" << '\n';
    }
    std::cout << "main devam ediyor\n";
}

/*--------------------------------------------------------
Aşağıdaki örnekte exception mekanizması devreye girdiğinden
destructor çağrılamamıştır.
f1 called
f2 called
constructor 0x21df41e5b70 adresindeki nesne kaynaklar edindi
exception caught
main devam ediyor
-------------------------------------------------------*/
#include <iostream>

class ResourceUser{
public:
    ResourceUser()
    {
        std::cout << "constructor " << this << " adresindeki nesne kaynaklar edindi" << '\n';
    }
    ~ResourceUser()
    {
        std::cout << "destructor " << this << " adresindeki nesne kaynakları geri verdi" << '\n';
    }
private:
    unsigned char buffer[1024]{};
};

void f3()
{
    auto p = new ResourceUser;
    throw 1;
    delete p;
}
void f2()
{
    std::cout << "f2 called\n";
    f3();
}
void f1()
{
    std::cout << "f1 called\n";
    f2();
}

int main()
{
    try {
        f1();
    }
    catch (int){
        std::cout << "exception caught" << '\n';
    }
    std::cout << "main devam ediyor\n";
}

/*--------------------------------------------------------
rethrow statement

try {

}
catch(system_exception &ex){
    //kendi üstünüze düşen işleri yapmadınız.
    throw std::out_of_range???
    //yakaladığınız hata nesnesinin kendisini throw ediyorsunuz.
}
Aşağıdaki örnekte rethrow mekanizması söz konusudur çünkü
exception'ın yakalandığı catch bloğu içerisinde throw deyimi
bulunmaktadır.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

void f3()
{
    cout << "f3 cagrildi\n";
    throw out_of_range{"aralik disi deger\n"};
}
void f2()
{
    std::cout << "f2 cagrildi\n";
    try {
        f3();
    }
    catch (const std::out_of_range& ex){
        cout << "hata f2 fonksiyonu icinde yakalandi : " << ex.what() << '\n';
        throw ex;
    }
    cout << "bu yazi da ekranda cikmayacak" << '\n';
}

int main()
{
    try {
        f2();
    }
    catch (const std::out_of_range& ex){
        cout << "hata main icinde yakalandi" << '\n';
    }
    cout << "main devam ediyor\n";
}

/*--------------------------------------------------------
Aşağıdaki örnekte throw statement tek başına kullanılmıştır
bu durumda catch bloğu kendisine gönderilen exceptionı aynen
kendisinden sonra gelen try bloğuna aktarır bu durumda out_of_range
parametreye sahip catch bloğu çalıştırılır.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

void func()
{
    try {
        throw out_of_range{"range error"};
    }
    catch (const exception& ex){
        cout << "error caught in func function : " << ex.what() << '\n';
        //iki farklı throw statement arasındaki farkı görürüz.
        //throw ex;
        throw;
    }
}

int main()
{
    try {
        func();
    }
    catch (int){
        cout << "error caught (int)" <<'\n';
    }
    catch (const out_of_range& ex){
        cout << "error caught (std::out_of_range)" << '\n';
    }
    catch (const exception& ex){
        cout << "error caught (std::exception)" << '\n';
    }
    cout << "main devam ediyor\n";
}

/*--------------------------------------------------------
Yukarıdaki örneğin başka bir fonksiyon yazarak yapılması durumu
-------------------------------------------------------*/
#include <iostream>

using namespace std;

void handle_exception()
{
    cout << "handle exception function called"<< '\n';
    cout << "some processes are done" << '\n';
    throw;
}

void func()
{
    try {
        throw out_of_range{"range error"};
    }
    catch (const exception& ex){
        cout << "error caught in func function : " << ex.what() << '\n';
        handle_exception();
    }
}

int main()
{
    try {
        func();
    }
    catch (int){
        cout << "error caught (int)" <<'\n';
    }
    catch (const out_of_range& ex){
        cout << "error caught (std::out_of_range)" << '\n';
    }
    catch (const exception& ex){
        cout << "error caught (std::exception)" << '\n';
    }
    cout << "main devam ediyor\n";
}

/*--------------------------------------------------------
constructors & exception handling
Aşağıdaki örnekte Myclass sınıfının int parametreli constructoruna
tek sayı gönderirken bir sıkıntı olmazken çift sayı gönderilmesi durumunda
exception throw edilecektir. Söz konusu exception Exception&
parametreli catch bloğu tarafından yakalanır.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

class Myclass{
public:
    Myclass(int x)
    {
        cout << "kaynaklar edinildi\n";
        if(x % 2 == 0)
            throw invalid_argument{"cift sayi olamaz..."};
        cout << "bir sorun yok\n";
    }
    ~Myclass()
    {
        cout << "destructor cagrildi\n";
        cout << "kaynaklar geri verildi\n";
    }
};

int main()
{
    try {
        Myclass m(4);
    }
    catch (int){
        cout << "error caught (int)" <<'\n';
    }
    catch (const out_of_range& ex){
        cout << "error caught (std::out_of_range)" << '\n';
    }
    catch (const exception& ex){
        cout << "error caught (std::exception)" << '\n';
    }
    cout << "main devam ediyor\n";
}
/*--------------------------------------------------------
Aşağıdaki örnekte nesne yaratımı sırasında öncelikle Member
sınıfının constructoru çağrılır ve bu çağrı sırasında exception
throw edileceği için Myclass sınıfının ctoru çağrılmadan akış
sonlandırılır. Member sınıfının ctorundan fırlatılan exception
int parametreli catch bloğu tarafından yakalanır.
-------------------------------------------------------*/
#include <iostream>

class Member{
public:
    Member()
    {
        std::cout << "member constructor called\n";
        throw 1;
    }
    ~Member()
    {
        std::cout << "member destroyed\n";
    }
};

class Myclass{
public:
    Myclass()
    {
        std::cout << "Myclass constructor\n";
        throw 1;
    }
    ~Myclass()
    {
        std::cout << "Myclass destructor\n";
    }
private:
    Member mx;
};

int main()
{
    try{
        Myclass mx;
    }
    catch(int){
        std::cout << "hata yakalandi\n";
    }

}

/*--------------------------------------------------------
Bu noktadaki kısımda unique_ptr akıllı pointerı kullanmak daha iyi
bir teknik olur nedenini ilerde inceleyecez.
-------------------------------------------------------*/
#include <iostream>
#include <memory>

class Member{
public:
    Member()
    {
        std::cout << "member constructor called\n";
        throw 1;
    }
    ~Member()
    {
        std::cout << "member destroyed\n";
    }
};

class Myclass{
public:
    Myclass() : p(new Member)
    {
        std::cout << "Myclass constructor\n";
        throw 1;
    }
    ~Myclass()
    {
        std::cout << "Myclass destructor\n";
    }
private:
    std::unique_ptr<Member> p;
};

int main()
{
    try{
        Myclass mx;
    }
    catch(int){
        std::cout << "hata yakalandi\n";
    }

}

/*--------------------------------------------------------
Exception guarantees:
1-)Basic(exception) guarantee
2-)Strong(exception) guarantee
3-)no throw guarantee

noexcept anahtar sözcüğü : no except anahta sözcüğü aşağıda
gösterildiği gibi fonksiyonlar için kullanılan bir anahtar sözcüktür.
Bu anahtar sözcük o fonksiyonun exception throw etmeyeceğinin
garantisini verir.

void foo(int)noexcept;
void foo(); //may throw an exception
Aşağıdaki örnekteki gibi noexcept anahtar sözcüğünün içerisinde
++x ifadesi kullanılması herhangi bir şekilde bir side effecte
neden olmaz.
-------------------------------------------------------*/
#include <iostream>

void foo(int);

int main()
{
    int x = 5;

    constexpr auto b = noexcept(++x);

    std::cout << "x : " << x << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnek için herhangi şekilde bir ekran çıktısı
söz konusu değildir.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

int main()
{
    constexpr auto b = noexcept(cout << "ali");
}
/*--------------------------------------------------------
Aşağıdaki örnekte A sınıfının default ctoru çağrılmaz!!
-------------------------------------------------------*/
#include <iostream>

using namespace std;

class A{
public:
    A()
    {
        cout << "A default ctor\n";
    }
};

class Myclass{
private:
};


int main()
{
    constexpr auto b = noexcept(A());
}
/*--------------------------------------------------------
Aşağıdaki örnekteki kodda copy assignment fonksiyonunun çağrılması
söz konusu değildir.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

class A{
public:
    A()
    {
        cout << "A default ctor\n";
    }
    A(const A&)
    {
        cout << "A copy constructor\n";
    }
    A& operator=(const A&)
    {
        cout << "A copy assignment\n";
        return *this;
    }
};

class Myclass{
private:
    A ax;
};


int main()
{
    Myclass x , y;
    constexpr auto b = noexcept(x = y);
}
/*--------------------------------------------------------
noexcept olan bir fonksiyonun noexcept olmayan bir
fonksiyon ile override edilmesi syntax hatasına
neden olur.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

class Base{
public:
    virtual void func()noexcept;
};

class Der : public Base {
public:
    void func()override;
};

int main()
{
    Der myder;
}
/*--------------------------------------------------------
Ancak override edilen fonksiyonun tüm overrideları da eğer
noexcept ise herhangi şekilde bir syntax hatası söz konusu
olmaz.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

class Base{
public:
    virtual void func()noexcept
    {
        cout << "Base::func\n";
    }
};

class Der : public Base {
public:
    void func()noexcept override
    {
        cout << "Der::func\n";
    }
};

int main()
{
    Der myder;
}
/*--------------------------------------------------------
Aşağıdaki örnekte herhangi şekilde bir syntax hatası yoktur
çünkü bu durumda sadece türemiş sınıfta bulunan func fonksiyonu
noexcept yapılmıştır bu kurala ingilizce promise no less require no more
-------------------------------------------------------*/
#include <iostream>

using namespace std;

class Base{
public:
    virtual void func()
    {
        cout << "Base::func\n";
    }
};

class Der : public Base {
public:
    void func()noexcept override
    {
        cout << "Der::func\n";
    }
};

int main()
{
    Der myder;
}
/*--------------------------------------------------------
Aşağıdaki örnekte syntax hatasının nedeni noexcept olan
bir fonksiyon pointerına noexcept olmayan bir fonksiyon adresinin
atanmaya çalışmasıdır. noexcept fonksiyonun farklılaşmasına
neden olur.
-------------------------------------------------------*/

void func(int)noexcept;
void foo(int);

int main()
{
    void (*fp) (int)noexcept = &foo;

    fp(12); //error
}
/*--------------------------------------------------------
Aşağıdaki örnekte push back fonksiyonu çağrıldığında
move ctor noexcept olmadığı için sadece eklenen eleman için
taşıma semantiği devreye girecektir. Ekran çıktısı:
COPY
COPY
COPY
MOVE
COPY
COPY
COPY
-------------------------------------------------------*/
#include <iostream>
#include <vector>

using namespace std;

class Person{
public:
    Person(const char* p)
    {

    }
    Person(const Person&)
    {
        cout << "COPY" << '\n';
    }
    Person(Person&&)
    {
        cout << "MOVE" << '\n';
    }
};

int main()
{
    vector<Person> pvec{"mustafa","ayhan","zeliha"};
    pvec.push_back("kaya");
}
/*--------------------------------------------------------
Aşağıdaki durumda ise noexcept anahtar sözcüğü kullanıldığı
için taşıma semantiği kullanmak artık güvenli hale getirilmiştir.
Bu sebepten taşıma semantiği için move ctor kullanılır. Bu
kopyalama göre maliyeti ciddi anlamda düşürür.
COPY
COPY
COPY
MOVE
MOVE
MOVE
MOVE
-------------------------------------------------------*/
#include <iostream>
#include <vector>

using namespace std;

class Person{
public:
    Person(const char* p)
    {

    }
    Person(const Person&)
    {
        cout << "COPY" << '\n';
    }
    Person(Person&&)noexcept
    {
        cout << "MOVE" << '\n';
    }
};

int main()
{
    vector<Person> pvec{"mustafa","ayhan","zeliha"};
    pvec.push_back("kaya");
}
/*--------------------------------------------------------
std::terminate

1-) Yazacağınız sınıfların destructor'ı noexcept olmalı
2-) Yazacağınız sınıfların move ctor'ı (mümkünse) noexcept olmalı
3-) Yazacağınız tüm swap işlevleri noexcept olması gerekiyor.

Aşağıdaki örnekte exception fırlatılır ancak yakalanamaz bu
yüzden terminate fonksiyonu çağrılır.
-------------------------------------------------------*/
#include <iostream>
#include <vector>

using namespace std;

class Member{
public:
    Member(int x)
    {
        if(x % 2 == 0)
            throw 1;
    }
};

class Myclass{
public:
    Myclass() : mx(14)
    {
        try{

        }
        catch(int){
            cout << "hata Myclass constructor icinde yakalandi\n";
        }
    }
private:
    Member mx;
};

int main()
{
    Myclass mx;
}
/*--------------------------------------------------------
function try block kullanımı için bir örnek
Aşağıdaki örnekte exception neden yakalanmıyor öğren!!!
-------------------------------------------------------*/
#include <iostream>

using namespace std;

class Member{
public:
    Member(int x)
    {
        if(x % 2 == 0)
            throw 1;
    }
};

class Nec {
public:
    Nec() try: mx{20}
    {

    }
    catch (const exception& ex){
        cout << "exception caught : " << ex.what() << '\n';
        throw logic_error{"baska bir turden hata nesnesi"};
    }
private:
    Member mx;
};

int main()
{
    try {
        Nec nx;
    }
    catch (const exception& ex){
        cout << "exception caught : " << ex.what() << '\n';
    }
}
/*--------------------------------------------------------
Format error sınıfı runtime error sınıfından türemiş bir
sınıftır.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

class FormatError : public runtime_error{
public:
    FormatError() : runtime_error{"format error"} {}
};

int main()
{
    try {
        throw FormatError{};
    }
    catch (const exception& ex){
        cout << "exception caught : " << ex.what() << '\n';
    }
}
/*--------------------------------------------------------
Templates(şablonlar):şablonlar kısaca derleyiciye kod yazdıran özel
fonksiyonlara denir. Templateler generic(türden bağımsız) programlamanın
temelini oluşturmaktadır. void pointerlar bunun daha basit bir
yaklaşımla yapılmasıdır. C++ ile generic programlamaya bakış açısı
çok daha farklı bir hale gelmiştir. Templatelerin en önemli özelliklerinden
biri de STL(Standart Template library)'de çok önemli bir yere sahip
olmasıdır. Örneğin string sınıfı da container olmasının yanı sıra
bir templatedir. string dediğimiz şey aslında aşağıdaki örnekte
gösterilen basic_string dir. yani aşağıda gösterilen ifadeyle
string kütüphanesindeki string containerı aynı işi yapar ancak
tabi ki aşağıdaki ifadeyi belirtmek oldukça zahmetli olduğundan
dolayı string yazmak çok daha mantıklıdır ancak bu string
dediğimiz olayın nerden geldiğini bilmek de oldukça önemlidir.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

int main()
{
    basic_string<char,char_traits<char>,allocator<char>> str = "Ali";
    cout << str << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnek için tür çıkarımı int olarak yapılır.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

template <typename T>
class TypeTeller{

};

template <typename T>
void func(T)
{
    TypeTeller<T> y;
    cout << typeid(x).name() << '\n';
}

int main()
{
    func(10);
}

/*--------------------------------------------------------
Aşağıdaki örnek için tür çıkarımı const char[4] olarak yapılır.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

template <typename T>
class TypeTeller{

};

template <typename T>
void func(T x)
{
    TypeTeller<T> y;
}
int foo(int x)
{
    return x * x;
}

int main()
{
    func("ali");
}
/*--------------------------------------------------------
Aşağıdaki örnekte tür çıkarımı int (&r) [5] şeklinde yapılacaktır.
Bu durum auto anahtar sözcüğüyle aynıdır.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

template <typename T>
class TypeTeller{

};

template <typename T>
void func(T&)
{
    TypeTeller<T> y;
}
int foo(int x)
{
    return x * x;
}

int main()
{
    int a[5]{};
    func(a); //int[5]  int (&r)[5]
}
/*--------------------------------------------------------
Aşağıdaki örnekte T yerine gelen tür int olacaktır. func fonksiyonu
içerisinde bildirilen x değişkeni int&& türünden olacaktır.
fonksiyon çağrısının altında belirtilen auto&& x = 5;
ifadesi T&& param = 5 ifadesiyle aynı anlama gelir.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

template <typename T>
void func(T&& param)
{
    T x;
}

int main()
{
    int a = 5;
    func(5);
    auto&& x = 5;
}
/*--------------------------------------------------------
Aşağıdaki örnekte x'in türü kesinlikle int&&&& değildir.
böyle durumlarda sabit ifadesi veya değişken ifadesiyle ilk değer
verme durumlarına göre sol taraf referansı(l value reference)
veya sağ taraf referansı(r value reference) olabilir. Eğer
sabit ifadesiyse r value referans değişken ifadesi ise
l value reference olacaktır.
-------------------------------------------------------*/
#include <iostream>


int main()
{
    using mytype = int&&;
    int ival{};
    mytype&& x = 10;
}
/*--------------------------------------------------------
Aşağıdaki örnekte T için tür çıkarımı int& olarak yapılır
çünkü değişken ifadesiyle ilk değer verme söz konusudur.
auto için ise x in türü int& yani sol taraf referansıdır.
-------------------------------------------------------*/
#include <iostream>

template <typename T>
void func(T&&){}

int main()
{
    int ival = 5;
    func(ival);

    auto&& x = ival;
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>

int main()
{
    using mytype = int&;

    mytype& x = 10;
}
/*--------------------------------------------------------
templateler için tür çıkarımı auto anahtar sözcüğüyle(auto type deduction)
yapılan tür çıkarımıyla aynıdır ancak decltype'tan farklıdır.
C++ dilinde reference to reference yoktur.
Ancak bazı bağlamlarda reference collapsing mekanizması devreye
girer. Aşağıdaki tabloda birince sütun bildirimi ikinci sütun verilen
ilk değerinin referansının 3.sütun ise yapılacak tür çıkarımı göstermektedir.

T&      &       T&
T&      &&      T&
T&&     &       T&
T&&     &&      T&&
-------------------------------------------------------*/

/*--------------------------------------------------------
Aşağıdaki örnek için T'nin yerine gelen tür int* olurken tür
çıkarımı int** olarak yapılmaktadır.
-------------------------------------------------------*/
#include <iostream>

template <typename T>
void func(T*){}

int main()
{
    int x = 10;
    int* p = &x;
    int** ptr = &p;

    func(ptr);
    auto* z = ptr;
}
/*--------------------------------------------------------
Aşağıdaki örnekte foo fonksiyonunda a için tür çıkarımı int(&)[5] olarak yapılır.
Aynı durum func fonksiyonu için de geçerlidir ancak aradaki fark birinde
dizi boyunu hazır olarak int türünde bildirilmiştir.
-------------------------------------------------------*/
#include <iostream>

template <typename T,typename size>
void func(T(&)[size]){}

template <typename T>
void foo(T &){}

int main()
{
    int a[5]{};

    foo(a); //int[5]
    func(a);
}
/*--------------------------------------------------------
Aşağıdaki foo int açılımıyla çağrıldığı için foo fonksiyonunun
son durumda tür çıkarıyla hali int* foo(int*) şeklinde olacaktır.
-------------------------------------------------------*/
#include <iostream>

template <typename T>
T* foo(T *);
//int* foo(int*)

int main()
{
    foo<int>(10);
}
/*--------------------------------------------------------
Aşağıdaki örnekte T için tür çıkarımı yapılamadığından syntax
hatası oluşmaktadır.
-------------------------------------------------------*/
#include <iostream>

template <typename T>
T foo();

//could not deduce template argument for T

int main()
{
    int x = foo();
}
/*--------------------------------------------------------
Aşağıdaki örnekte syntax hatasının nedeni bir parametrede int
türden değişken diğer parametrede double türden bir değişken olduğundan
dolayı bir ambiguity oluşmasından kaynaklanmaktadır.(tür çıkarımı yapılamamasından)
-------------------------------------------------------*/
#include <iostream>

template <typename T>
void func(T x,T y);

int main()
{
    func(10,2.0);
}
/*--------------------------------------------------------
Aşağıdaki örnekte de yine tür çıkarımı yapılamamasından dolayı
bir syntax hatası söz konusudur.
-------------------------------------------------------*/
#include <iostream>

template <typename T> //template(type) parameter
void func(T x,T &&); //x call parameter

int main()
{
    int ival{ 10 };
    func(ival , ival); // int  int&(error)
}

/*--------------------------------------------------------
Aşağıdaki örnekte F için tür çıkarımı int(*)(int) şeklinde
yapılır çünkü bu durumda fonksiyon fonksiyon adresine dönüştülür
ve F için tür çıkarımı bir function pointer olarak yapılır.
-------------------------------------------------------*/
#include <iostream>
int func(F f) //int(*)(int)
{
    return f(12);
}

int foo(int x)
{
    std::cout << "foo cagrildi\n";
    return x * x + 5;
}

int main()
{
    auto x = func(foo);
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>

template <typename T>
auto func(T x) -> decltype(x + 1.3);
/*--------------------------------------------------------
İki tane stringin toplanması veya iki tane sayının toplanması
için birden fazla fonksiyon yazmak yerine aşağıdaki gibi template
kullanılabilir.
-------------------------------------------------------*/
#include <iostream>
#include <string>

template <typename T>
T sum(T x,T y)
{
    return x + y;
}

int main()
{
    using namespace std;

    string s1 = "ismail";
    string s2 = "ucar";

    auto x = sum(s1,s2);
    cout << "x = " << x << '\n';
}
/*--------------------------------------------------------
Herhangi farklı türden türden değerlerin toplanması için birden
fazla fonksiyon yazmak yerine aşağıdaki template kullanılabilir.
-------------------------------------------------------*/
#include <iostream>
#include <string>

template <typename R, typename T, typename U>
R sum(T t,U u)
{
    return t + u;
}

int main()
{
    auto x = sum<double> (12, 4.5);
}
/*--------------------------------------------------------
Aşağıdaki örnekte yapılan foo çağrılarına bağlı olarak farklı bir
şekilde tür çıkarımı yapılacaktır.
-------------------------------------------------------*/
#include <iostream>
#include <string>

template <typename T>
T foo(T x)
{
    return x + x;
}

int main()
{
    foo(1.2);
    foo(12.f);
    foo(123);
    foo('A');
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <string>

template <typename T, typename U>
auto sum(T t,U u) ->decltype(t * u)
{

}

int main()
{

}
/*--------------------------------------------------------
Herhangi aynı türden iki değişkeni takas etmek için aşağıdaki
swap fonksiyonu kullanılabilir.
-------------------------------------------------------*/
#include <iostream>

template <typename T>
void Swap(T& x,T& y)
{
    T temp = std::move(x);
    x = std::move(y);
    y = std::move(temp);
}

int main()
{

}
/*--------------------------------------------------------
decltype ve auto'nun birlikte kullanılması durumu
-------------------------------------------------------*/
#include <iostream>

int main()
{
    decltype(auto) x = 10;
}
/*--------------------------------------------------------
decltype ile tür her zaman neyse o olarak elde edilir.
referanslığın constluğun düşmesi vs durumlar söz konusu değildir.
-------------------------------------------------------*/
#include <iostream>

int main()
{
    int ar[] = {2, 4, 7};

    decltype(ar);
}
/*--------------------------------------------------------
Aşağıdaki örnekte her ne kadar sorun yok gibi gözükse de (x)
ifadesi için tür çıkarımı int& olarak yapılacaktır. Bu durumda
referanslara ilk değer vermek C++ dili kurallarına göre zorunlu olduğundan
syntax hatası oluşacaktır.
-------------------------------------------------------*/
#include <iostream>

int main()
{
    int x = 10;

    decltype((x)) a;
}
/*--------------------------------------------------------
neden kullanılır?

make_unique
make_shared

decltype(auto) ile yine derleyici bir tür çıkarımı yapar.
İlk değer veren ifadeden tür elde edilir.
Ancak, auto'dan farklı olarak çıkarım decltype kuralları göre yapılır.

decltype(expr)
    value category of expr  PR value    T
    value category of expr  L value     T&
    value category of expr  X value     T&&
-------------------------------------------------------*/
#include <iostream>

template <typename T>
auto func(T& x)
{
    return x;
}

int main()
{
    int ival{ 3 };

    int& r = func(ival);
}
/*--------------------------------------------------------
Aşağıdaki örnekte yukarıdaki örnekteki gibi bir tür uyuşmazlığı olmamasının
nedeni bu örnekte decltype(auto)'nun kullanılmasından kaynaklanmaktadır.
-------------------------------------------------------*/
#include <iostream>

template <typename T>
decltype(auto) func(T& x)
{
    return x;
}

int main()
{
    int ival{ 3 };

    int& r = func(ival);
}
/*--------------------------------------------------------
C++20 kurallarına göre auto anahtar sözcüğü artık parametre değişkenleri
için de kullanılabilir hale gelmiştir.  Abbreviated template syntax??
-------------------------------------------------------*/
#include <iostream>

void func(auto x)
{

}

/*--------------------------------------------------------
Aşağıdaki örnekte double dışında herhangi bir parametreyle yapılan func
çağrıları için template kullanılmış func fonksiyonu çağrılacaktır
ancak double parametreli için double parametreli fonksiyon çağrılacaktır.
-------------------------------------------------------*/
#include <iostream>

template <typename T>
void func(T)
{
    std::cout << "function template type T is : " << typeid(T).name() << '\n';
}

void func(double)
{
    std::cout << "func(double)\n";
}
int main()
{
    func(10);
    func(12.5);
}
/*--------------------------------------------------------
Aşağıdaki örnekte ise int parametreli func çağrıları için int
parametreli func çağrılırken herhangi başka parametreli func
çağrıları içinse
-------------------------------------------------------*/
#include <iostream>

template <typename T>
void func(T)
{
    std::cout << "function template type T is : " << typeid(T).name() << '\n';
}

void func(int)
{
    std::cout << "func(int)\n";
}
int main()
{
    func(10);
    func(12.5);
}
/*--------------------------------------------------------
Aşağıdaki örnekte syntax hatasının nedeni template fonksiyonun
delete edilmesidir. fonksiyon eğer hiç olmasaydı int parametreli
func çağrısı bir warning ile gerçekleşirdi çünkü burda bir narrowing
conversion söz konusu olurdu.
-------------------------------------------------------*/
#include <iostream>

template <typename T>
void func(T x) = delete;

void func(int);

int main()
{
    func(876);
    func(13.5); //error
}
/*--------------------------------------------------------
Aşağıdaki örnekte ekrana 2 basılır bunun nedeni templatelerde
çağrılan duruma daha yakın olan o olmasından kaynaklıdır.
-------------------------------------------------------*/
#include <iostream>

template <typename T>
void func(T)
{
    std::cout << "1\n";
}

template <typename T>
void func(T*)
{
    std::cout << "2\n";
}

template <typename T>
void func(T**)
{
    std::cout << "3\n";
}


int main()
{
    int x = 10;

    func(&x);
}
/*--------------------------------------------------------
Aşağıdaki örnekte gene üstte belirtilen kural geçerlidir
int** türüne en yakın olan T** olacağından 3 numaralı fonksiyon
çağrısı gerçekleşecektir.
-------------------------------------------------------*/
#include <iostream>

template <typename T>
void func(T)
{
    std::cout << "1\n";
}

template <typename T>
void func(T*)
{
    std::cout << "2\n";
}

template <typename T>
void func(T**)
{
    std::cout << "3\n";
}


int main()
{
    int x = 10;
    int*ptr = &x;
    func(&ptr);
}
/*--------------------------------------------------------
Aşağıdaki örnekte info olarak daha yakın olan fonksiyon 2
numaralı fonksiyon olduğundan dolayı o fonksiyon çağrısı
gerçekleşecektir.
-------------------------------------------------------*/
#include <iostream>

template <typename T>
void func(T &)
{
    std::cout << "1\n";
}

template <typename T>
void func(T(&)[10])
{
    std::cout << "2\n";
}

int main()
{
    int a[10]{};

    func(a);
}
/*--------------------------------------------------------
Bir dizi yazdırma fonksiyonunun template kullanılarak iterator
semantiğine benzetilmesi durumu
-------------------------------------------------------*/
#include <iostream>

template <typename Iter>
void Print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ <<' ';
    }
    std::cout << '\n';
}

int main()
{
    int a[5] = {0,1,2,3,4};

    Print(a, a + 5);
}
/*--------------------------------------------------------
vector sınıfı gibi containerlar da bu tarz bir template ile birlikte
kullanılabilir. Aslında STL standart template kütüphanesinde bulunan ekrana basma
fonksiyonu da bununla hemen hemen aynıdır STL konusunda bu
daha detaylı işlenecektir.
-------------------------------------------------------*/
#include <iostream>
#include <vector>

template <typename Iter>
void Print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ <<' ';
    }
    std::cout << '\n';
}

int main()
{
    std::vector<int> ivec{10, 20, 30, 40, 50};

    Print(ivec.begin(),ivec.end());
}

/*--------------------------------------------------------
Ekran çıktısı:
type T is i
type T is d
type T is l
type T is c
-------------------------------------------------------*/
#include <iostream>

class Myclass{
public:
    template<class T>
    void func(T x)
    {
        std::cout << "type T is " << typeid(T).name() << '\n';
    }
};

int main()
{
    Myclass m;
    m.func(12);
    m.func(1.2);
    m.func(1L);
    m.func('A');
}
/*--------------------------------------------------------
class templates(sınıf şablonları):Bu sefer bu sefer tek bir fonksiyon
için template belirtilmesi yerine komple sınıfa ait bir class
template tanımlanır. Sınıf şablonlarıyla ilgili aşağıdaki
örneği inceleyiniz.
-------------------------------------------------------*/
#include <iostream>

template <typename T>
class Myclass{
public:
    T& func(T x);
private:
    T mx;
};

template <typename T>
T& Myclass<T>::func(T x)
{
    ///
}

int main()
{
    Myclass m;
    m.func(12);
    m.func(1.2);
    m.func(1L);
    m.func('A');
}

/*--------------------------------------------------------
Farklı açılım sahip sınıf nesnelerinin birbirine atanması
geçersizdir.
-------------------------------------------------------*/
#include <iostream>

template <typename T>
class Myclass{
public:

};

int main()
{
    Myclass<int> m1;
    Myclass<double> m2;

    m1 = m2;
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>

template <typename T>
class Nec{
public:
    Nec foo();
    Nec func();
};

template <typename T>
Nec Nec<T>::foo()
{
    Nec x;
}

template <typename T>
Nec Nec<T>::func()
{
    Nec y;
}

/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>

template<typename T>
class Myclass{
public:
};

void g(Myclass<double>);
void g(Myclass<int>);
void g(Myclass<long>);
/*--------------------------------------------------------
STL'in pair fonksiyonunun manuel yazımı
-------------------------------------------------------*/
#include <iostream>

template <typename T,typename U>
struct Pair{
    Pair() : first{},second{} {}
    Pair(const T&t,const U&u) : first(t), second(u) {}
    T first;
    U second;
};

int main()
{
    Pair<int,double> px{12, 4.5};
    std::pair <int,double> idp{12, 4.5};
}
/*--------------------------------------------------------
Standard template library için Pair, Make pair ve pair compare
fonksiyonlarının manuel yazımı
-------------------------------------------------------*/
#include <iostream>

template <typename T,typename U>
struct Pair{
    Pair() : first{},second{} {}
    Pair(const T&t,const U&u) : first(t), second(u) {}
    T first;
    U second;
};

template <typename T,typename U>
Pair<T,U> MakePair(const T& t,const U& u)
{
    return Pair<T,U>{t,u};
}

template <typename T,typename U>
bool operator<(const Pair<T,U>& lhs, const Pair<T,U>& rhs)
{
    lhs.first < rhs.first || !(rhs.first < lhs.first) && lhs.second < rhs.second;
}

int main()
{
    auto x = MakePair(12,4.5);
}
/*--------------------------------------------------------
Nec sınıfının Myclass ın int açılımının açılımı türünden
bir nesne yaratımı gayet normal bir durumdur.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

template <typename T>
class Myclass{

};

template <typename T>
class Nec{

};

int main()
{
    Nec<Myclass<int>> mynec;
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>

template <typename T>
class Myclass {

};

int main()
{
    Myclass<int> x1;
    Myclass<Myclass<int>> x2;
    Myclass<Myclass<Myclass<int>>> x3;

    std::cout << typeid(x1).name() << '\n';
    std::cout << typeid(x2).name() << '\n';
    std::cout << typeid(x3).name() << '\n';
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <list>
#include <string>

using namespace std;

using namevec = std::vector<std::string>;

int main()
{
    vector<namevec> myvec;
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>

template<typename T>
class Myclass{
public:
    void foo(Myclass);
};

int main()
{
    Myclass<double> md;
    Myclass<int> mi;

    md.foo(mi);
}
/*--------------------------------------------------------
sınıf şablonu içerisinde fonksiyon şablonu olması durumu
-------------------------------------------------------*/
#include <iostream>

template <typename T>
class Myclass{
public:
    template <typename T>
    void foo(Myclass<U> x);
};

int main()
{
    Myclass<double> x;
    Myclass<int> y;
    x.foo(y);
}
/*--------------------------------------------------------
cout için kullanılan sola kaydırma operatörünün template kullanarak
overload edilmesi
-------------------------------------------------------*/
#include <iostream>

using namespace std;

template<typename T,typename U>
std::ostream& operator<<(std::ostream& os, const std::pair<T, U>& p)
{
    return os << "[" << p.first << "," << p.second << "]";
}

int main()
{
    pair<int,double> p1{12, 5.6};
    pair<const char*,int> p2{"alican",987};
    cout << p1 << '\n' << p2 << '\n';
}
/*--------------------------------------------------------
make_pair fonksiyonun sola kaydırma operatörünün overloadı ile birlikte
kullanılması durumu
-------------------------------------------------------*/
#include <iostream>

using namespace std;

template<typename T,typename U>
std::ostream& operator<<(std::ostream& os, const std::pair<T, U>& p)
{
    return os << "[" << p.first << "," << p.second << "]";
}

int main()
{
    auto x = make_pair(make_pair(make_pair(12, 4.5), make_pair("ali", 3.4)), make_pair('A','Z'));

    cout << x << '\n';
}
/*--------------------------------------------------------
Templatelerin varsayılan argüman alması fonksiyonların varsayalın
argüman almasından farklıdır. fonksiyonlarda başka bir argüman
ile varsayılan argüman alması syntax hatasıyken templateler
için bu oldukça normal bir durumdur.
-------------------------------------------------------*/
#include <iostream>

template <typename T,typename U = T>
class Myclass{

}

int main()
{
    Myclass<int, double> m1;
    Myclass<int> m2;
    Myclass<long> m3;

    std::cout << typeid(m1).name() << '\n';
    std::cout << typeid(m2).name() << '\n';
    std::cout << typeid(m3).name() << '\n';
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>

template <typename T>
class Allocator{

};

template <typename T, typename A = Allocator<T>>
class Vector{

};

/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>

template <typename T>
class Allocator{

};
template <typename K, typename C = Less<K> typename A = Allocator<K>>
class Set {

};

int main()
{
    set<int> myset;

    cout << typeid(myset).name() << '\n';
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>

template <int x = 10, int y = 20, int z = 30>
class Nec {

};

int main()
{
    Nec<2,5> mynec;

    std::cout << typeid(mynec).name() << '\n';
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>

class Myclass{

};

template <typename T, typename U = Myclass>
void func(T x, U y = U{})
{

}
class Nec{

};

int main()
{
    func(12); //func(12,Myclass{})
    func(2.3,Nec{});
}
/*--------------------------------------------------------
explicit specialization: Eğer aynı isimde birden fazla
class template veya function template varsa ve biri hariç
diğerinin template anahtar sözcüğünden sonra gelen açılım
kısmı boş ise bu durumda bu templatelere açılım kısmı dolu olan
template'in explicit specialization'ı denir. Örneğin aşağıdaki
örnekte Myclass sınıfının int ve char açılımı explicit specilization'a
bir örnektir.
-------------------------------------------------------*/
#include <iostream>

template <typename T>
class Myclass {
public:
    Myclass()
    {
        std::cout << "primary (master) template" << '\n';
    }
    void f1();
};

template <>
class Myclass<char>{
public:
    Myclass()
    {
        std::cout << "Myclass(char) explicit specialization" << '\n';
    }
};
template <>
class Myclass<int>{
public:
    Myclass()
    {
        std::cout << "Myclass(int) explicit specialization" << '\n';
    }
};

int main()
{
    Myclass<int> m1;
    Myclass<char> m2;
    Myclass<long> m3;
}
/*--------------------------------------------------------
Aşağıdaki örnekte T ile belirtilen template primary veya master
template'dir. int parametreli template ise onun explicit specialization
hali olacaktır.
-------------------------------------------------------*/
#include <iostream>

template<typename T>
void func(T x)
{

}

template<>
void func(int x)
{

}
/*--------------------------------------------------------
Aşağıdaki örnekte int parametreli func çağrıları hariç tüm
func çağrıları için primary template function çağrılacaktır sadece
int parametreliler için explicit specialization çağrılacaktır.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

template<typename T>
void func(T x)
{
    cout << "primary template template argument T is : " << typeid(T).name() << '\n';
}

template<>
void func()
{
    func('A');
    func(10 > 6);
    func(20.6);
    func(4);
}
/*--------------------------------------------------------
Aşağıdaki örnekte maximum değer elde etme fonksiyonu generic hale
getirilmiştir.
-------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

template<typename T>
T get_max(T x,T y)
{
    return x > y ? x : y;
}
int main()
{
    cout << get_max(12,45) << '\n';
    cout << get_max(45.6,98.78) << '\n';
    cout << get_max('A','!') << '\n';
    cout << get_max(45,12) << '\n';
    string s1{su},s2{cumhuriyet};
    cout << get_max(s1,s2) << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte anlatılmak istenen durum const char* türünden
değişkenler için bu generic fonksiyonun doğru çalışmayacağıdır.
Bunun nedeni burda referansların(adreslerin) karşılaştırmasıdır.
const char* parametreye özel bir explicit specialization yazılabilir.
-------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

template<typename T>
T get_max(T x,T y)
{
    return x > y ? x : y;
}
int main()
{
    const char* str1 = "zeynep";
    const char* str2 = "ayse";
    cout << get_max(str1,str2) << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte const char* parametreye özel bir explicit
specialization yazılmıştır bu sayede artık bu fonksiyon
const char* parametre için de her zaman doğru çalışacaktır.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <cstring>

using namespace std;

template<typename T>
T get_max(T x,T y)
{
    return x > y ? x : y;
}
template <>
const char* get_max(const char* s1,const char* s2)
{
    return strcmp(s1,s2) > 0 ? s1 : s2;
}


int main()
{
    const char* str1 = "zeynep";
    const char* str2 = "ayse";
    cout << get_max(str1,str2) << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte 3 numaralı fonksiyon çağrılacaktır bunun nedeni
explicit specialization'ın overload sete dahil edilmemesidir.
T ve T* arasında seçim yapılması söz konusudur bu durumda da
daha int* türüne daha yakın olan T* türü seçilecektir.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

template <typename T>
void foo(T)
{
    cout << '1' << '\n';
}
template <>
void foo(int*)
{
    cout << '2' << '\n';
}

template <typename T>
void foo(T *)
{
    cout << '3' << '\n';
}

int main()
{
    int* p{nullptr};

    foo(p);
}
/*--------------------------------------------------------
Aşağıdaki örnekte ise int* parametreli specialization bu sefer
T* parametreli foo fonksiyonunun explicit specialization'ı
olacağından bu durumda ekran çıktısı 3 olacaktır.
-------------------------------------------------------*/
#include <iostream>


using namespace std;

template <typename T>
void foo(T)
{
    cout << '1' << '\n';
}

template <typename T>
void foo(T *)
{
    cout << '2' << '\n';
}
template <>
void foo(int*)
{
    cout << '3' << '\n';
}

int main()
{
    int* p{nullptr};

    foo(p);
}
/*--------------------------------------------------------
Aşağıdaki örnekte ise gene yukardaki örnekteki kural söz konusu olduğundan
ekran çıktısı 4 olacaktır.
-------------------------------------------------------*/
#include <iostream>


using namespace std;

template <typename T>
void foo(T)
{
    cout << '1' << '\n';
}

template <>
void foo(int*)
{
    cout << '2' << '\n';
}

template <typename T>
void foo(T *)
{
    cout << '3' << '\n';
}
template <>
void foo(int*)
{
    cout << '4' << '\n';
}

int main()
{
    int* p{nullptr};

    foo(p);
}
/*--------------------------------------------------------
explicit specialization kullanarak faktoriyel fonksiyonunun
yazımı
-------------------------------------------------------*/
#include <iostream>

using namespace std;

template <typename T>
constexpr int factorial()
{
    return n * factorial<n - 1> ();
}

template <>
constexpr int factorial<0>()
{
    return 1;
}

int main()
{
    constexpr auto val = factorial<5>();
}
/*--------------------------------------------------------
struct template kullanarak bir faktoriyel değişkeni oluşturmak
-------------------------------------------------------*/

template <int n>
struct Factorial{
    static const int value = n > 1 ? n * Factorial<n - 1>::value : 1;
};

template <>
struct Factorial<0> {
    static const int value = 1;
};

int main()
{
    int a[Factorial<7>::value] = { 0 };
}
/*--------------------------------------------------------
Aşağıdaki örnekte m3 ve m4 nesneleri için primary template
yerine o template'e ait explicit specialization olan int ve float
açılımları çağrılacaktır. Ancak m1 ve m2 nesneleri için elbette
primary template çağrılacaktır.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

template <typename T>
class Myclass{
public:
    Myclass()
    {
        cout << "primary template" <<'\n';
    }
};
template <>
class Myclass<int>{
public:
    Myclass()
    {
        cout << "explicit specialization for Myclass<int>" << '\n';
    }
};

template <>
class Myclass<float>{
public:
    Myclass()
    {
        cout << "explicit specialization for Myclass<float>" << '\n';
    }
};

int main()
{
    Myclass<double> m1;
    Myclass<char> m2;
    Myclass<int> m3;
    Myclass<float> m4;
}
/*--------------------------------------------------------
1'den 100 e kadar olan sayıları döngü kullanmadan yazdırmanın
bir yolu(Mülakat sorusu)
-------------------------------------------------------*/
#include <iostream>

using namespace std;

template <int n>
struct Nec : Nec<n-1> {
    Nec()
    {
        cout << n << ' ';
    }
}
template<>
struct Nec<-1>{

};

int main()
{
    Nec<100> nec;
}
/*--------------------------------------------------------
Aşağıdaki örnekte dx nesnesi için D sınıfının ctorundan
önce C'nin ctoru o da çağrılmadan önce B sınıfının ctoru
o da çağrılmadan önce A sınıfının ctorunu çağrıcaktır. Bu
yüzden ekran çıktısı ABCD olacaktır.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

struct A {
    A()
    {
        cout <<'A';
    }
};
struct B : A{
    B()
    {
        cout << 'B';
    }
};
struct C : B{
    C()
    {
        cout << 'C';
    }
};
struct D : C{
    D()
    {
        cout << 'D';
    }
};
int main()
{
    D dx;
}
/*--------------------------------------------------------
Aşağıdaki örnekte Nec yapısının non-double bütün açılımları
için Nec::x 66 olurken double açılımı için değer 22 olacaktır.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

template <typename T>
struct Nec{
    static int x;
};

template <typename T>
int Nec<T>::x = 66;

template <>
int Nec<double>::x = 22;

int main()
{
   cout << Nec<int>::x << '\n';
   cout << Nec<double>::x << '\n';
}
/*--------------------------------------------------------
Aşağıdaki  örnekte yukarıdaki örnekte olduğu gibi non-int bütün
değerler için primary template çağrılırken int türü için
bir istisna söz konusudur.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

template<typename T>
struct Nec{
    void func(T)
    {
        cout << "primary template" << '\n';
    }
};

template <>
void Nec<int>::func(int)
{
    cout << "Nec<int>::func(int)\n";
}

int main()
{
   Nec<double> dnec;
   dnec.func(14);
   Nec<int> inec;
   inec.func(14);
}
/*--------------------------------------------------------
Partial specialization: Bu durumda ikinci yazılan template'in
içi boş bırakımaz açılımda farklılık görülür örneğin aşağıdaki
örnek için T* açılımı kullanılmıştır.
Aşağıdaki örnekte Myclass'ın int* veya char* gibi açılımları
türünden nesne yaratımı söz konusu olduğunda T* açılımına
sahip olan partial specialization kullanılacaktır.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

template<typename T>
class Myclass{
public:
    Myclass()
    {
        cout << "primary template" <<'\n';
    }
};

template <typename T>
class Myclass<T*>{
public:
    Myclass()
    {
        cout << "Myclass<T*>\n";
    }
};

int main()
{
   Myclass<int> x;
   Myclass<int*> y;
}
/*--------------------------------------------------------
Aşağıdaki örnekte bulunan partial specialization'ı inceleyiniz.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

template<typename T>
class Myclass{
public:
    Myclass()
    {
        cout << "primary template" <<'\n';
    }
};
//template partial specialization
template <typename T>
class Myclass<T*>{
public:
    Myclass()
    {
        cout << "Myclass<T*>\n";
    }
};
//template partial specialization
template <typename T>
class Myclass<T&>{
public:
    Myclass()
    {
        cout << "Myclass<T&>\n";
    }
};



//template partial specialization
template <typename T>
class Myclass<T[]>{
public:
    Myclass()
    {
        cout << "Myclass<T&>\n";
    }
};


int main()
{
   Myclass<int> x;
   Myclass<int*> y;
   Myclass<int&> z;
   Myclass<double []> t;
}
/*--------------------------------------------------------
Bir sınıf şablonu(class template) için yazılan partial specialization
primary template ile aynı sayıda template parametresine sahip olmak
zorunda değil. Ancak aynısı sayıda template argümanına sahip
olmak zorunda.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

template <typename T>
struct Nec{
    Nec()
    {
        cout << "primary template" <<'\n';
    }
};

template <typename T, typename  U>
struct Nec<pair<T,U>>{
    Nec()
    {
        cout << "partial specialization" <<'\n';
    }
};


int main()
{
   Nec<int> x;
   Nec<pair<int,double>> y;
}
/*--------------------------------------------------------
Aşağıdaki örnekte aynı türden açılımlar için partial specializition
kullanılırken farklı türler için primary template kullanılmaktadır.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

template <typename T,typename U>
struct Nec{
    Nec()
    {
        cout << "primary template" <<'\n';
    }
};

template <typename T>
struct Nec<T,T>{
    Nec()
    {
        cout << "partial specialization" <<'\n';
    }
};


int main()
{
   Nec<int,double> n1;
   Nec<int,int> n2;
   Nec<char,char> n3;
   Nec<int *, int *> n4;
}
/*--------------------------------------------------------
Aşağıdaki örnekte sadece n5 nesnesi için partial specialization
çağrılacaktır bunun nedeni sadece bu nesne için biri T
türü diğeri aynı türden pointer olmasından kaynaklanmaktadır.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

template <typename T,typename U>
struct Nec{
    Nec()
    {
        cout << "primary template" <<'\n';
    }
};

template <typename T>
struct Nec<T,T*>{
    Nec()
    {
        cout << "partial specialization" <<'\n';
    }
};


int main()
{
   Nec<int,double*> n1;
   Nec<int,int> n2;
   Nec<char,char> n3;
   Nec<int *, int *> n4;
   Nec<int, int*> n5;
}
/*--------------------------------------------------------
n nesnesi için de yine partial specialization devreye girecektir.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

template <typename T,typename U>
struct Nec{
    Nec()
    {
        cout << "primary template" <<'\n';
    }
};

template <typename T>
struct Nec<T,T*>{
    Nec()
    {
        cout << "partial specialization" <<'\n';
    }
};


int main()
{
   Nec<int*, int**> n;
}
/*--------------------------------------------------------
partial specialization kullanılarak yazılmış bir kuvvet alma
fonksiyonu
-------------------------------------------------------*/
#include <iostream>

using namespace std;

template <size_t base,size_t exp>
struct Power{
   constexpr static size_t value = base * Power<base,exp - 1>::value;
};

template <size_t base>
struct Power<base, 0u>{
    constexpr static size_t value = 1;
};


int main()
{
    constexpr auto val = Power<2,29>::value;
    cout << "val : " << val << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte type alias söz konusudur.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

template<typename T>
struct Nec{
    using type = int;
};

template <typename T>
struct Nec<T*>{
    using type = double;
};

int main()
{
    Nec<int>::type x{10};
    Nec<char*>::type y{};
}
/*--------------------------------------------------------

-------------------------------------------------------*/
class Myclass{
public:
    Myclass() = default;
    Myclass(Myclass&&)noexcept;
};

int main()
{
    std::is_nothrow_move_constructible<Myclass>::value;
}
/*--------------------------------------------------------
forward declaration
-------------------------------------------------------*/

template<typename T>
struct Neco;

template<>
struct Neco<int>{

};
/*--------------------------------------------------------
Bir template kullanarak bir dizinin uzunluğu bulunabilir.
-------------------------------------------------------*/

template<typename T,std::size_t size>
constexpr std::size_t asize(T(&)[size])
{
    return size;
}

int main()
{
    int a[20]{};

    constexpr auto size = asize(a);
}
/*--------------------------------------------------------

-------------------------------------------------------*/
typedef int inta[10];
using inta = int[10];

int main()
{
    inta x[20]; //int x[20][10]
}
/*--------------------------------------------------------
Aşağıdaki örnekte *p const olduğu için değiştirme girişimi
syntax hatasına neden olur.
-------------------------------------------------------*/
template <typename T>
using ptr = const T*;

int main()
{
    int x = 45;
    ptr<int> p{ &x };
    *p = 45; //error
}
/*--------------------------------------------------------

-------------------------------------------------------*/
template <typename T,int size>
using Array = T[size];

int main()
{
    Array<int, 5> x{};
    Array<double, 20> y{};
}
/*--------------------------------------------------------

-------------------------------------------------------*/
template <typename T, typename U>
class Myclass{

};

template <typename T>
using Nec = Myclass<T,int>;

int main()
{
    //Myclass<double,int>
    Nec<double> n;
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <set>

template<typename T>
using gset = std::set<T, std::greater<T>>;

int main()
{
    std::gset<int> igset;
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <set>
#include <vector>

template <typename Container>
void foo(Container c)
{
    Container::iterator iter = c.begin();
    //
}

int main()
{
    using namespace std;

    vector<int> ivec;

    foo(ivec);
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <set>
#include <vector>

template <typename T>
using veciter = typename std::vector<iterator>;
/*--------------------------------------------------------
Aşağıdaki örnekte val1 ve val2 arasında herhangi şekilde bir
fark yoktur.
-------------------------------------------------------*/
template <typename T>
struct Nec{
    //..
    constexpr static bool value{};
};

template <typename T>
constexpr static bool Nec_v = Nec<T>::value;

int main()
{
    constexpr auto val1 = Nec<int>::value;
    constexpr auto val2 = Nec_v<int>;
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <set>
#include <vector>
#include <type_traits>

template <typename T>
constexpr bool ispointer_v = std::ispointer<T>::value;

int main()
{
    constexpr auto b = ispointer_v<int*>;
}
/*--------------------------------------------------------
most vexing parse: Aşağıdaki örnekte bu mekanizma devreye girmektedir.
Bu durumda sanki B türünden bir nesneye A türünden bir nesne
gönderiliyormuş gibi görünse de burda most vexing parse
devreye girecektir. Bu sebeple aşağıdaki örnekte bir syntax
hatası söz konusudur.
-------------------------------------------------------*/

class A{
public:
};

class B{
public:
    B(A);
    void foo();
};

int main()
{
    B bx(A());
    bx.foo();//error
}
/*--------------------------------------------------------
Aşağıdaki örnekte bx1 hariç diğer foo çağrıları geçerlidir.
Bunun nedeni bx1 için most vexing parse devreye girecektir.
-------------------------------------------------------*/
class A{
public:
};

class B{
public:
    B(A);
    void foo();
};

int main()
{
    B bx1(A());
    B bx2(A{});
    B bx3{A()};
    B bx4{A{}};

    bx1.foo();
    bx2.foo();
    bx3.foo();
    bx4.foo();
}
/*--------------------------------------------------------

-------------------------------------------------------*/
template <typename T>
void func(T &x) //T is int(int)
{

}

int foo(int);

int main()
{
    func(foo);
}
/*--------------------------------------------------------
Template kullanarak bir faktoriyel fonksiyonu yazımı
Aşağıdaki örnek için constexpr anahtar sözcüğü ile fonksiyon
bildirimi gerçekleştiği için sabit ifadesiyle sonucun
elde edilmesi durumunda değer compile-time içerisinde hesaplanacaktır.
-------------------------------------------------------*/
template <int N>
constexpr int factorial()
{
    return N < 2 ? 1 : N * factorial<N - 1>();
}

int main()
{
    int a[factorial<6>()];
}
/*--------------------------------------------------------
Yukarıdaki örneğin farklı bir yaklaşımla çözümü
-------------------------------------------------------*/
template <int N>
constexpr int factorial()
{
    if constexpr (N < 2)
        return 1;
    else
        return N * factorial<N - 1>();
}

int main()
{
    int a[factorial<6>()];
}
/*--------------------------------------------------------

-------------------------------------------------------*/
class Myclass{};

using Ref = Myclass&;
using RefRef = Myclass&&;

int main()
{
    Myclass mx;
    Ref& r1 = mx;
    Ref&& r2 = mx;
    RefRef& r3 = mx;
    RefRef&& r4 = Myclass{};
}
/*--------------------------------------------------------
Aşağıdaki örnekte syntax hatasının nedeni ne Necati hocaya sor
-------------------------------------------------------*/
class Myclass{};

template <typename T>
void func(T&& param);

int main()
{
    Myclass m;
    func<Myclass&&> (m);
}
/*--------------------------------------------------------
Aşağıdaki örnekte ekran çıktısı:
foo(Nec&)
foo(const Nec&)
foo(Nec&&)
şeklinde olacaktır.
-------------------------------------------------------*/
#include <iostream>

class Nec {};

void foo(Nec&)
{
    std::cout << "foo(Nec&)\n";
}

void foo(const Nec&)
{
    std::cout << "foo(const Nec&)\n";
}
void foo(Nec&&)
{
    std::cout << "foo(Nec&&)\n";
}

int main()
{
    Nec nec;
    const Nec cnec;

    foo(nec);
    foo(cnec);
    foo(Nec{});
}
/*--------------------------------------------------------
Aşağıdaki örnekte ekran çıktısı:
foo(Nec&)
foo(Nec&)
foo(const Nec&)
foo(const Nec&)
foo(Nec&&)
foo(Nec&&)
şeklinde olacaktır.
bu örnekte bir forward fonksiyonu nasıl yazılır asıl o anlatılmak
istenmiştir.
-------------------------------------------------------*/
#include <iostream>

class Nec {};

void foo(Nec&)
{
    std::cout << "foo(Nec&)\n";
}

void foo(const Nec&)
{
    std::cout << "foo(const Nec&)\n";
}
void foo(Nec&&)
{
    std::cout << "foo(Nec&&)\n";
}

template <typename T>
void callfoo(T&& x)
{
    foo(std::forward<T>(x));
}

int main()
{
    Nec nec;
    const Nec cnec;

    foo(nec);
    callfoo(nec);
    foo(cnec);
    callfoo(cnec);
    foo(Nec{});
    callfoo(Nec{});
}
/*--------------------------------------------------------
Variadic parameter için tür argümanı yerine sabit ifadesi gönderimi
gerekir örneğin aşağıdaki örnek için istenildiği kadar
sabit ifadesi gönderilebilir. Ancak aşağıdaki kod syntax hatasıdır.
-------------------------------------------------------*/
#include <iostream>

//template parameter pack

template<int ...Args>
class Myclass {
    //...
};

int main()
{
    Myclass<> x;
    Myclass<int> y;
    Myclass<int, double> z;
    Myclass<int, double ,long> m;
}
/*--------------------------------------------------------
Yukarıdaki ifadesi doğrusu bu durumda herhangi bir şekilde bir syntax hatası
söz konusu değildir.
-------------------------------------------------------*/
#include <iostream>

//template parameter pack

template<int ...Args>
class Myclass {
    //...
};

int main()
{
    Myclass<> x;
    Myclass<12> y;
    Myclass<34,89> z;
    Myclass<90,67,78> m;
}
/*--------------------------------------------------------
Bir pack expansion örneği
-------------------------------------------------------*/
//pack expansion

template <typename T,typename ...Args>
void func(T x, Args ...args)
{

}

int main()
{
    func(10,2.3,5L,"ahmet");
}

/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>


template<typename ...Args>
void func(Args&& ...args)
{

}

int main()
{

}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>


template<typename ...Args>
void func(Args ...args)
{
    constexpr auto x = sizeof...(args);
    std::cout << "x = " << x << '\n';
}

int main()
{
    func();
}
/*--------------------------------------------------------
Aşağıdaki örnekte default parametre için sizeof değeri 0 olurken
3 tane parametre için sizeof değeri 3 olacaktır.
-------------------------------------------------------*/
#include <iostream>


template<typename ...Args>
class Myclass{
public:
    Myclass()
    {
        std::cout << sizeof...(Args) << '\n';
    }
};

int main()
{
    Myclass<> m1;
    Myclass<int,int,double> m2;
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>


template<typename ...Args>
class Myclass{
public:
    constexpr static std::size_t size = sizeof...(Args);
};

int main()
{
    std::cout << Myclass<int, int, double>::size << '\n';
}
/*--------------------------------------------------------
Standard template library içerisinde bulunan tuble sınıfı
da aslında bir variadic template'e sahiptir.
-------------------------------------------------------*/
#include <iostream>
#include <tuple>


template<typename ...Args>
void func(Args ...args)
{
    std::tuple<Args...> mytuple;
    std::tuple<int,double,long> mytuple;
}

int main()
{

    func(1,4.5,5L);
}

/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>

void func(int i, double d, std::string s)
{
    std::cout << "func called" << '\n';
}

template<typename ...Ts>
void foo(Ts ...params)
{
    func(params...);
}

int main()
{
    std::string name{"ali"};
    foo(1, 2.3, name);
}
/*--------------------------------------------------------
bitset sınıfının variadic template ile kullanımı
-------------------------------------------------------*/
#include <iostream>
#include <tuple>
#include <bitset>



template<typename ...Ts>
void foo(Ts ...args)
{
    int a[sizeof...(args)] = {(std::cout << args << ' ', 0)...};
}

int main()
{
    std::string name{"Murat"};
    foo(1, 2.3, name,std::bitset<32>{789234u});
}
/*--------------------------------------------------------

--------------------------------------------------------*/
#include <iostream>
#include <string>
#include <bitset>

void print(int p1, double p2, const char* p3, std::string p4, std::bitset<32> p5)
{
    int a[5] = {
    (std::cout << p1 << ' ',0) ,
    (std::cout << p2 << ' ',0) ,
    (std::cout << p3 << ' ',0) ,
    (std::cout << p4 << ' ',0) ,
    (std::cout << p5 << ' ',0)
    };
}

int main()
{
    std::string name{"Murat"};
    print(10,3.4,"ali",name, std::bitset<32>{789234u});
}
/*--------------------------------------------------------
unique_ptr smart pointerının manuel yazımı
--------------------------------------------------------*/

template <typename T, typename ...Ts>
std::unique_ptr<T> makeUnique(Ts && ...args)
{
    new T(std::forward<Ts>(args)...)
}
/*--------------------------------------------------------
Aşağıdaki örnekte tek parametre için non-variadic fonksiyon
çağrılırken birden fazla parametre için variadic fonksiyon
çağrılacaktır.
--------------------------------------------------------*/
#include <iostream>

template<typename T>
void f(T)
{
    std::cout << "non variadic function" << '\n';
}
template<typename ...Args>
void f(Args ...)
{
    std::cout << "variadic function" << '\n';
}

int main()
{
    f(1);
    f(12,4.5,"murat");
}

/*--------------------------------------------------------

--------------------------------------------------------*/
#include <iostream>

template<typename T>
void print(const T&)
{
    std::cout << "non variadic function" << '\n';
}
template<typename T,typename ...Args>
void print(const T& t,const Args& ...args)
{
    std::cout << sizeof...(Args) << '\n';
    print(args...);
}

int main()
{
    print(1);
    print(12,4.5,"murat");
}
/*--------------------------------------------------------
Aşağıdaki örnekte variadic print fonksiyonu tüm elemanları yazdırır.
--------------------------------------------------------*/
#include <iostream>

template<typename T>
void print(const T& t)
{
    std::cout << t << '\n';
}
template<typename T,typename ...Args>
void print(const T& t,const Args& ...args)
{
    print(t);
    print(args...);
}

int main()
{
    print(12,4.5,7L,"ali");
}
/*--------------------------------------------------------
Variadic template kullanılarak çok sayıda stringin birleştirilmesinin
bir yolu
--------------------------------------------------------*/
#include <iostream>
#include <string>

template<typename T>
T summer(const T& t)
{
    return t;
}
template<typename T,typename ...Types>
T summer(const T& first,const Types& ...args)
{
    return first + summer(args...);
}

int main()
{
    std::string s1{"ana"}, s2{"kin"}, s3{"sky"}, s4{"wal"}, s5{"ker"};

    std::cout << summer(s1,s2,s3,s4,s5);
}
/*--------------------------------------------------------
ostream kullanılarak output işlemi aşağıdaki örnekteki variadic
template ile yapılabilir.
--------------------------------------------------------*/
#include <iostream>
#include <string>

template<typename T,typename ...Types>
std::ostream& print(std::ostream& os,const T& t,const Types& ...args)
{
    os << t;
    if constexpr (sizeof...(args) > 0)
        os << ",";
    else
        os << '\n';
    if constexpr(sizeof...(args) != 0)
        print(os,args...);
    return os;
}

int main()
{
    print(std::cout, "ali", 12, 3.4, 56L);
}
/*--------------------------------------------------------
Aşağıdaki örnekte Myclass'ın Nec açılımı türünden bir nesne
yaratılması template içinde template ile yapılmıştır.
--------------------------------------------------------*/
template <template<typename> class N>
class Myclass {
    void func()
    {
        N<int> x;
        N<double> y;
    }
};

template <typename T>
class Nec {

};

int main()
{
    Myclass<Nec> x;
}
/*--------------------------------------------------------

--------------------------------------------------------*/
#include <iostream>

template <template<typename,typename> class N>
class Myclass {
    void func()
    {
        N<int> x;
        N<double> y;
    }
};

template <typename T1, typename T2>
class A {

};

int main()
{
    Myclass<A> x;
}
/*--------------------------------------------------------

--------------------------------------------------------*/
#include <iostream>
#include <typeinfo>

template <template<typename,int> class N>
class Myclass {
    Myclass()
    {
        std::cout << typeid(N<int,10>).name() << '\n';
    }
};

template <typename T, int x>
class A {

};

int main()
{
    Myclass<A> x;
}
/*--------------------------------------------------------

--------------------------------------------------------*/
template<typename T, template<typename> typename C>
class Nec{
public:
    Nec()
    {
        std::cout << typeid(C<T>).name() << '\n';
    }
};

template <typename T>
class A{

};

int main()
{
    Nec<char, A> nx;
}
/*--------------------------------------------------------
templatelerin varsayalın argüman alması
--------------------------------------------------------*/
#include <iostream>
#include <typeinfo>

template <int x = 10, int y = 20, int z = 30>
class Myclass {

};


int main()
{
    Myclass<6,7,8> m1;
    Myclass<6,7> m2;//Myclass <6,7,30>
    Myclass<6> m3;//Myclass <6,20,30>
    Myclass<> m4; //Myclass <10,20,30>
    Myclass m5; //Myclass <10,20,30>
}
/*--------------------------------------------------------
templatelerin varsayalın argüman alması
--------------------------------------------------------*/
#include <iostream>
#include <typeinfo>

class Myclass {

};

class A{};
class B{};

template<typename T,typename U = Myclass>
void func(T x, U y = U{})
{

}

int main()
{
    func(12);//func(12,Myclass{U{}});
}
/*--------------------------------------------------------
template ile using bildiriminin birlikte kullanımı
--------------------------------------------------------*/

template <typename T>
using Array = T[20];

int main()
{
    Array<int>;
    Array<double>;
}
/*--------------------------------------------------------
template ile using bildiriminin birlikte kullanımı
--------------------------------------------------------*/

template <typename T>
using Fptr = T(*)(T);

int main()
{
    Fptr<double> fp;
}
/*--------------------------------------------------------
set standart kütüphane fonksiyonunun template ve using bildirimiyle
kullanılması durumu
--------------------------------------------------------*/
#include <set>

template <typename T>
using gset = std::set<T, std::greater<T>>;

int main()
{
    gset<int>;
    gset<double>;
}
/*--------------------------------------------------------
iteratöre benziyen elemanlar kullanılarak yazılmış bir jenerik
print array fonksiyonu
--------------------------------------------------------*/
#include <iostream>
#include <list>

typename <typename P>
void print_array(P beg,P end)
{
    while(beg != end){
        std::cout << *beg << ' ';
        ++beg;
        }
    std::cout << '\n';
}

int main()
{
    using namespace std;
    list<int> mylist {3,5,8,1,9,4};
    print_array(mylist.begin(),mylist.end());
}
/*--------------------------------------------------------
STL(Standard template library):Derleyici içinde gelen içinde
çok sayıda araç barındıran standart bir şablon kütüphanesi
olarak tanımlanabilir.
STL'in içinde bulunan ve en sık kullanılan 3 eleman vardır Bunlar:
1-)Containers(Kaplar):Çeşitli tipte verilerin tutulabildiği özel sınıflara
container denir. En tipik örnekleri vector,string ve list olabilir.
2-)Iterators(Adımlayıcılar):Container içerisinde bulunan ögelerin konumunu
tutan pointer-like sınıflara iteratör denir. İteratörlerin bazıları pointerların
yaptığı işlerin tamamını yapabilirken bazıları bir kısmını yapabilmektedir.
Pointerların biraz daha soyutlanmış hali olarak da düşünülebilir.
3-)Algorithms(Algoritmalar):Veri yapılarında sık duyulan ihtiyaçlara karşılık
gelen Algoritmaları implimente eden sınıf şablonuna algoritmalar
denir.
Iterator categories:
1-)Input Iterator
2-)Output Iterator
3-)Forward Iterator
4-)Bidirectional Iterator
5-)Random Access Iterator
--------------------------------------------------------*/
/*--------------------------------------------------------
vector containerı ve algorithm standart kütüphanesinin
sort fonksiyonu
--------------------------------------------------------*/
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>

using namespace std;

template <typename T>
void print(T beg,T end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    vector<int> ivec{ 3, 7, 9, 2, 8, 1};
    print(ivec.begin(),ivec.end());
    sort(ivec.begin(),ivec.end());
    print(ivec.begin(),ivec.end());
}
/*--------------------------------------------------------

--------------------------------------------------------*/
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>

int main()
{
    vector<int> ivec{ 3, 7, 9, 2, 8, 1};
    for (auto iter = ivec.begin(); iter != ivec.end() ; ++iter) {
        cout << *iter << ' ';
    }
    cout << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte bir tanımsız davranış söz konusudur. Bunun nedeni
x in adresinin dizi adresinden tamamen alakasız bir adres olmasından
kaynaklanmaktadır.
--------------------------------------------------------*/
#include <iostream>
#include <algorithm>

int main()
{
    using namespace std;

    int a[] = {2, 6, 7, 9, 13, 7, 8, 9, 1, 2, 3};
    int x = 10;
    int* ptr = &x;
    sort(a,ptr);

    for(auto x : a)
        cout << x << ' ';
}
/*--------------------------------------------------------
Aşağıdaki örnekte ekran çıktısının 1 yani true olmasının
sebebi ivec'in uzunluğunun 0 olmasından kaynaklanmaktadır.
--------------------------------------------------------*/
#include <iostream>
#include <algorithm>

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << '\n';
}

int main()
{
    using namespace std;

    vector<int> ivec;

    cout << (begin(ivec) == end(ivec)) << '\n';
}
/*--------------------------------------------------------
Iterator Types:
1-)Input Iterator:Bu iteratörler ++,*(dereferencing) ve ok
operatörünün operandı yapılabilen iteratörlere verilen isimdir
2-)Output Iterator:Input iteratörün yapabildiği her şey ve üzerine != ve ==
operatörlerinin de operandı olabilen iteratürlere verilen isimdir.
3-)Forward Iterator:Output iteratörün yapabildiği her şeyin üzerine atama
işlemleri de bu iteratörle gerçekleştirilebilir.
4-)Bidirectional Iterator:Forward iteratörün yapabilirdiği her şeyin üzerine -- operatörünün
operandı da yapılabilen iteratörlere bidirectional iteratör denir.
5-)Random access Iterator:Bidirectional iteratörün yapabildiği her şeyin
üzerine [](index of),işlemli atama operatörlerinin , tüm karşılaştırma
operatörlerinin, toplama ve çıkarma operatörlerinin(toplama ve çıkarma kuralları pointerlarla aynıdır)
operandı olabilen iteratörlere random access iterators denir.
Bir iteratörün kategorisini sorgulamak için type_traits başlık
dosyasının is_same_v fonksiyonu kullanılabilir. Örneğin
aşağıdaki örnekte bu yapılmıştır. Örneğin list containerının
iteratörleri random access iterator türünden olmadığı için
ekrana 0 yazılacaktır.
Not:Bir fonksiyon çağrısına parametre değişkeni olarak begin ve
end iteratörleri geçilse bile bu şekilde container'a eleman
eklemek veya çıkarmak mümkün olmaz.
--------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <list>


int main()
{
    using namespace std;
    cout << is_same_v<list<int>::iterator::iterator_category, random_access_iterator_tag> << '\n';

}
/*--------------------------------------------------------
list container için iteratörler bidirectional iteratör
olacaktır.
--------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <list>


int main()
{
    using namespace std;
    cout << is_same_v<list<int>::iterator::iterator_category, bidirectional_iterator_tag> << '\n';

}
/*--------------------------------------------------------
Standart copyif kopyalama fonksiyonunun manuel yazımı. Bu
algoritma kendisine gönderilen fonksiyon adresindeki durumların
sağlanması durumunda kopyalama yapar.
--------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;

template<typename Iter>
void Print(Iter begin, Iter end) {
    while (begin != end) {
        cout << *begin++ << ' ';
    }
    cout << '\n';
}
template <typename InIter, typename OutIter, typename Pred>
OutIter CopyIf(InIter beg,InIter end,OutIter destbeg, Pred f)
{
    while(beg != end){
        if(f(*beg)){
            *destbeg++ = *beg;
        }
        ++beg;
    }
    return destbeg;
}
bool is_len_5(const string& str)
{
    return str.length() == 5;
}

int main()
{
    vector<string> ivec1 = {"Berke", "Kaya", "Mustafa", "Metin", "Mehmet", "Stefan", "Morty", "Jerry"};
    Print(ivec1.begin(), ivec1.end());
    vector<string> ivec2(10);
    auto iter = CopyIf(ivec1.begin(),ivec1.end(),ivec2.begin(),&is_len_5);
    Print(ivec2.begin(), iter);
}
/*--------------------------------------------------------
Lambda expressions(Lamda ifadeleri):Bu öyle bir ifadedir ki
derleyici bu ifade karşılığı bir sınıf(closure type) tanımlar
ve ifadenin kendisini tanımladığı sınıf türünden geçici nesne
olarak ele alır. Bu sayede sürekli olarak yeni bir fonksiyon
yazmak gerekmez bu açıdan lamda ifadeleri oldukça kullanışlıdır.
--------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;

template<typename Iter>
void Print(Iter begin, Iter end) {
    while (begin != end) {
        cout << *begin++ << ' ';
    }
    cout << '\n';
}
template <typename InIter, typename OutIter, typename Pred>
OutIter CopyIf(InIter beg,InIter end,OutIter destbeg, Pred f)
{
    while(beg != end){
        if(f(*beg)){
            *destbeg++ = *beg;
        }
        ++beg;
    }
    return destbeg;
}

int main()
{
    vector<string> ivec1 = {"Berke", "Kaya", "Mustafa", "Metin", "Mehmet", "Stefan", "Morty", "Jerry","Annelie","Dwayne","Abdulmuhtalip",};
    Print(ivec1.begin(), ivec1.end());
    vector<string> ivec2(11);
    int len;
    cout << "uzunlugu kac olanlar kopyalansin?" << '\n';
    cin >> len;
    auto iter = CopyIf(ivec1.begin(),ivec1.end(),ivec2.begin(),[len](const string& s){ return s.length() == len;});
    Print(ivec2.begin(), iter);
}
/*--------------------------------------------------------
Aşağıdaki örnekte 1 nolu ifade syntax hatasına sebep olurken
2 nolu ifade sebep olmaz bunun nedeni iter ifadesi const iken
*iter ifadesini const olmamasından kaynaklıdır. Yani kısacası
buna high level const denir.
--------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;

int main()
{
    vector<int> ivec{1,4,5,8,9,12};
    const vector<int>::iterator iter = ivec.begin();
    ++iter; //1
    *iter; //2
}
/*--------------------------------------------------------
vectorün kendisinin const yapılmasıyla vectorün iteratörünün
const yapılması aynı anlama gelmez aşağıdaki örnek için const iterator
kullanımı söz konusudur. Bu durumda *iter ifadesinin değiştirilmesi
syntax hatasına sebep olacaktır yani 2 nolu ifade syntax hatasıdır.
--------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;

int main()
{
    vector<int> ivec{1,4,5,8,9,12};
    vector<int>::const_iterator iter = ivec.begin();
    ++iter; //1
    *iter= 23; //2
}
/*--------------------------------------------------------
const iterator türünden başlangıç ve bitiş değerleri elde edilmek
istendiğinde bunun cbegin ve cend fonksiyonları kullanılır.
Örneğin aşağıdaki örnekte auto ile type deduction const iterator
türünden yapılacaktır.
--------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;

int main() {
    vector<int> ivec{1, 4, 5, 8, 9, 12};

    for(auto iter = ivec.cbegin();iter < ivec.cend();++iter){
        //*iter = (syntax error)
    }
}
/*--------------------------------------------------------
print fonksiyonunun rbegin ve rend parametreleriyle çağrılması
durumunda söz konusu container tersten yazdırılır.
--------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << '\n';
}

int main() {
    vector<int> ivec{1, 4, 5, 8, 9, 12};

    print(ivec.begin(),ivec.end());
    print(ivec.rbegin(),ivec.rend());
}
/*--------------------------------------------------------
rbegin aslında sona göre son elemanın konumunundan sonraki bellek bloğunun konumunu
tutmaktadır r ifadesi de zaten reverse anlamındadır.
--------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;

int main() {
    vector<int> ivec{1, 4, 5, 8, 9, 12};

    auto iter = ivec.rbegin();

    cout << "rbegin = " << *iter <<'\n';
    ++iter;
    cout << "rbegin = " << *iter <<'\n';
}
/*--------------------------------------------------------
ancak rend için durum biraz daha farklıdır. burda *iter
ifadesiyle elde edilen değer vector'ün tutulduğu bellek bloğundan
bir önceki bellek bloğundaki eleman elde edilir. ancak bu örnekte
iter ifadesi ilk elemanın konumunu tutmaktadır.
--------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;

int main() {
    vector<int> ivec{1, 4, 5, 8, 9, 12};

    auto iter = ivec.rend();

    cout << "rend = " << *iter <<'\n';
    --iter;
    cout << "rend = " << *iter <<'\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte 1 değerinin üretilmesinin sebebi rbegin in base'i ile
end'in aynı konumdaki elemanı tutmasından kaynaklanmaktadır.
--------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;

int main()
{
    vector<string> svec {"ahmet","bilge","neco","anakin","emre","doganay"};

    auto riter = svec.rbegin();

    auto iter = riter.base();

    cout << '\n';

    cout << (iter == svec.end());
}
/*--------------------------------------------------------
aşağıdaki örnekte .base ile elde edilen ifadelerin fonksiyona
gönderilmesinden kaynaklı tanımsız davranış durumu söz konusudur.
--------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << '\n';
}

int main()
{
    vector<string> svec {"ahmet","bilge","neco","anakin","emre","doganay"};

    auto riter_beg = svec.rbegin();
    auto riter_end = svec.rend();

    print(riter_beg,riter_end);
    cout << "********" << '\n';
    print(riter_beg.base(),riter_end.base()); //ub
}
/*--------------------------------------------------------
Find ve FindIf fonksiyonları
STL arama algoritmaları aranan değer bulunamadığında kendisine
gönderilen range'in end konumunu döndürür.
--------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;

template<typename InIter,typename T>
InIter Find(InIter beg,InIter end, const T& val)
{
    while(beg != end){
        if(*beg == val)
            return beg;
        ++beg;

    }
    return beg;

}
template<typename InIter,typename Pred>
InIter findIf(InIter beg,InIter end, Pred f)
{
    while(beg != end){
        if(f(*beg))
            return beg;
        ++beg;

    }
    return beg;
}


template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << '\n';
}

int main()
{
    vector<string> towns{"adana", "adiyaman", "afyonkarahisar", "agri", "aksaray", "amasya", "ankara",
                         "antalya", "ardahan", "artvin", "aydin", "balikesir", "bartin", "batman", "bayburt",
                         "bilecik", "bingol", "bitlis", "bolu", "burdur", "bursa", "canakkale", "cankiri", "corum",
                         "denizli", "diyarbakir", "duzce", "edirne", "elazig", "erzincan", "erzurum", "eskisehir",
                         "gaziantep", "giresun", "gumushane", "hakkari", "hatay", "igdir", "isparta", "istanbul", "izmir",
                         "kahramanmaras", "karabuk", "karaman", "kars", "kastamonu", "kayseri", "kilis",
                         "kirikkale", "kirklareli", "kirsehir","kocaeli", "konya", "kutahya", "malatya", "manisa",
                         "mardin", "mersin", "mugla", "mus","nevsehir", "nigde", "ordu","osmaniye", "rize",
                         "sakarya", "samsun", "sanliurfa", "siirt","sinop","sivas", "sirnak", "tekirdag","tokat",
                         "trabzon", "tunceli", "usak", "van", "yalova","yozgat", "zonguldak"};
    print(towns.begin(),towns.end());
    cout << "Aranan ili giriniz?" << '\n';
    string town;
    cin >> town;
    auto iter = Find(towns.begin(),towns.end(),town);
    if(iter != towns.end()){
        cout << "Bulundu" << '\n' << *iter << '\n';
        *iter = "!!!!!!!!";
        print(towns.begin(),towns.end());
    }
    else {
        cout << "Bulunamadi" <<'\n';
    }
}
/*--------------------------------------------------------
Yukarıdaki örnek if with init syntax'ı ile daha iyi hale getirilebilir.
--------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;

template<typename InIter,typename T>
InIter Find(InIter beg,InIter end, const T& val)
{
    while(beg != end){
        if(*beg == val)
            return beg;
        ++beg;

    }
    return beg;

}
template<typename InIter,typename Pred>
InIter findIf(InIter beg,InIter end, Pred f)
{
    while(beg != end){
        if(f(*beg))
            return beg;
        ++beg;

    }
    return beg;
}


template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << '\n';
}

int main()
{
    vector<string> towns{"adana", "adiyaman", "afyonkarahisar", "agri", "aksaray", "amasya", "ankara",
                         "antalya", "ardahan", "artvin", "aydin", "balikesir", "bartin", "batman", "bayburt",
                         "bilecik", "bingol", "bitlis", "bolu", "burdur", "bursa", "canakkale", "cankiri", "corum",
                         "denizli", "diyarbakir", "duzce", "edirne", "elazig", "erzincan", "erzurum", "eskisehir",
                         "gaziantep", "giresun", "gumushane", "hakkari", "hatay", "igdir", "isparta", "istanbul", "izmir",
                         "kahramanmaras", "karabuk", "karaman", "kars", "kastamonu", "kayseri", "kilis",
                         "kirikkale", "kirklareli", "kirsehir","kocaeli", "konya", "kutahya", "malatya", "manisa",
                         "mardin", "mersin", "mugla", "mus","nevsehir", "nigde", "ordu","osmaniye", "rize",
                         "sakarya", "samsun", "sanliurfa", "siirt","sinop","sivas", "sirnak", "tekirdag","tokat",
                         "trabzon", "tunceli", "usak", "van", "yalova","yozgat", "zonguldak"};
    print(towns.begin(),towns.end());
    cout << "Aranan ili giriniz?" << '\n';
    string town;
    cin >> town;
    if(auto iter = Find(towns.begin(),towns.end(),town);iter != towns.end()){
        cout << "Bulundu" << '\n' << *iter << '\n';
        *iter = "!!!!!!!!";
        print(towns.begin(),towns.end());
    }
    else {
        cout << "Bulunamadi" <<'\n';
    }
}
/*--------------------------------------------------------
has_unique_chars fonksiyonu setin char açılımının size'ı
aslında o yazıdaki karakter sayısını belirlediği için eğer yazının
kendi size değerine eşit ise o zaman unique karaktere sahiptir
diyebiliriz.
--------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <set>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << '\n';
}
bool has_unique_chars(const string& str)
{
    return set<char>(str.begin(),str.end()).size() == str.size();
}

int main()
{
    vector<string> towns{"adana", "adiyaman", "afyonkarahisar", "agri", "aksaray", "amasya", "ankara",
                         "antalya", "ardahan", "artvin", "aydin", "balikesir", "bartin", "batman", "bayburt",
                         "bilecik", "bingol", "bitlis", "bolu", "burdur", "bursa", "canakkale", "cankiri", "corum",
                         "denizli", "diyarbakir", "duzce", "edirne", "elazig", "erzincan", "erzurum", "eskisehir",
                         "gaziantep", "giresun", "gumushane", "hakkari", "hatay", "igdir", "isparta", "istanbul", "izmir",
                         "kahramanmaras", "karabuk", "karaman", "kars", "kastamonu", "kayseri", "kilis",
                         "kirikkale", "kirklareli", "kirsehir","kocaeli", "konya", "kutahya", "malatya", "manisa",
                         "mardin", "mersin", "mugla", "mus","nevsehir", "nigde", "ordu","osmaniye", "rize",
                         "sakarya", "samsun", "sanliurfa", "siirt","sinop","sivas", "sirnak", "tekirdag","tokat",
                         "trabzon", "tunceli", "usak", "van", "yalova","yozgat", "zonguldak"};
    print(towns.begin(),towns.end());
    cout << "Aranan ili giriniz?" << '\n';
    string town;
    cin >> town;
    if(auto iter = find_if(towns.begin(),towns.end(),has_unique_chars);iter != towns.end()){
        cout << "Bulundu" << '\n' << *iter << '\n';
        *iter = "!!!!!!!!";
        print(towns.begin(),towns.end());
    }
    else {
        cout << "Bulunamadi" <<'\n';
    }
}
/*--------------------------------------------------------

--------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << '\n';
}

int main()
{
    vector<string> ivec{1,2,4,8,9,34,67,89,45,78,12,56};
    print(ivec.begin(),ivec.end());
    cout << "Bir tamsayi giriniz?" << '\n';
    string ival;
    cin >> ival;
    if(auto iter = find_if(ivec.rbegin(),ivec.rend(),ival);iter != ivec.rend()){
        ivec.erase(iter.base()-1);
        print(ivec.rend(),ivec.rbegin());
    }
    else {
        cout << "Bulunamadi" <<'\n';
    }
}
/*--------------------------------------------------------
Klavyeden girilen tamsayıyı silen kod bu örnekte eğer iter.base()-1
yapılmasaydı silinmek istenen elemandan bir sonraki konumdaki öge
silinecektir.
--------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <set>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << '\n';
}

int main()
{
    vector<int> ivec{1,2,4,8,9,34,67,89,45,78,12,56};
    print(ivec.begin(),ivec.end());
    cout << "Bir tamsayi giriniz?" << '\n';
    int ival;
    cin >> ival;
    if(auto iter = find(ivec.rbegin(),ivec.rend(),ival);iter != ivec.rend()){
        ivec.erase(iter.base()-1);
        print(ivec.begin(),ivec.end());
    }
    else {
        cout << "Bulunamadi" <<'\n';
    }
}
/*--------------------------------------------------------
count standart fonksiyonu bir elemanın söz konusu veri yapısında
kaç adet olduğunu tespit eden fonksiyondur.
--------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <set>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << '\n';
}

int main()
{
    vector<int> ivec{1,2,4,8,9,34,67,89,45,78,12,12,12,56,56,78};
    print(ivec.begin(),ivec.end());
    cout << "Bir tamsayi giriniz?" << '\n';
    int ival;
    cin >> ival;

    cout << count(ivec.begin(),ivec.end(),ival) << '\n';
}
/*--------------------------------------------------------
lamda ifadesi kullanılarak çift olan sayıları tespit etme
yöntemi
--------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <set>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << '\n';
}

int main()
{
    vector<int> ivec{1,2,4,8,9,34,67,89,45,78,12,12,12,56,56,78};
    print(ivec.begin(),ivec.end());

    cout << count_if(ivec.begin(),ivec.end(),[](int x){return x % 2 == 0;}) << '\n';
}

/*--------------------------------------------------------

--------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <set>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << '\n';
}

int main()
{
    vector<int> ivec{1,2,4,8,9,34,67,89,45,78,12,12,12,56,56,78};
    print(ivec.begin(),ivec.end());
    int n;
    cout << "kaca tam bolunenler sayilsin?" << '\n';
    cin >> n;

    cout << count_if(ivec.begin(),ivec.end(),[n](int x){return x % n == 0;}) << '\n';
}
/*--------------------------------------------------------
Copy algoritmasına aşağıdaki örnekteki gibi back_inserter
fonksiyonuyla çağrılmazsa işini yapamaz aslında back_inserter
ve front_inserter fonksiyonları sırasıyla push_back ve front_back
fonksiyonlarına çağrı yapmaktadır.
--------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <set>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << '\n';
}

template<typename InIter,typename OutIter>
OutIter Copy(InIter beg,InIter end,OutIter destbeg)
{
    while(beg != end){
        *destbeg++ = *beg++;
    }
    return destbeg;
}

int main()
{
    vector<int> ivec{1,2,4,8,9,34,67,89,45,78,12,12,12,56,56,78};
    vector<int> x;

    Copy(ivec.begin(),ivec.end(),back_inserter(x));

    cout << "x.size() = " << x.size() << '\n';

    print(x.begin(),x.end());


}
/*--------------------------------------------------------
Eğer tersten yazdırılmak istenirse bu iş bu kez front_inserter
fonksiyonuna yapılır.
--------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <list>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << '\n';
}

template<typename InIter,typename OutIter>
OutIter Copy(InIter beg,InIter end,OutIter destbeg)
{
    while(beg != end){
        *destbeg++ = *beg++;
    }
    return destbeg;
}

int main()
{
    vector<int> ivec{1,2,4,8,9,34,67,89,45,78,12,12,12,56,56,78};
    list<int> x;

    copy(ivec.begin(),ivec.end(),front_inserter(x));

    cout << "x.size() = " << x.size() << '\n';

    print(x.begin(),x.end());


}
/*--------------------------------------------------------
Klavyeden girilen uzunluktaki tüm elemanları aşağıdaki algoritma
kullanılarak kopyalanabilir.
--------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <list>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << '\n';
}

template<typename InIter,typename OutIter>
OutIter Copy(InIter beg,InIter end,OutIter destbeg)
{
    while(beg != end){
        *destbeg++ = *beg++;
    }
    return destbeg;
}

int main()
{
    vector<string> towns{"adana", "adiyaman", "afyonkarahisar", "agri", "aksaray", "amasya", "ankara",
                         "antalya", "ardahan", "artvin", "aydin", "balikesir", "bartin", "batman", "bayburt",
                         "bilecik", "bingol", "bitlis", "bolu", "burdur", "bursa", "canakkale", "cankiri", "corum",
                         "denizli", "diyarbakir", "duzce", "edirne", "elazig", "erzincan", "erzurum", "eskisehir",
                         "gaziantep", "giresun", "gumushane", "hakkari", "hatay", "igdir", "isparta", "istanbul", "izmir",
                         "kahramanmaras", "karabuk", "karaman", "kars", "kastamonu", "kayseri", "kilis",
                         "kirikkale", "kirklareli", "kirsehir","kocaeli", "konya", "kutahya", "malatya", "manisa",
                         "mardin", "mersin", "mugla", "mus","nevsehir", "nigde", "ordu","osmaniye", "rize",
                         "sakarya", "samsun", "sanliurfa", "siirt","sinop","sivas", "sirnak", "tekirdag","tokat",
                         "trabzon", "tunceli", "usak", "van", "yalova","yozgat", "zonguldak"};
    list<string> slist;
    int len;
    cout << "Hangi uzunluktakiler kopyalansin?" << '\n';
    cin >> len;

    copy_if(towns.begin(),towns.end(),back_inserter(slist),[len](const string& s){ return s.size() == len; });

    cout << "x.size() = " << slist.size() << '\n';

    print(slist.begin(),slist.end());

}
/*--------------------------------------------------------

--------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <list>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << '\n';
}

template<typename InIter,typename OutIter>
OutIter Copy(InIter beg,InIter end,OutIter destbeg)
{
    while(beg != end){
        *destbeg++ = *beg++;
    }
    return destbeg;
}

int main()
{
    vector<string> towns{"adana", "adiyaman", "afyonkarahisar", "agri", "aksaray", "amasya", "ankara",
                         "antalya", "ardahan", "artvin", "aydin", "balikesir", "bartin", "batman", "bayburt",
                         "bilecik", "bingol", "bitlis", "bolu", "burdur", "bursa", "canakkale", "cankiri", "corum",
                         "denizli", "diyarbakir", "duzce", "edirne", "elazig", "erzincan", "erzurum", "eskisehir",
                         "gaziantep", "giresun", "gumushane", "hakkari", "hatay", "igdir", "isparta", "istanbul", "izmir",
                         "kahramanmaras", "karabuk", "karaman", "kars", "kastamonu", "kayseri", "kilis",
                         "kirikkale", "kirklareli", "kirsehir","kocaeli", "konya", "kutahya", "malatya", "manisa",
                         "mardin", "mersin", "mugla", "mus","nevsehir", "nigde", "ordu","osmaniye", "rize",
                         "sakarya", "samsun", "sanliurfa", "siirt","sinop","sivas", "sirnak", "tekirdag","tokat",
                         "trabzon", "tunceli", "usak", "van", "yalova","yozgat", "zonguldak"};
    list<string> slist1;
    list<string> slist2;
    int len;
    cout << "Hangi uzunluktakiler kopyalansin?" << '\n';
    cin >> len;

    copy_if(towns.begin(),towns.end(),back_inserter(slist1),[len](const string& s){ return s.size() == len; });

    print(slist1.begin(),slist1.end());

    copy_if(towns.begin(),towns.end(),front_inserter(slist2),[len](const string& s){ return s.size() == len; });

    print(slist2.begin(),slist2.end());

}
/*--------------------------------------------------------
compile-time içerisinde alternatif kod oluşturmak ve kod seçimi
yapmak

type-traits
tag-dispatch
SFINAE
constexpr if

advance fonksiyonu kullanılarak aşağıdaki örnekte vector containerının
sona göre -3 nolu elemanı elde edilmiştir ve bu eleman nurdur.
-1 nolu eleman ege olarak kabul edilmektedir ancak eğer
iter elemanına ilk ögenin konumu verilse nur 4 nolu öge olucaktı
yani nur elemanını elde etmek için iter,4 advance fonksiyonuna argüman
olarak geçilmelidir.
--------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <list>

using namespace std;

int main()
{
    vector<string> svec {"ali","eda","can","nur","efe","ege"};

    auto iter = svec.end();

    advance(iter,-3);

    cout << *iter << '\n';

}
/*--------------------------------------------------------

--------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <list>

using namespace std;

int main()
{
    vector<string> svec {"ali","eda","can","nur","efe","ege"};



}
/*--------------------------------------------------------
next fonksiyonu kullanılarak containerına ait 2 numaralı öge
silinebilir.
--------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <list>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << '\n';
}


int main()
{
    list<string> slist {"ali","eda","can","nur","efe","ege"};

    print(slist.begin(),slist.end());

    slist.erase(next(slist.begin()));

    print(slist.begin(),slist.end());

}
/*--------------------------------------------------------
prev fonksiyonuyla sondan bir önceki eleman silinebilir.
--------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <list>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << '\n';
}

int main()
{
    list<string> slist {"ali","eda","can","nur","efe","ege"};

    print(slist.begin(),slist.end());

    slist.erase(prev(slist.end(), 2));

    print(slist.begin(),slist.end());
}
/*--------------------------------------------------------
konumlar arası mesafe distance fonksiyonu kullanılarak elde edilebilir.
--------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <list>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << '\n';
}

int main()
{
    list<string> slist {"ali","eda","can","nur","efe","ege"};


    cout << distance(slist.begin(),slist.end());
}
/*--------------------------------------------------------
iter_swap fonksiyonunun bir kullanımı aşağıdaki örnekteki gibidir.
iter_swap fonksiyonu kullanılarak herhangi farklı iki containerın
elemanları değiştirilebilir.
--------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <list>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << '\n';
}

int main()
{
    list<string> slist {"ali","eda","can","nur","efe","ege"};
    vector<string> svec{"mert","tuna","lale","omer"};

    iter_swap(next(svec.begin()),prev(slist.end()));

    print(slist.begin(),slist.end());
    print(svec.begin(),svec.end());
}
/*--------------------------------------------------------
Container Types(Kap tipleri):
A-)Sequence Containers
    1-)Vector
    2-)Deque
    3-)list
    4-)forward_list
    5-)array
    6-)string
B-)Associate Containers
    1-)Set
    2-)Multiset
    3-)Map
    4-)MultiMap
C-)Unoredered Associative Containers
    1-)Unordered Set
    2-)Unordered Multiset
    3-)Unordered Map
    4-)Unordered Multimap
--------------------------------------------------------*/
/*--------------------------------------------------------
Array List(java) = vector
vector sınıfı bir dynamic array dir diyebiliriz. Bu yüzden
sürekli olarak bir reallocation olması söz konusudur. Bu yüzden
ciddi maliyetleri olabilir. size değeri capacity değerine eşit
olduğunda ve bir ekleme(insert) söz konusu olduğunda bir reallocation
söz konusu olacaktır. reallocation sırasında kopyalama mı
taşıma mı yapılacağı container'ın move constructorının
noexcept yapılıp yapılmamasıyla ilgilidir. string sınıfında
olduğu gibi burda da size değeriyle capacity değeri birbirinden
farklıdır. size değeri büyüklüğü ifade ederken capacity değeri daha
ne kadar büyütülebileceği göstermektedir. Daha doğrusu bellekte
ne kadar yer ayrıldığıdır. Aşağıdaki örnekte de görüldüğü size
ve capacity değerleri birbirinden farklıdır.
--------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <list>

using namespace std;

int main()
{
    vector<int> ivec(10);
    auto cap = ivec.capacity();

    for(;;){
        ivec.push_back(0);
        if(ivec.capacity() > cap){
            cout << "size = "<< ivec.size << "cap = " << ivec.capacity() << '\n';
            getchar();
            cap = ivec.capacity();
        }
    }
}
/*--------------------------------------------------------
Aslında vector container'ında varsayılan template argümanı
std::allocator'ındır ancak bizim bu ifadeyi yazmamıza gerek yoktur.
Örneğin:
std::vector<int> ivec;
yazmakla:
std::vector <int,std::allocator<int>> ivec;
yazmak arasında bir fark yoktur.
Farklı bir şekilde aşağıdaki iki ifade de aynı anlama
gelmektedir. Yani:
vec.size()
demekle
size(vec)
demek arasında bir fark yoktur.
--------------------------------------------------------*/
/*--------------------------------------------------------
Aşağıdaki örnekte auto ile tür çıkarımı init list olarak yapılacaktır.
--------------------------------------------------------*/
#include <initializer_list>

int main()
{
    auto x = {12,34,67,78};
}
/*--------------------------------------------------------
Yukarıdaki örnek Uniform init yapılsaydı syntax hatası oluşacaktı.
--------------------------------------------------------*/
#include <initializer_list>

int main()
{
    auto x {12,34,67,78}; //error
}
/*--------------------------------------------------------
init list içerisinde yalnızca aynı türden elemanlar bulunabilir.
Başka bir elemanın araya karışması durumunda syntax hatası oluşur.
--------------------------------------------------------*/
#include <initializer_list>

int main()
{
    auto x = {12,34,67,78,89.34}; //error
}
/*--------------------------------------------------------
Aşağıdaki örnekte x değişkeni için init list tür çıkarımı
yapılırken y için double türden bir değişken olarak tür çıkarımı
yapılacaktır.
--------------------------------------------------------*/
#include <initializer_list>

int main()
{
    auto x = {12,34,67,78};
    auto y{6.7};
}
/*--------------------------------------------------------
Aşağıdaki örnek için tür çıkarımı yapılamadığından syntax hatası oluşur.
--------------------------------------------------------*/
#include <initializer_list>


template <typename T>
void func(T x);

int main()
{
    using namespace std;

    auto a = {1,4,7,8};
    func({1,4,7,8});
    func(a);
}

/*--------------------------------------------------------
init listler immutabledır bu yüzden elemanlarının değiştirme
girişimleri syntax hatasına neden olur.
--------------------------------------------------------*/
#include <initializer_list>

using namespace std;

int main()
{
    auto x = {12,34,67,78};
    auto iter = x.begin();
    *iter = 10; //error
}

/*--------------------------------------------------------
init listin elemanları değişken olabilir ve for each döngü
deyimi kullanılarak aşağıdaki gibi init list içerisinde gezinilebilir.
--------------------------------------------------------*/
#include <initializer_list>

using namespace std;

void func(int);

int main()
{
    int x = 5,y = 354;

    for(auto a : {x,y,3,7,9,5})
        func(a);
}
/*--------------------------------------------------------
Aşağıdaki örnekte x ve y aynı siziyi gösteren pointerlar
gibi düşünülebilir.
--------------------------------------------------------*/
#include <initializer_list>

using namespace std;

void func(int);

int main()
{
    auto x = {1,3,5,7,9};
    auto y = x;

    cout << boolalpha;

    cout << (x.begin() == y.begin()) << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte overload resolution kurallarına göre init list
parametreli ctor çağrılacaktır.
--------------------------------------------------------*/
#include <initializer_list>

using namespace std;

class Myclass{
public:
    Myclass(initializer_list<int>)
    {
        cout << "init list" << '\n';
    }
    Myclass(int)
    {
        cout << "int" << '\n';
    }
};

int main()
{
    Myclass m1{12};
}

/*--------------------------------------------------------
Aşağıdaki örnekte tüm çağrılarda init list parametreli ctor çağrılacak
--------------------------------------------------------*/
#include <initializer_list>

using namespace std;

class Myclass{
public:
    Myclass(initializer_list<int>)
    {
        cout << "init list" << '\n';
    }
    Myclass(int)
    {
        cout << "int" << '\n';
    }
    Myclass(int,int)
    {
        cout << "int int" << '\n';
    }
};

int main()
{
    Myclass m1{};
    Myclass m2{12};
    Myclass m3{12,45};
}
/*--------------------------------------------------------
Ancak brace init yapıldığı zaman bu durumda int parametreli
ctor çağrısı yapılacaktır.
--------------------------------------------------------*/
#include <iostream>
#include <initializer_list>

using namespace std;

class Myclass{
public:
    Myclass(initializer_list<int>)
    {
        cout << "init list" << '\n';
    }
    Myclass(int)
    {
        cout << "int" << '\n';
    }
    Myclass(int,int)
    {
        cout << "int int" << '\n';
    }
};

int main()
{
    Myclass m1(12); //int
    Myclass m2{12}; //init list
}
/*--------------------------------------------------------
Aşağıdaki örnekte copy ctor çağrısı yapılacaktır. Maliyet açısından
taşıma semantiği kullanmak yerine bunu kullanmak oldukça maliyetlidir.
--------------------------------------------------------*/
#include <iostream>
#include <initializer_list>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << '\n';
}

int main()
{
    vector<string> vec1 = {"ali","erdem","ayse"};
    auto vec2 = vec1;
    print(vec1.begin(),vec1.end());
    print(vec2.begin(),vec2.end());
}
/*--------------------------------------------------------
Aşağıdaki örnekte taşıma semantiği kullanımı söz konusudur.
--------------------------------------------------------*/
#include <iostream>
#include <initializer_list>
#include <vector>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << '\n';
}

int main()
{
    vector<string> vec1 = {"ali","erdem","ayse"};
    auto vec2 = move(vec1);
    print(vec1.begin(),vec1.end());
    print(vec2.begin(),vec2.end());
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <initializer_list>
#include <vector>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << '\n';
}

int main()
{
    vector<string> vec1 = {"ali","erdem","ayse"};
    vector<string> vec2;
    for(size_t i = 0;i < vec1.size();++i)
        vec2.push_back(std::move(vec1[i]));
    cout << "vec1.size() = " << vec1.size << '\n';
    print(vec1.begin(),vec1.end());
    print(vec2.begin(),vec2.end());
}
/*--------------------------------------------------------
Taşıma semantiği kullanıldığında taşınan ögeye ne olur:
1-)Taşınan öge hale kullanılabilir.
2-)Moved from state
3-) Değeri belli değil
-------------------------------------------------------*/
#include <string>

int main()
{
    std::string str{"ankara"};
    std::string s = std::move(str);
    str = "izmir"; //geçerli
}

/*--------------------------------------------------------

--------------------------------------------------------*/
#include <vector>
#include <iostream>
#include <string>

int main()
{
    std::string str;
    std::vector<std::string> svec;
    while(std::cin >> str){
        //svec.push_back(str);
        svec.push_back(std::move(str));
    }
}

/*--------------------------------------------------------
const char* türünden bir dizinin bir vectore kopyalanması
aşağıdaki gibi yapılabilir.
--------------------------------------------------------*/
#include <vector>
#include <iostream>
#include <string>

using namespace std;

int main()
{
    const char* p[] = {"bilge","fatih","berke","necati};

    vector<string> svec(begin(p),end(p));
}

/*--------------------------------------------------------

-------------------------------------------------------*/
#include <vector>
#include <iostream>
#include <string>

using namespace std;

int main()
{
    vector<int> ivec = 60; //error
    vector<int> ivec(60);
}
/*--------------------------------------------------------
CTAD nedir araştır?
-------------------------------------------------------*/
#include <vector>
#include <iostream>
#include <string>

using namespace std;

int main()
{
    vector x{1,4,5,7,8}; //CTAD
}
/*--------------------------------------------------------
reserve fonksiyonu adından da anlaşılabileceği gibi
rezerve etmek anlamına gelmektedir. Aşağıdaki örnekte
görülen ifade de 2000 elemanlık bellek bloğunu
rezerve eder.
--------------------------------------------------------*/
#include <vector>
#include <iostream>
#include <string>

using namespace std;

int main()
{
    vector<string> svec;
    svec.reserve(2000);

    cout << "svec.capacity() = " << svec.capacity() << '\n';
}
/*--------------------------------------------------------
reverse fonksiyonu capacity değerinin her zaman o değerde
kalacağı anlamına gelmez. capacity değeri duruma bağlı reallocation
ile doğrudan ilintilidir.
-------------------------------------------------------*/
#include <vector>
#include <iostream>
#include <string>

using namespace std;

int main()
{
    vector<string> svec;
    svec.reserve(2000);

    cout << "svec.capacity() = " << svec.capacity() << '\n';

    svec.assign(10000,"ali");

    cout << "svec.capacity() = " << svec.capacity() << '\n';
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <vector>
#include <iostream>
#include <string>

int main()
{
    vector<string> svec = {"ali","erdem","ayse","zeynep","esma"};

    cout << svec[2] << '\n';
    svec[4] += "can";
    cout << svec[2].size() << '\n';

    for(size_t i{};i < svec.size();++i){
        cout << svec[i] << '\n';
    }
}
/*--------------------------------------------------------
Vector'ün olmayan bir elemanına erişim durumu tanımsız davranışa
sebep olur ancak bir exception throw edilmesi söz konusu
değildir.
-------------------------------------------------------*/
#include <vector>
#include <iostream>
#include <string>

int main()
{
    vector<string> svec = {"ali","erdem","ayse","zeynep","esma"};

    try {
        cout << svec[6];//undefined behaviour
    }
    catch(const exception& ex){
        cout << "exception caught" << ex.what() << '\n';
    }

}
/*--------------------------------------------------------
Yukarıdaki örneğin at fonksiyonuyla yazımı
--------------------------------------------------------*/
#include <vector>
#include <iostream>
#include <string>

int main()
{
    vector<string> svec = {"ali","erdem","ayse","zeynep","esma"};

    try {
        cout << svec.at(6);//undefined behaviour
    }
    catch(const exception& ex){
        cout << "exception caught" << ex.what() << '\n';
    }

}
/*--------------------------------------------------------
const bir vector'un elemanları değiştirilemez bu doğrudan
syntax hatasına sebep olur.
-------------------------------------------------------*/
int main()
{
    const vector<string> svec = {"ali","erdem","ayse","zeynep","esma"};

    svec.front() = "mehmet";//error

}
/*--------------------------------------------------------
resize fonksiyonu kullanılarak vector doğrudan küçültülebilir.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <list>
#include <initializer_list>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << '\n';
}

int main()
{
    vector<string> svec = {"ali","erdem","ayse","zeynep","esma"};

    print(svec.begin(),svec.end());
    svec.resize(3);
    print(svec.begin(),svec.end());
}
/*--------------------------------------------------------
pop_back fonksiyonu kullanılarak containerdan bulunan son
eleman silinebilir.
--------------------------------------------------------*/
#include <iostream>
#include <vector>
#include <string>
#include <list>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << '\n';
}

int main()
{
    vector<string> svec = {"ali","erdem","ayse","zeynep","esma"};

    while (!svec.empty()) {
        print(svec.begin(), svec.end());
        (void)getchar();
        svec.pop_back();
    }
}
/*--------------------------------------------------------
Aşağıdaki örnekteki kod doğru çalışmamaktadır çünkü base konumu
aslında bizim istediğimiz elemandan sonra gelen ögenin konumudur.
istediğimiz ögenin silinmesi için svec.base()-1 yapmak gerekmektedir.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <list>
#include <initializer_list>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << '\n';
}

int main()
{
    vector<string> svec = {"ali","erdem","ayse","zeynep","esma","mustafa","mehmet","berke","huseyin","selim"};

    print(svec.begin(), svec.end());

    string name;
    cout << "silinecek ismi giriniz?" << '\n';
    cin >> name;


    if(auto riter = find(svec.rbegin(),svec.rend(),name);riter != svec.rend()){
        svec.erase(riter.base());
        print(svec.begin(), svec.end());
        cout << "svec.size() = " << svec.size() << '\n';
    }
    else {
        cout << "Bulunamadi\n";
    }

}
/*--------------------------------------------------------
Yukarıdaki örneğin doğru çözümü
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <list>
#include <initializer_list>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << '\n';
}

int main()
{
    vector<string> svec = {"ali","erdem","ayse","zeynep","esma","mustafa","mehmet","berke","huseyin","selim"};

    print(svec.begin(), svec.end());

    string name;
    cout << "silinecek ismi giriniz?" << '\n';
    cin >> name;


    if(auto riter = find(svec.rbegin(),svec.rend(),name);riter != svec.rend()){
        svec.erase(riter.base() - 1);
        print(svec.begin(), svec.end());
        cout << "svec.size() = " << svec.size() << '\n';
    }
    else {
        cout << "Bulunamadi\n";
    }

}
/*--------------------------------------------------------
Aşağıdaki kodda herhangi şekilde bir syntax hatası yoktur ancak
yorum satırındaki ifade yorum satırından çıkartılırsa syntax
hatası oluşur. exception yakalanması da söz konusu değildir.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <list>
#include <initializer_list>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << '\n';
}

int main()
{
    vector<string> svec = {"ali","erdem","ayse","zeynep","esma","mustafa","mehmet","berke","huseyin","selim"};

    print(svec.begin(), svec.end());

    try {
        auto iter = svec.erase(svec.begin() + 3,svec.begin() + 1);
        print(svec.begin(), svec.end());
    }
    catch (const exception& ex){
        cout << "exception caught" << ex.what() << '\n';
    }
    //cout << "*iter" << *iter << '\n';

}
/*--------------------------------------------------------
Aşağıdaki örnekte sondan bir önceki elemanın değeri huseyin iken
fatih yapılacakmış gibi düşünülse de aksine burda bir kopyalama söz konusudur
huseyin elemanı olduğu konumda kalır ve capacity değerinde bir
bellek bloğu daha kullanılır son durumda son konumda selim ve sondan
bir önceki konumda fatih olur.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <list>
#include <initializer_list>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << '\n';
}

int main()
{
    vector<string> svec = {"ali","erdem","ayse","zeynep","esma","mustafa","mehmet","berke","huseyin","selim"};

    print(svec.begin(), svec.end());
    svec.insert(svec.end() - 1,"fatih");
    print(svec.begin(), svec.end());

}
/*--------------------------------------------------------
insert fonksiyonunun yapabildiği bazı işlemler
--------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <list>
#include <initializer_list>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << '\n';
}

int main()
{
    vector<string> svec{"ali","erdem","ayse","zeynep","esma"};
    list<string> mylist{"ela","naz","ece","nur"};

    print(svec.begin(), svec.end());
    svec.insert(svec.begin(),"korhan"); // tek eleman ekle
    svec.insert(svec.begin(),{"ali","can","nur"}); //init listi ekle
    svec.insert(svec.begin(),5 ,"kerim"); // 5 tane kerim ekle
    svec.insert(svec.begin(),mylist.begin(),mylist.end()); // başka bir containerı ekle
    print(svec.begin(), svec.end());

}

/*--------------------------------------------------------
Örnek Soru: Bir container için aşağıdaki durumlar isteniyor:
1-)Eğer bir ismin uzunluğu 5 ise ondan sonraki bellek bloğuna o isimden
bir tane daha eklenecek.
2-)Eğer bir ismin uzunluğu 6 ise o isim silinecek
-------------------------------------------------------*/
//--------------------------------------------------------
/*--------------------------------------------------------
Farklı tipte containerlar assign fonksiyonu kullanılarak
birbirine atanabilir.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <list>
#include <initializer_list>
#include <set>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << '\n';
}

int main()
{
    vector<string> svec{"ali","erdem","ayse","zeynep","esma"};
    set<string> myset{"ela","naz","ece","nur"};

    print(svec.begin(), svec.end());
    svec = myset; //error
    svec.assign(myset.begin(),myset.end());

}
/*--------------------------------------------------------
assign fonksiyonunun bazı kullanımları
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <list>
#include <initializer_list>
#include <set>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << '\n';
}

int main()
{
    vector<string> svec{"ali","erdem","ayse","zeynep","esma"};
    set<string> myset{"ela","naz","ece","nur"};

    print(svec.begin(), svec.end());
    //svec = myset; //error
    svec.assign(myset.begin(),myset.end());
    print(svec.begin(), svec.end());
    svec.assign({"nuri","huri","sami"});
    print(svec.begin(), svec.end());
    svec.assign(10,"recep");
    print(svec.begin(), svec.end());
}
/*--------------------------------------------------------
bir vector containerının boşaltmanın bazı yolları
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <list>
#include <set>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    vector<string> svec{"ali","nur","deniz","ferhan"};
    cout << svec.size() << '\n';
    svec.clear();
    svec.resize(0);
    svec.erase(svec.begin(),svec.end());
    svec.assign({});
    svec ={};
    svec = vector <string> {};
    print(svec.begin(),svec.end());
}
/*--------------------------------------------------------
Aşağıdaki örnekte ekran çıktısı aşağıdaki gibidir:
Myclass(int,int,int)
move ctor
************
Myclass(int,int,int)
--------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <list>
#include <initializer_list>
#include <set>

using namespace std;

class Myclass{
public:
    Myclass(int,int,int)
    {
        cout << "Myclass(int,int,int)" << '\n';
    }
    Myclass()
    {
        cout << "default ctor" << '\n';
    }
    Myclass(const Myclass&)
    {
        cout << "copy ctor" << '\n';
    }
    Myclass(Myclass&&)
    {
        cout << "move ctor" << '\n';
    }
};

int main()
{
    vector<Myclass> myvec;
    myvec.reserve(20);

    myvec.push_back(Myclass{1,4,7});
    cout << "************" << '\n';
    myvec.emplace_back(1,4,7);
}
/*--------------------------------------------------------
emplace_back fonksiyonu kopyalamanın mümkünse elimine edilmesi
sağlar bu sayede sınıfın copy ctoru çağrılmaz bu da optimizasyon
için oldukça faydalıdır.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <list>
#include <set>

using namespace std;

class Myclass{
public:
    Myclass()
    {
        cout << "Myclass default ctor" << '\n';
    }
    Myclass(const Myclass&)
    {
        cout << "Myclass copy ctor" << '\n';
    }
};

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    vector<Myclass> myvec;
    myvec.reserve(20);

    Myclass m;
    myvec.emplace_back(m);
}
/*--------------------------------------------------------
Aşağıdaki örnekte sadece default ctor çağrısı gerçekleştirilir.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <list>
#include <set>

using namespace std;

class Myclass{
public:
    Myclass()
    {
        cout << "Myclass default ctor" << '\n';
    }
    Myclass(const Myclass&)
    {
        cout << "Myclass copy ctor" << '\n';
    }
    Myclass(Myclass&&)
    {
        cout << "Myclass move ctor" << '\n';
    }
};

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    vector<Myclass> myvec;
    myvec.reserve(20);

    myvec.emplace_back();
}
/*--------------------------------------------------------
Aşağıdaki örnekte sadece int,int,int parametreli ctor çağrılır
bunun nedeni emplace_back kullanımından kaynaklıdır. Eğer
bu örnekte push_back fonksiyonu kullanılsaydı bu durumda copy
ctor çağrılırdı bu da ciddi bir maliyet anlamına gelir.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <list>
#include <set>

using namespace std;

class Myclass{
public:
    Myclass(int,int,int)
    {
        cout << "Myclass(int,int,int)" << '\n';
    }
    Myclass()
    {
        cout << "Myclass default ctor" << '\n';
    }
    Myclass(const Myclass&)
    {
        cout << "Myclass copy ctor" << '\n';
    }
    Myclass(Myclass&&)
    {
        cout << "Myclass move ctor" << '\n';
    }
};

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    vector<Myclass> myvec;
    myvec.reserve(20);

    myvec.emplace_back(1,4,7);
}
/*--------------------------------------------------------
vector'ün capacity değeri size değerinin düşmesiyle düşürülmez
ancak capacity değerini değiştirmek için shrink to fit fonksiyonu
kullanılabilir.
--------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <list>
#include <set>

using namespace std;

int main()
{
    vector <int> ivec(100'000);
    cout << "ivec.size() = " << ivec.size() << '\n';
    cout << "ivec.capacity() = " << ivec.capacity() << '\n';
    ivec.erase(ivec.begin() + 5 , ivec.end());

    cout << "ivec.size() = " << ivec.size() << '\n';
    cout << "ivec.capacity() = " << ivec.capacity() << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte bir swap trick gösterilmiştir. bu sayede
ivec'in capacity değeri gene düşürülebilir.
--------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <list>
#include <set>

using namespace std;

int main()
{
    vector <int> ivec(100'000);
    cout << "ivec.size() = " << ivec.size() << '\n';
    cout << "ivec.capacity() = " << ivec.capacity() << '\n';
    ivec.erase(ivec.begin() + 5 , ivec.end());

    cout << "ivec.size() = " << ivec.size() << '\n';
    cout << "ivec.capacity() = " << ivec.capacity() << '\n';

    vector<int>{ivec}.swap(ivec);

    cout << "ivec.size() = " << ivec.size() << '\n';
    cout << "ivec.capacity() = " << ivec.capacity() << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte shrink_to_fit fonksiyonu kullanılarak
ivec vectorünün capacity değeri düşürülmüştür.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <list>
#include <set>

using namespace std;

int main()
{
    vector <int> ivec(100'000);
    cout << "ivec.size() = " << ivec.size() << '\n';
    cout << "ivec.capacity() = " << ivec.capacity() << '\n';
    ivec.erase(ivec.begin() + 5 , ivec.end());

    cout << "ivec.size() = " << ivec.size() << '\n';
    cout << "ivec.capacity() = " << ivec.capacity() << '\n';

    ivec.shrink_to_fit();

    cout << "ivec.size() = " << ivec.size() << '\n';
    cout << "ivec.capacity() = " << ivec.capacity() << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte şaşırtıcı gibi görünse de vec2 vec1'den büyüktür
bunun nedeni 100000 elemana sahip de olsa ilk elemanlar karışılaştırıldığında
2 0'dan büyük olduğu için ivec2 daha büyük olarak değerlendirilecektir.
-------------------------------------------------------*/
#include <vector>

using namespace std;

int main()
{
    vector<int> vec1(100'000);
    vector<int> vec2{2};

    cout << boolalpha << (vec2 > vec1) << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte ivec1 tek elemanlı bir dinamik diziyken
ivec2 12 tane elemana sahip bir dinamik dizidir.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>


int main()
{
    using namespace std;

    vector<int> ivec1{12};
    vector<int> ivec2(12);
    cout << ivec1.size() <<'\n';
    cout << ivec2.size() <<'\n';
}
/*--------------------------------------------------------
transform algoritmasının genel biçimi:
transform(<source container begin konumu>,<source container end konumu>,
<target container begin konumu>,<elemanlara yapılacak işlem için fonksiyon adresi(lamda ifadesi de olabilir)>)
Örneğin aşağıdaki örnekte kaynak container'dan hedef container
içerisinde kareleri alınarak kopyalama yapılmıştır.
--------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <list>

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int square(int x)
{
    return x * x;
}

int main()
{
    vector <int> ivec{1,4,5,7,9,12,8};
    list<int> ilist(ivec.size());

    transform(ivec.begin(),ivec.end(),ilist.begin(),&square);

    print(ivec.begin(),ivec.end());
    print(ilist.begin(),ilist.end());

}
/*--------------------------------------------------------
Yukarıdaki örnekte transform algoritması bir fonksiyon ile
kullanılmıştır ancak oraya bir lamda ifadesi yazmak da mümkündür.
Aşağıdaki örnekte de bu yapılmıştır.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <list>

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int square(int x)
{
    return x * x;
}

int main()
{
    vector <int> ivec{1,4,5,7,9,12,8};
    list<int> ilist(ivec.size());
    int n;
    cout << "kac kati?" << '\n';
    cin >> n;

    transform(ivec.begin(),ivec.end(),ilist.begin(),[n](int val){return n * val;});

    print(ilist.begin(),ilist.end());

}

/*--------------------------------------------------------
lamda ifadelerinin genel biçimi:
[<fonksiyon içinde kullanılacak ifadeler>]<typename T(optional)> (<parametre değişkenleri>)
<duruma aşağıdaki ifadelerden biri ve hiçbiri olabilir>:
->type(type türünden döndür)
mutable([] içerisinde belirtilen ifade veya ifadeleri değiştirilebilir yap)
constexpr(fonksiyonu constexpr yap)
noexcept(fonksiyonu no except yap)
{code};
Lamda ifadeleri aslında derleyiciye fonksiyon yazdıran kodlardır.
Not:Bir lamda ifadesi const bir üye fonksiyondur ve const üye
fonksiyonun tüm özelliklerini gösterir. Örneğin aşağıdaki kod geçersizdir:

[x]() {++x}; //error

Aşağıdaki örnekte ajnx_ sınıfı aslında derleyici tarafından
yazılmış lamda ifadesinin birebir kopyasıdır.
-------------------------------------------------------*/
#include <iostream>

class ajnx_{
public:
    void operator()()const
    {
        cout << "merhaba dunya" <<'\n';
    }
};

int main()
{
    []{cout << "merhaba dunya" << '\n'}(); //IIFE
    ajnx_{}();
}
/*--------------------------------------------------------
Aşağıdaki örnekte lamda ifadesinin tür çıkarımının auto ile
yapılmasından dolayı her bir nesne için ayrı ayrı lamda ifadeleri
yazılmak zorunda kalmadı.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;

int main()
{
    auto f = [](const string& s) {return s.length();};
    string s1{"alican"};
    string s2{"taylan"};

    auto x = f(s1);
    auto y = f(s2);
}

/*--------------------------------------------------------
global ve static yerel değişkenler lamda ifadeleri
içerisinde doğrudan kullanılır herhangi bir şekilde [] içerisinde
belirtmek gerekmez.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

int g = 123;

int main()
{
    static int p = 78;
    auto f = [](int x){return p * x + g; };
}
/*--------------------------------------------------------

-------------------------------------------------------*/
class nec13{
public:
    nec13(int x) : x(x) {}
    int operator()(int a)const {return x * a;}
private:
    int x;
}

int main()
{
    int x = 10;
    auto f = [x](int a){return a * x;};
}
/*--------------------------------------------------------
Aşağıdaki örnekte syntax hatası olmasının nedeni lamda ifadelerinin
default olarak const üye fonksiyon olmasından kaynaklanmaktadır.
-------------------------------------------------------*/

int main()
{
    int x = 10;
    auto f = [x](int a){ x++;}; //error
}
/*--------------------------------------------------------
string sınıfının resize fonksiyonu da const üye fonksiyon içerisinde kullanılamaz
çünkü bu da bir değiştirme girişimi olarak değerlendirilir.
-------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

class Myclass{
public:
    void fun()const
    {
        s.resize(10);//error
    }
    string s;
};

int main()
{
    string s{"necati"};
    [s] {s.assign(5,'A');}; //error
}
/*--------------------------------------------------------
const üye fonksiyonlarda olduğu gibi mutable anahtar sözcüğüyle
bir lamda ifadesinin bildirilmesi durumunda değiştirme
girişimi geçerlidir.
-------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

int main()
{
    int a = 5;

    [a](int x)mutable{ a*=x; }
}
/*--------------------------------------------------------
lamda ifadelerinin köşeli parantezleri içerisinde , ile
belirtilen otomatik ömürlü nesneler lamda ifadesi içerisinde
kullanılabilir.
-------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

int main()
{
    int a = 5;
    string s{"alican"};
    int* ptr{};
    [a,s,ptr]() {};
}

/*--------------------------------------------------------
lamda ifadelerinde eğer tüm otomatik ömürlü nesnelerin kullanımı
istenirse köşeli parantez içerisine
--------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

int main()
{
    int a = 5;
    string s{"alican"};
    int* ptr{&a};

    [=](){ cout << s << a << *ptr; };
}
/*--------------------------------------------------------
aşağıdaki örnekte eğer fonksiyon çağrılsa da çağrılmasa da
x değişkenin değeri 5 olarak kalacaktır.
-------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

int main()
{
    int x = 5;

    auto f = [x]()mutable{x = 999;};

    f();

    cout << "x = " << x << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte x bu sefer call by reference olduğu için
x'in değeri bu şekilde değiştirilebilir ancak bu örnekte
de fonksiyon çağrısı yapılmadığı için x'in değeri
yine 5 olarak kalıcaktır.
-------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

int main()
{
    int x = 5;

    auto f = [&]()mutable{x = 999;};

    cout << "x = " << x << '\n';
}

/*--------------------------------------------------------
Aşağıdaki örnekte fonksiyon çağrısı söz konusu olduğundan
bu durumda x'in değeri son durumda 999 olacaktır.
-------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

int main()
{
    int x = 5;

    auto f = [&]()mutable{x = 999;};

    x = 20;
    f();

    cout << "x = " << x << '\n';
}
/*--------------------------------------------------------
Lamda ifadelerinin köşeli parantezlerinde bildirilen
bazı ifadelerin anlamları:
1-)[x]:x call by value olarak geç
2-)[x,y]:x ve y'yi call by value olarak geç
3-)[&x]: x i call by reference olarak geç
4-)[&x,y]:x i call by reference olarak geç y'yi call by value olarak geç
5-)[=]:hepsini call by value olarak geç
6-)[&]:hepsini call by reference olarak geç
7-)[=,&x]:all call by value but x
8-)[&,x]:all call by reference but x
-------------------------------------------------------*/
/*--------------------------------------------------------
Bir lamda ifadesinin noexcept olması aynı fonksiyonlarda
olduğu gibi o fonksiyonun exception göndermeyeceğini garanti
altına almaktadır.
-------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

int main()
{

    auto f = []()noexcept{ };

    constexpr auto b = noexcept(f());

}
/*--------------------------------------------------------
Aşağıdaki örnekte 5. yazıldığından dolayı
-------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

int main()
{

    auto f = [](int x){return x + 5.; };

    auto val = f(10);

}
/*--------------------------------------------------------
Aşağıdaki örnekte ->double ifadesi lamda ifadesiyle belirtilen
fonksiyonun geri dönüş değerinin double geri dönüş değerini
double olarak değerlendirilir.
-------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

int main()
{

    auto f = [](int x)->double{return x + 5; };

    auto val = f(10);

}
/*--------------------------------------------------------
Aşağıdaki örnekte syntax hatasının nedeni if'e girilmesiyle
girilmesi durumunda farklı tür çıkarımları yapılmaktadır.
-------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

int main()
{

    auto f = [](int x){
        if(x > 10)
            return x;
        return x * 1.5;
    };
}

/*--------------------------------------------------------
count_if algoritması ve test kodu
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;

class lenPred{
public:
    lenPred(size_t len) : m_len{len}{}
    bool operator()(string& s)const { return s.size() == m_len;}
private:
    size_t m_len;
};

int main()
{
    vector<string> svec{"mert","mustafa","irem","abdulmuhtalip","abdullah","metin","berke"
                        ,"berkay","bilge","necati","mert"};
    size_t len;
    cout << "uzunluk degerini giriniz : ";
    cin >> len;

    cout << count_if(svec.begin(),svec.end(),lenPred{len}) << '\n';
}
/*--------------------------------------------------------
Yukarıdaki örneğin lamda ifadesi kullanılarak yazılması
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;

int main()
{
    vector<string> svec{"mert","mustafa","irem","abdulmuhtalip","abdullah","metin","berke"
                        ,"berkay","bilge","necati","mert"};
    size_t len;
    cout << "uzunluk degerini giriniz : ";
    cin >> len;

    cout << count_if(svec.begin(),svec.end(),
    [len](const string& s){return s.size() == len; }) << '\n';
}

/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    vector<int> ivec{1,2,56,89,90,45,243,67,12,49,70};
    sort(ivec.begin(),ivec.end(),[](int a,int b)
    {return a % 2 != 0 && b % 2 == 0 || a % 2 == b % 2 && a < b});

    print(ivec.begin(),ivec.end());
}

/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    vector<int> ivec{1,2,56,89,90,45,243,67,12,49,70};
    int n;
    cout <<
    cin >> n;

    print(ivec.begin(),ivec.end());
}

/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;

int main()
{
    vector<int> ivec{1,2,56,89,90,45,243,67,12,49,70};
    int n;
    cout << "kac ile bolunebilen eleman bulunsun?\n";
    cin >> n;

    if(auto iter = find_if(ivec.begin(),ivec.end(),[n](int x){return x % n == 0;});iter != ivec.end()){
        cout << "bulundu\n";
        cout << "*iter = " << *iter << '\n';
    }
    else
    cout << "bulunamadi" << '\n';

}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;

int main()
{
    auto f = [](int x){return x * x;};
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;

int main()
{
    auto f = [](int x){return x * x;};
}
/*--------------------------------------------------------
closure type
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;

int main()
{
    auto f = [](int x){return x * x;};

    decltype(f) x(f);

    f = x;
}

/*--------------------------------------------------------
Aşağıdaki örnekte false değer üretilmesinin sebebi ifadelerin
türlerinin aynı olmasına karşın aynı closure type'a sahip olmamalarından
kaynaklanmaktadır.
-------------------------------------------------------*/
#include <iostream>

int main()
{
    auto f1 = [](int x){return x + 4;};
    auto f2 = [](int x){ return x + 4;};

    cout << boolalpha;
    cout << is_same_v <decltype(f1), decltype(f2)> << '\n';
    cout << typeid(f1).name() << '\n';
    cout << typeid(f2).name() << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte syntax hatasının nedeni bu atamanın viable
olmamasından kaynaklanmaktadır. çünkü bu durumda tür çıkarımı
lamda ifadesi olarak yapılır bir function pointer olarak değil.
-------------------------------------------------------*/
#include <iostream>

int main()
{
    int ival{3};
    int (*fptr)(int) = [ival](int x){return x + ival + 4;};
}
/*--------------------------------------------------------
Ancak aşağıdaki gibi köşeli parantez içerisinde herhangi bir
ifade belirtilmemesi durumunda bu atama doğrudan yapılabilir.
-------------------------------------------------------*/
#include <iostream>

int main()
{
    int (*fptr)(int) = [](int x){return x + 4;};

    std::cout << fptr(12) << '\n';
}
/*--------------------------------------------------------
Bir lamda ifadesinin bir fonksiyon göstericisi olarak görülmesi
için lamda ifadesinin başına + konulmalıdır. Buna positive lamda
idiom denir.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <type_traits>
#include <vector>

using namespace std;

int main()
{
    auto f = +[](int x){return x + 4;};

    cout << typeid(f).name() << '\n';
}

/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <type_traits>
#include <vector>

using namespace std;

template <typename T>
void func(T)
{
    ///...
}

int main()
{
    func(+[](int x){return x + 4;});
}
/*--------------------------------------------------------
Algorithm kütüphanesinde bulunan bazı fonksiyonlar veri yapılarından
eleman siliyormuş gibi görünse de aslında bu durum böyle
değildir. Gerçekte olan o veri yapısından lojik silme
yapılması veya başka bir değişle ögelere silinmiş gibi
davranılması anlamına gelmektedir. Örneğin aşağıdaki veri yapısından
1 olan elemanlar silinmiş gibi yapılırsa bu elemanlar veri
yapısının sonuna konulur ancak bu aşamada dikkat edilmesi
gereken durum son durumda sonda bulunan elemanların 1 olmasının
garanti olmamasıdır.
-------------------------------------------------------*/
/*--------------------------------------------------------
Aşağıdaki örnekte logic_end konumu vector'ün sonuna
atılan yani silinmiş muamelesi yapılan elemanların ilkinin
konumunu tutmaktadır. Bu durumda eğer logic_end ile
ivec.end() konumu arasındaki distance değeri silinmiş olan
eleman sayısına eşittir.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <type_traits>
#include <vector>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg!=end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    vector<int> ivec{1,3,5,4,9,23,78,90,12,45,67,12,98,103};
    print(ivec.begin(),ivec.end());
    int ival;
    cout << "silinecek elemani giriniz?\n";
    cin >> ival;
    auto logic_end = remove(ivec.begin(),ivec.end(),ival);
    cout << "size : " << ivec.size() << '\n';
    //lojik olarak kaç öge silindi
    cout << "lojik silinmiş öge sayisi : " << distance(logic_end,ivec.end()) << '\n';
    cout << "lojik silinmemiş öge sayisi : " << distance(ivec.begin(),logic_end) << '\n';
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <type_traits>
#include <vector>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg!=end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    vector<int> ivec{1,3,5,4,9,23,78,90,12,45,67,12,98,103};
    print(ivec.begin(),ivec.end());
    int ival;
    cout << "silinecek elemani giriniz?\n";
    cin >> ival;
    auto logic_end = remove(ivec.begin(),ivec.end(),ival);
    cout << "size : " << ivec.size() << '\n';
    //lojik olarak kaç öge silindi
    cout << "lojik silinmiş öge sayisi : " << distance(logic_end,ivec.end()) << '\n';
    cout << "lojik silinmemiş öge sayisi : " << distance(ivec.begin(),logic_end) << '\n';
    print(logic_end,ivec.end()); //silinmiş olan ögeleri tuttuğunu bir garantisi yok

    ivec.erase(logic_end,ivec.end());
    print(ivec.begin(),ivec.end());

    cout << "size = " << ivec.size() << '\n';
}
/*--------------------------------------------------------
Eğer programcı lojik silme değil de fiziksel sile yapılmak
istenirse bu durumda erase fonksiyonu da remove ile birlikte
kullanılmalıdır.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <type_traits>
#include <vector>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg!=end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    vector<int> ivec{1,3,5,4,9,23,78,90,12,45,67,12,98,103};
    print(ivec.begin(),ivec.end());
    int ival;
    cout << "silinecek elemani giriniz?\n";
    cin >> ival;

    ivec.erase(remove(ivec.begin(),ivec.end(),ival),ivec.end());
    print(ivec.begin(),ivec.end());

    cout << "size = " << ivec.size() << '\n';
}

/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <type_traits>
#include <vector>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg!=end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    vector<int> ivec{1,3,5,4,9,23,78,90,12,45,67,12,98,103};
    print(ivec.begin(),ivec.end());
    int ival;
    cout << "silinecek elemani giriniz?\n";
    cin >> ival;
    auto logic_end = remove(ivec.begin(),ivec.end(),ival);
    cout << "size : " << ivec.size() << '\n';
    //lojik olarak kaç öge silindi
    cout << "lojik silinmiş öge sayisi : " << distance(logic_end,ivec.end()) << '\n';
    cout << "lojik silinmemiş öge sayisi : " << distance(ivec.begin(),logic_end) << '\n';
    print(logic_end,ivec.end()); //silinmiş olan ögeleri tuttuğunu bir garantisi yok

    ivec.erase(logic_end,ivec.end());
    print(ivec.begin(),ivec.end());

    cout << "size = " << ivec.size() << '\n';
}
/*--------------------------------------------------------
remove_if algoritmasıyla lijik silme yerine fiziksel silme yapmak
için erase fonksiyonu kullanılabilir.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <type_traits>
#include <vector>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg!=end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    vector<int> ivec{1,3,5,4,9,23,78,90,12,45,67,12,98,103};
    print(ivec.begin(),ivec.end());
    int ival;
    cout << "Kaca tam bolunenler silinsin?\n";
    cin >> ival;

    ivec.erase(remove_if(ivec.begin(),ivec.end(),[ival](int x){return x % ival == 0;}))

    print(ivec.begin(),ivec.end());

    cout << "size = " << ivec.size() << '\n';
}
/*--------------------------------------------------------
Amacım bu değerlerin fiziksel olarak silinmesi ise remove-erase
veya erase-remove idiomu kullanılır.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <type_traits>
#include <vector>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg!=end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    vector<int> ivec{1,3,5,4,9,23,78,90,12,45,67,12,98,103};
    print(ivec.begin(),ivec.end());
    int ival;
    cout << "Kaca tam bolunenler silinsin?\n";
    cin >> ival;

    auto n = erase(ivec, ival);

    cout << n << "eleman silindi\n";
    cout << "size = " << ivec.size() << '\n';

    print(ivec.begin(),ivec.end());
}
/*--------------------------------------------------------
erase_if idiomu
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <type_traits>
#include <vector>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg!=end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    vector<int> ivec{1,3,5,4,9,23,78,90,12,45,67,12,98,103};
    print(ivec.begin(),ivec.end());
    int ival;
    cout << "Kaca tam bolunenler silinsin?\n";
    cin >> ival;

    auto n = erase_if(ivec, [ival](int x){return x % ival == 0;});

    cout << n << "eleman silindi\n";
    cout << "size = " << ivec.size() << '\n';

    print(ivec.begin(),ivec.end());
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <type_traits>
#include <vector>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg!=end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    vector<int> ivec{1,3,5,4,9,23,78,90,12,45,67,12,98,103};
    print(ivec.begin(),ivec.end());

    ivec.erase(unique(ivec.begin(),ivec.end()),ivec.end());
    print(ivec.begin(),ivec.end());

}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <type_traits>
#include <vector>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg!=end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    vector<int> ivec{1,3,5,4,9,23,78,90,12,45,67,12,98,103};
    print(ivec.begin(),ivec.end());

    ivec.erase(unique(ivec.begin(),ivec.end(),[](int a,int b){ return a % 2 == b % 2;}),ivec.end());
    print(ivec.begin(),ivec.end());

}
/*--------------------------------------------------------
Aşağıdaki stringi aralarında tek bir boşluk kalacak duruma getiren program
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <type_traits>
#include <vector>

using namespace std;

int main()
{
   string str{"kaan   ali  veli  hakan irma    aysenur    saadet  selim necati"};

   cout << '|' << str << '|' << '\n';
   str.erase(unique(str.begin(),st.end(),[](char c1,char c2){return std::isspace(c1) && isspace(c2)}),str.end());

   cout << '|' << str << '|' << '\n';
}
/*--------------------------------------------------------
plus'ın int açılımı int türünden değerler için toplama yap anlamı
taşımaktadır.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <type_traits>
#include <vector>

using namespace std;

int main()
{
   cout << plus<int>{}(12,45) << '\n';
}
/*--------------------------------------------------------
sort algoritması default olarak 3.parametrede bu örnek için
less'in int açılımı kullanır. Yani default olarak sort algoritması
küçükten büyüğe sıralama(sorting ascending order) yapar.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <type_traits>
#include <vector>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg!=end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    vector<int> ivec{1,3,5,4,9,23,78,90,12,45,67,12,98,103};
    print(ivec.begin(),ivec.end());

    sort(ivec.begin(),ivec.end());
    print(ivec.begin(),ivec.end());

}
/*--------------------------------------------------------
Eğer sıralama büyükten küçüğe(sorting descending order) doğru
yapılmak istenirse bu durumda greater'ın int açılımı 3.parametreye
argüman olarak geçilmelidir.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <type_traits>
#include <vector>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg!=end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    vector<int> ivec{1,3,5,4,9,23,78,90,12,45,67,12,98,103};
    print(ivec.begin(),ivec.end());

    sort(ivec.begin(),ivec.end(),greater<int>{});
    print(ivec.begin(),ivec.end());

}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <type_traits>
#include <vector>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg!=end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    vector<int> ivec{1,3,5,4,9,23,78,90,12,45,67,12,98,103};
    print(ivec.begin(),ivec.end());

    sort(ivec.begin(),ivec.end(),less{});
    //sort(ivec.begin(),ivec.end(),[](int a,int b){return a > b;});
    print(ivec.begin(),ivec.end());

}
/*--------------------------------------------------------
transform algoritması kullanılarak iki vektörün elemanları çarpılabilir.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <type_traits>
#include <vector>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg!=end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    vector<int> x{1,3,5,4,9,23,78,90,12,45,67,12,98,103};
    vector<int> y{21,89,23,6,47,22,9,5,3,90,34,17,8,23};
    vector<int> z(x.size());
    print(x.begin(),x.end());
    print(y.begin(),y.end());

    transform(x.begin(),x.end(),y.begin(),z.begin(),multiplies{});
    print(z.begin(),z.end());

}
/*--------------------------------------------------------
transform algoritmasının negate argümanıyla kullanımı negate
ile kullanımı durumunda aşağıdaki örnekte vector'ün elemanları
son durumda negatif olur.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <type_traits>
#include <vector>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg!=end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    vector<int> ivec{1,3,5,4,9,23,78,90,12,45,67,12,98,103};
    print(ivec.begin(),ivec.end());

    transform(ivec.begin(),ivec.end(),ivec.begin(),negate{});
    print(ivec.begin(),ivec.end());

}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <type_traits>
#include <vector>

using namespace std;

int main()
{
    string str{"necati  ergin  berke sertel  irma aysenur   bolat  gurhan sancar"};

    cout << '|' << str << '|' << '\n';
    sort(begin(str),end(str),greater{});
    cout << '|' << str << '|' << '\n';
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <type_traits>
#include <vector>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg!=end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    vector<string> svec{"necati","berke","gurhan","bilge","aysenur","irmak"};
    print(svec.begin(),svec.end());

    const auto fcomp = [](const string& s1,const string& s2){
        return s1.length() < s2.length() || s1.length() == s2.length() && s1 < s2;
    };
    sort(svec.begin(),svec.end(),fcomp);
    print(svec.begin(),svec.end());

}

/*--------------------------------------------------------
stable_sort algoritması:Örneğin aynı isimdeki ve farklı yaşdaki
kişiler aynı yerde gruplanması bir algoritmanın stable olduğunu
gösterir. örneğin farklı yaşta buluna ahmetlerin aynı yerde gruplanması
buna örnek verilebilir çünkü bu örnek için anahtar ahmet olacağı için
bu durumda sıralama böyle gerçekleşti.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <type_traits>
#include <vector>
#include <fstream>
#include <format>

using namespace std;

class Person{

public:
    Person() = default;
    Person(string name, int age) : m_name{move(name)},m_age{age} {}
    friend stream&operator<<(stream& os,const& Person per)
    {
        return os << format("{: <14} {:<5}",per.m.name,per.m_age);
    }
private:
    string m_name;
    int m_age;
};

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg!=end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    vector<Person> pvec{{"necati",12},{"berke",34},{"gurhan",56},{"bilge",78},{"mustafa",90},{"aysenur",45},{"irmak",15}};
    print(pvec.begin(),pvec.end());

    sort(pvec.begin(),pvec.end(),fcomp);
    print(pvec.begin(),pvec.end());

}

/*--------------------------------------------------------
partial_sort algoritması: söz konusu veri yapısının belirli
bir bölümünü sortlamak için kullanılır. Örneğin aşağıdaki
örnekte vector'ün ilk 20 elemanı sıralanmıştır.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;


template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg!=end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
   vector<int> ivec{11,23,56,78,90,12,34,56,73,45,65,19,12,34,70,81,92,91,104,765,123,45,65,89,44,32,12,95,101,99};

   print(begin(ivec),end(ivec));
   partial_sort(begin(ivec),begin(ivec)+20,end(ivec));
   print(begin(ivec),end(ivec));
}

/*--------------------------------------------------------
partial_sort_copy fonksiyonu ise veri yapıları için aşağıdaki
örnekte olduğu gibi sort edilmiş belli bir rangedeki ögelerin
kopyalanmasını sağlar.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;


template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg!=end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
   vector<int> ivec1{11,23,56,78,90,12,34,56,73,45,65,19,12,34,70,81,92,91,104,765,123,45,65,89,44,32,12,95,101,99};
   vector<int> ivec2(20);


   print(begin(ivec1),end(ivec1));
   partial_sort_copy(begin(ivec1),end(ivec1),begin(ivec2),end(ivec2));
   print(begin(ivec2),end(ivec2));
}

/*--------------------------------------------------------
nth element fonksiyonu veri yapısı sortlandığın söz konusu indeks
değerinde bulunan elemanın yerine sortlama tamamlandıktan
sonra hangi elemanının geleceğini bulup o elemanı doğru
indekse getirir
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;


template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg!=end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
   vector<int> ivec{11,23,45,7,12};

   cout << "indeks : " << '\n';
    int n;
    cin >> n;
    nth_element(begin(ivec),begin(ivec) + n,end(ivec));

   print(begin(ivec),end(ivec));
}

/*--------------------------------------------------------
Bir veri yapısının ortanca değeri nth element algoritması
kullanılarak veri yapısının tamamı sıralanmadan yapılabilir.
Bu az elemanlı veri yapıların çok bir tasarruf sağlamasa da
büyüklüğü yüksek olan veri yapılarında ciddi anlamda tasarruf
sağlamaktadır.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;


template<typename Iter>
void print(Iter beg, Iter end) {
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main() {
    vector<int> ivec{11, 23, 56, 78, 90, 12, 34, 56, 73, 45, 65, 19, 34, 70, 81, 92, 91, 104, 765, 123, 45, 65, 89, 44,
                     32, 95, 101, 99};

    nth_element(ivec.begin(), ivec.begin() + ivec.size() / 2, ivec.end());
    cout << "ortanca deger : " << ivec[ivec.size() / 2] << '\n';
    sort(begin(ivec), end(ivec));
    print(begin(ivec), end(ivec));
}

/*--------------------------------------------------------
Aşağıdaki örnekte partition algoritmasıyla klavyeden girilen
harfe bağlı olarak o harfi içeren string referansları vector'ün
başında toplanmaktadır.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;


template<typename Iter>
void print(Iter beg, Iter end) {
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main() {
    vector<string> towns{"adana", "adiyaman", "afyonkarahisar", "agri", "aksaray", "amasya", "ankara",
                         "antalya", "ardahan", "artvin", "aydin", "balikesir", "bartin", "batman", "bayburt",
                         "bilecik", "bingol", "bitlis", "bolu", "burdur", "bursa", "canakkale", "cankiri", "corum",
                         "denizli", "diyarbakir", "duzce", "edirne", "elazig", "erzincan", "erzurum", "eskisehir",
                         "gaziantep", "giresun", "gumushane", "hakkari", "hatay", "igdir", "isparta", "istanbul", "izmir",
                         "kahramanmaras", "karabuk", "karaman", "kars", "kastamonu", "kayseri", "kilis",
                         "kirikkale", "kirklareli", "kirsehir","kocaeli", "konya", "kutahya", "malatya", "manisa",
                         "mardin", "mersin", "mugla", "mus","nevsehir", "nigde", "ordu","osmaniye", "rize",
                         "sakarya", "samsun", "sanliurfa", "siirt","sinop","sivas", "sirnak", "tekirdag","tokat",
                         "trabzon", "tunceli", "usak", "van", "yalova","yozgat", "zonguldak"};

    char ch;
    cout << "Bir harf giriniz?\n";
    cin >> ch;

    auto iter = partition(towns.begin(),towns.end(),[ch](const string& s){return s.find(ch) != string::npos;});

    cout << "partisyon tamamlandi partisyon noktasi indeksi : " << distance(towns.begin(),iter) <<'\n';

    if(iter != towns.end())
        cout << *iter << '\n';
    print(begin(towns), end(towns));
}

/*--------------------------------------------------------
stable_partition algoritması klavyeden girilen harfe bağlı olarak
harfi içeren stringlerin sırasını bozmadan sıralamayı gerçekleştirir.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;


template<typename Iter>
void print(Iter beg, Iter end) {
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main() {
    vector<string> towns{"adana", "adiyaman", "afyonkarahisar", "agri", "aksaray", "amasya", "ankara",
                         "antalya", "ardahan", "artvin", "aydin", "balikesir", "bartin", "batman", "bayburt",
                         "bilecik", "bingol", "bitlis", "bolu", "burdur", "bursa", "canakkale", "cankiri", "corum",
                         "denizli", "diyarbakir", "duzce", "edirne", "elazig", "erzincan", "erzurum", "eskisehir",
                         "gaziantep", "giresun", "gumushane", "hakkari", "hatay", "igdir", "isparta", "istanbul", "izmir",
                         "kahramanmaras", "karabuk", "karaman", "kars", "kastamonu", "kayseri", "kilis",
                         "kirikkale", "kirklareli", "kirsehir","kocaeli", "konya", "kutahya", "malatya", "manisa",
                         "mardin", "mersin", "mugla", "mus","nevsehir", "nigde", "ordu","osmaniye", "rize",
                         "sakarya", "samsun", "sanliurfa", "siirt","sinop","sivas", "sirnak", "tekirdag","tokat",
                         "trabzon", "tunceli", "usak", "van", "yalova","yozgat", "zonguldak"};

    char ch;
    cout << "Bir harf giriniz?\n";
    cin >> ch;

    auto iter = stable_partition(towns.begin(),towns.end(),[ch](const string& s){return s.find(ch) != string::npos;});

    cout << "partisyon tamamlandi partisyon noktasi indeksi : " << distance(towns.begin(),iter) <<'\n';

    if(iter != towns.end())
        cout << *iter << '\n';
    print(begin(towns), end(towns));
}

/*--------------------------------------------------------
partition_copy algoritması aşadaki koddan da anlaşılabileceği
gibi klavyeden girilen harfi içeren ve içermeyen olmak üzere 2
adet vector containerı kullanmaktadır. Bu algoritma kullanılırken
tabi ki containerları back_inserter ile birlikte kullanmak
gerekmektedir.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;


template<typename Iter>
void print(Iter beg, Iter end) {
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main() {
    vector<string> towns{"adana", "adiyaman", "afyonkarahisar", "agri", "aksaray", "amasya", "ankara",
                         "antalya", "ardahan", "artvin", "aydin", "balikesir", "bartin", "batman", "bayburt",
                         "bilecik", "bingol", "bitlis", "bolu", "burdur", "bursa", "canakkale", "cankiri", "corum",
                         "denizli", "diyarbakir", "duzce", "edirne", "elazig", "erzincan", "erzurum", "eskisehir",
                         "gaziantep", "giresun", "gumushane", "hakkari", "hatay", "igdir", "isparta", "istanbul",
                         "izmir",
                         "kahramanmaras", "karabuk", "karaman", "kars", "kastamonu", "kayseri", "kilis",
                         "kirikkale", "kirklareli", "kirsehir", "kocaeli", "konya", "kutahya", "malatya", "manisa",
                         "mardin", "mersin", "mugla", "mus", "nevsehir", "nigde", "ordu", "osmaniye", "rize",
                         "sakarya", "samsun", "sanliurfa", "siirt", "sinop", "sivas", "sirnak", "tekirdag", "tokat",
                         "trabzon", "tunceli", "usak", "van", "yalova", "yozgat", "zonguldak"};
    vector<string> ok_vec;
    vector<string> not_ok_vec;
    print(begin(towns), end(towns));

    char ch;
    cout << "Bir harf giriniz?\n";
    cin >> ch;

    partition_copy(towns.begin(), towns.end(), back_inserter(ok_vec), back_inserter(not_ok_vec),
                   [ch](const string &s) { return s.find(ch) != string::npos; });

    print(begin(ok_vec), end(ok_vec));
    print(begin(not_ok_vec), end(not_ok_vec));
}

/*--------------------------------------------------------
is_sorted algoritması veri yapısının sortlanıp sortlanmadığını
göstermektedir.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;

int main()
{
    vector<int> ivec{2,6,8,10,20,123};

    cout << boolalpha << is_sorted(ivec.begin(),ivec.end()) <<'\n';
}

/*--------------------------------------------------------
is_sorted_until algoritması veri yapısının nereye kadar sıralı
olduğuna bağlı olarak bir iteratör geri döndürür. Ağağıdaki
örnekte bu iteratör auto anahtar sözcüğü ile elde edilip
distance fonksiyonuna verilmiştir.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;

int main()
{
    vector<int> ivec{123,60,60,50,70,40,20};

    auto iter = is_sorted_until(ivec.begin(),ivec.end(),greater<int>{});

    cout << distance(ivec.begin(),iter) << '\n';

    cout << *iter <<" elemanina kadar sirali" << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte bir partial specilization söz konusudur.
Bu örnekte val değeri mantıksal 0 değeri yani cpp için false veya 0
olarak ele alınabilir.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;

int main()
{
    vector<bool> bvec(25);

    auto val = bvec[10];

    cout << val << '\n';
}

/*--------------------------------------------------------
Anahtar Notlar:
Çok fazla baştan ekleme işlemi yapılıyorsa deque

Vector'de size capacity'ye eşit olduğunda insert işlemi yapıldığında
reallocation gerçekleşir. Bu reallocation sırasında iteratörler
ve referanslar geçersiz hale gelir ve başka bir bellek bloğu
kullanılır. Kısacası bellek bloğunun gene aynı bellek bloğunu
kullanmasının bir garantisi yoktur.

C dizilerine vector bellek bloğu adresini geçebiliriz
ancak bu durum deque için böyle değildir.

Reallocation maliyetinden kaçınmak için Vector'deki büyüme önceden
öngörülemiyorsa (önceden reserve ile yer ayırma şansımız yoksa std::deque
daha iyi bir seçenek olabilir.)

vector<bool> yerine deque<bool> kullanmak için.

vector<> tek ardışık bir bellek alanı kullanıyor.
Ancak deque chunk'lar kullanıyor.
-------------------------------------------------------*/
/*--------------------------------------------------------
Örnek Soru: Bir vector containerı içerisinde uzunluğu 5 olan
stringler silinirken uzunluğu 6 olanlardan bir tane daha eklenecek.

Aşağıdaki kod doğru görünse de aslında yanlıştır bunun nedeni ekleme
işleminden sonra sonra söz konusu iteratörün eklemenin yapıldığı yerde
değil eklenen elemanın konumunu göstermektedir.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;


template<typename Iter>
void print(Iter beg, Iter end) {
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main() {
    vector<string> towns{"adana", "adiyaman", "afyonkarahisar", "agri", "aksaray", "amasya", "ankara",
                         "antalya", "ardahan", "artvin", "aydin", "balikesir", "bartin", "batman", "bayburt",
                         "bilecik", "bingol", "bitlis", "bolu", "burdur", "bursa", "canakkale", "cankiri", "corum",
                         "denizli", "diyarbakir", "duzce", "edirne", "elazig", "erzincan", "erzurum", "eskisehir",
                         "gaziantep", "giresun", "gumushane", "hakkari", "hatay", "igdir", "isparta", "istanbul",
                         "izmir",
                         "kahramanmaras", "karabuk", "karaman", "kars", "kastamonu", "kayseri", "kilis",
                         "kirikkale", "kirklareli", "kirsehir", "kocaeli", "konya", "kutahya", "malatya", "manisa",
                         "mardin", "mersin", "mugla", "mus", "nevsehir", "nigde", "ordu", "osmaniye", "rize",
                         "sakarya", "samsun", "sanliurfa", "siirt", "sinop", "sivas", "sirnak", "tekirdag", "tokat",
                         "trabzon", "tunceli", "usak", "van", "yalova", "yozgat", "zonguldak"};
    print(begin(towns), end(towns));
    for(auto iter = towns.begin();iter != towns.end();++iter){
        if(iter->length() == 6){
            towns.insert(iter,*iter);
        }
        else if(iter->length() == 5){
            towns.erase(iter);
        }
    }
    print(begin(towns), end(towns));
}
/*--------------------------------------------------------
Yukarıdaki kodun doğru yazımı aşağıdaki gibi yapılabilir.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;


template<typename Iter>
void print(Iter beg, Iter end) {
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main() {
    vector<string> towns{"adana", "adiyaman", "afyonkarahisar", "agri", "aksaray", "amasya", "ankara",
                         "antalya", "ardahan", "artvin", "aydin", "balikesir", "bartin", "batman", "bayburt",
                         "bilecik", "bingol", "bitlis", "bolu", "burdur", "bursa", "canakkale", "cankiri", "corum",
                         "denizli", "diyarbakir", "duzce", "edirne", "elazig", "erzincan", "erzurum", "eskisehir",
                         "gaziantep", "giresun", "gumushane", "hakkari", "hatay", "igdir", "isparta", "istanbul",
                         "izmir",
                         "kahramanmaras", "karabuk", "karaman", "kars", "kastamonu", "kayseri", "kilis",
                         "kirikkale", "kirklareli", "kirsehir", "kocaeli", "konya", "kutahya", "malatya", "manisa",
                         "mardin", "mersin", "mugla", "mus", "nevsehir", "nigde", "ordu", "osmaniye", "rize",
                         "sakarya", "samsun", "sanliurfa", "siirt", "sinop", "sivas", "sirnak", "tekirdag", "tokat",
                         "trabzon", "tunceli", "usak", "van", "yalova", "yozgat", "zonguldak"};
    print(begin(towns), end(towns));
    for(auto iter = towns.begin();iter != towns.end();++iter){
        if(iter->length() == 6){
            iter = towns.insert(iter,*iter);
            ++iter;
        }
        else if(iter->length() == 5){
            towns.erase(iter);
        }
    }
    print(begin(towns), end(towns));
}
/*--------------------------------------------------------
Aşağıdaki örnekte bir tanımsız davranış söz konusudur. Tanımsız davranışın
nedeni deque container'ına ait ögelerin bellekte ardışık tutulmamasından
kaynaklanmaktadır.
-------------------------------------------------------*/
#include <iostream>
#include <map>
#include <string>
#include <algorithm>
#include <vector>
#include <list>
#include <deque>

using namespace std;

void print_array(const int* ptr,size_t size)
{
    while(sizde--)
        printf("%d ",*ptr++);
}

int main()
{
    deque<int> x{2,5,6,78,90,23,12,45,67,45,67};
    print_array(&*x.begin(),x.size()); //ub
}
/*--------------------------------------------------------
reverse Algoritması adından da anlaşılabileceği gibi containerı
tersten yazdırır.
-------------------------------------------------------*/
#include <iostream>
#include <map>
#include <string>
#include <algorithm>
#include <vector>
#include <list>
#include <deque>

using namespace std;

template<typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main() {

    list<string> towns{"adana", "adiyaman", "afyonkarahisar", "agri", "aksaray", "amasya", "ankara",
                         "antalya", "ardahan", "artvin"};

    print(towns.begin(),towns.end());
    towns.reverse();
    print(towns.begin(),towns.end());
    return 0;
}
/*--------------------------------------------------------
reallocation sonrası bir containerı ait bir nesneyi
gösteren pointer dangling pointer durumuna gelir ve bu
pointerın gösterdiği nesneye erişmek tanımsız davranıştır.
-------------------------------------------------------*/
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
#include <iostream>
#include <map>
#include <string>
#include <algorithm>
#include <vector>
#include <list>
#include <deque>

using namespace std;

template<typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main() {

    list<int> mylist{2,5,6,78,90,23,12,45,67,45,67};

    print(mylist.begin(),mylist.end());
    mylist.unique([](int a,int b){return a % 2 == b % 2;});
    print(mylist.begin(),mylist.end());
    return 0;
}
/*--------------------------------------------------------
merge algoritması kendisine parametre gönderilen listin tüm elemanlarını
diğer bir liste taşınır. Aşağıdaki örnekte de son durumda y listinin
size değeri 0 olacaktır.
-------------------------------------------------------*/
#include <iostream>
#include <map>
#include <string>
#include <algorithm>
#include <vector>
#include <list>
#include <deque>

using namespace std;

template<typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main() {

    list<int> x{2,5,6,78,90,23,12,45,67,45,67};
    list<int> y{6,7,8,67,98,25,13,56,79,57,17};

    print(x.begin(),x.end());
    print(y.begin(),y.end());
    x.merge(y);
    cout << "x.size : " << x.size() <<'\n';
    cout << "y.size : " << y.size() <<'\n';
    print(x.begin(),x.end());
    return 0;
}
/*--------------------------------------------------------
merge algoritmasının ikinci paramteresine bir lamda ifadesi
geçilmesi durumu
-------------------------------------------------------*/
#include <iostream>
#include <map>
#include <string>
#include <algorithm>
#include <vector>
#include <list>
#include <deque>

using namespace std;

template<typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}
auto f = [](const string& s1, const string& s2){
    return s1.length() < s2.length() || s1.length() == s2.length() && s1 < s2;
};

int main() {

    list<string> x{"adana", "adiyaman", "afyonkarahisar", "agri", "aksaray", "amasya", "ankara",
                   "antalya", "ardahan", "artvin"};
    list<string> y{ "aydin", "balikesir", "bartin", "batman", "bayburt",
                    "bilecik", "bingol", "bitlis", "bolu", "burdur"};

    print(x.begin(),x.end());
    print(y.begin(),y.end());
    x.merge(y,f);
    cout << "x.size : " << x.size() <<'\n';
    cout << "y.size : " << y.size() <<'\n';
    print(x.begin(),x.end());
    return 0;
}

/*--------------------------------------------------------
remove_if algoritması ve test kodu
-------------------------------------------------------*/
#include <iostream>
#include <map>
#include <string>
#include <algorithm>
#include <vector>
#include <list>
#include <deque>

using namespace std;

template<typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}
auto f = [](const string& s1, const string& s2){
    return s1.length() < s2.length() || s1.length() == s2.length() && s1 < s2;
};

int main() {

    list<string> x{"adana", "adiyaman", "afyonkarahisar", "agri", "aksaray", "amasya", "ankara",
                   "antalya", "ardahan", "artvin"};

    auto n = x.remove_if([](const string& s){return s.length() > 4;});

    print(x.begin(),x.end());
    cout << n <<" oge silindi"<<'\n';
    return 0;
}

/*--------------------------------------------------------
remove algoritması kullanılarak bu fonksiyona argüman olarak
geçilen ifade container'dan atılabilir.
-------------------------------------------------------*/
/*--------------------------------------------------------
splice algoritması ve test kodu
splice algoritması kendisine gönderilen container içerisinde
3.parametreye geçilen elemanın konumdaki elemanı diğer liste
aktarma işlemini gerçekleştirir.
-------------------------------------------------------*/
#include <iostream>
#include <map>
#include <string>
#include <algorithm>
#include <vector>
#include <list>
#include <deque>

using namespace std;

template<typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main() {

    list<string> males{"mehmet","ismail","murat","recep","gurkan","ali","yasar"};
    list<string> females{"ayse","eda","nur","leyla","sinem","gizem"};

    males.splice(males.begin(),females, next(females.begin()));

    print(males.begin(),males.end());
    print(females.begin(),females.end());
    return 0;
}

/*--------------------------------------------------------
Eğer splice algoritmasının 3.parametresine hiçbir argüman geçilmezse
bu durumda söz konusu listin tamamı diğer liste eklenir.
-------------------------------------------------------*/
#include <iostream>
#include <map>
#include <string>
#include <algorithm>
#include <vector>
#include <list>
#include <deque>

using namespace std;

template<typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main() {

    list<string> males{"mehmet","ismail","murat","recep","gurkan","ali","yasar"};
    list<string> females{"ayse","eda","nur","leyla","sinem","gizem"};

    males.splice(males.begin(),females);

    print(males.begin(),males.end());
    print(females.begin(),females.end());
    return 0;
}

/*--------------------------------------------------------
forward listin advance fonksiyonu ve test kodu
Bu fonksiyon gösterilen indekste bulunan elemandan ikinci
parametre kadar sonrasındaki elemana ulaşır.
-------------------------------------------------------*/
#include <iostream>
#include <map>
#include <string>
#include <algorithm>
#include <vector>
#include <forward_list>
#include <deque>

using namespace std;

template<typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}
auto f = [](const string& s1, const string& s2){
    return s1.length() < s2.length() || s1.length() == s2.length() && s1 < s2;
};

int main() {

    forward_list<string> males{"mehmet","ismail","murat","recep","gurkan","ali","yasar"};


    print(males.begin(), males.end());
    auto iter = males.begin();
    advance(iter,2);
    cout << *iter << '\n';
    return 0;
}

/*--------------------------------------------------------
insert_after ise söz konusu iteratör konumundan sonraki bölüme
n adet 3.parametreye argüman olarak geçilen ögeden ekler.
-------------------------------------------------------*/
#include <iostream>
#include <map>
#include <string>
#include <algorithm>
#include <vector>
#include <forward_list>
#include <deque>

using namespace std;

template<typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}


int main() {

    forward_list<string> males{"mehmet","ismail","murat","recep","gurkan","ali","yasar"};


    print(males.begin(), males.end());
    males.insert_after(males.begin(),5,"kaya");

    print(males.begin(), males.end());
    return 0;
}


/*--------------------------------------------------------
erase_after fonksiyonu ve before_begin fonsiyonu birlikte
kullanılarak containerın ilk n elemanı silinebilir.
-------------------------------------------------------*/
#include <iostream>
#include <map>
#include <string>
#include <algorithm>
#include <vector>
#include <forward_list>
#include <deque>

using namespace std;

template<typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}


int main() {

    forward_list<string> males{"mehmet","ismail","murat","recep","gurkan","ali","yasar"};

    print(males.begin(), males.end());
    males.erase_after(males.before_begin(),next(males.begin(),3));

    print(males.begin(), males.end());
    return 0;
}

/*--------------------------------------------------------
set containerını default parametreleri aşağıdaki gibidir.
kısacası set elemanlar nasıl verilirse verilsin otomatik sıralama
yapar.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <algorithm>
#include <vector>
#include <set>
#include <forward_list>

using namespace std;

int main() {

    set<int,less<int>,allocator<int>> myset;
    return 0;
}

/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <algorithm>
#include <vector>
#include <set>
#include <forward_list>

using namespace std;

template<typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}


int main()
{
    set<string> males{"mehmet","ismail","murat","recep","gurkan","ali","yasar"};
    print(males.begin(), males.end());
    return 0;
}

/*--------------------------------------------------------
eğer set in greater açılımı kullanılırsa bu durumda
büyükten küçüğe sıralama(descending order sorting) gerçekleştirilir.
insert fonksiyonu diğer containerlarda olduğu gibi burda da eleman
ekler ancak farklı olarak sette eklenen elemanlara bağlı olarak
sorting tekrardan gerçekleştirilir.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <algorithm>
#include <vector>
#include <set>
#include <forward_list>

using namespace std;

template<typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}


int main() {

    set<string,greater<>> myset{"mehmet","ismail","murat","recep","gurkan","ali","yasar"};
    myset.insert("meral");
    print(myset.begin(), myset.end());
    myset.insert("ayse");
    print(myset.begin(), myset.end());
    myset.insert("bilge");
    print(myset.begin(), myset.end());
    myset.insert("kaya");
    print(myset.begin(), myset.end());
    return 0;
}

/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <algorithm>
#include <vector>
#include <set>
#include <forward_list>

using namespace std;

template<typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}


int main() {

    auto fpred = [](const string& s1, const string& s2){
        return s1.length() < s2.length() || s1.length() == s2.length() && s1 < s2;
    };

    set<string> males{"mehmet","ismail","murat","recep","gurkan","ali","yasar"};
    set<string> myset;
    for(auto name : males){
        cout << name << " eklenecek" << '\n';
        myset.insert(name);
        print(myset.begin(),myset.end());
        (void)getchar();
    }
    return 0;
}

/*--------------------------------------------------------
set içerisinde find fonksiyonu kullanılarak arama yapmak
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <algorithm>
#include <vector>
#include <set>

using namespace std;

template<typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}


int main() {

    set<string> towns{"adana", "adiyaman", "afyonkarahisar", "agri", "aksaray", "amasya", "ankara",
                         "antalya", "ardahan", "artvin", "aydin", "balikesir", "bartin", "batman", "bayburt",
                         "bilecik", "bingol", "bitlis", "bolu", "burdur", "bursa", "canakkale", "cankiri", "corum",
                         "denizli", "diyarbakir", "duzce", "edirne", "elazig", "erzincan", "erzurum", "eskisehir",
                         "gaziantep", "giresun", "gumushane", "hakkari", "hatay", "igdir", "isparta", "istanbul",
                         "izmir",
                         "kahramanmaras", "karabuk", "karaman", "kars", "kastamonu", "kayseri", "kilis",
                         "kirikkale", "kirklareli", "kirsehir", "kocaeli", "konya", "kutahya", "malatya", "manisa",
                         "mardin", "mersin", "mugla", "mus", "nevsehir", "nigde", "ordu", "osmaniye", "rize",
                         "sakarya", "samsun", "sanliurfa", "siirt", "sinop", "sivas", "sirnak", "tekirdag", "tokat",
                         "trabzon", "tunceli", "usak", "van", "yalova", "yozgat", "zonguldak"};

    print(towns.begin(),towns.end());
    string str;
    cout << "aranacak ili giriniz" << '\n';
    cin >> str;
    if(auto iter = towns.find(str);iter != towns.end()){
        cout << "bulundu " << *iter << '\n';
    }
    else
        cout << "bulunamadi" << '\n';
    return 0;
}

/*--------------------------------------------------------
count fonksiyonu kullanılarak söz konusu elemandan container
 içerisinde kaç adet bulunduğu hesaplanabilir.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <algorithm>
#include <vector>
#include <set>

using namespace std;

template<typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}


int main() {

    set<string> towns{"adana", "adiyaman", "afyonkarahisar", "agri", "aksaray", "amasya", "ankara",
                         "antalya", "ardahan", "artvin", "aydin", "balikesir", "bartin", "batman", "bayburt",
                         "bilecik", "bingol", "bitlis", "bolu", "burdur", "bursa", "canakkale", "cankiri", "corum",
                         "denizli", "diyarbakir", "duzce", "edirne", "elazig", "erzincan", "erzurum", "eskisehir",
                         "gaziantep", "giresun", "gumushane", "hakkari", "hatay", "igdir", "isparta", "istanbul",
                         "izmir",
                         "kahramanmaras", "karabuk", "karaman", "kars", "kastamonu", "kayseri", "kilis",
                         "kirikkale", "kirklareli", "kirsehir", "kocaeli", "konya", "kutahya", "malatya", "manisa",
                         "mardin", "mersin", "mugla", "mus", "nevsehir", "nigde", "ordu", "osmaniye", "rize",
                         "sakarya", "samsun", "sanliurfa", "siirt", "sinop", "sivas", "sirnak", "tekirdag", "tokat",
                         "trabzon", "tunceli", "usak", "van", "yalova", "yozgat", "zonguldak"};

    print(towns.begin(),towns.end());
    string str;
    cout << "aranacak ili giriniz" << '\n';
    cin >> str;

    cout << towns.count(str) << " adet " << str << " var" << '\n';
    return 0;
}

/*--------------------------------------------------------
Set container'ı açılım kısmının ikinci bölümüne kendi yazdığımız
herhangi bir fonksiyonla birlikte kullanabiliriz.
-------------------------------------------------------*/
#include <set>

struct Acmp{
    bool operator()(consty A&, const A&)const;
};

int main()
{
    using namespace std;

    set<A,Acmp> myset;
}
/*--------------------------------------------------------
setin ikinci kısmında decltype ile birlikte lamda ifadeleriyle
kullanımı legaldir. Bu durum C++20 ile legal hale getirilmiştir.
-------------------------------------------------------*/
#include <set>

class A{

};

int main()
{
    auto f = [](const A& x,const A& y) {return true;};

    using namespace std;

    set<A,decltype(f)> myset;
}
/*--------------------------------------------------------
1-)It has to be antisymetric
a < b true ise b < a false olmalı
a op b true ise b op a false olmalı

2-)It has to be transitive
a < b && b < c ===> a < c

3-)It has to be irreflexive.
a < a always false

4-) It has to have transitivity of equivalence
!(a < b) && !(b < a) doğru ise
!(b < c) && !(c < b) doğru ise
!(a < c) && !(c < a) doğru olması gerekir.
set containerında aşağıdaki gibi bir tanımlama geçersizdir.
-------------------------------------------------------*/
#include <set>

int main()
{
    using namespace std;
    set<int> myset(20);
}
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
Aşağıdaki kod run yapıldığında sıralama default olarak less
açılımına göre yapıldığı için küçükten büyüğe doğru sıralama
(ascending order sorting) gerçekleştirilir.
--------------------------------------------------------*/
#include <iostream>
#include <set>

int main()
{
    using namespace std;
    set<int> myset{1,4,2,5,2,6,8,2,3,7,7};

    cout << "size = " << myset.size() << '\n';
    for(auto i : myset){
        cout << i << " " ;
    }
}
/*--------------------------------------------------------
Aşağıdaki örnekte ise setin greater açılımı kullanıldığı için
bu durumda sıralama büyükten küçüğe(descending order sorting)
doğru yapılır.
--------------------------------------------------------*/
#include <iostream>
#include <set>

int main()
{
    using namespace std;
    set<int,greater<>> myset{1,4,2,5,2,6,8,2,3,7,7};

    cout << "size = " << myset.size() << '\n';
    for(auto i : myset){
        cout << i << " " ;
    }
}
/*--------------------------------------------------------
contains fonksiyonu ve test kodu.
contains fonksiyonu adından da anlaşılabileceği gibi bir container
içerisinde bir elemanın varlığını sorgular. Geri dönüş değeri türü
bool türüdür.
--------------------------------------------------------*/
#include <iostream>
#include <set>

int main()
{
    using namespace std;
    set<int,greater<>> myset{1,4,2,5,2,6,8,2,3,7,7};

    cout << "Aranacak sayiyi giriniz?\n";
    int val;
    cin >> val;

    if(myset.contains(val)){
        cout << "evet var" << '\n';
    }
    else
        cout << "hayir yok" << '\n';
}
/*--------------------------------------------------------
setin count fonksiyonu ve test kodu
Not:sette her elemandan biğr tane olabileceği için örneğin
2 arandığında 1 tane bulunur. multi_set containerı için bir
anahtardan birden fazla bulunabilir.
--------------------------------------------------------*/
#include <iostream>
#include <set>

int main()
{
    using namespace std;
    set<int,greater<>> myset{1,4,2,5,2,6,8,2,3,7,7};

    cout << "Aranacak sayiyi giriniz?\n";
    int val;
    cin >> val;

    if(myset.count(val)!= 0){
        cout << "evet "<< myset.count(val) << " tane var" << '\n';
    }
    else
        cout << "hayir yok" << '\n';
}
/*--------------------------------------------------------
set container'ının find fonksiyonu ve test kodu
-------------------------------------------------------*/
#include <iostream>
#include <set>
#include <string>

int main()
{
    using namespace std;
    set<string> names{"mert","mustafa","irem","abdulmuhtalip","abdullah","metin","berke"
            ,"berkay","bilge","kaya","mert"};

    cout << "Aranacak ismi giriniz?\n";
    string name;
    cin >> name;

    if(auto iter = names.find(name);iter != names.end()){
        cout << "Bulundu : " << *iter <<' '<< iter->size() << '\n';
    }
    else
        cout << "Bulunamadi" << '\n';
}
/*--------------------------------------------------------
set containerındaki elemanları doğrudan yani
standard conversion kullanılarak değiştirme girişimi
syntax hatasına neden olur.
-------------------------------------------------------*/
#include <iostream>
#include <set>
#include <string>

int main()
{
    using namespace std;
    set<string> names{"mert","mustafa","irem","abdulmuhtalip","abdullah","metin","berke"
            ,"berkay","bilge","kaya","mert"};

    cout << "Aranacak ismi giriniz?\n";
    string name;
    cin >> name;

    if(auto iter = names.find(name);iter != names.end()){
       *iter = "Sabri"; //error

    }
    else
        cout << "Bulunamadi" << '\n';
}
/*--------------------------------------------------------
Ancak bu atama eğer const cast operatörü kullanılarak yapılırsa
bu durumda geçerli hale gelir.
-------------------------------------------------------*/
#include <iostream>
#include <set>
#include <string>

int main()
{
    using namespace std;
    set<string> names{"mert","mustafa","irem","abdulmuhtalip","abdullah","metin","berke"
            ,"berkay","bilge","necati","mert"};

    cout << "Aranacak ismi giriniz?\n";
    string name;
    cin >> name;

    if(auto iter = names.find(name);iter != names.end()){
       const_cast<string&>(*iter) = "sabri";
    }
    else
        cout << "Bulunamadi" << '\n';
    for(auto i:names){
        cout << i << ' ';
    }

}
/*--------------------------------------------------------
eğer setteki anahtarı değiştirmek istiyorsanız
eski anahtarı silecek yeni anahtarı insert edeceksiniz.
tabi bu durumda sette tutulmakta olan öge destroy edilecek.
(C++ 17 ye göre böyleydi)

C++17 ve sonrasında bu tür işlemler şöyle yapılabilir oldu

extract işlevini çağrıcaksınız.
bu metot size node_handle döndürecek
bu node_handle ile node'a erişim node'da tutulan veriyi değiştirebilirsiniz
sonra da bu node'u yine node_handle'ı kullanarak sete taşıyacaksınız.

sequence kaplarda insert işlevinden aldığınız geri dönüş değeri
eklenmiş ögenin konumudur. normal olarak (?) assoc. kaplarda
ekleme işlemleri anahtar ile yapılır.

Aşağıdaki örnekte insert fonksiyonu kullanılarak bir ekleme
yapılmıştır.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <set>

using namespace std;

template<typename Iter>
void print(Iter beg, Iter end) {
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main() {
    set<string> names {"majid","bilge","necati","irma","fatih"};
    print(names.begin(),names.end());

    names.insert("elmas");
    cout << names.size() << '\n';
    print(names.begin(),names.end());

}
/*--------------------------------------------------------
set bulunan her eleman aslında bir pairdir. Bu pairlere ait
ikinci eleman bool türündendir ve o eleman bulunup bulunmadığını
sorgulamak için kullanılır eğer var olan bir eleman insert edilmek
istenirse bu durumda bool elemanları false değer döndürür
aşağıdaki örnekte de bu özellik kullanılmıştır.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <set>

using namespace std;

template<typename Iter>
void print(Iter beg, Iter end) {
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main() {
    set<string> names {"majid","bilge","necati","irma","fatih"};
    print(names.begin(),names.end());

    //pair<set<string>::iterator,bool> p = names.insert("berke");
    auto p = names.insert("berke");

    if(p.second){
        cout << "ekleme islemi yapildi" << '\n';
        cout << *p.first << '\n';
    }
    else{
        cout << "ekleme yapilmadi zaten var"<< '\n';
        cout << "distance = " << distance(names.begin(),p.first) << "\n";
    }
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <set>

using namespace std;

template<typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    set<string> names{"bilge","fatih","irma","majid","kaya"};

    if(names.insert("ali").second){
        cout << "eleman yok" << '\n';
    }
    else
        cout << "eleman var" << '\n';
}
/*--------------------------------------------------------
insert fonksiyonu kullanılarak eklenen eleman bir pair olacağından
bunun second değerini aşağıdaki örnek için elde ettiğimiz zaman
bir true değer olacağından bu değeri if deyimi içerinsde kullanmak mümkündür.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <set>

using namespace std;

template<typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    set<string> names{"bilge","fatih","irma","majid","kaya"};

    if(names.insert("ali").second){
        cout << "eleman yok" << '\n';
    }
    else
        cout << "eleman var" << '\n';
    print(names.begin(),names.end());
}
/*--------------------------------------------------------
auto type deduction kullanılarak pair ifadesine ilk değer verilebilir.
Örneğin aşağıdaki örnek için tür çıkarımı pair'in string,double
açılımı şeklinde yapılır.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <set>

using namespace std;

pair<string,double> func()
{
    return pair<string,double> {"muzaffer",4.5};
}

int main()
{
    auto [name,wage] = func();
}
/*--------------------------------------------------------
Aşağıdaki örnekte görüldüğü gibi for each döngü deyimi aşağıdaki gibi
kullanıldığı durumda vector dinamik dizisine ait pair nesneleri
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <set>
#include <vector>

using namespace std;

int main()
{
    vector<pair<string,int>> myvec{{"mehmet",34},{"mustafa",56},{"berke",24}};

    for(const auto&[name,age]:myvec){
        cout << "name : " << name << " age : " << age << '\n';
        }
}
/*--------------------------------------------------------
Aşağıdaki örnekteki kod geçerlidir ve a dizisine ait tüm elemanlar
auto ile bu şekilde kullanılabilir.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <set>
#include <vector>

using namespace std;

int main()
{
    int a[]{1,2,3};
    auto [x,y,z] = a;
    x++;
    y++;
    z++;
    cout << "x : " << x << " y : " << y << " z : " << z;
}
/*--------------------------------------------------------
Bir structın auto ile type deduction'ı aşağıdaki örnekte
olduğu gibi yapılabilir.
-------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

struct Nec{
        int x;
        double d;
        string str;
    };
Nec foo();

int main()
{
    auto [ival,dval,name] = foo();
}

/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <set>
#include <vector>

using namespace std;

int main()
{
    set<string> myset{"ali","can","ece","nur","tan","eda"};

    auto [iter,inserted] = myset.insert("nur");
}
/*--------------------------------------------------------
multisette bir anahtardan birden fazla bulunabilir. Bu
sebeple aşağıdaki gibi bir kontrole gerek yoktur.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <set>
#include <vector>

using namespace std;

int main()
{
    multiset<string> myset{"ali","can","ece","nur","tan","eda"};

    auto iter = myset.insert("nur");

    if(iter != myset.end()){
        cout << "ekleme yapildi" << '\n';
        cout << *iter << '\n';
    }
    else
        cout << " ekleme yapilmadi" << '\n';
}
/*--------------------------------------------------------
Yukarıdaki örneğin doğru yazımı aşağıdaki gibi yapılabilir.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <set>
#include <vector>

using namespace std;

int main()
{
    multiset<string> myset{"ali","can","ece","nur","tan","eda"};

    auto iter = myset.insert("nur");
    cout << "ekleme yapildi" << '\n';
    cout << *iter << '\n';
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <set>
#include <vector>

using namespace std;

int main()
{
    set<string> myset;

    myset.insert(myset.begin(),12);

}
/*--------------------------------------------------------
set containerının erase fonksiyonu ve test kodu
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <set>
#include <vector>

using namespace std;

template<typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    set<int> myset{1,4,7,19,24,67,69,80};

    print(myset.begin(),myset.end());
    myset.erase(myset.begin());
    print(myset.begin(),myset.end());
}
/*--------------------------------------------------------
prev fonksiyonu kullanılarak erase fonksiyonu ile sondan
bir önceki eleman silinebilir.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <set>
#include <vector>

using namespace std;

template<typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    set<int> myset{1,4,7,19,24,67,69,80};

    print(myset.begin(),myset.end());
    myset.erase(myset.begin());
    print(myset.begin(),myset.end());
    myset.erase(prev(myset.end()));
    print(myset.begin(),myset.end());
}
/*--------------------------------------------------------
erase fonksiyonu bir range şeklinde de aşağıdaki örnekte görüldüğü
gibi verilebilir.
-------------------------------------------------------*/
#include <iostream>
#include <set>
#include <vector>

using namespace std;

template<typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    set<int> myset{1,4,7,19,24,67,69,80};

    print(myset.begin(),myset.end());
    myset.erase(myset.begin());
    print(myset.begin(),myset.end());
    myset.erase(prev(myset.end()));
    print(myset.begin(),myset.end());
    myset.erase(next(myset.begin()), prev(myset.end()));
    print(myset.begin(),myset.end());
}
/*--------------------------------------------------------
Klavyeden girilen bir anahtar aşağıdaki örnekte olduğu gibi
containerdan atılabilir.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <set>
#include <vector>

using namespace std;

template<typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    set<int> myset{1,4,7,19,24,67,69,80};

    print(myset.begin(),myset.end());
    int ival;
    cout << "silinecek anahtar degerini giriniz\n";
    cin >> ival;
    myset.erase(ival);
    print(myset.begin(),myset.end());
}
/*--------------------------------------------------------
Handle değeri klavyeden girilen stringin set içerisinde olup
olmamasına göre değişmektedir.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <set>

using namespace std;


template<typename Iter>
void print(Iter beg, Iter end) {
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main() {
    set<string> names {"majid","bilge","necati","irma","fatih"};
    print(names.begin(),names.end());

    cout << "isim giriniz?" << '\n';
    string name;
    cin >> name;

    auto handle = names.extract(name);

    cout << "size = " << names.size() << '\n';
    (void)getchar();
}
/*--------------------------------------------------------
Aşağıdaki örnekte eğer klavyeden girilen string set içerisinde
varsa bu durumda ifin true bölümü çalıştırılıp söz konusu eleman
için taşıma gerçekleştirilir.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <set>

using namespace std;


template<typename Iter>
void print(Iter beg, Iter end) {
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main() {
    set<string> names {"majid","bilge","necati","irma","fatih"};
    print(names.begin(),names.end());

    cout << "isim giriniz?" << '\n';
    string name;
    cin >> name;

    auto handle = names.extract(name);

    if(handle){
        handle.value() = "nurullah";
        names.insert(move(handle));
    }
    else{
        cout << "bulunamadi\n";
    }

    print(names.begin(),names.end());
}
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <set>

using namespace std;


template<typename Iter>
void print(Iter beg, Iter end) {
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main() {
    set<string> names {"majid","bilge","necati","irma","fatih"};
    print(names.begin(),names.end());

    cout << "isim giriniz?" << '\n';
    string name;
    cin >> name;

    auto handle = names.extract(name);

    handle.value() = "kaya";
    names.insert(move(handle));
    print(names.begin(),names.end());
}
/*--------------------------------------------------------
Aşağıdaki örnekte merge fonksiyonuna argüman olarak geçilen
set .(nokta) operatöründen önceki sete eklenir.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <set>

using namespace std;


template<typename Iter>
void print(Iter beg, Iter end) {
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main() {
    set<string> males {"majid","mustafa","necati","mehmet","fatih"};
    set<string> females{"bilge","irmak","asli","zeynep"};
    print(males.begin(),males.end());

    males.merge(females);

    cout << "females.size() : " << females.size() << '\n';
    cout << "males.size() : " << males.size() << '\n';

    print(males.begin(),males.end());
}
/*--------------------------------------------------------
Lower Bound
Upper Bound
Equal Range

2 3 3 3 4 7 9 9

lower bound bir anahtarın sırayı bozmadan eklenebileceği
son konum anahtardan >= olan ilk ögenin konumu

upper bound bir anahtarın sırayı bozmadan eklenebileceği
son konum anahtardan > olan ilk ögenin konumu

Aşağıdaki örnek için lower bound konumu 1 den sonrasıdır,
upper bound için ise en sağdaki 2'den sonraki konumdur.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <set>

using namespace std;


template<typename Iter>
void print(Iter beg, Iter end) {
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main() {
    multiset<int> myset{1,2,2,2,3,5,5};

    auto iter_lower = myset.lower_bound(2);
    auto iter_upper = myset.upper_bound(2);
    cout << "distance for lower bound : " << distance(myset.begin(),iter_lower) << '\n';
    cout << "distance for upper bound : " << distance(myset.begin(),iter_upper) << '\n';
    cout << "anahtar sayisi : " << distance(iter_lower,iter_upper) << '\n';
}
/*--------------------------------------------------------
equal range operatörü bir pair nesnesi tutmaktadır.
Bu nesnelerden birincisi lower bound değerini
tutarken  ikincisi upper bound değerini tutmaktadır.
Aşağıdaki örnekte görüldüğü gibi distance ile üretilen
değerler upper ve lower bound değerleri için aynıdır.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <set>

using namespace std;


template<typename Iter>
void print(Iter beg, Iter end) {
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main() {
    multiset<int> myset{1,2,2,2,3,5,5,5,5,6,6,6,8,9};

    pair<multiset<int>::iterator,multiset<int>::iterator> ip = myset.equal_range(5);

    auto iter_lower = myset.lower_bound(5);
    auto iter_upper = myset.upper_bound(5);
    cout << "distance for lower bound : " << distance(myset.begin(),iter_lower) << '\n';
    cout << "distance for upper bound : " << distance(myset.begin(),iter_upper) << '\n';
    cout << "distance for lower bound : " << distance(myset.begin(),ip.first) << '\n';
    cout << "distance for upper bound : " << distance(myset.begin(),ip.second) << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte görüldüğü gibi structural binding kullanılarak
upper ve lower bound değerlerine ilk değer verme işlemi yapılabilir.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <set>

using namespace std;


template<typename Iter>
void print(Iter beg, Iter end) {
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main() {
    multiset<int> myset{1,2,2,2,3,5,5,5,5,6,6,6,8,9};

    auto [iter_lower,iter_upper] = myset.equal_range(5);
    cout << "distance for lower bound : " << distance(myset.begin(),iter_lower) << '\n';
    cout << "distance for upper bound : " << distance(myset.begin(),iter_upper) << '\n';
    cout << "anahtar sayisi : " << distance(iter_lower,iter_upper) << '\n';
}
/*--------------------------------------------------------
vector containerları için lower bound değerleri aşağıdaki
örnekte olduğu gibi hesaplanabilir. Bu durumda set containerında
olduğu gibi elemanlar sıralı şekilde gelmediği için
önce sorting işlemi yapılıp sonra lower_bound fonksiyonunu
ilk iki parametre olarak vector'ün başlangıç ve bitiş konumları
geçilebilir.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <set>

using namespace std;


template<typename Iter>
void print(Iter beg, Iter end) {
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main() {
   vector<int> ivec {1,5,8,9,3,4,8,1,2,3,3,4,1};

   sort(ivec.begin(),ivec.end());
   print(ivec.begin(),ivec.end());

   auto iter_lower = lower_bound(ivec.begin(),ivec.end(),3);

   cout << "distance : " << iter_lower-ivec.begin() << '\n';
}
/*--------------------------------------------------------
greater parametresi ile çağrılması durumunda büyükten küçüğe
sıralamaya göre lower bound değeri belirlenir.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <set>

using namespace std;


template<typename Iter>
void print(Iter beg, Iter end) {
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main() {
   vector<int> ivec {1,5,8,9,3,4,8,1,2,3,3,4,1};

   sort(ivec.begin(),ivec.end(),greater{});
   print(ivec.begin(),ivec.end());

   auto iter_lower = lower_bound(ivec.begin(),ivec.end(),3,greater{});

   cout << "distance : " << iter_lower-ivec.begin() << '\n';
}

/*--------------------------------------------------------
Bir vector'ü ekleme yapıldıkça sürekli olarak sıralı(sorted)
tutmak aşağıdaki kod ile mümkün kılınabilir.
------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;


template<typename Iter>
void print(Iter beg, Iter end) {
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main() {

    vector<string> names {"majid","bilge","necati","irma","fatih"};
   auto f = [](const string& s1, const string& s2){
       return s1.size() < s2.size() ||
       s1.size() == s2.size() && s1 < s2;
   };

   for(int i = 0;i < 10;++i){
       string name;
       cout << "Bir isim giriniz : " << '\n';
       cin >> name;
       cout << name << " eklenecek" << '\n';
       auto  iter = lower_bound(names.begin(),names.end(),name,f);
       names.insert(iter,name);
       print(names.begin(),names.end());
       (void)getchar();
   }
}
/*--------------------------------------------------------
Aşağıdaki fonksiyonlar kullanılarak mape eleman eklemesi yapılabilir.
-------------------------------------------------------*/
#include <iostream>
#include <map>

using namespace std;


int main()
{
   map<int,double> mymap{{12,45.6},{78,9.78},{37,102.34}};


   pair<int,double> px{234,45.79};
   mymap.insert(px);
   mymap.insert(pair<int,double>{5,2.3});
   mymap.insert({4,2.23});
   mymap.insert(make_pair(5,1.1));
   mymap.emplace(56,1.1);

   for(auto p : mymap){
       cout << p.first << " " << p.second << '\n';
   }
}

/*--------------------------------------------------------
insert fonksiyonları için bazı örnekler
--------------------------------------------------------*/
#include <iostream>
#include <map>
#include <string>

using namespace std;

template<typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
   map<string,double> mymap{
       {"mustafa",45.6},
       {"mehmet",9.78},
       {"berke",102.34}
   };

   mymap.insert({"kaya",78.9});
   mymap["naciye"] = 45; //naciye yoksa ekle varsa anahtarı değiştir
   (void)getchar();
   for(const auto&[name,num]:mymap){
       cout << name << "   " << num << '\n';
   }
}
/*--------------------------------------------------------
Mape vectorde bulunan tüm isimleri ekliyip bu isimlere
karşılık gelen anahtar değerlerini 1 arttıran kod aşağıdaki
gibi yazılabilir.
-------------------------------------------------------*/
#include <iostream>
#include <map>
#include <string>
#include <vector>

using namespace std;

template<typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    vector<string> names {"majid","bilge","necati","irma","fatih"};
    map<string,int> cmap;
    for(const auto& s:names){
        ++cmap[s];
    }
}
/*--------------------------------------------------------
Aşağıdaki örnekte tüm isimlere karışılık gelen anahtar değerleri
1 olarak elde edilecektir.
--------------------------------------------------------*/
#include <iostream>
#include <map>
#include <string>
#include <vector>

using namespace std;

template<typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    vector<string> names {"majid","bilge","necati","irma","fatih"};
    map<string,int> cmap;
    for(const auto& s:names){
        ++cmap[s];
    }
    for(const auto& [name,count] : cmap){
        cout << name << ' ' << count << '\n';
    }
}
/*--------------------------------------------------------
Aşağıdaki örnekte görüldüğü gibi bir kod ile dosyaya yazdırılma işlemi
 gerçekleştirilebilir.
--------------------------------------------------------*/
#include <iostream>
#include <map>
#include <string>
#include <vector>
#include <fstream>


using namespace std;

template<typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    vector<string> names {"majid","bilge","necati","irma","fatih"};
    map<string,int> cmap;
    for(const auto& s:names){
        ++cmap[s];
    }
    ofstream ofs{"out.txt"};
    if(!ofs){
        cerr << "out.txt dosyasi olusturulamadi" << '\n';
        exit(EXIT_FAILURE);
    }
    vector<pair<string,int>> cvec{cmap.begin(),cmap.end()};

    auto fcmp = [](const pair<string,int>& p1,const pair<string,int>& p2){
        return p2.second < p1.second;
    };

    sort(cvec.begin(),cvec.end(),fcmp);

    for(const auto& [name,count] : cmap){
        ofs << name << ' ' << count << '\n';
    }
}
/*--------------------------------------------------------
Mapin elemanları aşağıdaki gibi elde edilebilir.
--------------------------------------------------------*/
#include <iostream>
#include <map>
#include <string>
#include <vector>
#include <fstream>


using namespace std;

int main()
{
    map<string,int> mymap{{"berke",78}};

    auto x = mymap[1];
}
/*--------------------------------------------------------
Aşağıdaki örnekte istenen id değerine bağlı olarak söz konusu
 anhatarın değiştirilmesi anlatılmak istenmiştir.
--------------------------------------------------------*/
#include <iostream>
#include <map>
#include <string>
#include <vector>
#include <fstream>


using namespace std;

template<typename Iter>
void print(Iter beg, Iter end) {
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main() {

    map<int, string> idmap{{547,   "handesu"},
                           {6350,  "cengiz"},
                           {30456, "esra"},
                           {78272, "mehmet"},
                           {32893, "berke"}};
    for (const auto &[number, person_name]: idmap) {
        cout << number << ' ' << person_name << '\n';
    }

    int ival;
    cout << "bir id degeri giriniz?\n";
    cin >> ival;

    if (auto iter = idmap.find(ival);iter != idmap.end()) {
        cout << "isim : " << iter->second <<'\n';
        iter->second ="nurullah";
    }
    else {
        cout << "bulunamadi" << '\n';
    }
    for(const auto& [number,person_name]:idmap){
        cout << number << " " << person_name << '\n';
    }
}

/*--------------------------------------------------------
insert or assign fonksiyonu kullanılarak eleman hep
eklenebilir hem de var olan elemanının anahtar değeri değiştirilebilir.
Bu açıdan bu fonksiyon oldukça kullanışlıdır. Örneğin
aşağıdaki örnekte 547 anahtarının değeri handesu iken
ali olarak değiştirilmiştir.
-------------------------------------------------------*/
#include <iostream>
#include <map>
#include <string>
#include <vector>


using namespace std;

int main() {

    map<int, string> idmap{{547,   "handesu"},
                           {6350,  "cengiz"},
                           {30456, "esra"},
                           {78272, "mehmet"},
                           {32893, "berke"}};
    for (const auto &[number, person_name]: idmap) {
        cout << number << ' ' << person_name << '\n';
    }
    cout << "************" << '\n';
    auto[iter,inserted] = idmap.insert_or_assign(547,"ali");
    for(const auto& [number,person_name]:idmap){
        cout << number << " " << person_name << '\n';
    }
}

/*--------------------------------------------------------
bir mapte bulunan stringleri bir vector containerına
kopyalama syntaxı
-------------------------------------------------------*/
#include <iostream>
#include <map>
#include <string>
#include <vector>

using namespace std;

template<typename Iter>
void print(Iter beg, Iter end) {
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main() {

    map<int, string> idmap{{547,   "handesu"},
                           {6350,  "cengiz"},
                           {30456, "esra"},
                           {78272, "mehmet"},
                           {32893, "berke"}};
    vector<string> svec;
    svec.reserve(idmap.size());

    for(const auto& [no,name]: idmap){
        svec.push_back(name);
    }
    print(svec.begin(),svec.end());
}

/*--------------------------------------------------------
transform algoritması
-------------------------------------------------------*/
#include <iostream>
#include <map>
#include <string>
#include <vector>
#include <algorithm>


using namespace std;

template<typename Iter>
void print(Iter beg, Iter end) {
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main() {

    map<int, string> idmap{{547,   "handesu"},
                           {6350,  "cengiz"},
                           {30456, "esra"},
                           {78272, "mehmet"},
                           {32893, "berke"}};
    vector<string> svec(5);
    svec.reserve(idmap.size());

    transform(idmap.begin(),idmap.end(),svec.begin(),[](const auto& p){return p.second;});
    print(svec.begin(),svec.end());
}
/*--------------------------------------------------------
For each döngü deyimi aşağıdaki gibi çalışmaktadır.
Burdaki örnekte kod stringlere ait ilk karakterleri yazdırmaktadır.
--------------------------------------------------------*/
#include <iostream>
#include <map>
#include <string>
#include <vector>
#include <algorithm>


using namespace std;

void myfunc(const string& s)
{
    cout << s[0];
}
template<typename Iter,typename Func>
Func ForEach(Iter beg,Iter end,Func f)
{
    while (beg != end){
        f(*beg++);
    }
    return f;
}
template<typename Iter>
void print(Iter beg, Iter end) {
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main() {

    vector<string> svec{{  "handesu"},
                           {  "cengiz"},
                           { "esra"},
                           { "mehmet"},
                           { "berke"}};
    ForEach(svec.begin(),svec.end(), myfunc);
    print(svec.begin(),svec.end());
}
/*--------------------------------------------------------
For each döngü deyiminin lamda ifadesi kullanılarak çalıştırılması
 durumu. Bu kod ile stringlere can stringi eklenmiştir.
--------------------------------------------------------*/
#include <iostream>
#include <map>
#include <string>
#include <vector>
#include <algorithm>


using namespace std;

template<typename Iter,typename Func>
Func ForEach(Iter beg,Iter end,Func f)
{
    while (beg != end){
        f(*beg++);
    }
    return f;
}
template<typename Iter>
void print(Iter beg, Iter end) {
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main() {

    vector<string> svec{{  "handesu"},
                           {  "cengiz"},
                           { "esra"},
                           { "mehmet"},
                           { "berke"}};
    ForEach(svec.begin(),svec.end(), [](string& s){s += "can";});
    print(svec.begin(),svec.end());
}
/*--------------------------------------------------------
Örnek bir hash kullanımı hasher a argüman olarak geçilen aynı
string her zaman aynı değeri elde eder.
--------------------------------------------------------*/
#include <iostream>
#include <map>
#include <string>
#include <vector>
#include <algorithm>


using namespace std;

template<typename Iter,typename Func>
Func ForEach(Iter beg,Iter end,Func f)
{
    while (beg != end){
        f(*beg++);
    }
    return f;
}
template<typename Iter>
void print(Iter beg, Iter end) {
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main() {

    hash<string> hasher;
    cout << hasher("berke") << '\n';
}

/*--------------------------------------------------------
contains fonksiyonu bir container eğer söz konusu elemanı içeriyorsa
true değer döndürürken eğer içermiyorsa false değer döndürmektedir.
-------------------------------------------------------*/
//örnek eklenecek
/*--------------------------------------------------------
bir unordered set containerının setten farkı otomatik olarak
 sıralanmamasıdır. Aşağıdaki örnekte ise bu containerın bucket_count
 fonksiyonu kullanılmaktadır.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <unordered_set>


using namespace std;

int main() {

    unordered_set<string> myset(500);

    cout << "bucket count : " << myset.bucket_count() << '\n';
}
/*--------------------------------------------------------
load factor değeri size değerinin bucket count değerine
bölünmesiyle elde edilebilir size değerinin bucket count
değerinden farklı olduğu unutulmamalıdır.
-------------------------------------------------------*/
#include <iostream>
#include <map>
#include <string>
#include <vector>
#include <algorithm>
#include <unordered_set>


using namespace std;

int main() {

    unordered_set<string> towns{"adana", "adiyaman", "afyonkarahisar", "agri", "aksaray", "amasya", "ankara",
                         "antalya", "ardahan", "artvin", "aydin", "balikesir", "bartin", "batman", "bayburt",
                         "bilecik", "bingol", "bitlis", "bolu", "burdur", "bursa", "canakkale", "cankiri", "corum",
                         "denizli", "diyarbakir", "duzce", "edirne", "elazig", "erzincan", "erzurum", "eskisehir",
                         "gaziantep", "giresun", "gumushane", "hakkari", "hatay", "igdir", "isparta", "istanbul", "izmir",
                         "kahramanmaras", "karabuk", "karaman", "kars", "kastamonu", "kayseri", "kilis",
                         "kirikkale", "kirklareli", "kirsehir","kocaeli", "konya", "kutahya", "malatya", "manisa",
                         "mardin", "mersin", "mugla", "mus","nevsehir", "nigde", "ordu","osmaniye", "rize",
                         "sakarya", "samsun", "sanliurfa", "siirt","sinop","sivas", "sirnak", "tekirdag","tokat",
                         "trabzon", "tunceli", "usak", "van", "yalova","yozgat", "zonguldak"};
    cout << "size : " << towns.size() << '\n';
    cout << "bucket count : " << towns.bucket_count() << '\n';

    cout << "load factor : " << towns.load_factor() << '\n';
    cout << "load factor : " << (float)towns.size()/ towns.bucket_count() << '\n';

    cout << "max load factor : " << towns.max_load_factor() << '\n';

}
/*--------------------------------------------------------
Map kullanarak bir anahtarın değerini değiştirmeden kendisini
 değiştirmek aşağıdaki gibi yapılabilir.
--------------------------------------------------------*/
#include <iostream>
#include <map>
#include <string>
#include <vector>

using namespace std;

template<typename Iter>
void print(Iter beg, Iter end) {
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main() {

    map<string,int> mymap{{  "handesu",547},
                           {  "cengiz",6350},
                           { "esra",30456},
                           { "mehmet",78272},
                           { "berke",32893}};
    for(const auto&[id,name]:mymap){
        cout << "name : " << name << " id : " << id << '\n';
    }
    string oldname,newname;
    cout << "eski ve yeni isimleri giriniz?\n";
    cin >> oldname >> newname;
    if(mymap.contains(newname)){
        cout << "yeni isim mapte zaten var!";
        return -1;
    }
    if(auto iter = mymap.find(oldname) ; iter != mymap.end()){
        auto value = iter->second;
        mymap.erase(iter);
        mymap.insert({newname,value});
    }
    else {
        cout << "bulunamadi\n";
    }
    for(const auto&[id,name]:mymap){
        cout << "name : " << name << " id : " << id << '\n';
    }
}
/*--------------------------------------------------------
Yukarıdaki örneğin handle kullanılarak başka bir yaklaşımla
 yapılması. Bu örnek için extract fonksiyonu kullanılmıştır.
--------------------------------------------------------*/
#include <iostream>
#include <map>
#include <string>
#include <vector>
#include <algorithm>
#include <unordered_set>


using namespace std;

template<typename Iter,typename Func>
Func ForEach(Iter beg,Iter end,Func f)
{
    while (beg != end){
        f(*beg++);
    }
    return f;
}
template<typename Iter>
void print(Iter beg, Iter end) {
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main() {

    map<string,int> mymap{{  "handesu",547},
                           {  "cengiz",6350},
                           { "esra",30456},
                           { "mehmet",78272},
                           { "berke",32893}};
    for(const auto&[id,name]:mymap){
        cout << "name : " << name << " id : " << id << '\n';
    }
    string oldname,newname;
    cout << "eski ve yeni isimleri giriniz?\n";
    cin >> oldname >> newname;

    auto handle = mymap.extract(oldname);
    if(handle){
        handle.key() = newname;
        handle.mapped() += 100;
        mymap.insert(move(handle));
        for(const auto&[id,name]:mymap){
            cout << "name : " << name << " id : " << id << '\n';
        }
    }
    else{
        cout << "bulunamadi" << '\n';
    }
}
/*--------------------------------------------------------
ostream iteratör kullanılarak doğrudan standart outputa eleman
yazdırmak
--------------------------------------------------------*/
#include <iostream>
#include <map>
#include <string>
#include <vector>
#include <iterator>


using namespace std;

template<typename Iter,typename Func>
Func ForEach(Iter beg,Iter end,Func f)
{
    while (beg != end){
        f(*beg++);
    }
    return f;
}
template<typename Iter>
void print(Iter beg, Iter end) {
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main() {

    vector<string> svec{"ali","nihan","ekrem","berke","zeynep"};

    copy(svec.begin(),svec.end(),ostream_iterator<string>{cout,"\n"});
}
/*--------------------------------------------------------
ostream iteratör kullanılarak dosyaya kopyalama işlemi copy
 fonksiyonu kullanılarak yapılabilir.
--------------------------------------------------------*/
#include <iostream>
#include <map>
#include <string>
#include <vector>
#include <iterator>
#include <fstream>


using namespace std;

template<typename Iter,typename Func>
Func ForEach(Iter beg,Iter end,Func f)
{
    while (beg != end){
        f(*beg++);
    }
    return f;
}
template<typename Iter>
void print(Iter beg, Iter end) {
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main() {

    vector<string> svec{"ali","nihan","ekrem","berke","zeynep"};

    ofstream ofs{"out.txt"};
    if(!ofs){
        cerr << "out.txt dosyasi olusturalamadi\n";
        exit(EXIT_FAILURE);
    }

    copy(svec.begin(),svec.end(),ostream_iterator<string>{ofs,"\n"});
}
/*--------------------------------------------------------
ostream iteratörün farklı bir kullanımı. Bu kullanımla
--------------------------------------------------------*/
#include <iostream>
#include <map>
#include <string>
#include <vector>
#include <iterator>
#include <fstream>

using namespace std;

int main() {

    ostream_iterator<int> os{cout,"\n"};

    for(int i = 0;i < 10;++i){
        *os=i;
    }
}
/*--------------------------------------------------------
Reference Wrapper sınıfının bir kullanımı. Reference wrapper
 sınıfı aslında kendisine gönderilen argümanın bir referansa
 bağlanmasını sağlar.
--------------------------------------------------------*/

using namespace std;

template<typename T>
class ReferenceWrapper{
public:
    ReferenceWrapper(T& x) : mp(&x) {}
private:
    T* mp;
};


int main()
{
    int ival{35};
    ReferenceWrapper r{ival};
}
/*--------------------------------------------------------
Reference Wrapper sınıfı ile söz konusu referansta bulunan
 değer bir overload ile elde edilebilir.
--------------------------------------------------------*/

using namespace std;

template<typename T>
class ReferenceWrapper{
public:
    ReferenceWrapper(T& x) : mp(&x) {}
    operator T&()
    {
        return *mp;
    }
private:
    T* mp;
};


int main()
{
    int ival{35};
    ReferenceWrapper r{ival};

    ++r;
    ++r.operator int &();
}
/*--------------------------------------------------------
son durumda ival in değeri 37 olarak elde edilecektir.
-------------------------------------------------------*/

#include <iostream>

using namespace std;

template<typename T>
class ReferenceWrapper{
public:
    ReferenceWrapper(T& x) : mp(&x) {}
    operator T&()
    {
        return *mp;
    }
private:
    T* mp;
};


int main()
{
    int ival{35};
    ReferenceWrapper r{ival};

    ++r;
    ++r.operator int &();
    cout << "ival : "<< ival << '\n';
}
/*--------------------------------------------------------
Reference Wrapper sınıfı kullanılarak bir vectorün referans
 elemanlarına birden fazla değişken bağlanabilir. bu durumda
 vectore ait elemanların değeri değiştirildiği zaman bağlanan
 değişkenlerin değeri değişir.
--------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

template<typename T>
class ReferenceWrapper{
public:
    ReferenceWrapper(T& x) : mp(&x) {}
    operator T&()
    {
        return *mp;
    }
private:
    T* mp;
};


int main()
{
    int x{10},y{20},z{30};

    vector<ReferenceWrapper<int>> ivec {x,y,z};

    ++ivec[0]; //++x
}
/*--------------------------------------------------------
Reference Wrapper sınıfı için bir örnek
--------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

template<typename T>
class ReferenceWrapper{
public:
    ReferenceWrapper(T& x) : mp(&x) {}
    operator T&()
    {
        return *mp;
    }
private:
    T* mp;
};


int main()
{
    int x = 10;
    int y = 20;

    ReferenceWrapper<int> r = x;

}
/*--------------------------------------------------------
Reference Wrapper sınıfının yaptığı iş functional başlık
 dosyasının içinde bulunan ref isimli fonksiyon çağrılarak
 bu class'ın yaptığı iş yapılabilir bu özellik C++17 ile
 birlikte eklenmiştir.
--------------------------------------------------------*/
#include <functional>

using namespace std;

template<typename T>
void func(T x)
{
    //code
    ++x;
}

int main()
{
    int ival{23};
    func(ref(ival));
}
/*--------------------------------------------------------
copy if ile bir biggie nesnesinin birlikte kullanılması
 durumu
--------------------------------------------------------*/

#include <iostream>
#include <vector>
#include <functional>

using namespace std;

struct Biggie{
    bool operator()(int x)
    {
        return true;
    }
    char buffer[4096];
};


int main()
{
    int ival{23};
    vector<int> vx(100);
    generate(vx.begin(),vx.end(),rand);
    vector<int> vy(100);
    Biggie bg{};
    copy_if(vx.begin(),vx.end(),vy.begin(),bg);
}
/*--------------------------------------------------------
reference wrapper sınıfı kullanılarak referans üzerinden
 stringlere ekleme yapılabilir.
--------------------------------------------------------*/

#include <iostream>
#include <vector>
#include <functional>

using namespace std;

int main()
{
    string s1{"bilge"};
    string s2{"saban"};

    reference_wrapper rw = s1;

    rw.get() += "su";

    cout << s1 << '\n';

    rw = s2;
    rw.get() += "can";
    cout << s2 << '\n';
}
/*--------------------------------------------------------
reference wrapper sınıfı kullanılarak bir listin elemanlarına
referans olan bir vector containerı oluşturulabilir
--------------------------------------------------------*/
#include <list>
#include <iostream>
#include <vector>
#include <functional>

using namespace std;

int main()
{
   list <string> mylist{"ali","ender","seda","nur","gul"};

   vector<reference_wrapper<string>> myvec{mylist.begin(),mylist.end()};

   sort(myvec.begin(),myvec.end());

   for(const auto& s: myvec){
       cout << s.get() << ' ';
   }
   cout << '\n';
}
/*--------------------------------------------------------
shuffle fonksiyonu ve random kütüphanesinin fonksiyonu
 kullanılarak vector istenildiği gibi karıştırılabilir.
--------------------------------------------------------*/
#include <list>
#include <iostream>
#include <vector>
#include <functional>
#include <random>

using namespace std;

template<class Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
   list <string> mylist{"ali","ender","seda","nur","gul"};

   vector<reference_wrapper<string>> myvec{mylist.begin(),mylist.end()};

   shuffle(myvec.begin(),myvec.end(),mt19937{});

   for(const auto& s: myvec){
       cout << s.get() << ' ';
   }
   cout << '\n';

    print(mylist.begin(),mylist.end());
}
/*--------------------------------------------------------
bind fonksiyonun bir kullanımı. bind fonksiyonu ile fonksiyon
 çağrısı gerçekleştirilebilir. Ancak önemli bir nokta bind kullanılarak
 bir template fonksiyon çağrısı gerçekleştirilemez. Bu syntax hatasına
 neden olur.
--------------------------------------------------------*/
#include <list>
#include <iostream>
#include <vector>
#include <functional>
#include <random>

using namespace std;

template<class Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
   list <string> mylist{"ali","ender","seda","nur","gul"};

   auto f = bind(print,mylist.begin(),mylist.end()); //error
   f();
}
/*--------------------------------------------------------
bind fonksiyonun bir kullanımı. bind fonksiyonu ile fonksiyon
 çağrısı gerçekleştirilebilir.
--------------------------------------------------------*/
#include <list>
#include <iostream>
#include <vector>
#include <functional>
#include <random>

using namespace std;

void iprint(int a,int b,int c)
{
    cout << "a : " << a << " b : " << b << " c : " << c << '\n';
}
int main()
{
    auto f = bind(iprint,5,7,12); //error
   f();
}

/*--------------------------------------------------------
Yukarıdaki örnekte yapılan iş aşağıdaki örnekteki gibi de yapılabilir.
-------------------------------------------------------*/
#include <iostream>
#include <functional>

using namespace std;

void iprint(int a,int b,int c)
{
    cout << "a : " << a << " b : " << b << " c : " << c << '\n';
}
int main()
{
    bind(iprint,5,7,12)();

}
/*--------------------------------------------------------
bind fonksiyonu kullanılarak fonksiyonlara varsayılan argüman
 geçilebilir örneğin aşağıdaki örnek için 3.parametre 20 olarak
 gönderilir.
--------------------------------------------------------*/
#include <list>
#include <iostream>
#include <vector>
#include <functional>
#include <random>

using namespace std;

void iprint(int a,int b,int c)
{
    cout << "a : " << a << " b : " << b << " c : " << c << '\n';
}
int main()
{
    using namespace placeholders;
    auto f = bind(iprint,5,7,_1);

    f(20);//iprint(5,7,20)

}
/*--------------------------------------------------------
bind fonksiyonu kullanılarak fonksiyonlara varsayılan argüman
 geçilebilir örneğin aşağıdaki örnek için 3.parametre 20 olarak
 gönderilir.
--------------------------------------------------------*/
#include <list>
#include <iostream>
#include <vector>
#include <functional>
#include <random>

using namespace std;

void iprint(int a,int b,int c)
{
    cout << "a : " << a << " b : " << b << " c : " << c << '\n';
}
int main()
{
    using namespace placeholders;
    auto f = bind(iprint,_1,_2,_3);
    f(12,45,7);//iprint(12,45,7)
}
/*--------------------------------------------------------
Nesnelerin parametre değişkeni olan referanslara bağlanması
--------------------------------------------------------*/
#include <list>
#include <iostream>
#include <vector>
#include <functional>
#include <random>

using namespace std;

void func(int &a,int &b,int & c)
{
    ++a;
    ++b;
    ++c;
}

int main()
{
    int x{10},y{20},z{30};

    func(x,y,z);

    cout << x << " " << y << " " << z << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte fonksiyon çağrısı gerçekleştirilmediği için
 bu örnek için x y ve z değerlerinde herhangi şekilde bir değişiklik
 olmaz.
--------------------------------------------------------*/
#include <list>
#include <iostream>
#include <functional>

using namespace std;

void func(int &a,int &b,int & c)
{
    ++a;
    ++b;
    ++c;
}

int main()
{
    using namespace std::placeholders;
    int x{10},y{20},z{30};

    auto f = bind(func,_1,_2,_3);

    cout << x << " " << y << " " << z << '\n';
}
/*--------------------------------------------------------
Şühpesiz fonksiyon çağrısı gerçekleştirildiği zaman x y z
değerleri değişecektir.
-------------------------------------------------------*/
#include <list>
#include <iostream>
#include <functional>

using namespace std;

void func(int &a,int &b,int & c)
{
    ++a;
    ++b;
    ++c;
}

int main()
{
    using namespace std::placeholders;
    int x{10},y{20},z{30};

    auto f = bind(func,_1,_2,_3);
    f(x,y,z);
    cout << x << " " << y << " " << z << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte x y z değerlerinde bir değişiklik meydana gelmez bunun
 nedeni aslında fonksiyonun değişkenlerle değil o nesnelerin
 değerleriyle yapılmasından kaynaklanmaktadır. Yani
 kısaca burda call by value gerçekleşir.
--------------------------------------------------------*/
#include <list>
#include <iostream>
#include <vector>
#include <functional>
#include <random>

using namespace std;

void func(int &a,int &b,int & c)
{
    ++a;
    ++b;
    ++c;
}

int main()
{
    using namespace std::placeholders;
    int x{10},y{20},z{30};

    auto f = bind(func,x,y,z);
    f();
    cout << x << " " << y << " " << z << '\n';
}
/*--------------------------------------------------------
Ancak yukardaki örnekten farklı olarak reference wrapper
 kullanılsaydı bu durumda call by reference gerçekleşeceğinden
 x y z değerleri değişecektir.
--------------------------------------------------------*/
#include <list>
#include <iostream>
#include <vector>
#include <functional>
#include <random>

using namespace std;

void func(int &a,int &b,int & c)
{
    ++a;
    ++b;
    ++c;
}

int main()
{
    using namespace std::placeholders;
    int x{10},y{20},z{30};

    auto f = bind(func, ref(x), ref(y),ref(z));
    f();
    cout << x << " " << y << " " << z << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte syntax hatasının nedeni reference wrapper'ın
 kullanılmamasından kaynaklanmaktadır.
--------------------------------------------------------*/
#include <list>
#include <iostream>
#include <vector>
#include <functional>
#include <random>

using namespace std;

void Print(ostream& os,int x,int y)
{
    os << '[' << x << "] [" << y << "]\n";
}

int main() {
    using namespace std::placeholders;

    auto f = bind(Print,cout,_1,_2);
    f(36,64);
}
/*--------------------------------------------------------
Yukarıdaki örnekteki problemin çözümü reference wrapper
 sınıfının kullanarak legal hale getirilebilir.
--------------------------------------------------------*/
#include <list>
#include <iostream>
#include <vector>
#include <functional>
#include <random>

using namespace std;

void Print(ostream& os,int x,int y)
{
    os << '[' << x << "] [" << y << "]\n";
}

int main()
{
    using namespace std::placeholders;

    auto f = bind(Print,ref(cout),_1,_2);
    f(36,64);
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <list>
#include <iostream>
#include <vector>
#include <functional>
#include <random>

using namespace std;

class Nec
{
public:
    int operator()(int a,int b)const
    {
        return a * a + b * b;
    }
};

int main()
{
    using namespace std::placeholders;

    auto fn = [](int x,int y) {return x * x + y * y;};

    auto f = bind(fn,10,_1);

    cout << f(30) << '\n';
}
/*--------------------------------------------------------
bind fonksiyonunun bir sınıf nesnesiyle birlikte kullanılması durumu
--------------------------------------------------------*/
#include <list>
#include <iostream>
#include <vector>
#include <functional>
#include <random>

using namespace std;

class Myclass
{
public:
    void print(int a,int b)const
    {
        cout << a << " " << b << '\n';
    }
};

int main() {
    using namespace std::placeholders;
    Myclass m;

    auto f = bind(&Myclass::print,m,_1,_2);

    f(10,20);
}
/*--------------------------------------------------------
Bind kullanılarak standart outputa ostream iteratör ve bind fonksiyon
 kullanılarak yazma yapmanın bir yolu
--------------------------------------------------------*/
#include <list>
#include <iostream>
#include <vector>
#include <functional>
#include <iterator>

using namespace std;

int main()
{
    using namespace std::placeholders;

    vector<int> ivec{12,5,8,9,20,3,6,7};

    auto f = bind(greater<int>{},_1,5);

    copy_if(ivec.begin(),ivec.end(),ostream_iterator<int>{cout,"\n"},f);
}
/*--------------------------------------------------------
bind fonksiyonu ve ostream iteratör kullanılarak copy_if
algoritması aşağıdaki örnekte olduğu gibi çalıştırılabilir.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <iterator>

using namespace std;

int main()
{
    using namespace std::placeholders;

    vector<int> ivec{12,5,8,9,20,3,6,7};

    copy_if(ivec.begin(),ivec.end(),ostream_iterator<int>{cout,"\n"},bind(greater<int>{},_1,5));
}
/*--------------------------------------------------------
not_fn fonksiyonu ve test kodu
not_fn adaptörüne bir fonksiyon argüman olarak geçilebilir not
fn ile çift olmayan sayılar bu şekilde elde edilebilir.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <iterator>

using namespace std;


template<typename Iter>
void print(Iter beg, Iter end) {
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

bool is_Even(int val)
{
    return val % 2 == 0;
}

int main()
{
    auto f = not_fn(is_Even);

    cout << boolalpha << f(40) << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte vector elemanlarından çift olmayan ostream
iteratör kullanılarak standart output'un bufferına yazdırılır.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <iterator>

using namespace std;


template<typename Iter>
void print(Iter beg, Iter end) {
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

bool is_Even(int val)
{
    return val % 2 == 0;
}

int main()
{
    vector<int> ivec{12,5,8,9,20,3,6,7};

    copy_if(ivec.begin(),ivec.end(),ostream_iterator<int>{cout,"\n"}, not_fn(is_Even));
}
/*--------------------------------------------------------
mem_fn adaptörü ve test kodu
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

class Myclass{
public:
        int func(int x)const
        {
            cout << "Myclass::func(int x)\n";
            return mx + x;
        }
        int mx{10};
    };

int main()
{
    Myclass m;

    auto f = mem_fn(&Myclass::func);

    cout << f(m,50) << '\n';

}
/*--------------------------------------------------------
mem_fn ile transform algoritmasının birlikte kullanımı
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <iterator>

using namespace std;


template<typename Iter>
void print(Iter beg, Iter end) {
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    vector<string> svec{"Mehmet","Mustafa","Helin","Mert","Ayse","Bilge"};

    print(svec.begin(),svec.end());

    transform(svec.begin(),svec.end(),ostream_iterator<size_t>{cout,"\n"},mem_fn(&string::size));
}
/*--------------------------------------------------------
invoke fonksiyonu kullanılarak ilk parametredeki fonksiyonun
geri dönüş değeri parametre değişkenlerine bağlı olarak elde
edilir.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <iterator>

using namespace std;

int sum(int x,int y)
{
    return x + y;
}

int main()
{
    cout << invoke(sum,10,20) << '\n';
}
/*--------------------------------------------------------
function fonksiyonunun açılımı bir fonksiyon pointer türüdür.
Aşağıdaki örnek için sum fonksiyonunun türü int(*)(int,int)
olacaktır.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <functional>

using namespace std;

int sum(int x,int y)
{
    return x + y;
}

int main()
{
    function<int(int,int)> fn{sum};

    cout << fn(10,20) << '\n';
}
/*--------------------------------------------------------
fn fonksiyonu önce sum fonksiyonunu gösterirken son durumda
multiply fonksiyonunu göstermektedir.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <functional>

using namespace std;


int sum(int x,int y)
{
    return x + y;
}
int multiply(int x,int y)
{
    return x * y;
}

int main()
{
    function<int(int,int)> fn{sum};

    cout << fn(10,20) << '\n';

    fn = multiply;

    cout << fn(5,4) << '\n';
}
/*--------------------------------------------------------
bu fonksiyonlar bir sınıfın non static üye fonksiyonunu da
aşağıdaki örnekte gösterildiği gibi gösterebilir.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <functional>

using namespace std;

class Myclass{
    public:
        int operator()(int a,int b)const
        {
            return a * b;
        }
    };

int sum(int x,int y)
{
    return x + y;
}
int multiply(int x,int y)
{
    return x * y;
}

int main()
{
    function<int(int,int)> fn{Myclass{}};

    cout << fn(10,20) << '\n';
}
/*--------------------------------------------------------
eğer aşağıdaki örnekteki gibi bir fonksiyon fn gibi bir
ifadeye atanmazsa ve çağrılma girişiminde bulunulursa bu
durumda bad function call türünden bir exception throw edilir.
-------------------------------------------------------*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <functional>

using namespace std;

int main()
{
    function<int(int,int)> fn;
    try {
        cout << fn(10,20) << '\n';
    }
    catch(const exception& ex) {
        cout << "exception caught : " << ex.what() << '\n';
    }

}
/*--------------------------------------------------------
Bir fonksiyon var olup olmadığı aşağıdaki örnekteki kod ile kontrol
edilebilir.
-------------------------------------------------------*/
#include <iostream>
#include <functional>

using namespace std;

int foo(int a,int b)
{
        return a * b;
}

int main()
{
    function<int(int,int)> fn;

    fn = foo;

    if(fn){
        cout << "ben sana bos degilim\n";
    }
    else
        cout << "kendimi bombos hissediyorum\n";
}
/*--------------------------------------------------------
function'ın operator bool fonksiyonu yine fonksiyonun
var olup olmadığını kontrol etmek için kullanılabilir.
-------------------------------------------------------*/
#include <iostream>
#include <functional>

using namespace std;

int foo(int a,int b)
{
        return a * b;
}

int main()
{
    function<int(int,int)> fn;

    fn = foo;

   if(fn.operator bool()){
        auto n = fn(12,34);
   }
}
/*--------------------------------------------------------
Bir vector containerının elemanları function adaptörü türünden olabilir.
-------------------------------------------------------*/
#include <iostream>
#include <vector>
#include <functional>

using namespace std;

void f1()
{
    cout << "f1 cagrildi\n";
}
void f2()
{
    cout << "f2 cagrildi\n";
}
void f3()
{
    cout << "f3 cagrildi\n";
}

using ftype = function<void()>;

int main()
{
    vector<ftype> myvec;

    myvec.push_back(f1);
    myvec.push_back(f2);
    myvec.push_back(f3);
    myvec.push_back([](){cout << "merhaba dunya\n";});

    for(auto f: myvec){
        f();
    }

}
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
#include <iostream>
#include <functional>

using namespace std;

int foo(int,int);


int main()
{
    function<int(int)> fn;

    fn = bind(foo,placeholders::_1,20);

}
/*--------------------------------------------------------
typeid ile fonksiyon türü elde edilebilir.
-------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

int foo(int,int);


int main()
{
    cout << typeid(decltype(foo)).name() << '\n';
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <functional>

using namespace std;

int foo(int,int);


int main()
{
    function f = foo;
}
/*--------------------------------------------------------
array containerı ve test kodu
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <array>

using namespace std;

int main()
{
    array<int,5> ar;

    for(auto val : ar){
        cout << val << ' '; //garbage values
    }
}
/*--------------------------------------------------------
array'in bool açılımı için ilk değer verme işlemi yapılmamışsa
bu durumda değerle rastgele değerlerdir.(true veya false)
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <array>

using namespace std;

int main()
{
    array<bool,5> ar;

    for(auto val : ar){
        cout << boolalpha << val << ' '; //garbage values
    }
}
/*--------------------------------------------------------
Aşağıdaki gibi bir ilk değer verme array containerı için geçersizdir.
container boyutu belirtilmek zorundadır.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <array>

using namespace std;

int main()
{
    array<int> ar = {2,4,6,8,9,12};

}
/*--------------------------------------------------------
array containerının empty fonksiyonu bu fonksiyon container
boş ise true, boş değil ise false değer üretecektir.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <array>

using namespace std;

int main()
{
    array<int,3> ar ;

    cout << boolalpha;

    cout << ar.empty() << '\n';

}
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <array>

using namespace std;

int main()
{
    array<int,5> ax;

    for(size_t i{};i < ax.size();++i){
        ax[i] = i * 10;
    }
    for(auto val : ax){
        cout << val << ' ';
    }
}
/*--------------------------------------------------------
Eğer array'in at fonksiyonuyla boyutunun dışında bir eleman
elde edilmeye çalışılırsa bu durumda exception fırlatılır.
exception caught : array::at: __n (which is 20) >= _Nm (which is 5)
-------------------------------------------------------*/
#include <iostream>
#include <array>

using namespace std;


int main()
{
    array<int,5> ax;

    try{
        auto n = ax.at(20);
    }
    catch(const exception& ex){
        cout << "exception caught : " << ex.what() << '\n';
    }
}
/*--------------------------------------------------------
array'in sort fonksiyonuyla sıralanması geçerlidir.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <array>

using namespace std;

int main()
{
    array<int,5> ax{12,4,8,7,1};
    sort(ax.begin(),ax.end());
    //sort(begin(ax),end(ax));
}
/*--------------------------------------------------------
array ile bitsel sola kaydırma operatörünün overload'ının
bir arada kullanılması durumu
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <array>

using namespace std;


template<typename T>
ostream& operator<<(stream& os,const array<T,n>& ar)
{
    os << '[';
    for(size_t i{};i < ar.size();++i){
        os << ar[i] << ", ";
    }
    os << ar.back() << ']';

    return os;
}

int main()
{
    array ax{1.2,4.4,2.3,7.8,5.9,2.45};

    cout << ax << '\n';
}
/*--------------------------------------------------------
array containerı içerisinde başka bir array containerı bulunabilir.
Bu dizi dizileri yani matrislere benzetilebilir.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <array>

using namespace std;


template<typename T,size_t n>
ostream& operator<<(ostream& os,const array<T,n>& ar)
{
    os << '[';
    for(size_t i{};i < ar.size();++i){
        os << ar[i] << ", ";
    }
    os << ar.back() << ']';

    return os;
}

int main()
{
    array<array<int,3>,5> ar{{{1,1,1},{2,2,2},{3,3,3},{4,4,4},{5,5,5}}};

    cout << ar << '\n';

}
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <array>

using namespace std;


template<typename T,size_t n>
ostream& operator<<(ostream& os,const array<T,n>& ar)
{
    os << '[';
    for(size_t i{};i < ar.size();++i){
        os << ar[i] << ", ";
    }
    os << ar.back() << ']';

    return os;
}

int main()
{
    array<int,5> ar{1,4,7,9,2};

    for(auto x : ar){
        cout << x << " ";
    }

    cout << "\n\n";
    cout << ar << '\n';
}
/*--------------------------------------------------------
structure binding kullanılarak array containerının değerini
verme durumu
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <array>

using namespace std;


template<typename T,size_t n>
ostream& operator<<(ostream& os,const array<T,n>& ar)
{
    os << '[';
    for(size_t i{};i < ar.size();++i){
        os << ar[i] << ", ";
    }
    os << ar.back() << ']';

    return os;
}

int main()
{
    array<int,3> ar{1,4,7};

    auto [x,y,z] = ar;

    cout << "x = " << x << '\n';
    cout << "y = " << y << '\n';
    cout << "z = " << z << '\n';
}
/*--------------------------------------------------------
get ile array containerın açılımlarıyla elemanları elde edilebilir.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <array>

using namespace std;


template<typename T,size_t n>
ostream& operator<<(ostream& os,const array<T,n>& ar)
{
    os << '[';
    for(size_t i{};i < ar.size();++i){
        os << ar[i] << ", ";
    }
    os << ar.back() << ']';

    return os;
}

int main()
{
    array<int,3> ar{1,4,7};

    ++get<0>(ar); //ar[0]++
    get<1>(ar) = 45; //ar[1] = 45
    get<2>(ar) += 2; //ar[2] += 2
}
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <array>
#include <tuble>

using namespace std;


template<typename T,size_t n>
ostream& operator<<(ostream& os,const array<T,n>& ar)
{
    os << '[';
    for(size_t i{};i < ar.size();++i){
        os << ar[i] << ", ";
    }
    os << ar.back() << ']';

    return os;
}

using artype = array<int,5>;

int main()
{
    constexpr auto size = tuple_size<artype>::value;
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <array>
#include <tuble>

using namespace std;


template<typename T,size_t n>
ostream& operator<<(ostream& os,const array<T,n>& ar)
{
    os << '[';
    for(size_t i{};i < ar.size();++i){
        os << ar[i] << ", ";
    }
    os << ar.back() << ']';

    return os;
}

using artype = array<int,5>;

int main()
{
    constexpr auto size = tuple_size<artype>::value;
    constexpr auto size = tuple_size_v<artype>;

    tuple_element_t<0,artype> x{};
}
/*--------------------------------------------------------
tuple containerının bazı örnekleri
bir tuple'ın elemanlarını elde etmek için get'in o indeksince
açılımı kullanılır.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <array>
#include <tuple>

using namespace std;

int main()
{
   tuple<int,double,string,char> t1{};
   tuple<int,double,string,char> t2{12,5.6,"berke",'A'};

   cout << get<0>(t2) <<'\n';
    cout << get<1>(t2) <<'\n';
    cout << get<2>(t2) <<'\n';
    cout << get<3>(t2) <<'\n';
}
/*--------------------------------------------------------
Eğer bir tuple icerisinde aynı türden bir tek eleman varsa
bu durumda o elemana tür açılımı kullanılarak erişilebilir.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <array>
#include <tuple>

using namespace std;

int main()
{
   tuple<int,double,string,char> t2{12,5.6,"berke",'A'};

   cout << get<int>(t2) << '\n';

   get<string> (t2) += "can";

   cout << get<string>(t2) << '\n';
}
/*--------------------------------------------------------
Ancak aynı türden birden fazla eleman var ise bu durumda bir ambiguity
söz konusudur bu da syntax hatasına neden olur.
-------------------------------------------------------*/
#include <iostream>
#include <tuple>

using namespace std;

int main()
{
   tuple<int,double,int,char> t2{12,5.6,56,'A'};

   cout << get<int>(t2) << '\n';

}
/*--------------------------------------------------------
Tuple ile using bildirimi birlikte kullanılması durumu
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <tuple>

using namespace std;

using birth_year = int;
using name = string;
using wage = double;

using Person = tuple<birth_year ,name,wage>;

int main()
{
   Person person{1987,"Deniz Ercan",34.57};

   get<name>(person) = "Selda Akman";
}
/*--------------------------------------------------------
make tuple fonksiyonu adından da anlaşılabileceği gibi bir tuple
oluşturur. auto anahtar sözcüğü yardımıyla make_tuple dan gelen
nesne auto type deduction ile doğrudan alınabilir.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <tuple>

using namespace std;

int main()
{
   int x = 35;
   double dval = 5.6;
   string name = "mustafa";
   auto t = make_tuple(x,dval,name);
   cout << get<2>(t).size() << '\n';
}
/*--------------------------------------------------------
Bir fonksiyonun geri dönüş değeri bir tuple olabilir.
Yani aşağıdaki örnekteki kod geçerlidir.
-------------------------------------------------------*/
#include <list>
#include <string>
#include <tuple>

using namespace std;

tuple<int,string,double> foo()
{
    //code
    return {45,"Muhsin",5.9};
}

int main()
{
    auto t = foo();
    int age = get<0>(t);
    string name = get<1>(t);
    double dval = get<2>(t);
}

/*--------------------------------------------------------
bir pair nesnesinin referans semantiğiyle kullanılması durumunu
-------------------------------------------------------*/

#include <list>
#include <iostream>
#include <string>
#include <tuple>

using namespace std;

tuple<int,string,double> foo()
{
    //code
    return {45,"Muhsin",5.9};
}

int main()
{
   int x = 10;
   double dval = 5.6;

   pair<int&,double&> p{x,dval};

   p.first = 4542;
   p.second = 745.9862;

   cout << "x = " << x << '\n';
   cout << "dval = " << dval << '\n';
}

/*--------------------------------------------------------
Eğer bir paire reference wrapper bir nesne ile make_pair
yapılırsa bu durumda yukarıdaki işin aynısı yapılmış olur.
Bunu ikinci yolla yapmak çok daha iyi bir yöntemdir.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <tuple>
#include <functional>

using namespace std;

tuple<int,string,double> foo()
{
    //code
    return {45,"Muhsin",5.9};
}

int main()
{
   int x = 10;
   double dval = 5.6;

   auto p = make_pair(ref(x),ref(dval));

   p.first = 45;
   p.second = 12.5;

   cout << "x = " << x << '\n';
   cout << "dval = " << dval << '\n';
}


/*--------------------------------------------------------
make paire benzer olarak make tuple fonksiyonu da bulunmaktadır.
-------------------------------------------------------*/
#include <list>
#include <iostream>
#include <string>
#include <tuple>
#include <functional>

using namespace std;

int main()
{
   int x = 10;
   double dval = 5.6;
    string name = "Mustafa";
    auto t = make_tuple(x,dval,name);

    get<0>(t) = 45;
    get<1>(t) = 12.6;
    get<2>(t) = "Mehmet";

    cout << "name : " << name << '\n';
}


/*--------------------------------------------------------
tie fonksiyonu make tuple fonksiyonundan farklı olarak tüm
değişkenlerde reference wrapper sınıfı kullanılarak bir
tuple yapılmış gibi ele alınır yani Yukarıdaki örnekten farklı
olarak son durumda name stringinin değeri Mustafa olacaktır.
-------------------------------------------------------*/
#include <list>
#include <iostream>
#include <string>
#include <tuple>
#include <functional>

using namespace std;

int main()
{
   int x = 10;
   double dval = 5.6;
    string name = "Mustafa";
    auto t = tie(x,dval,name);

    get<0>(t) = 45;
    get<1>(t) = 12.6;
    get<2>(t) = "Mehmet";

    cout << "name : " << name << '\n';
}
/*--------------------------------------------------------
tie fonksiyonuyla bağlanan ifadelere aşağıdaki örnekteki gibi
bir tuble nesne bağlanılabilir. Bu durumda söz konusu
değişkenler pointerlar gibi ele alınır. Yorum satırından
ifade ile tie fonksiyonun kullanımı arasında hiçbir fark yoktur.
-------------------------------------------------------*/
#include <list>
#include <iostream>
#include <string>
#include <tuple>
#include <functional>

using namespace std;

tuple<int,string,double> foo()
{
    //code
    return {45,"Muhsin",5.9};
}

int main()
{
    int x;
    double dval;
    string name;

    /*
    tuple<int&,string&,double&> tx(x,name,dval);
    tx = foo();
    */

    tie(x,name,dval) = foo();

    cout << "x : " << x << '\n';
    cout << "name : " << name << '\n';
    cout << "dval : " << dval << '\n';
}
/*--------------------------------------------------------
İki değişkenin tuble kullanılarak oldukça pratik bir şekilde
yer değiştirilmesi
-------------------------------------------------------*/
#include <list>
#include <iostream>
#include <string>
#include <tuple>
#include <functional>

using namespace std;

tuple<int,string,double> foo()
{
    //code
    return {45,"Muhsin",5.9};
}

int main()
{
    int x = 10, y = 34;

    tie(x,y) = tuple(y,x);

    cout << "x : " << x << '\n';
    cout << "y : " << y << '\n';
}
/*--------------------------------------------------------
stack containerı:stack containerı kısaca son girenin ilk çıktığı
bir veri yapısıdır. Queue veri yapısının tam tersi özellik gösterir.
Queue için gerçek hayttaki kuyruk gibi first in first out olarak
isimlendirilir. stack için bu durum first in last out olarak
adlandırılabilir. Bir stack containerının prototipi aşağıdaki
gibi ifade edilebilir.
-------------------------------------------------------*/
/*--------------------------------------------------------
stacke eleman eklemek için push fonksiyonu
eleman çıkarmak için pop fonksiyonu çağrılır.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <vector>
#include <stack>

using namespace std;

template<typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    stack<int> istack;
    istack.push(24);
    istack.pop();
}
/*--------------------------------------------------------
stack containerının push,top,pop ve empty fonksiyonları
ve test kodu
-------------------------------------------------------*/
#include <ctime>
#include <iostream>
#include <string>
#include <cstdlib>
#include <stack>
#define randomize() srand(time(nullptr))

using namespace std;

string get_random_town()
{
    string towns[]{"adana", "adiyaman", "afyonkarahisar", "agri", "aksaray", "amasya", "ankara",
                         "antalya", "ardahan", "artvin", "aydin", "balikesir", "bartin", "batman", "bayburt",
                         "bilecik", "bingol", "bitlis", "bolu", "burdur", "bursa", "canakkale", "cankiri", "corum",
                         "denizli", "diyarbakir", "duzce", "edirne", "elazig", "erzincan", "erzurum", "eskisehir",
                         "gaziantep", "giresun", "gumushane", "hakkari", "hatay", "igdir", "isparta", "istanbul", "izmir",
                         "kahramanmaras", "karabuk", "karaman", "kars", "kastamonu", "kayseri", "kilis",
                         "kirikkale", "kirklareli", "kirsehir","kocaeli", "konya", "kutahya", "malatya", "manisa",
                         "mardin", "mersin", "mugla", "mus","nevsehir", "nigde", "ordu","osmaniye", "rize",
                         "sakarya", "samsun", "sanliurfa", "siirt","sinop","sivas", "sirnak", "tekirdag","tokat",
                         "trabzon", "tunceli", "usak", "van", "yalova","yozgat", "zonguldak"};
    return towns[rand() % 81];
}

int main()
{
    randomize();
    stack<string> towns;
    for(int i = 0;i < 10;++i){
        string town = get_random_town();
        towns.push(town);
        cout << town << " ekleniyor" << '\n';
        getchar();
    }
    for(int i = 0;i < 10;++i){
        cout << towns.top() << " cikariliyor" << '\n';
        getchar();
        towns.pop();
    }
    cout << "stack bos mu?" << (towns.empty() ? "evet" : "hayir") << '\n';
}
/*--------------------------------------------------------
queue containerının stack containerının tam tersi olarak
düşünülebilir stack containerında ilk giren son çıkarken
burda ilk giren ilk çıkar prensibi geçerlidir.
-------------------------------------------------------*/
/*--------------------------------------------------------
queue containerı: queue containerı aslında stack containerının
tam tersi olarak düşünülebilir çünkü queue containerında
elemanlardan önce giren ilk çıkarken stack için bu durum
sonra giren ilk çıkar mantığına göre çalışmaktadır. queue
containerına ait front fonksiyonu ilk giren elemanı verirken
back fonksiyonu son eklenen elemanı verir. pop fonksiyonu
ilk eklenen elemanı çıkarırken push fonksiyonu ekleme yapar.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <queue>
#include <cstdlib>
#include <ctime>
#define randomize() srand(time(nullptr))

using namespace std;

string towns[]{"adana", "adiyaman", "afyonkarahisar", "agri", "aksaray", "amasya", "ankara",
                     "antalya", "ardahan", "artvin", "aydin", "balikesir", "bartin", "batman", "bayburt",
                     "bilecik", "bingol", "bitlis", "bolu", "burdur", "bursa", "canakkale", "cankiri", "corum",
                     "denizli", "diyarbakir", "duzce", "edirne", "elazig", "erzincan", "erzurum", "eskisehir",
                     "gaziantep", "giresun", "gumushane", "hakkari", "hatay", "igdir", "isparta", "istanbul", "izmir",
                     "kahramanmaras", "karabuk", "karaman", "kars", "kastamonu", "kayseri", "kilis",
                     "kirikkale", "kirklareli", "kirsehir","kocaeli", "konya", "kutahya", "malatya", "manisa",
                     "mardin", "mersin", "mugla", "mus","nevsehir", "nigde", "ordu","osmaniye", "rize",
                     "sakarya", "samsun", "sanliurfa", "siirt","sinop","sivas", "sirnak", "tekirdag","tokat",
                     "trabzon", "tunceli", "usak", "van", "yalova","yozgat", "zonguldak"};
string names[]{"berke","mustafa","meric","toygar","mehmet","arif","kaya","irem","elif","nur","zeynep","ipek"};

int main()
{
    queue<string> qx;
    randomize();

    for(int i = 0;i < 10;++i){
        auto s = names[rand() % 12] + " memleket : " + towns[rand() % 81];
        cout << s << " kuyruga ekleniyor\n";
        qx.push(s);
        getchar();
    }
    for(int i = 0;i < qx.size(); ++i){
        cout << qx.front() << "\n";
    }
    for(int i = 0;i < qx.size(); ++i){
        cout << qx.front() << " kuyruktan cikariliyor\n";
        qx.pop();
        getchar();
    }
}
/*--------------------------------------------------------
priority queue containerı için durum biraz daha farklıdır.
priority queue da örneğiin aşağıdaki örnek için stringler
lexicographical compare kullanılarak karşılaştırılır buna
göre sırada en önde z ile başlayan zeynep olur.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <queue>
#include <cstdlib>
#include <ctime>
#define randomize() srand(time(nullptr))

using namespace std;

string towns[]{"adana", "adiyaman", "afyonkarahisar", "agri", "aksaray", "amasya", "ankara",
                     "antalya", "ardahan", "artvin", "aydin", "balikesir", "bartin", "batman", "bayburt",
                     "bilecik", "bingol", "bitlis", "bolu", "burdur", "bursa", "canakkale", "cankiri", "corum",
                     "denizli", "diyarbakir", "duzce", "edirne", "elazig", "erzincan", "erzurum", "eskisehir",
                     "gaziantep", "giresun", "gumushane", "hakkari", "hatay", "igdir", "isparta", "istanbul", "izmir",
                     "kahramanmaras", "karabuk", "karaman", "kars", "kastamonu", "kayseri", "kilis",
                     "kirikkale", "kirklareli", "kirsehir","kocaeli", "konya", "kutahya", "malatya", "manisa",
                     "mardin", "mersin", "mugla", "mus","nevsehir", "nigde", "ordu","osmaniye", "rize",
                     "sakarya", "samsun", "sanliurfa", "siirt","sinop","sivas", "sirnak", "tekirdag","tokat",
                     "trabzon", "tunceli", "usak", "van", "yalova","yozgat", "zonguldak"};
string names[]{"berke","mustafa","meric","toygar","mehmet","arif","kaya","irem","elif","nur","zeynep","ipek"};

int main()
{
    priority_queue<string> qx;
    randomize();

    for(int i = 0;i < 10;++i){
        auto s = names[rand() % 12] + " memleket : " + towns[rand() % 81];
        cout << s << " kuyruga ekleniyor\n";
        qx.push(s);
        getchar();
    }
    while(!qx.empty()){
        cout << qx.top() << " kuyruktan cikariliyor\n";
        qx.pop();
        getchar();
    }
}
/*--------------------------------------------------------
heap algoritmasının make_heap fonksiyonuna bir örnek.
make_heap fonksiyonu bir containerı veya bir diziyi heap
veri yapısı haline dönüştürür. Geri dönüş değeri void türünden
olduğu için auto ile kullanılan bir değişkene dahi atama yapılamaz.
Bu yüzden make_pair veya make_tuple tarzı fonksiyonlarla bu açıdan
farklıdır.
-------------------------------------------------------*/
clean code solid design patern araştır.

#include <iostream>
#include <string>
#include <queue>
#include <cstdlib>
#include <ctime>
#define randomize() srand(time(nullptr))

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << "\n";
}

int main()
{
    vector<int> ivec{12,34,56,78,9,13};
    print(ivec.begin(),ivec.end());
    make_heap(ivec.begin(),ivec.end(),greater{});
    print(ivec.begin(),ivec.end());
}
/*--------------------------------------------------------
pop_heap fonksiyonu ve pop_back fonksiyonu birlikte kullanılarak heap veri yapısından eleman
çıkarılabilir. burda pop_heap'in amacı eleman çıkarılmadan önceki sıranın belirlenip pop_back
kullanılınca sıraya göre en sondaki elemanı silmektir.
-------------------------------------------------------*/
#include <iostream>

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << "\n";
}

int main()
{
    vector<int> ivec{12,34,56,78,9,13};
    print(ivec.begin(),ivec.end());
    make_heap(ivec.begin(),ivec.end(),greater{});
    print(ivec.begin(),ivec.end());

    pop_heap(ivec.begin(),ivec.end(),less{});
    cout << " heapten cikarilacak eleman : " << ivec.back() << '\n';
    ivec.pop_back();
    print(ivec.begin(),ivec.end());
}
/*--------------------------------------------------------
push_heap ve push_back kullanılarak aşağıdaki gibi vector
containerınına
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <queue>
#include <cstdlib>
#include <ctime>
#define randomize() srand(time(nullptr))

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << "\n";
}

int main()
{
    vector<int> ivec;
    randomize();

    for(int i = 0;i < 10;++i){
        auto n = rand();
        cout << n << " kuyruga eklendi\n";
        ivec.push_back(n);
        push_heap(ivec.begin(),ivec.end());
        getchar();
    }
    print(ivec.begin(),ivec.end());

    while(!ivec.empty()){
        pop_heap(ivec.begin(),ivec.end());
        cout << ivec.back() << " kuyruktan cikarildi\n";
        getchar();
        ivec.pop_back();
    }
}
/*--------------------------------------------------------
make_heap ve sort_heap fonksiyonları
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <queue>
#include <cstdlib>
#include <ctime>

using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << "\n";
}

int main()
{
    vector<int> ivec{12,34,56,78,9,13};
    print(ivec.begin(),ivec.end());
    make_heap(ivec.begin(),ivec.end(),greater{});
    print(ivec.begin(),ivec.end());
    sort_heap(ivec.begin(),ivec.end(),less{});
    print(ivec.begin(),ivec.end());
}
/*--------------------------------------------------------
STL'in is_heap fonksiyonu
                        9309
                8470           8286
        8239        4227   1087         4802
1482         3481

heap aslında ikili arama ağacı olduğu için is_heap
fonksiyonu da ikili arama ağacı kurallarına uygun olup olmadığını
test eder. İkili arama ağacında en önemli kural başlangıç
elemanının solda bulunan tüm düğümlerden küçük olmasına
dayanmaktadır.
-------------------------------------------------------*/
#include <iostream>
#include <queue>


using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << "\n";
}

int main()
{
    int a[] = {9309,8470,8286,8239,4227,1087,4802,1482,3481};
    cout << boolalpha << is_heap(begin(a),end(a)) << '\n';
}
/*--------------------------------------------------------
is_heap_until fonksiyonuyla hangi elemana kadar ikili arama
ağacı kurallarının bozulmadığı kontrol edilebilir.
-------------------------------------------------------*/
#include <iostream>
#include <queue>


using namespace std;

template <typename Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        std::cout << *beg++ << ' ';
    }
    std::cout << "\n";
}

int main()
{
    int a[] = {9309,8470,8286,8239,23456,1087,4802,1482,3481,4122};
    cout << boolalpha << is_heap(begin(a),end(a)) << '\n';

    auto iter = is_heap_until(begin(a), end(a));
    if(iter != end(a)){
        cout << "heap i bozan ilk eleman : " << *iter << '\n';
        cout << "idx = " << iter - begin(a) << '\n';
    }
}
/*--------------------------------------------------------
Standart Kütüphanenin bitset sınıfı:
Bu sınıf C dilinde uzun yoldan yapılan pek çok işlemin
çok daha rahat bir şekilde yapılmasını sağlayan ve gömülü
yazılımda sıkça kullanılan bir sınıftır.
bitsel sınıfı: c dilinde de sıkça kullanılan ve gömülü
yazılım tarafında oldukça önemli bir yere sahip olan bitseL
işlemlerin modern C++'ın bitsel sınıfının  eklenmesiyle
oldukça yapılması kolay bir hale gelmiştir. Bitsel sınıfının
kullanılması için öncelikle bitset standart kütüphanesi include
edilmelidir. Aşağıdaki örnek 16 bitlik bir sayı elde edilmiştir.
Default olarak x değişkeninin bütün bitleri 0 olacaktır.
-------------------------------------------------------*/
#include <bitset>
#include <iostream>


using namespace std;

int main()
{
    bitset<16> x;
    cout << x << '\n';
}

/*--------------------------------------------------------
Klavyeden girilen int türden bir sayının bitleri aşağıdaki
gibi görüntülenebilir.
-------------------------------------------------------*/
#include <bitset>
#include <iostream>

using namespace std;

int main()
{
    int x;
    cout << "bir tam sayi giriniz?\n";
    cin >> x;
    cout << bitset<32>(x) << '\n';
}
/*--------------------------------------------------------
32 bitlik bir sayıya -1 atandığında -1'in tüm bitleri 1 olduğundan
tüm bitleri 1 olan bir sonuç elde edilecektir.
-------------------------------------------------------*/
#include <bitset>
#include <iostream>

using namespace std;

int main()
{
    bitset<32>bs(-1);

    cout << bs << '\n';
}

/*--------------------------------------------------------
bitset sınıfının reset fonksiyonu tahmin edilebileceği gibi
bitlerin hepsini 0 yapacaktır.
-------------------------------------------------------*/
#include <bitset>
#include <iostream>

using namespace std;

int main()
{
    bitset<32>bs(-1);

    cout << bs << '\n';
    bs.reset();
    cout << bs << '\n';
}
/*--------------------------------------------------------
reset fonksiyonuna geçilen argümanıncı bit de argüman geçilmesi
durumunda aşağıdaki örnekte olduğu gibi 0 yapılabilir. Örneğin
aşağıdaki örnekteki ifade 5. biti 0 yap anlamında kullanılabilir.
-------------------------------------------------------*/
#include <bitset>
#include <iostream>

using namespace std;

int main()
{
    bitset<32>bs(-1);

    cout << bs << '\n';
    bs.reset(5);
    cout << bs << '\n';
}

/*--------------------------------------------------------
set fonksiyonu 2.parametreye argüman geçilmemesi durumunda
söz konusu biti 1 yapar ancak 2.parametresine argüman olarak false
geçilirse bu durumda o biti 0 yapar. Aşağıdaki örnekte bu durum
anlatılmak istenmiştir.
-------------------------------------------------------*/
#include <bitset>
#include <iostream>

using namespace std;

int main()
{
    bitset<32>bs(-1);

    cout << bs << '\n';
    bs.set(5,false);
    cout << bs << '\n';
}

/*--------------------------------------------------------
Bitsel bazı işlemlerin gömülü yazılımdaki tabirleri:
Bir biti birlemek:
->to set the bit
->to turn the bit on
Bir biti sıfırlamak:
->to reset the bit
->to turn the bit off
->to clear the bit
Bir biti değiştirmek:
->to toggle the bit
->to flip the bit
Bir biti elde etmek:
->to get the bit
-------------------------------------------------------*/
/*--------------------------------------------------------
bitsel sınıfının flip fonksiyonu sayının tüm bitlerinin
değiştirilmesinde kullanılabilir.
-------------------------------------------------------*/
#include <bitset>
#include <iostream>

using namespace std;

int main()
{
    bitset<32>bs(-1);

    cout << bs << '\n';
    bs.flip();
    cout << bs << '\n';
}

/*--------------------------------------------------------
Eğer argüman geçilirse bu durumda argüman geçilen sayıncı bit değiştirilir.
-------------------------------------------------------*/
#include <bitset>
#include <iostream>

using namespace std;

int main()
{
    bitset<32>bs(-1);

    cout << bs << '\n';
    bs.flip(5);
    cout << bs << '\n';
}

/*--------------------------------------------------------
bitset sınıfının flip fonksiyonunun 2 parametreli bir overload'ı
yoktur bu sebeple aşağıdaki kod syntax hatasına neden olur
-------------------------------------------------------*/
#include <bitset>
#include <iostream>

using namespace std;

int main()
{
    bitset<32>bs(-1);

    cout << bs << '\n';
    bs.flip(5,true); //syntax error
    cout << bs << '\n';
}

/*--------------------------------------------------------
bitset sınıfının any count none ve all fonksiyonları
count:bitlerin sayısını elde eder
any:herhangi bir bit 1 ise true değilse false döndürür.
none:hiçbir bit 0 değilse false döndürür.
all: tüm bitler 1 ise true döndürür.
-------------------------------------------------------*/
#include <bitset>
#include <iostream>

using namespace std;

int main()
{
    bitset<32>bs(-1);


    cout << bs.count() << '\n';
    cout << boolalpha;

    cout << "any : " << bs.any() << '\n';
    cout << "none : " << bs.none() << '\n';
    cout << "all : " << bs.all() << '\n';
}
/*--------------------------------------------------------
bitset sınıfının to_string fonksiyonu
-------------------------------------------------------*/
#include <bitset>
#include <iostream>

using namespace std;

int main()
{
    bitset<32>bs(-1);


    auto str  = bs.to_string();
}

/*--------------------------------------------------------
bitset sınıfı türünden bir sayının index of operatörüyle
istenilen biti değiştirilebilir.
-------------------------------------------------------*/
#include <bitset>
#include <iostream>

using namespace std;

int main()
{
    bitset<32>x(-1);

    x[5] = false;

    cout << x << '\n';
}
/*--------------------------------------------------------
1 2 ve 3 numaralı ifadelerin tamamı biti değiştirmek için
kullanılabilir.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

int main()
{
    bitset<16>x;

    x[5] = true; //1

    cout << x << '\n';

    x[5] = 0; //2

    cout << x << '\n';

    x.operator[](5) = true; //3
}

/*--------------------------------------------------------
bir sayının bitine kendisinin başka bir biti atanabilir.
-------------------------------------------------------*/
#include <bitset>
#include <iostream>

using namespace std;

int main()
{
    bitset<16>x;

    x[5] = true;
    x[5] = x[3];

    if(x[4]){

    }
}

/*--------------------------------------------------------
Bir sayının bütün bitlerini uzun yoldan 1 yapmak için aşağıdaki
for döngüsü kullanılabilir.
-------------------------------------------------------*/
#include <bitset>
#include <iostream>

using namespace std;

int main()
{
    bitset<16>x;

    for(size_t i{};i < x.size();++i){
        x.operator[](i) = true;
    }
    cout << x << '\n';
}
/*--------------------------------------------------------
bitset sınıfının sola kaydırma operatörü overload edilmiştir.
Bu örnek için overloadı kullanılmaktadır.
-------------------------------------------------------*/
#include <bitset>
#include <iostream>

using namespace std;

int main()
{
    bitset<16>x{255u};

    cout << x << '\n';

    x <<= 2;

    cout << x << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
#include <bitset>
#include <iostream>
#include <string>

using namespace std;

int main()
{
    string str{"11111111111111111111"};

    bitset<32> bs1{str};

    cout << bs1 << '\n'; //00000000000011111111111111111111

    bitset<32> bs2{str,5}; //00000000000000000111111111111111

    cout << bs2 << '\n';

    bitset<32> bs3{str,5,3}; //00000000000000000000000000000111

    cout << bs3 << '\n';
}
/*--------------------------------------------------------
Akıllı Göstericiler(Smart Pointers):
1-)unique_ptr
2-)shared_ptr
  ->weak_ptr
Smart Pointerlar C++11 ile dile eklenmiş modern C++ öncesinde
sadece auto_ptr smart pointerı kullanılmaktaydı ancak C++11
ile birlikte auto_ptr deprecated oldu ve C++14 ile dilden kaldırıldı.
unique_ptr:tek bir nesnenin tutulabileceği adından da anlaşılabileciği
gibi bir unique olan nesnedir. Bu akıllı pointer sınıfı en sık kullanılan
akıllı pointer sınıfıdır.
shared_ptr:Aynı anda iki farklı pointer aynı nesneyi gösterebilir.
Bu adından da anlaşılabileceği gibi nesne paylaşılır. unique_ptr'dan sonra
en sık kullanılan akıllı pointer sınıfıdır.
weak_ptr:Bu kullanımı pek sık olmayan bir akıllı pointer sınıfı
olup shared_ptr'ın yapamadığı bazı işlerde ona yardımcı bir sınıftır
denilebilir. ihtiyaç duyulduğu durumlar ilerde ele alınacaktır.
Smart Pointerlar ne işe yarar?
Normalde standart new veya array new operatörüyle yaratılan bir dinamik ömürlü nesne
normal delete veya array delete ile kaynağının geri verilmesi gerekir eğer
bu kaynak geri verilmezse bu durumda resource leak(kaynak sızıntısı) oluşur.
Smart Pointer sınıfları bu kaynağın geri verileceğini garanti ederler ve bu işi
programcımın insiyatifinden kurtarırlar denilebilir. Bir nevi
C# Java gibi dillerdeki Garbage Collector mekanizmasını görürler
gibi düşünülebilir.
new ve delete operatörlerinin yaptığı işler aşağıdaki gibi ifade edilebilir.
-------------------------------------------------------*/
#include <memory>
#include <iostream>

using namespace std;


void* operator new(std::size_t size)
{
    cout << "operator new called for the size of : " << size << '\n';

    if(size == 0)
        ++size;

    if(void* ptr = malloc(size))
        return ptr;

    throw bad_alloc{};
}

void operator delete(void* ptr)noexcept
{
    cout << "operator delete called for the address of : "  << ptr << '\n';

    free(ptr);
}

class Ber
{
public:
    Ber()
    {
        cout << "Ber default ctor" << '\n';
        cout << "Ber ctor this : " << this << '\n';
    }
    ~Ber()
    {
        cout << "Ber destructor" << '\n';
        cout << "Ber dtor this : " << this << '\n';
    }

private:
    unsigned char buffer[1024];
};

int main()
{
    cout << "sizeof(Ber) : " << sizeof(Ber) << '\n';
    char mybuffer[sizeof(Ber)];

    cout << "mybuffer dizisinin adresi : " << (void*)mybuffer << '\n';
    Ber* p = new(mybuffer)Ber;

    cout << "p : " << p << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte bir tanımsız davranış söz konusudur. Bunun
nedeni placement new operatörünün kullanılmasından kaynaklı
olarak delete ile nesneye ait destructor'ın çağrılamamasından kaynaklıdır.
Burda dinamik olarak üretilmemmiş bir bellek bloğunun delete kullanılarak
bellek atılması da aynı şekilde tanımsız davranıştır.
Bu gibi durumlarda destructor doğrudan çağrılmalıdır.
-------------------------------------------------------*/
#include <memory>
#include <iostream>

using namespace std;

class Ber
{
public:
    Ber()
    {
        cout << "Ber default ctor" << '\n';
        cout << "Ber ctor this : " << this << '\n';
    }
    ~Ber()
    {
        cout << "Ber destructor" << '\n';
        cout << "Ber dtor this : " << this << '\n';
    }

private:
    unsigned char buffer[1024];
};

int main()
{
    cout << "sizeof(Ber) : " << sizeof(Ber) << '\n';
    char mybuffer[sizeof(Ber)];

    cout << "mybuffer dizisinin adresi : " << (void*)mybuffer << '\n';
    Ber* p = new(mybuffer)Ber;

    cout << "p : " << p << '\n';

    delete p; //ub
}
/*--------------------------------------------------------
Yukarıdaki problemin çözümü aşağıdaki gibi destructor çağrısının
doğrudan yapılmasıyla çözülebilir.
-------------------------------------------------------*/
#include <memory>
#include <iostream>

using namespace std;

class Ber
{
public:
    Ber()
    {
        cout << "Ber default ctor" << '\n';
        cout << "Ber ctor this : " << this << '\n';
    }
    ~Ber()
    {
        cout << "Ber destructor" << '\n';
        cout << "Ber dtor this : " << this << '\n';
    }

private:
    unsigned char buffer[1024];
};

int main()
{
    cout << "sizeof(Ber) : " << sizeof(Ber) << '\n';
    char mybuffer[sizeof(Ber)];

    cout << "mybuffer dizisinin adresi : " << (void*)mybuffer << '\n';
    Ber* p = new(mybuffer)Ber;

    cout << "p : " << p << '\n';

    p->~Ber();
}
/*--------------------------------------------------------
C++ dilinde 3 farklı new operatörü bulunmaktadır bunlar:
1-)normal new:Bu new operatörüyle yaratılan dinamik ömürlü
nesneler normal delete operatörüyle bellekten atılabilir. Bu
kaynağı array new veya sadece destructor çağrısı ile geri verilmeye çalışması
Tanımsız davranışa neden olur. Örneğin Myclass bir sınıf olmak üzere
normal new operatörü aşağıdaki gibi kullanılabilir:

p = new Myclass();
delete p;

2-)array new:Array new kullanılarak yaratılan dinamik ömürlü nesneler
array delete operatörüyle bellekten free edilmelidir. Aksi durumda
resource leak(kaynak sızıntısı) veya undefined behaviour oluşabilir.
Kısaca kaynak aşağıdaki örnekteki gibi geri verilip bellek free edilmelidir.

p = new Myclass[expresion];
delete[] p;

3-)placement new:Bu operatörle elde edilen kaynak mutlaka
doğrudan bir destructor çağrısı kullanılarak yapılmalıdır.
Bu durumda delete operatörünün kullanılması durumunda bir undefined
behaviour söz konusu olacaktır.

p = new(address) Myclass;
p->~Myclass();

Not:new operatörü malloc fonksiyonuyla her ne kadar çok benzese de arada
önemli bir fark vardır bu fark malloc fonksiyonu başarısız olduğu durumda
null pointer döndürürken new operatörü başarısız olma durumunda exception
sınıfından kalıtım yoluyla elde edilmiş bad_alloc sınıfı türünden bir exception
throw eder bu nedenle malloc da olduğu gibi bir başarısızlık kontrolü
gerçekleştirilemez.

Standart kütüphanenin
set_new_handler işleviyle kayıt edilen fonksiyon neler yapabilir?

1-)öyle bir koda sahiptir ki kod çalıştığında operatör new fonksiyonu başarılı olur.
2-)set_new_handler'a nullptr ile gönderir. Böylece opeartor new bad_alloc throw eder.
3-)Kendisi bad_alloc ya da bad_alloc sınıfından kalıtım yoluyla elde edilmiş bir sınıf türünden exception throw eder.
4-)Kendisi (yer açma konusunda) başarısız olduğundan 2.bir fonksiyon kayıt eder.
Aşağıdaki örneği düzelt.
--------------------------------------------------------*/
#include <vector>
#include <iostream>
#include <string>

using namespace std;

vector <void*> vec;


void func()
{
    for(;;){
        vec.push_back(operator new(1024 * 1024 * 10));
        cout << '\n';
    }
}

void othernewhandler()
{
    static int count = 0;
    cout << "othernewhandler islevine yapılan " << ++count << ".cagri\n";
    (void)getchar();
    if(count == 10){
        set_new_handler(nullptr);
    }
}
void mynewhandler()
{
    static int count = 0;
    cout << "mynewhandler islevine yapılan " << ++count << ".cagri\n";
    (void)getchar();
    if(count == 10){
        set_new_handler(othernewhandler);
    }
}


int main()
{
    auto fp = set_new_handler(mynewhandler);
    try{
        func();
    }
    catch (const exception& ex){
        cout << "exception caught : " << ex.what() << '\n';
    }
}
/*--------------------------------------------------------
unique_ptr'ın kullanımı aşağıdaki gibi olabilir
-------------------------------------------------------*/
#include <memory>
#include <iostream>
#include <string>

using namespace std;

int main()
{
    unique_ptr<int> upx;
    unique_ptr<string> upy;
}

/*--------------------------------------------------------
upx nesnesi eğer bir elemana bağlanmamışsa bu durumda
operatör bool fonkisyonu false değer üretecektir yani
aşağıdaki gibi bir if deyimiyle bu akıllı pointer nesnesinin
dolu veya boş olduğu tespit edilebilir.
-------------------------------------------------------*/
#include <memory>
#include <iostream>

using namespace std;

int main()
{
    unique_ptr<int> upx;

    if(upx)
        cout << "ben doluyum" << '\n';
    else
        cout << "ben bosum";

}

/*--------------------------------------------------------
Aşağıdaki örnekte bu kez upx dolu olduğundan dolayı true değer
üretilecektir.
-------------------------------------------------------*/
#include <memory>
#include <iostream>
#include <string>

using namespace std;

int main()
{
    unique_ptr<int> upx{new int{24}};

    cout << "upx = " << (upx ? "dolu" : "bos") << '\n';
}

/*--------------------------------------------------------
Boş olan bir smart pointer nesnesinin dereferencing operatörüyle
birlikte kullanımı tanımsız davranışa neden olur. Bunun sebebi
tahmin edilebileceği gibi o pointerın bir nesneyi göstermemesindendir.
Ancak burda exception throw edilmesi durumu da söz konusu değildir.
-------------------------------------------------------*/
#include <memory>
#include <iostream>
#include <string>

using namespace std;

int main()
{
    unique_ptr<int> upx;

    try{
        cout << *upx << '\n';//ub
    }
    catch(const exception& ex){
        cout << "exception caught : " << ex.what() << '\n';
    }
}
/*--------------------------------------------------------
Bir unique_ptr nesnesine ilk değer olarak bir incomplete type olabilir.
ancak bir fonksiyonu prototip üzerinden çağırma girişimi
undefined reference olarak değerlendirilir.
-------------------------------------------------------*/
#include <memory>
#include <iostream>

using namespace std;

class Myclass{};

void foo();

int main()
{
    unique_ptr<Myclass> uptr (new Myclass);

    foo();//error
}
/*--------------------------------------------------------
Aşağıdaki örnekteki gibi bir atama C++'ta geçersizdir. Bunun
nedeni
-------------------------------------------------------*/
#include <memory>
#include <iostream>
#include <string>

using namespace std;

class Myclass{};

int main()
{
    unique_ptr<Myclass> uptr = new Myclass;
}
/*--------------------------------------------------------
Aşağıdaki örnekte bir tanımsız davranış söz konusudur.
Burda bir raw pointer bir akıllı pointera doğrudan atanmak
istenmiştir ve bu durum bir tanımsız davranışa neden olur.
Bu gibi durumlarda make_unique fonksiyonunu kullanmak gerekmektedir.
-------------------------------------------------------*/
#include <memory>

using namespace std;

class Myclass{};

int main()
{
    Myclass m{};
    Myclass* p = &m;
    unique_ptr<Myclass> uptr(p);
}

/*--------------------------------------------------------
Aşağıdaki gibi bir durumda akıllı pointer artık unique olmadığından
dolayı burda gene bir tanımsız davranış söz konusudur.
-------------------------------------------------------*/
#include <memory>
#include <string>

using namespace std;

class Myclass{};

int main()
{
    auto pd = new Myclass{};
    unique_ptr<Myclass> upx(pd);
    unique_ptr<Myclass> upy(pd);
}
/*--------------------------------------------------------
Aşağıdaki örnekte main devam ediyor yazısından önce Myclass
sınıfının destructor çağrısı gerçekleştirilecektir.
-------------------------------------------------------*/
#include <memory>
#include <iostream>
#include <string>

using namespace std;

class Myclass{
public:
    Myclass()
    {
        cout << "Myclass ctor" << '\n';
    }
    ~Myclass()
    {
        cout << "Myclass dtor" << '\n';
    }
};

int main()
{
    {
        unique_ptr<Myclass> uniquePtr(new Myclass);
        cout << uniquePtr << '\n';
    }

    cout << "Main devam ediyor" << '\n';
}

/*--------------------------------------------------------
standart make unique fonksiyonu aşağıdaki gibi bir fonksiyondur.
-------------------------------------------------------*/
#include <iostream>
#include <memory>

using namespace std;

template<typename T,typename ...Args>
unique_ptr<T> MakeUnique(Args &&...args)
{
	return unique_ptr<T>{new T(forward<Args>(args)...)};
}

int main()
{
	
}
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
#include <iostream>
#include <memory>

using namespace std;

class Date {
public:
	Date(int day, int month, int year)
	{
		m_day = day;
		m_month = month;
		m_year = year;
	}
private:
	int m_day, m_month, m_year;
};

template<typename T,typename ...Args>
unique_ptr<T> MakeUnique(Args &&...args)
{
	return unique_ptr<T>{new T(forward<Args>(args)...)};
}

int main()
{
	auto uptr = MakeUnique<Date>( 1,5,2055 );
}
/*--------------------------------------------------------
Standart make_unique fonksiyonu
-------------------------------------------------------*/
#include <iostream>
#include <memory>


using namespace std;

class Date {
public:
	Date(int day, int month, int year)
	{
		m_day = day;
		m_month = month;
		m_year = year;
	}
	int getDay()
	{
		return m_day;
	}
	int getMonth()
	{
		return m_month;
	}
	int getYear()
	{
		return m_year;
	}
private:
	int m_day, m_month, m_year;
};

void func(unique_ptr<Date>);

int main()
{
	auto uptr = make_unique<Date>(1,2,1987);

	cout << uptr->getMonth() << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte görüldüğü gibi bir unique_ptr ın Date 
açılımı türünden bir parametre değişkenine sahip olan 
func fonksiyonuna argüman olarak 3 değişik ifade gönderilebilir.
-------------------------------------------------------*/
#include <iostream>
#include <memory>


using namespace std;

class Date {
public:
	Date()
	{
		m_day = m_month = m_year = 1;
	}
	Date(int day, int month, int year)
	{
		m_day = day;
		m_month = month;
		m_year = year;
	}
	int getDay()
	{
		return m_day;
	}
	int getMonth()
	{
		return m_month;
	}
	int getYear()
	{
		return m_year;
	}
private:
	int m_day, m_month, m_year;
};

void func(unique_ptr<Date>)
{

}

int main()
{
	auto uptr = make_unique<Date>(1,2,1987);

	func(move(uptr));
	func(make_unique<Date>());
	func(unique_ptr<Date>{new Date( 2,3,1998 )});
}
/*--------------------------------------------------------
Aşağıdaki örnekte en upx akıllı pointerı doluyken upx 
akıllı pointerı upy'ye taşındığı zaman upy akıllı pointerı dolu
hel gelirken son durumda upx pointerı dangling pointer durumuna 
gelecektir.
-------------------------------------------------------*/
#include <iostream>
#include <memory>


using namespace std;

class Date {
public:
	Date()
	{
		m_day = m_month = m_year = 1;
	}
	Date(int day, int month, int year)
	{
		m_day = day;
		m_month = month;
		m_year = year;
	}
	int getDay()
	{
		return m_day;
	}
	int getMonth()
	{
		return m_month;
	}
	int getYear()
	{
		return m_year;
	}
private:
	int m_day, m_month, m_year;
};


int main()
{
	auto upx = make_unique<Date>(1,2,1987);

	unique_ptr<Date> upy;

	cout << "upx : " << (upx ? "dolu" : "bos") << '\n';
	cout << "upy : " << (upy ? "dolu" : "bos") << '\n';
	upy = move(upx);
	cout << "upx : " << (upx ? "dolu" : "bos") << '\n';
	cout << "upy : " << (upy ? "dolu" : "bos") << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte bir taşıma semantiği kullanımı olduğu 
için yalnızca 1 2 1987 tarihi için destructor çağrısı
gerçekleştirilecektir.
-------------------------------------------------------*/
#include <iostream>
#include <memory>

using namespace std;

class Date {
public:
	Date()
	{
		m_day = m_month = m_year = 1;
	}
	Date(int day, int month, int year)
	{
		m_day = day;
		m_month = month;
		m_year = year;
	}
	int getDay()
	{
		return m_day;
	}
	int getMonth()
	{
		return m_month;
	}
	int getYear()
	{
		return m_year;
	}
	~Date()
	{
		cout << m_day << '.' << m_month << '.' << m_year << " tarihi destroy ediliyor." << '\n';
	}
private:
	int m_day, m_month, m_year;
};


int main()
{
	auto upx = make_unique<Date>(1,2,1987);
	auto upy = make_unique<Date>(5,5,1955);

	upx = move(upy);
	(void)getchar();
}
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
#include <iostream>
#include <memory>


using namespace std;

class Date {
public:
	Date()
	{
		m_day = m_month = m_year = 1;
	}
	Date(int day, int month, int year)
	{
		m_day = day;
		m_month = month;
		m_year = year;
	}
	int getDay()
	{
		return m_day;
	}
	int getMonth()
	{
		return m_month;
	}
	int getYear()
	{
		return m_year;
	}
	~Date()
	{
		cout << m_day << '.' << m_month << '.' << m_year << " tarihi destroy ediliyor." << '\n';
	}
private:
	int m_day, m_month, m_year;
};

unique_ptr<Date> func(unique_ptr<Date> x)
{
	return x;
}

int main()
{
	auto y = func(make_unique<Date>(1,4,1987));
	(void)getchar();
}
/*--------------------------------------------------------
Aşağıdaki örnekte reset fonksiyonu çağrıldığında 1 4 1987
tarihi için destructor çağrısı gerçekleştirilir. getchar 
çağrısında sonra ise 3 3 1933 tarihi için destructor 
çağrılır. Destructor çağrısına kadar uptr reset fonksiyonundan
sonra 3 3 1933 tarihini gösteren bir akıllı pointer haline gelmiştir.
-------------------------------------------------------*/
#include <iostream>
#include <memory>


using namespace std;

class Date {
public:
	Date()
	{
		m_day = m_month = m_year = 1;
	}
	Date(int day, int month, int year)
	{
		m_day = day;
		m_month = month;
		m_year = year;
	}
	int getDay()
	{
		return m_day;
	}
	int getMonth()
	{
		return m_month;
	}
	int getYear()
	{
		return m_year;
	}
	~Date()
	{
		cout << m_day << '.' << m_month << '.' << m_year << " tarihi destroy ediliyor." << '\n';
	}
private:
	int m_day, m_month, m_year;
};

unique_ptr<Date> func(unique_ptr<Date> x)
{
	return x;
}

int main()
{
	auto uptr = func(make_unique<Date>(1,4,1987));
	uptr.reset(new Date(3,3,1933));
	(void)getchar();
}
/*--------------------------------------------------------
standart release fonksiyonu ve test kodu.
Aşağıdaki örnekte bir akıllı pointer nesnesi bir normal 
pointera devredildiği için delete manuel olarak çağrılmalıdır
aksi durumda memory leak oluşur.
-------------------------------------------------------*/
#include <iostream>
#include <memory>


using namespace std;

class Date {
public:
	Date()
	{
		m_day = m_month = m_year = 1;
	}
	Date(int day, int month, int year)
	{
		m_day = day;
		m_month = month;
		m_year = year;
	}
	int getDay()
	{
		return m_day;
	}
	int getMonth()
	{
		return m_month;
	}
	int getYear()
	{
		return m_year;
	}
	~Date()
	{
		cout << m_day << '.' << m_month << '.' << m_year << " tarihi destroy ediliyor." << '\n';
	}
private:
	int m_day, m_month, m_year;
};



int main()
{
	unique_ptr<Date> uptr{ new Date{11,11,2011}};
	
	Date* dateptr = uptr.release();
	(void)getchar();
}
/*--------------------------------------------------------
Yukarıdaki örnekte oluşan memory leak durumu delete operatörünün
çağrılmasıyla çözülebilir. Bu durumda pointer bir akıllı 
pointer olmadığından dolayı kendi kendini delete etmeyecektir.
-------------------------------------------------------*/
#include <iostream>
#include <memory>


using namespace std;

class Date {
public:
	Date()
	{
		m_day = m_month = m_year = 1;
	}
	Date(int day, int month, int year)
	{
		m_day = day;
		m_month = month;
		m_year = year;
	}
	int getDay()
	{
		return m_day;
	}
	int getMonth()
	{
		return m_month;
	}
	int getYear()
	{
		return m_year;
	}
	~Date()
	{
		cout << m_day << '.' << m_month << '.' << m_year << " tarihi destroy ediliyor." << '\n';
	}
private:
	int m_day, m_month, m_year;
};



int main()
{
	unique_ptr<Date> uptr{ new Date{11,11,2011}};
	
	cout << "uptr : " << (uptr ? "dolu" : "bos") << '\n';
	Date* dateptr = uptr.release();
	cout << "uptr : " << (uptr ? "dolu" : "bos") << '\n';
	
	delete dateptr;
}
/*--------------------------------------------------------
Aşağıdaki örnekte otomatik ömürlü bir Date nesnesi bir smart 
pointera atandığından burda smart pointer için destructor 
çağrısı yapılacaktır.
-------------------------------------------------------*/
#include <iostream>
#include <memory>


using namespace std;

class Date {
public:
	Date()
	{
		m_day = m_month = m_year = 1;
	}
	Date(int day, int month, int year)
	{
		m_day = day;
		m_month = month;
		m_year = year;
	}
	int getDay()
	{
		return m_day;
	}
	int getMonth()
	{
		return m_month;
	}
	int getYear()
	{
		return m_year;
	}
	friend ostream& operator<< (ostream& out, const Date& date) {
		out << date.m_day << '.' << date.m_month << '.' << date.m_year;
		return out;
	}
	Date& operator*() {
		return *this;
	}
	~Date()
	{
		cout << m_day << '.' << m_month << '.' << m_year << " tarihi destroy ediliyor." << '\n';
	}
private:
	int m_day, m_month, m_year;
};



int main()
{
	Date mydate{2,2,1922};
	unique_ptr<Date> uptr{ new Date{23,3,1987} };

	cout << *uptr << '\n';
	*uptr = mydate;
	cout << *uptr << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte ise uptr akıllı pointerı için reset fonksiyonu 
çağrılıp Date sınıfının default constructorı çağrılacaktır.
bu yüzden son durumda hem default ctor ile oluşturulan 
nesne için destructor çağrılacaktır aynı zamanda otomatik 
ömürlü mydate nesnesi için de
Anahtar Notlar:Bu örnek mydate nesnesi otomatik ömürlü bir sınıf nesnesi
olduğundan bunun için delete operatörünün çağrılmasına gerek
yoktur bu ancak dinamik olarak new operatörüyle oluşturulmuş
sınıf nesneleriyle ilgilidir.
-------------------------------------------------------*/
#include <iostream>
#include <memory>


using namespace std;

class Date {
public:
	Date()
	{
		m_day = m_month = m_year = 1;
	}
	Date(int day, int month, int year)
	{
		m_day = day;
		m_month = month;
		m_year = year;
	}
	int getDay()
	{
		return m_day;
	}
	int getMonth()
	{
		return m_month;
	}
	int getYear()
	{
		return m_year;
	}
	friend ostream& operator<< (ostream& out, const Date& date) {
		out << date.m_day << '.' << date.m_month << '.' << date.m_year;
		return out;
	}
	Date& operator*() {
		return *this;
	}
	~Date()
	{
		cout << m_day << '.' << m_month << '.' << m_year << " tarihi destroy ediliyor." << '\n';
	}
private:
	int m_day, m_month, m_year;
};



int main()
{
	Date mydate{2,2,1922};
	unique_ptr<Date> uptr{ new Date{23,3,1987} };

	cout << *uptr << '\n';
	uptr.reset(new Date);
	cout << *uptr << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte pdate dinamik ömürlü nesnesi uptr smart 
pointerına atanırken smart pointer için destructor çağrısı
gerçekleştirileceği için o dinamik ömürlü nesne için de
tekrar bir delete operatörü kullanımına gerek yoktur.
Adresler elde edildiğinde aynı bu adreslerin aynı olması 
bunun bir kanıdı olarak görülebilir.
-------------------------------------------------------*/
#include <iostream>
#include <memory>


using namespace std;

class Date {
public:
	Date()
	{
		m_day = m_month = m_year = 1;
	}
	Date(int day, int month, int year)
	{
		m_day = day;
		m_month = month;
		m_year = year;
	}
	int getDay()
	{
		return m_day;
	}
	int getMonth()
	{
		return m_month;
	}
	int getYear()
	{
		return m_year;
	}
	friend ostream& operator<< (ostream& out, const Date& date) {
		out << date.m_day << '.' << date.m_month << '.' << date.m_year;
		return out;
	}
	Date& operator*() {
		return *this;
	}
	~Date()
	{
		cout << m_day << '.' << m_month << '.' << m_year << " tarihi destroy ediliyor." << '\n';
	}
private:
	int m_day, m_month, m_year;
};



int main()
{
	auto pdate = new Date{2,2,1922};
	cout << "dinamik date nesnesinin adresi : " << pdate << '\n';
	unique_ptr<Date> uptr{ pdate };

	auto p = uptr.get();

	cout << "up.get() : " << p << '\n';

	(void)getchar();
}
/*--------------------------------------------------------
up bir smart pointer olmak üzere up 4 farklı şekilde 
dangling hale getirilebilir:
up.reset();
up.reset(nullptr);
up = nullptr;
ur.release();
-------------------------------------------------------*/
/*--------------------------------------------------------
get fonksiyonu eğer nesne boş ise sadece sıfırlardan oluşan
bir adres elde eder.
-------------------------------------------------------*/
#include <memory>
#include "Date.h"

using namespace std;

int main()
{
	unique_ptr<Date> up{};

	cout << up.get() << '\n';
}
/*--------------------------------------------------------
Eğer nesne doluysa bu durumda o nesneye ait olan adres elde 
edilir.
-------------------------------------------------------*/
#include <memory>
#include "Date.h"

using namespace std;

int main()
{
	unique_ptr<Date> up{new Date(2,3,1987)};

	cout << up.get() << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekteki kod geçersizdir. uptr nesnesi unique_ptr
türünün date,f fonksiyonunun türü şeklinde elde edilecektir.
ancak burda Date nesnesi türünden bu türe doğrudan dönüşüm olmadığından
syntax hatası oluşacaktır.
-------------------------------------------------------*/
#include <memory>
#include "Date.h"

using namespace std;

int main()
{
	auto f = [](Date* p)
	{
		cout << *p << "nesnesi delete ediliyor" << '\n';
		delete p;
	};

	unique_ptr<Date,decltype(f)> up{new Date(2,3,1987)}; //error

	cout << up.get() << '\n';
}
/*--------------------------------------------------------
Aşağıdaki kodda bir syntax hatası söz konusudur.
-------------------------------------------------------*/
#include <memory>
#include <iostream>

using namespace std;

struct List {};

typedef struct List* ListHandle;

ListHandle create_list(void)
{
	ListHandle handle = (ListHandle)malloc(1000);
	//code
	cout << "list olusturuldu" << '\n';
	return handle;
}

void destroy_list(ListHandle handle)
{
	cout << "liste sonlandirildi" << '\n';
	free(handle);
}

int main()
{
	auto f = [](ListHandle b)
	{
		destroy_list(b);
	};

	unique_ptr<List, decltype(f)> up( create_list(),f);
}
/*--------------------------------------------------------
bir smart pointer kullanarak dosyaya C tarzı yazı yazdırma
-------------------------------------------------------*/
#define _CRT_SECURE_NO_WARNINGS

#include <memory>
#include <iostream>

using namespace std;



int main()
{
	auto fdel = [](FILE* f)
	{
		if (f)
			fclose(f);
	};

	unique_ptr<FILE, decltype(fdel)> up(fopen("berke.txt","w"), fdel);

	fprintf(up.get(),"bugun hava cok guzel.");
}
/*--------------------------------------------------------
get_deleter fonksiyonun türü struct std::default_delete<class Date>
türüdür. Bu fonksiyon çağrılması sonucu auto ile type deduction
yapılıp aşağıdaki örnekte typeid operatörü yardımıyla ekran 
çıktısı elde edilmiştir.
-------------------------------------------------------*/
#include <memory>
#include <iostream>
#include "Date.h"

using namespace std;



int main()
{
	auto uptr = make_unique<Date>(1,4,1987);

	auto mydeleter = uptr.get_deleter();

	cout << typeid(mydeleter).name() << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte delete operatörü çağrılırken pdate zaten
uptr'nin bir akıllı olmasından dolayı zaten delete edilecektir.
pdate nesnesi ise uptr nesnesini göstermektedir. Bu nesnenin
destroy edilmesi yani bu nesne için delete operatörünün 
çağrılması durumunda bu nesne ile birlikte aslında uptr da 
delete edilecektir. Ancak bu bir akıllı pointer nesnesi olduğundan 
tekrardan destroy edilme girişiminde bulunulması sonucu 
terminate fonksiyonu çağrılacaktır. Hatayı düzeltmek 
için delete işlemi silinmelidir.
-------------------------------------------------------*/
#include <memory>
#include <iostream>
#include "Date.h"

using namespace std;



int main()
{
	unique_ptr<Date> uptr{ new Date{1, 4, 1987} };

	auto pdate = uptr.get();

	delete pdate;
}
/*--------------------------------------------------------
Aşağıdaki örnekte her elemanı unique_ptr türünden olan bir 
vector containerı örneği görülmektedir. emplace_back ile eklenen
Date nesnesi pop_back fonksiyonu kullanılarak çıkartılmasaydı
bu durumda bir smart pointer nesnesi olduğu için bu durumda
nesne gene de delete edilecekti.
-------------------------------------------------------*/
#include <memory>
#include <iostream>
#include <vector>
#include "Date.h"

using namespace std;



int main()
{
	vector<unique_ptr<Date>> myvec;

	for (int i = 0; i < 100; ++i) {
		myvec.push_back(make_unique<Date>(Date::random()));
	}
	myvec.emplace_back(new Date{1,4,1987});

	myvec.pop_back();
}

/*--------------------------------------------------------
Bu örnekteki durumda ise getchar çağrısından önce new operatörüyle
yaratılmış Date nesnesi için destructor çağrısı gerçekleştirilecektir.
Ancak yukarıdaki örnekte olduğu gibi bu nesneler unique_ptr
türünden olsaydı destructor çağrısı gerçekleştirilmeyecekti.
-------------------------------------------------------*/
#include <memory>
#include <iostream>
#include <vector>
#include "Date.h"

using namespace std;



int main()
{
	vector<unique_ptr<Date>> myvec;

	myvec.reserve(100);
	myvec.emplace_back(new Date{1,4,1987});

	myvec.pop_back();
	(void)getchar();
}
/*--------------------------------------------------------
Aşağıdaki örnekteki kod C++ için resmen bir saatli bombadır.
Bu kodda eğer bir exception fırlatılırsa bu durumda asla delete 
işlemi gerçekleştirilmeyecektir. Kısacası kod exception throw
ederse bir kaynak sızıntısı(resource leak) oluşacaktır.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

class Myclass {
public:
	~Myclass()
	{
		cout << "Myclass destructor" << '\n';
	}
};

void foo()
{
	throw runtime_error{"error\n"};
}

void func()
{
	Myclass* p = new Myclass;
	foo();
	delete p;
}

int main()
{
	try {
		func();
	}
	catch (const exception& ex) {
		cout << "exception caught : " << ex.what() << '\n';
	}
}
/*--------------------------------------------------------
Yukarıdaki problemin çözümü bunu bir raw pointer yerine bir 
smart pointer nesnesi kullanılarak yapılabilir. Bu durumda 
exception throw edilse dahi Myclass sınıfına ait destructor çağrısı 
gerçekleştirilecektir.
-------------------------------------------------------*/
#include <memory>
#include <iostream>
#include <vector>
#include "Date.h"

using namespace std;

class Myclass {
public:
	~Myclass()
	{
		cout << "Myclass destructor" << '\n';
	}
};

void foo()
{
	throw runtime_error{"error\n"};
}

void func()
{
	unique_ptr<Myclass> p{ new Myclass };
	foo();
}

int main()
{
	try {
		func();
	}
	catch (const exception& ex) {
		cout << "exception caught : " << ex.what() << '\n';
	}
}
/*--------------------------------------------------------

-------------------------------------------------------*/
/*--------------------------------------------------------
Aşağıdaki kodu inceleyiniz.
-------------------------------------------------------*/
#include <memory>
#include <iostream>
#include <string>
#include "Date.h"

using namespace std;

class Myclass {
public:
	Myclass() = default;
	Myclass(const Myclass& other) : mptr{ new string(*other.mptr) } {}
	Myclass& operator=(Myclass&&) = default;
	Myclass& operator=(const Myclass& other)
	{
		mptr.reset(new string{ *other.mptr });
		return *this;
	}
private:
	unique_ptr<string> mptr;
};



int main()
{
	Myclass x, y;
}
/*--------------------------------------------------------
Aşağıdaki örnekte syntax hatasının nedeni Myclass sınıfının
incomplete type olmasından kaynaklanmaktadır.
-------------------------------------------------------*/
#include <memory>

using namespace std;

class Myclass;

int main()
{
	unique_ptr<Myclass>uptr;
}
/*--------------------------------------------------------
Ancak aşağıdaki örnekteki gibi bir yerde incomplete type 
olarak bırakıp diğer tarafta tanımlama yapılırsa bu durumda 
bu geçerli hale gelir.
-------------------------------------------------------*/
#include <memory>
#include "Myclass.h"

using namespace std;

int main()
{
	unique_ptr<Myclass>uptr;
}
//Myclass.cpp
#include "Myclass.h"

class Ber {

};

Myclass::~Myclass() = default;
//Myclass.h
#pragma once

#include <iostream>

class Ber;

class Myclass {
public:
	~Myclass();
private:
	std::unique_ptr<Ber> mptr;
};
/*--------------------------------------------------------
Pimpl idiomu
Ekleme yapılacak 
-------------------------------------------------------*/
/*--------------------------------------------------------

-------------------------------------------------------*/

/*--------------------------------------------------------
shared_ptr smart pointerı
-------------------------------------------------------*/
#include <memory>
#include <string>
#include "Myclass.h"

using namespace std;

class Person {
public:
	Person() = default;
	Person(string name, string surname)
	{
		m_name = name;
		m_surname = surname;
	}
	~Person()
	{
		cout << m_name << ' ' << m_surname << " kisisi destroy ediliyor" << "\n";
	}
private:
	string m_name, m_surname;
};

int main()
{
	shared_ptr<Person> sp{ new Person{"Anakin","Skywalker"} };

}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <memory>
#include <string>
#include "Myclass.h"

using namespace std;

class Person {
public:
	Person() = default;
	Person(string name, string surname)
	{
		m_name = name;
		m_surname = surname;
	}
	~Person()
	{
		cout << m_name << ' ' << m_surname << " kisisi destroy ediliyor" << "\n";
	}
private:
	string m_name, m_surname;
};

int main()
{
	shared_ptr<Person> sp{ new Person{"Anakin","Skywalker"},
						[](Person* p) {
							cout << "the object at the address : " << p << " is being destroyed\n";
							delete p; } 
						};
}
/*--------------------------------------------------------
make_unique fonksiyonu olduğu gibi standart make_shared fonksiyonu
da bulunmaktadır.shared_ptr adından da anlaşılabileceği gibi 
birden fazla değişken aynı nesneyi paylaşabilir. unique_ptr
için bu olay tek değişkenle sınırlıdır. Ancak taşımayla bu 
işlem unique_ptr ile bu legal hale getirilebilir.
-------------------------------------------------------*/
#include <memory>
#include <string>
#include <iostream>

using namespace std;

class Person {
public:
	Person() = default;
	Person(const string& name, const string& surname)
		: m_name(name), m_surname(surname) {}

	friend std::ostream& operator<<(std::ostream& os, const Person& p) {
		os << p.m_name << ' ' << p.m_surname;
		return os;
	}
	~Person() {
		cout << m_name << ' ' << m_surname << " is being destroyed\n";
	}
private:
	string m_name, m_surname;
};

int main()
{
	shared_ptr<Person> sp;

	auto sptr1 = make_shared<Person>("Kaya","Sertel");

	auto sptr2 = sptr1;

	sp = sptr1;

	cout << *sp << '\n';
	cout << *sptr1 << '\n';
	cout << *sptr2 << '\n';
}
/*--------------------------------------------------------
shared_ptr'ın use_count fonksiyonu kaç adet değişkenin 
söz konusu nesnenin kaynağını tuttuğunu elde etmektedir.
Aşağıdaki kodda ekran çıktısı aşağıdaki gibi olacaktır:
sp.use_count() : 0


sptr1.use_count() : 1

sptr1.use_count() : 2
sptr2.use_count() : 2

sptr1.use_count() : 3
sptr2.use_count() : 3
sp.use_count() : 3
Selami Karakelle
Selami Karakelle
Selami Karakelle
Selami Karakelle is being destroyed
-------------------------------------------------------*/
#include <memory>
#include <string>
#include <iostream>

using namespace std;

class Person {
public:
	Person() = default;
	Person(const string& name, const string& surname)
		: m_name(name), m_surname(surname) {}

	friend std::ostream& operator<<(std::ostream& os, const Person& p) {
		os << p.m_name << ' ' << p.m_surname;
		return os;
	}
	~Person() {
		cout << m_name << ' ' << m_surname << " is being destroyed\n";
	}
private:
	string m_name, m_surname;
};

int main()
{
	shared_ptr<Person> sp;
	cout << "sp.use_count() : " << sp.use_count() << '\n';
	(void)getchar();

	auto sptr1 = make_shared<Person>( "Selami","Karakelle" );

	(void)getchar();
	cout << "sptr1.use_count() : " << sptr1.use_count() << '\n';

	auto sptr2 = sptr1;
	(void)getchar();
	cout << "sptr1.use_count() : " << sptr1.use_count() << '\n';
	cout << "sptr2.use_count() : " << sptr2.use_count() << '\n';

	sp = sptr1;
	(void)getchar();

	cout << "sptr1.use_count() : " << sptr1.use_count() << '\n';
	cout << "sptr2.use_count() : " << sptr2.use_count() << '\n';
	cout << "sp.use_count() : " << sp.use_count() << '\n';

	cout << *sp << '\n';
	cout << *sptr1 << '\n';
	cout << *sptr2 << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte iki person nesnesi için destructor çağrısı
gerçekleştirilecektir.
-------------------------------------------------------*/
#include <memory>
#include <string>
#include <iostream>

using namespace std;

class Person {
public:
	Person() = default;
	Person(const string& name, const string& surname)
		: m_name(name), m_surname(surname) {}

	friend std::ostream& operator<<(std::ostream& os, const Person& p) {
		os << p.m_name << ' ' << p.m_surname;
		return os;
	}
	~Person() {
		cout << m_name << ' ' << m_surname << " is being destroyed\n";
	}
private:
	string m_name, m_surname;
};

int main()
{
	Person* p = new Person{"Batuhan","Menkuer"};
	shared_ptr<Person> sptr(p);

	auto sptr_2 = make_shared<Person>("Kaya","Sertel");
}
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
struct Ber {
	char mbuf[1024];
};

void foo()
{
	cout << "foo cagrildi\n";
	auto pn = new Ber;
	shared_ptr<Ber> sptr{ pn };
	cout << '\n';
}

int main()
{
	cout << "sizeof(Ber) : " << sizeof(Ber) << '\n';

	foo();
}
/*--------------------------------------------------------
Aşağıdaki örnekte use_count fonksiyonu toplam kaynağı 5 
olarak elde edecektir.
-------------------------------------------------------*/
#include <memory>
#include <string>
#include <iostream>

using namespace std;

int main()
{
	auto sp = make_shared<string>("mehmet");

	auto x = sp;
	auto y = sp;
	auto z = sp;
	auto t = sp;

	if (sp) {
		cout << "dolu, kaynagi var\n";
		cout << sp.use_count() << '\n';
	}
	else {
		cout << "bos kaynak yok\n";
	}
}
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
#include <memory>
#include <string>
#include <iostream>

using namespace std;

int main()
{
	auto sp = make_shared<string>("mehmet");

	auto x = sp;
	auto y = sp;
	auto z = sp;
	auto t = sp;

	auto ps = x.get();

	x.reset(new string{"tacettin"});

	cout << "x.use_count : " << x.use_count() << '\n';

	if (sp) {
		cout << "dolu, kaynagi var\n";
		cout << sp.use_count() << '\n';
	}
	else {
		cout << "bos kaynak yok\n";
	}
}

/*--------------------------------------------------------

-------------------------------------------------------*/
#include <memory>
#include <string>
#include <iostream>
#include <vector>
#include <random>

using namespace std;

class Person {
public:
	Person() = default;
	Person(const string& name, const string& surname)
		: m_name(name), m_surname(surname) {}

	friend std::ostream& operator<<(std::ostream& os, const Person& p) {
		os << p.m_name << ' ' << p.m_surname;
		return os;
	}
	~Person() {
		cout << m_name << ' ' << m_surname << " is being destroyed\n";
	}
private:
	string m_name, m_surname;
};

string rname()
{
	vector<string> names = { "John", "Jane", "Michael", "Emily", "David", "Sophie", "William", "Olivia", "James", "Isabella" };
	mt19937 rng(random_device{}());
	uniform_int_distribution<int> dist(0, names.size() - 1);
	return names[dist(rng)];
}

string rsurname()
{
	vector<string> surnames = { "Smith", "Johnson", "Williams", "Jones", "Brown", "Davis", "Miller", "Wilson", "Moore", "Taylor" };
	mt19937 rng(random_device{}());
	uniform_int_distribution<int> dist(0, surnames.size() - 1);
	return surnames[dist(rng)];
}

void foo()
{
	throw runtime_error{ "error" };
}

int main()
{
	vector<Person*> pvec;

	for (int i = 0; i < 10; ++i) {
		pvec.emplace_back(new Person{rname(),rsurname()});
	}

	for (const auto& sptr : pvec) {
		cout << *sptr << '\n';
	}

	try {
		foo();
	}
	catch (const exception& ex) {
		cout << "exception caught : " << ex.what() << '\n';
	}
}
/*--------------------------------------------------------
Aşağıdaki örnekte tahmin edilebileceği gibi use_count fonksiyonunun
üreteceği değer 1 olacaktır.
-------------------------------------------------------*/
#include <memory>
#include <string>
#include <iostream>
#include <vector>

using namespace std;

class Person {
public:
	Person() = default;
	Person(const string& name, const string& surname)
		: m_name(name), m_surname(surname) {}

	friend std::ostream& operator<<(std::ostream& os, const Person& p) {
		os << p.m_name << ' ' << p.m_surname;
		return os;
	}
	~Person() {
		cout << m_name << ' ' << m_surname << " is being destroyed\n";
	}
private:
	string m_name, m_surname;
};

int main()
{
	auto sp = make_shared<Person>("Nurullah","Gulersoy");
	cout << *sp << '\n';
	cout << "use count = " << sp.use_count() << '\n';
}
/*--------------------------------------------------------
weak_ptr C++'ta en az kullanılan smart pointer sınıfıdır.
Bu smart pointer shared_ptr'a yardımcı olan bir smart pointerdır.
Aşağıdaki örnekte anlatılmak istenen bir weak_ptr nesnesinin
shared_ptr nesnesinin referans sayacını arttırmayacağını
göstermektir. Aynı zamanda lock fonksiyonu kullanılarak 
shared_ptr'ın operator bool fonksiyonu gibi kullanılarak 
o nesnenin dolu olup olmadığını sorgulayabilir.
-------------------------------------------------------*/
#include <memory>
#include <string>
#include <iostream>
#include <vector>

using namespace std;

class Person {
public:
	Person() = default;
	Person(const string& name, const string& surname)
		: m_name(name), m_surname(surname) {}

	friend std::ostream& operator<<(std::ostream& os, const Person& p) {
		os << p.m_name << ' ' << p.m_surname;
		return os;
	}
	~Person() {
		cout << m_name << ' ' << m_surname << " is being destroyed\n";
	}
private:
	string m_name, m_surname;
};

void foo()
{
	throw runtime_error{ "error" };
}

int main()
{
	auto sp = make_shared<Person>("Nurullah","Gulersoy");
	cout << *sp << '\n';
	cout << "use count = " << sp.use_count() << '\n';

	weak_ptr<Person> wp{sp};
	cout << "sp.use_count() : " << sp.use_count() << '\n';
	cout << "wp.use_count() : " << wp.use_count() << '\n';

	sp.reset();

	auto spx = wp.lock();

	if (spx) {
		cout << "kaynak halen hayatta\n";
		cout << *spx << '\n';
	}
	else {
		cout << "kaynak sonlanmis\n";
	}
	(void)getchar();
}
/*--------------------------------------------------------
weak_ptr'ın expired fonksiyonu ile ona bağlı olan shared 
ptr nesnesinin sonlanıp sonlanmadığını anlayabiliriz.
-------------------------------------------------------*/
#include <memory>
#include <string>
#include <iostream>
#include <vector>

using namespace std;

class Person {
public:
	Person() = default;
	Person(const string& name, const string& surname)
		: m_name(name), m_surname(surname) {}

	friend std::ostream& operator<<(std::ostream& os, const Person& p) {
		os << p.m_name << ' ' << p.m_surname;
		return os;
	}
	~Person() {
		cout << m_name << ' ' << m_surname << " is being destroyed\n";
	}
private:
	string m_name, m_surname;
};

void foo()
{
	throw runtime_error{ "error" };
}

int main()
{
	auto sp = make_shared<Person>("Nurullah","Gulersoy");
	cout << *sp << '\n';
	cout << "use count = " << sp.use_count() << '\n';

	weak_ptr<Person> wp{sp};
	cout << "sp.use_count() : " << sp.use_count() << '\n';
	cout << "wp.use_count() : " << wp.use_count() << '\n';

	//sp.reset();

	if (!wp.expired()) {
		cout << "kaynak halen hayatta\n";
		cout << *spx << '\n';
	}
	else {
		cout << "kaynak sonlanmis\n";
	}
}
/*--------------------------------------------------------
Aşağıdaki örnekte shared_ptr<B> türünden bir eleman kullanmak
yerine weak_ptr kullanılsaydı use_count yoluyla elde 
edilen referans sayacı artmayacağından dolayı buna yönelik 
bir problem oluşmayacaktı.
-------------------------------------------------------*/
#include <memory>
#include <string>
#include <iostream>
#include <vector>
#include <random>
#include "Person.h"

using namespace std;

struct B;

struct A {
	//her A nesnesinin bptr elemanı bir shared_pointer
	shared_ptr<B> bptr;
	//B* ptr;
	~A()
	{
		cout << "A destructor\n";
	}
};

struct B {
	shared_ptr<A> aptr;
	~B()
	{
		cout << "B destructor\n";
	}
};

int main()
{
	shared_ptr<A> pa{new A};
	shared_ptr<B> pb{ new B };

	pa->bptr = pb;
	pb->aptr = pa;

	cout << pb.use_count() << '\n';
	cout << pa.use_count() << '\n';
	cout << pa->bptr.use_count() << '\n';
	cout << pb->aptr.use_count() << '\n';
	(void)getchar();
}
/*--------------------------------------------------------
Aşağıdaki örnekte shared_ptr smart pointerı kullanılarak 
oluşturulduğundan bu nesneler için destructor çağrısı 
referans sayacının 2 olmasından dolayı gerçekleştirilemez.
O sebeple bu gibi durumlar için bu tip nesnelerinin
weak_ptr türünden olması gerekmektedir.
-------------------------------------------------------*/
#include <memory>
#include <string>
#include <iostream>

using namespace std;

class Cat {
public:
	Cat(const string name) : m_name{ name }
	{
		cout << "oyunda " << m_name << " isimli kedi olusturuldu.\n";
	}
	~Cat()
	{
		cout << m_name << " isimli kedi oyundan cikarildi.\n";
	}

	void cry()
	{
		cout << m_name << " miyavliyor\n";
	}
	string get_name()const
	{
		return m_name;
	}
	void display_friend_status()
	{
		if (mp_friend) {
			cout << "kedi : " << m_name << " bir arkadasa sahip... arkadasinin ismi : " << mp_friend->get_name() << '\n';
		}
		else {
			cout << "kedi : " << m_name << " bir arkadasa sahip degil\n";
		}
	}
	void make_friend(shared_ptr<Cat> x)
	{
		mp_friend = x;
		cout << m_name << " " << x->get_name() << " ile arkadas oldu\n";
	}
private:
	string m_name;
	shared_ptr<Cat> mp_friend;
};
int main()
{
	auto pcat1 = make_shared<Cat>("pamuk");
	auto pcat2 = make_shared<Cat>("karma");

	pcat1->display_friend_status();
	pcat2->display_friend_status();

	pcat1->make_friend(pcat2);
	pcat2->make_friend(pcat1); //1

	pcat1->display_friend_status();
	pcat2->display_friend_status();
}
/*--------------------------------------------------------
Yukarıdaki problemin çözümü orda nesnesin bir weak_ptr türünden
yapılmasıyla olabilir. Bununla birlikte referans sayacında 
bir artış olmayacağından bu nesneler için destructor çağrısı 
gerçekleştirilecektir.
-------------------------------------------------------*/
#include <memory>
#include <string>
#include <iostream>

using namespace std;

class Cat {
public:
	Cat(const string name) : m_name{ name }
	{
		cout << "oyunda " << m_name << " isimli kedi olusturuldu.\n";
	}
	~Cat()
	{
		cout << m_name << " isimli kedi oyundan cikarildi.\n";
	}

	void cry()
	{
		cout << m_name << " miyavliyor\n";
	}
	string get_name()const
	{
		return m_name;
	}
	void display_friend_status()
	{
		if (auto sp = mp_friend.lock()) {
			cout << "kedi : " << m_name << " bir arkadasa sahip... arkadasinin ismi : " << sp->get_name() << '\n';
		}
		else {
			cout << "kedi : " << m_name << " bir arkadasa sahip degil\n";
		}
	}
	void make_friend(shared_ptr<Cat> x)
	{
		mp_friend = x;
		cout << m_name << " " << x->get_name() << " ile arkadas oldu\n";
	}
private:
	string m_name;
	weak_ptr<Cat> mp_friend;
};
int main()
{
	auto pcat1 = make_shared<Cat>("pamuk");
	auto pcat2 = make_shared<Cat>("karma");

	pcat1->display_friend_status();
	pcat2->display_friend_status();

	pcat1->make_friend(pcat2);
	pcat2->make_friend(pcat1);

	pcat1->display_friend_status();
	pcat2->display_friend_status();
}
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
#include <memory>
#include <string>
#include <iostream>

class Ber : public enable_shared_from_this<Nec>{
public: 
    void func()
    {
    //ben hangi dinamik ömürlü nesne için çağrıldıysa
    //o dinamik ömürlü nesneyi gösteren shared_ptr 'nin
    //kopyasını oluşturmak istiyoruz.
    auto sp = shared_from_this();
    cout << sp.use_count() << '\n';
    (void)getchar();
    }
};

int main()
{
    Ber* pber = new Ber;

    try{
        pber->func();
    }
    catch(const exception ex){
        cout << "exception caught : " << ex.what() << '\n';
    }
}
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
#include <memory>
#include <string>
#include <iostream>
#include <vector>

using namespace std;
using namevec = vector<string>;

class NameList {
public:
	NameList() = default;
	NameList(initializer_list<string> slist) : msp_vec{ new namevec{slist} } {}
	void print()const
	{
		for (const auto& s : *msp_vec)
			cout << s << '\n';
		cout << '\n';
	}
	void add_name(string name)
	{
		msp_vec->push_back(std::move(name));
	}
	size_t size()const
	{
		return msp_vec->size();
	}
	void remove(const string& name)
	{
		erase(*msp_vec,name);
	}
private:
	shared_ptr<namevec> msp_vec;
};

int main()
{
	NameList x{"ali","canan","sezai","nurdan"};
    cout << "x listesinde " << x.size() << " isim var\n";
    x.print();
    NameList y{x};
    y.add_name("korhan");
    y.add_name("alican");

    cout << "x listesinde " << x.size() << " isim var\n";
    x.print();

    NameList z{y};

    z.remove("sezai");
    z.remove("ali");

    y.print();

    NameList a{"ece","tan","gul","eda"};

    a.print();
    z.print();
    NameList b{a};
    NameList c{a};

    c.add_name("tunc");
    b.add_name("ferda");

    a.print();
}
/*--------------------------------------------------------
taşıyıcı iteratörler(move iterators): Bu iteratör sınıfı
kopyalama yerine taşıma semantiğini kullandığından pek 
çok açıdan programcıya avantaj sağlayabilirler.
Aşağıdaki örnekte bir vector containerı bir list containerına taşınmıştır.
Bu işlemi yapmanın en kolay yolu move iterator kullanmaktır.
Aşağıdaki örnekte görüldüğü gibi son durumda vector containerında
bulunan elemanlar boş stringlerdir.
-------------------------------------------------------*/
#include <iomanip>
#include <string>
#include <iostream>
#include <vector>
#include <list>

using namespace std;


int main()
{
	vector<string> svec{
         "berke sertel",
         "mustafa yilmaz",
         "samet aybaba",
         "aziz yildirim",
         "suleyman seba",
    };

    list<string> slist{make_move_iterator(svec.begin()), make_move_iterator(svec.end())};

    for(const auto& s : svec){
        cout << quoted(s) << " ";
    }
    cout << '\n';
}
/*--------------------------------------------------------
Eğer move iterator değilde iterator doğrudan geçilseydi bu durumda
vector containerı son durumda boş olmayacaktı.
-------------------------------------------------------*/
#include <iomanip>
#include <string>
#include <iostream>
#include <vector>
#include <list>

using namespace std;


int main()
{
	vector<string> svec{
         "berke sertel",
         "mustafa yilmaz",
         "samet aybaba",
         "aziz yildirim",
         "suleyman seba",
    };

    list<string> slist{svec.begin(), svec.end()};

    for(const auto& s : svec){
        cout << quoted(s) << " ";
    }
    cout << '\n';
}
/*--------------------------------------------------------
move iterator aşağıdaki gibi using bildirimiyle de kullanılmaktadır.
Bu üretimde oldukça yaygın kullanılan bir yöntemdir.
-------------------------------------------------------*/
#include <iomanip>
#include <string>
#include <iostream>
#include <vector>
#include <list>

using namespace std;


int main()
{
	vector<string> svec{
         "berke sertel",
         "mustafa yilmaz",
         "samet aybaba",
         "aziz yildirim",
         "suleyman seba",
    };

    using moveIter = move_iterator<vector<string>::iterator>;

    list<string> slist{moveIter{svec.begin()},moveIter{svec.end()}};

    for(const auto& s : svec){
        cout << quoted(s) << " ";
    }
    cout << '\n';
}
/*--------------------------------------------------------
Bu örnek doğrudan standart move fonksiyonunun kullanımıyla
da yapılabilir.
-------------------------------------------------------*/
#include <iomanip>
#include <string>
#include <iostream>
#include <vector>
#include <list>

using namespace std;


int main()
{
	vector<string> svec{
         "berke sertel",
         "mustafa yilmaz",
         "samet aybaba",
         "aziz yildirim",
         "suleyman seba",
    };

    vector<string> destvec(svec.size());

    move(svec.begin(),svec.end(),destvec.begin());

    for(const auto& s : svec){
        cout << quoted(s) << " ";
    }
    cout << '\n';
}
/*--------------------------------------------------------
Veya aynı örnek copy algoritmasına move iteratorler argüman
olarak geçilerek de yapılabilir.
-------------------------------------------------------*/
#include <iomanip>
#include <string>
#include <iostream>
#include <vector>
#include <list>

using namespace std;


int main()
{
	vector<string> svec{
         "berke sertel",
         "mustafa yilmaz",
         "samet aybaba",
         "aziz yildirim",
         "suleyman seba",
    };

    vector<string> destvec(svec.size());

    copy(move_iterator(svec.begin()),move_iterator(svec.end()),destvec.begin());

    for(const auto& s : svec){
        cout << quoted(s) << " ";
    }
    cout << '\n';
}
/*--------------------------------------------------------
upper bound, lower bound ve distance
-------------------------------------------------------*/
#include <memory>
#include <string>
#include <iostream>
#include <vector>

using namespace std;

int main()
{
	vector<int> ivec{2,3,4,5,5,5,4,6,7,8,9};

	auto iter_lower = lower_bound(ivec.begin(),ivec.end(),5);
	auto iter_upper = upper_bound(ivec.begin(), ivec.end(), 5);

	cout << distance(ivec.begin(), iter_lower) << '\n';
	cout << distance(ivec.begin(), iter_upper) << '\n';
}
/*--------------------------------------------------------
upper bound ve lower bound test kodu
-------------------------------------------------------*/
#include <memory>
#include <iostream>
#include <vector>

using namespace std;

int main()
{
    vector<int> ivec{2,3,4,5,5,5,4,6,7,8,9};

    auto [iter_lower, iter_upper] = equal_range(ivec.begin(), ivec.end(), 5, greater{});

    cout << distance(ivec.begin(), iter_lower) << '\n';
    cout << distance(ivec.begin(), iter_upper) << '\n';
}
/*--------------------------------------------------------
binary search algoritması ve test kodu
-------------------------------------------------------*/
#include <string>
#include <iostream>
#include <vector>
#include <ctime>
#include <cstdlib>
#include <algorithm>
#define randomize() srand(time(nullptr))

using namespace std;

template<class Iter>
void print(Iter beg,Iter end)
{
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    vector<string> towns{ "adana", "adiyaman", "afyonkarahisar", "agri", "aksaray", "amasya", "ankara",
                          "antalya", "ardahan", "artvin", "aydin", "balikesir", "bartin", "batman", "bayburt",
                          "bilecik", "bingol", "bitlis", "bolu", "burdur", "bursa", "canakkale", "cankiri", "corum",
                          "denizli", "diyarbakir", "duzce", "edirne", "elazig", "erzincan", "erzurum", "eskisehir",
                          "gaziantep", "giresun", "gumushane", "hakkari", "hatay", "igdir", "isparta", "istanbul", "izmir",
                          "kahramanmaras", "karabuk", "karaman", "kars", "kastamonu", "kayseri", "kilis",
                          "kirikkale", "kirklareli", "kirsehir","kocaeli", "konya", "kutahya", "malatya", "manisa",
                          "mardin", "mersin", "mugla", "mus","nevsehir", "nigde", "ordu","osmaniye", "rize",
                          "sakarya", "samsun", "sanliurfa", "siirt","sinop","sivas", "sirnak", "tekirdag","tokat",
                          "trabzon", "tunceli", "usak", "van", "yalova","yozgat", "zonguldak" };
    randomize();
    vector<string> svec;
    for (int i = 0; i < 20; ++i)
        svec.insert(svec.begin(), towns[rand() % 82]);
    sort(svec.begin(), svec.end());
    print(svec.begin(), svec.end());

    string key;
    cout << "aranacak sehir : ";
    cin >> key;

    if (binary_search(svec.begin(), svec.end(), key))
        cout << "var\n";
    else
        cout << "yok\n";
}
/*--------------------------------------------------------
includes fonksiyonu ve test kodu
-------------------------------------------------------*/
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main()
{
    vector<int> ivec{1,3,5,5,7,7,9,12,23,45,67,78,90,123,234};
    vector<int> keys{5,12,78,90};

    cout << boolalpha << includes(ivec.begin(), ivec.end(), keys.begin(), keys.end()) << '\n';
}
/*--------------------------------------------------------
merge algoritması ve test kodu
Bu örnekte merge algoritmasında son parametre sort algoritmasında
olduğu gibi burda da less{} olarak kabul edilir. tersi 
bir sıralama yapılmak istenirse bu durumda bu durumda 
buraya greater{} geçilmelidir.
-------------------------------------------------------*/
#include <string>
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

template<class Iter>
void print(Iter beg, Iter end)
{
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}


int main()
{
    vector<string> males{ "mehmet","ismail","murat","recep","gurkan","ali","yasar" };
    vector<string> females{ "ayse","eda","nur","leyla","sinem","gizem" };

    sort(males.begin(), males.end());
    sort(females.begin(),females.end());
    print(males.begin(), males.end());
    print(females.begin(), females.end());

    vector<string> persons;
    persons.reserve(males.size() + females.size());

    merge(males.begin(),males.end(), females.begin(), females.end(),back_inserter(persons));
    print(persons.begin(), persons.end());
}
/*--------------------------------------------------------
Son argümana less(default argüman) yerine greater geçilmesi
durumunda küçükten büyüğe değil büyükten küçüğe sıralama
gerçekleşecektir.
-------------------------------------------------------*/
#include <string>
#include <iostream>
#include <vector>

using namespace std;

template<class Iter>
void print(Iter beg, Iter end)
{
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}


int main()
{
    vector<string> males{ "mehmet","ismail","murat","recep","gurkan","ali","yasar" };
    vector<string> females{ "ayse","eda","nur","leyla","sinem","gizem" };

    sort(males.begin(), males.end());
    sort(females.begin(),females.end());
    print(males.begin(), males.end());
    print(females.begin(), females.end());

    vector<string> persons;
    persons.reserve(males.size() + females.size());

    merge(males.begin(), males.end(), females.begin(), females.end(), back_inserter(persons), greater{});
    print(persons.begin(), persons.end());
}
/*--------------------------------------------------------
Programlamada kümelerle ilgili bazı işlemler
kesişimi(intersection)      A n B
birleşimi(union)            A U B
farkı(difference)           A - B
simetrik fark(symmetric difference) (A - B) U (B - A)
set intersection fonksiyonu iki containerdaki elemanların kesişim
kümesini elde eden bir fonksiyondur.
-------------------------------------------------------*/
#include <string>
#include <iostream>
#include <vector>
#include <algorithm>
#include "Person.h"

using namespace std;

template<class Iter>
void print(Iter beg, Iter end)
{
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}


int main()
{
    vector<string> x;
    vector<string> y;
    vector<string> z;
    for (int i = 0; i < 5; ++i) {
        x.insert(x.begin(),rtown());
        y.insert(y.begin(), rtown());
    }
    sort(x.begin(),x.end());
    sort(y.begin(),y.end());
    print(x.begin(),x.end());
    print(y.begin(),y.end());

    set_intersection(x.begin(),x.end(),y.begin(),y.end(),back_inserter(z));

    print(z.begin(),z.end());
}
/*--------------------------------------------------------
set union fonksiyonu kullanılarak iki tane containerın 
birleşim kümesini başka bir containera kopyalanabilir.
-------------------------------------------------------*/
#include <string>
#include <iostream>
#include <vector>
#include <algorithm>
#include "Person.h"

using namespace std;

template<class Iter>
void print(Iter beg, Iter end)
{
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}


int main()
{
    vector<string> x;
    vector<string> y;
    vector<string> z;
    for (int i = 0; i < 5; ++i) {
        x.insert(x.begin(),rtown());
        y.insert(y.begin(), rtown());
    }
    sort(x.begin(),x.end());
    sort(y.begin(),y.end());
    print(x.begin(),x.end());
    print(y.begin(),y.end());

    set_union(x.begin(),x.end(),y.begin(),y.end(),back_inserter(z));

    print(z.begin(),z.end());
}
/*--------------------------------------------------------
set difference fonksiyonuyla A - B farkı elde edilebilir.
-------------------------------------------------------*/
#include <string>
#include <iostream>
#include <vector>
#include <algorithm>
#include "Person.h"

using namespace std;

template<class Iter>
void print(Iter beg, Iter end)
{
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}


int main()
{
    vector<string> x;
    vector<string> y;
    vector<string> z;
    for (int i = 0; i < 20; ++i) {
        x.insert(x.begin(), rtown());
        y.insert(y.begin(), rtown());
    }
    sort(x.begin(), x.end());
    sort(y.begin(), y.end());
    print(x.begin(), x.end());
    print(y.begin(), y.end());

    set_difference(x.begin(), x.end(), y.begin(), y.end(), back_inserter(z));

    print(z.begin(), z.end());
}
/*--------------------------------------------------------
set_symmetric_difference fonksiyonu ve test kodu
-------------------------------------------------------*/
#include <string>
#include <iostream>
#include <vector>
#include <algorithm>
#include "Person.h"

using namespace std;

template<class Iter>
void print(Iter beg, Iter end)
{
    while (beg != end) {
        cout << *beg++ << ' ';
    }
    cout << '\n';
}


int main()
{
    vector<string> x;
    vector<string> y;
    vector<string> z;
    vector<string> diff_xy;
    vector<string> diff_yx;


    for (int i = 0; i < 20; ++i) {
        x.insert(x.begin(), rtown());
        y.insert(y.begin(), rtown());
    }
    sort(x.begin(), x.end());
    sort(y.begin(), y.end());
    print(x.begin(), x.end());
    print(y.begin(), y.end());

    set_difference(x.begin(), x.end(), y.begin(), y.end(), back_inserter(diff_xy));
    set_difference(y.begin(), y.end(), x.begin(), x.end(), back_inserter(diff_yx));
    set_symmetric_difference(x.begin(), x.end(), y.begin(), y.end(),back_inserter(z));
    print(diff_xy.begin(),diff_xy.end());
    print(diff_yx.begin(),diff_yx.end());

    print(z.begin(), z.end());
}
/*--------------------------------------------------------
Aşağıdaki örnekte f için tür çıkarımı int (*f) (int)
-------------------------------------------------------*/
int foo(int);

int main()
{
    auto f = foo;
}
/*--------------------------------------------------------
Aşağıdaki örnekte 1 ve 3 nolu satırlardan 1 nolu satır bir 
üye fonksiyon adresi elde edilmesi hedeflenirken 3 nolu satırda
bu free/stand alone function için bir adres elde edilmek isteniyor.
Diyebiliriz. Bu durumda 1 nolu satır 3 nolu satıra 2 nolu 
satır da 4 nolu satıra benzetilebilir. 2 ve 4 nolu satırlarda
doğrudan fonksiyon adresi kullanılıp 1 ve 3 nolu satırlarda 
ise bir fonksiyon adresine dönüşüm söz konusudur
-------------------------------------------------------*/

class Myclass {
public:
    static void func(int){}
};


void foo(double, double) {}

int main()
{
    auto fm1 = Myclass::func;//1
    auto fm2 = &Myclass::func;//2
    void (*fm3)(int) = Myclass::func;
    void (*fm4)(double, double) = foo;//3
    void (*fm5)(double, double) = &foo;//4
}
/*--------------------------------------------------------
non-static üye fonksiyonlarda ise durum biraz daha farklı 
bir durum söz konusudur. non-static üye fonksiyonlarda 
this pointerı olduğu için static üye fonksiyonlardan farklı 
ele alınır. Burda farklı olarak non-staticlik olduğu için
&Myclass::func diye belirtilmesi zorunludur.
-------------------------------------------------------*/
class Myclass {
public:
    int func(int) { return 10; }
};

int main()
{
    auto fp1 = &Myclass::func;
    int (Myclass:: * fp2) (int) = &Myclass::func;
}
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
class Myclass {
public:
    double func(double) { return 20.5; }
};

int main()
{
    auto fp1 = &Myclass::func;
    double (Myclass:: * fp2) (double) = &Myclass::func;
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include<iostream>

using namespace std;

class Myclass {
public:
    double func(int x,int y) 
    { 
        cout << "Myclass::func cagrildi x = " << x << "y = " << y << '\n';
        cout << "this = " << this << '\n';

        return 1.5 * (x + y);
    }
};

int main()
{
    auto fp = &Myclass::func;

    Myclass m;
    cout << "&m = " << &m << '\n';

    auto dval = (m.*fp)(12, 34);

    cout << "dval = " << dval << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte bazı non-static üye fonksiyon göstericileri
örnekleri verilmiştir.
-------------------------------------------------------*/
#include<iostream>

using namespace std;

class Myclass {
public:
    double func(int x,int y) 
    { 
        cout << "Myclass::func cagrildi x = " << x << "y = " << y << '\n';
        cout << "this = " << this << '\n';

        return 1.5 * (x + y);
    }
};

int main()
{
    auto fp = &Myclass::func;

    Myclass m;
    Myclass* p = &m;

    (m.*fp)(1,2);
    (p->*fp)(1, 2);
    ((*p).*fp)(5,12);
}
/*--------------------------------------------------------
Standart kütüphanenin invoke fonksiyonu ve test kodu Bu
-------------------------------------------------------*/
#include<iostream>


using namespace std;

class Myclass {
public:
    double func(int x,int y) 
    { 
        cout << "Myclass::func cagrildi x = " << x << "y = " << y << '\n';
        cout << "this = " << this << '\n';

        return 1.5 * (x + y);
    }
};

int main()
{
    auto fp = &Myclass::func;

    Myclass m;
    Myclass* p = &m;

    invoke(&Myclass::func,m,10,20);
    invoke(fp,m,10,20);
    invoke(fp,p,10,20);
    invoke(fp, &m, 10, 20);
}
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
#include<iostream>


using namespace std;

class Myclass {
public:
    Myclass() = default;
    Myclass(int (Myclass::* f)(int)) : mfp{ f } {}

    int f1(int) { return 10; }
    int f2(int) { return 20; }
    int f3(int) { return 30; }

    void set_mfp(int (Myclass::* f)(int))
    {
        mfp = f;
    }
    void func(int x)
    {
        //mfp'nin gösterdiği fonksiyonu çağırmak istiyorum.
        auto n1 = (this->*mfp)(x);
        auto n2 = invoke(mfp,this,x);
        auto n3 = invoke(mfp,*this,x);
    }
private:
    int (Myclass::* mfp)(int) {&Myclass::f1};
};

int main()
{
    Myclass m;

    m.func(12);

    m.set_mfp(&Myclass::f2);
    m.func(12);

    Myclass mx{&Myclass::f1};
    Myclass my{&Myclass::f2};
    Myclass mz{&Myclass::f3};
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include<iostream>


using namespace std;

class Myclass {
public:
    Myclass() = default;
    Myclass(int (Myclass::* f)(int)) : mfp{ f } {}

    int f1(int) 
    { 
        cout << "Myclass::f1()\n";
        return 1; 
    }
    int f2(int) 
    { 
        cout << "Myclass::f2()\n";
        return 1; 
    }
    int f3(int) 
    { 
        cout << "Myclass::f3()\n";
        return 1; 
    }

    void set_mfp(int (Myclass::* f)(int))
    {
        mfp = f;
    }
    void func(int x)
    {
        //mfp'nin gösterdiği fonksiyonu çağırmak istiyorum.
        auto n1 = (this->*mfp)(x);
        auto n2 = invoke(mfp,this,x);
        auto n3 = invoke(mfp,*this,x);
    }
private:
    int (Myclass::* mfp)(int) {&Myclass::f1};
};

int main()
{
    Myclass m;

    m.func(12);

    m.set_mfp(&Myclass::f2);
    m.func(12);

    Myclass mx{&Myclass::f1};
    Myclass my{&Myclass::f2};
    Myclass mz{&Myclass::f3};
}
/*--------------------------------------------------------
typedef ve using bildirimi test kodu
-------------------------------------------------------*/
#include<iostream>


using namespace std;

class Myclass {
public:
    int foo(int, int) { return 1; }
};

typedef int(Myclass::* MYCLASS_PTR)(int,int);
using MYCLASS_PTR = int (Myclass::*)(int,int);

int main()
{
    MYCLASS_PTR fp = &Myclass::foo;
}
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
#include<iostream>


using namespace std;

class Myclass {
public:
    int f1(int, int) { return 1; }
    int f2(int, int) { return 1; }
    int f3(int, int) { return 1; }
    int f4(int, int) { return 1; }
};

typedef int(Myclass::* MYCLASS_PTR)(int,int);
using MYCLASS_PTR = int (Myclass::*)(int,int);

int main()
{
    MYCLASS_PTR ar[] = {&Myclass::f1,&Myclass::f2,&Myclass::f3,&Myclass::f4};

    Myclass mx;

    for (auto f : ar) {
        (mx.*f)(1,2);
        std::invoke(f,mx,1,2);
    }
}
/*--------------------------------------------------------
C++'ın any sınıfı herhangi bir değişken olabilir.
-------------------------------------------------------*/
#include <string>
#include <iostream>
#include <any>

int main()
{
    std::any x = 4;

    x = 20.9;

    x = "berke";

    x = std::string {"ankara"};

    std::cout << &x << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte fp için tür çıkarımı int Myclass::*
türünden yapılacaktır. bu mx veri elemanının bir non-static
veri elemanı olmasından kaynaklanmaktadır.
-------------------------------------------------------*/
#include <iostream>

class Myclass{
public:
    int mx;
};

int main()
{
    auto fp = &Myclass::mx;
    int Myclass::* p = &Myclass::mx;

    Myclass m;

    std::cout << "m.mx: " << m.mx << '\n';

    m.*p = 5;

    std::cout << "m.mx: " << m.mx << '\n';
}
/*--------------------------------------------------------
aşağıdaki örnekte is_int fonksiyon static assert ile birlikte
kullanılaraktür kontrolü aşağıdaki örnekte olduğu gibi
yapılabilir.
-------------------------------------------------------*/

template <typename T>
struct is_int{
    static constexpr bool value = false;
};

template <>
struct is_int<int>{
    static constexpr bool value = true;
};

template <typename T>
void func(T x)
{
    static_assert(is_int<T>::value);
}

int main()
{
    func(12);
}
/*--------------------------------------------------------
is_pointer standart fonksiyonunun manuel yazımı
-------------------------------------------------------*/
template <typename T>
struct is_pointer{
    static constexpr bool value = false;
};

template <typename T>
struct is_pointer<T*>{
    static constexpr bool value = true;
};

template <typename T>
void func(T x)
{
    if constexpr (is_pointer<T>::value){
        //code variant a
    }
    else {
        //code variant a
    }
}

int main()
{
    int x{};
}
/*--------------------------------------------------------
Standart type_traits kütüphanesinin is_class ve is_enum fonksiyonları
ve test kodu
-------------------------------------------------------*/
#include <iostream>
#include <type_traits>

using namespace std;

enum class Color{Red,Blue,Purple};
class Myclass{};

int main()
{
    constexpr auto b1 = is_class<int>::value;
    constexpr auto b2 = is_enum<decltype(Color::Blue)>::value;

    cout << boolalpha;
    cout << b1 << '\n';
    cout << b2 << '\n';
}
/*--------------------------------------------------------
aşağıdaki örnekte syntax hatasının nedeni fonksiyonun sadece
bir sınıf nesnesiyle çağrılabilmesinden kaynaklanmaktadır.
-------------------------------------------------------*/
#include <iostream>
#include <type_traits>

using namespace std;

template <typename T>
void func(T x)
{
    static_assert(is_class<T>::value,"This function can only call with a class argument");
}

int main()
{
    func(12);
}
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
#include <iostream>

template<typename T,T v>
struct integral_constant
{
    static constexpr T value = v;
    using value_type = T;
    using type = integral_constant;
    constexpr explicit operator value_type() const noexcept{return value;}
    constexpr value_type operator()()const noexcept{return value;}//since C++14
};

int main()
{
    std::cout << integral_constant<int,5>::value;
}
/*--------------------------------------------------------
standart kütüphanenin is_pointer fonksiyonu aşağıdaki gibi
manuel şekilde yazılabilir.
-------------------------------------------------------*/
#include <iostream>

template<typename T>
struct IsPointer : std::false_type{};

template<typename T>
struct IsPointer<T*> : std::true_type{};

int main()
{
    static_assert(IsPointer<int*>::value);
}
/*--------------------------------------------------------
dizilerin uzunlukları 0 olamaz. sebeple aşağıdaki kod
false yani 0 değerini üreteceğinden bu durumda bir
syntax hatası oluşur.
-------------------------------------------------------*/
int main()
{
    int arr[sizeof(int) > 4];
}
/*--------------------------------------------------------
Ancak aşağıdaki örnekte true değer üretileceğinden uzunluğu
1 olan bir dizi elde edilecektir.
-------------------------------------------------------*/
int main()
{
    int arr[sizeof(int) > 2];
}
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
#include <iostream>

template<typename T>
void func(T x)
{
    static_assert(std::is_integral_v<T>,"func template is only for integer types");
}

int main()
{
    func(12);
}
/*--------------------------------------------------------
//ekleme yapılacak
-------------------------------------------------------*/
#include <iostream>

enum class Color{Red,Blue};

union Berko{
    int x : 3;
    int y : 5;
    //...
};

int main()
{
    constexpr auto b = std::is_class_v<Berko>;
}
/*--------------------------------------------------------
remove_reference structları ve test kodu
-------------------------------------------------------*/
template<typename T>
struct remove_reference
{
    using type = T;
};

template <typename T>
struct remove_reference<T&>
{
    using type = T;
};

template <typename T>
struct remove_reference<T&&>
{
    using type = T;
};
/*--------------------------------------------------------
Aşağıdaki örnekte syntax hatasının nedeni vector containerına
ait olan iteratörün random access iterator olup list containerına
ait olan iteratörün ise biderictional iterator olmasından
kaynaklanmaktadır.
-------------------------------------------------------*/
#include <iostream>
#include <list>
#include <vector>



int main()
{
    using namespace std;

    vector<int> ivec(100);
    list<int> ilist(100);

    auto vec_iter = ivec.begin();
    auto list_iter = ilist.begin();
    int n = 5;

    vec_iter += 5;
    list_iter += 5;//error
}
/*--------------------------------------------------------
advance fonksiyonu aşağıdaki örnekte olduğu gibi hem bidirection
iterator hem de random access iterator ile çalışmaktadır.
Bunun manuel yazımı da aşağıdaki gibidir.
-------------------------------------------------------*/
#include <iostream>
#include <list>
#include <vector>

namespace details{
    template<typename Raniter,typename Distance>
    void advance(Raniter& it,Distance n,std::random_access_iterator_tag)
    {
        it += n;
    }
    template<typename Biditer,typename Distance>
    void advance(Biditer& it,Distance n,std::bidirectional_iterator_tag)
    {
        if(n > 0){
            while(n--) ++it;
        }
        else{
            while(n++) --it;
        }
    }
}
namespace mystd {
    template<typename Iter, typename Distance>
    void advance(Iter &it, Distance n) {
        details::advance(it, n, typename Iter::iterator_category());
    }
}

int main()
{


    std::vector<int> ivec(100);
    std::list<int> ilist(100);

    auto vec_iter = ivec.begin();
    auto list_iter = ilist.begin();
    int n = 5;
    mystd::advance(vec_iter,5);
    mystd::advance(list_iter,5);
    std::cout << *vec_iter << '\n';
    std::cout << *list_iter << '\n';
}
/*--------------------------------------------------------
problem:

derleme zamanında func isimli fonksiyon için
farklı kod seçiminin yapılmasını sağlayacak bir

tam sayı türleri için
    ayrı kod
tam sayı olmayan türler için ayrı kod

tag dispatch tekniğinini kullanın

if constexpr (constant expression){
    //kod
}
else {
    kod
}
-------------------------------------------------------*/
#include <iostream>
#include <type_traits>

template<typename T>
void func(T x)
{
    if constexpr (std::is_pointer_v<T>){
        std::cout << "pointer turleri icin kod\n";
    }
    else{
        std::cout << "pointer olmayan turler icin kod\n";
    }
}

int main()
{
    func(10);
}
/*--------------------------------------------------------
pointer türleri için ifin true bölümü ve false bölümü için
ifin false bölümü çalıştırılacaktır.
-------------------------------------------------------*/
#include <iostream>
#include <list>
#include <vector>
#include <type_traits>

template<typename T>
void func(T x)
{
    if constexpr (std::is_pointer_v<T>){
        std::cout << "pointer turleri icin kod\n";
    }
    else{
        std::cout << "pointer olmayan turler icin kod\n";
    }
}

int main()
{
    int x = 10;
    auto ptr = &x;
    func(ptr);
}
/*--------------------------------------------------------
aşağıdaki örnekte sınıf nesneleri için ifin true bölümü
çalıştırılırken diğer nesneler için false bölümü çalıştırılacaktır.
-------------------------------------------------------*/
#include <iostream>
#include <list>
#include <vector>
#include <type_traits>

struct Ber{};

template<typename T>
void func(T x)
{
    if constexpr (std::is_class_v<T>){
        std::cout << "class turleri icin kod\n";
    }
    else{
        ++x;
    }
}

int main()
{
    Ber ber;
    func(ber);
}
/*--------------------------------------------------------
Aşağıdaki örnekte türün string türü olması, aritmetik tür olması
veya başka bir tür olması durumunda farklı işlemler uygunlanmıştır.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <type_traits>

template<typename T>
std::string as_string(T x)
{
    if constexpr(std::is_same_v<T,std::string>){
        return x;
    }
    else if constexpr(std::is_arithmetic_v<T>){
        return std::to_string(x);
    }
    else {
        return std::string(x);
    }
}

int main()
{
    using namespace std;
    cout << as_string(string("hello")) <<'\n';
    cout << as_string(42) << '\n';
    cout << as_string(4.2) << '\n';
    cout << as_string("hello")<< '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte A satırı her zaman syntax hatasıdır. Ancak
sadece 1 nolu fonksiyon çağrıldığı takdirde integral türünden
olduğu için ifin true bölümüne gireceğinden bu durumda syntax
hatası oluşmaz. Ancak 2 nolu çağrı gibi ifin false bölümüne
giriş gerçekleştiğinde bu durumda syntax hatası oluşacaktır.
C satırı ise A satırı gibi daima syntax hatası olacaktır.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <type_traits>

template<class T>
void func(T tx)
{
    if constexpr (std::is_integral_v<T>){
        if(tx != 0){
            func(tx--);
            //...
        }
    }
    else{
        //undeclared_f(); //syntax error (name non dependant on template parameter)(A)
        undeclared(tx); //error if else part instantiated(B)
        //static_assert(false,"not integral type"); //syntax error(C)
    }
}
int main()
{
    func(2); //1
    func(2.5); //2
}
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
#include <iostream>
#include <type_traits>

template<class T>
void func(T& tx)
{
    if(tx > 0){
        if constexpr(std::is_integral_v<T>){
            ++tx;
        }
        else {
            --tx;
        }
    }
}
int main()
{
    using namespace std;
    int ival = 5;
    double dval = 2.5;
    func(ival);
    func(dval);

    cout << "ival : " << ival << '\n';
    cout << "dval : " << dval << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <type_traits>

struct Ber{};


int main()
{
    Ber ber;

    if constexpr (sizeof(int) > 2){

    }
    else{
        --ber;
    }
}
/*--------------------------------------------------------
Aşağıdaki örnekte figonacci sayılarının sayısına bağlı olarak
kendisi elde edilen bir örnek verilmiştir.
-------------------------------------------------------*/
#include <iostream>

template<int N>
constexpr int fibo()
{
    if constexpr (N >= 2){
        return fibo<N-1>() + fibo<N-2>();
    }
    else
        return N;
}

int main()
{
    constexpr auto y = fibo<8>();
    std::cout << y << '\n';
}
/*--------------------------------------------------------
//ekleme yapılacak
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <type_traits>

template<typename T>
typename T::value_type func(T x){};

double::value_type func(double);

int main()
{
    func(1.2);
}
/*--------------------------------------------------------
Aşağıdaki örnekte T::value_type'ı int olacağından func
fonksiyonunun tüm overloadları için geri dönüş değeri
int olacaktır. Overload resolution kurallarına göre
daha fazla bilgi verilen seçilecektir.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <type_traits>

struct Ber{
    using value_type = int;
};

template<typename T>
typename T::value_type func(T x);

template<typename T>
typename T::value_type func(T* ptr);

int main()
{

}
/*--------------------------------------------------------
Bu kod, C++'da işlev aşırı yükleme ve SFINAE (Substitution Failure Is Not An Error) örneklerinden birini göstermektedir.
Kod, bir dizinin veya bir konteynerin boyutunu döndüren bir işlev şablonu olan len işlevini tanımlar ve farklı
türlerdeki argümanlar için aşırı yüklenir.

len işlev şablonu, iki farklı işlev imzasıyla tanımlanır. İlk imza, bir dizi referansını argüman olarak alır ve dizinin boyutunu,
yani dizideki eleman sayısını döndürür. İkinci imza, size() üye işlevine sahip bir tür olan Tnin bir const referansını alır
ve argümandaki size() işlevini çağırdığında elde edilen sonucu döndürür.

len bir dizi argümanı ile çağrıldığında, derleyici doğrudan eşleşme olduğu için ilk aşırı yükleme seçilir.
"tmp" gibi bir karakter dizisi argümanı ile çağrıldığında, o da const char[N] dizisine dönüştürülür,
bu nedenle yine ilk aşırı yükleme seçilir.

Ancak, len işlevi bir int işaretçisi veya bir allocator ile çağrıldığında, hiçbir aşırı yüklenen işlev argümanla
eşleşmediği için, derleyici SFINAE kullanır ve sert bir hata ile sonuçlanacak şablon anında gerçekleştirilemez.
Sonuç olarak, len(p) ve len(x) çağrıları derleme hatası ile sonuçlanır.

Sonuç olarak, len işlev şablonu, C++'da işlev aşırı yükleme ve SFINAE'nin nasıl birlikte
çalıştığına dair iyi bir örnektir ve farklı türlerdeki argümanlar için genel işlevsellik sağlar.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <type_traits>


template<typename T, unsigned N>
std::size_t len(T(&)[N])
{
    return N;
}

template<typename T>
typename T::size_type len(T const& t)
{
    return t.size();
}

int main()
{
    using namespace std;
    int a[10]{};
    cout << len(a);
    cout << len("tmp");
    int* p{};
    cout << len(p); //error
    allocator<int> x;
    cout << len(x); //error
}
/*--------------------------------------------------------
Bu kod, SFINAE (Substitution Failure Is Not An Error) kavramını kullanarak, farklı türler için
iki farklı işlev şablonunu (function template) çağırmak için örnek bir kod örneğidir.

İlk önce std::enable_if kullanarak, birinci func işlev şablonu yalnızca tamsayı (integral) türleri kabul eder.
İkinci func işlev şablonu ise, ilk işlev şablonundan farklı olarak, tamsayı türleri haricindeki türleri kabul eder.
Burada std::enable_if kullanarak işlev şablonunun parametre listesinde koşullu derleme (conditional compilation) yapılır.
İlk parametre olan T x tipi std::is_integral_v'nin doğruluğuna bağlı olarak tanımlanır.
Bu durumda, std::is_integral_v koşulu doğru olduğunda, yani T bir tamsayı türü ise, ilk şablon kullanılacaktır.
Aksi takdirde, std::is_integral_v koşulu yanlış olduğunda, yani T bir tamsayı türü değilse, ikinci şablon kullanılacaktır.

Örneğin, func(1) çağrısı bir tamsayı türüdür, böylece ilk şablon olan "Integer types" mesajı yazdırılırken,
func(1.1) çağrısı bir ondalıklı sayıdır, bu nedenle ikinci şablon olan "non-integer types" mesajı yazdırılır.
func(A{}) çağrısı da A yapısını kullanarak, dolayısıyla ikinci şablon kullanılır.

Bu örnekte SFINAE, işlevlerin türlerine göre davranışını değiştirmesine ve
tür uyumsuzluğu hatalarının önlenmesine yardımcı olur.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <type_traits>

template<typename T>
void func(T x,std::enable_if<std::is_integral_v<T>>* = nullptr)
{
    std::cout << "Integer types" << '\n';
}

template<typename T>
void func(T x,std::enable_if<!std::is_integral_v<T>>* = nullptr)
{
    std::cout << "non integer types" << '\n';
}

struct A{};

int main()
{
    func(1);
    func(1u);
    func('A');
    func(true);
    func(1.1);
    func(A{});
}
/*--------------------------------------------------------
C++'ta input ve Output işlemleri için kullanılan iostream 
kütüphanesi
-------------------------------------------------------*/
/*--------------------------------------------------------
Anahtar Notlar:endl bir fonksiyondur. kesinlikle sadece new line için
kullanılmamalıdır flush işlemini de yapar. Durup
dururken standart input bufferını flush etmek gerekli
değildir bu gibi durumlarda \n(line feed) kaçış karakteri
tercih edilmelidir.
-------------------------------------------------------*/
/*--------------------------------------------------------
Aşağıdaki örnekte ilk iki ifade Hello ifadesini standart outputa
basarken son ifade cout nesnesinin adresini ekrana basar
bu da: 00007FF719FC0C10 böyle bir adrestir.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

int main()
{
    cout << "Hello\n";
    operator<<(cout,"Hello\n");
    cout.operator<<("Hello\n");
}
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

int main()
{
    int x = 10;
    double dval = 3.4;

    cout << x << '\n';
    cout.operator<<(x).operator<<(dval);
}
/*--------------------------------------------------------
aşağıdaki örnekte 1 ve 2 nolu satır ile
-------------------------------------------------------*/
#include <iostream>

using namespace std;

int main()
{
    int x = 10;
    double dval = 3.4;

    cout << x << endl; //1
    cout << dval << endl; //2

    cout.operator<<(x).operator<<(endl); //3
    cout.operator<<(dval).operator<<(endl); //4
}
/*--------------------------------------------------------
Aşağıdaki örnekte dashline fonksiyonu kullanılarak alt
satıra geç çizgi koy alt satıra geç işlemleri uygulanır.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

ostream& dashline(ostream& os)
{
    return os << "\n-------------------------------------\n";
}

int main()
{
    int x = 10;
    double dval = 3.4;
    long lval = 3456L;

    cout << x << dashline << dval << dashline << lval << dashline;

}
/*--------------------------------------------------------
Yukarıdaki işlemlerin aynısı aşağıdaki örnekte olduğu gibi
de yapılabilir.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

ostream& dashline(ostream& os)
{
    return os << "\n-------------------------------------\n";
}

int main()
{
    int x = 10;
    double dval = 3.4;
    long lval = 3456L;

    cout.operator<<(x).operator<<(dashline).operator<<(dval).operator<<(dashline).operator<<(lval).operator<<(dashline);
}
/*--------------------------------------------------------
aşağıdaki örnekte Hex fonksiyonu hexadecimal yani 16 lık
sistemde basım yaparken Oct fonsiyonu ise octal yani 8 lik
sistem üzerinde çalışmaktadır.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

ostream& Hex(ostream& os)
{
    os.setf(ios::hex,ios::basefield);
    return os;
}

ostream& Oct(ostream& os)
{
    os.setf(ios::oct,ios::basefield);
    return os;
}

int main()
{
    int x = 123;

    cout << x << '\n' << Hex << x << '\n' << Oct << x << '\n';
}
/*--------------------------------------------------------
aşağıdaki örnekte ekran çıktısı int int int olacaktır.
çünkü typeid operatörüne verilen değer bir enum türü olacağından
burda üretilen değer int türü olacaktır.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

int main()
{
    cout << typeid(ios_base::fmtflags).name() << '\n';
    cout << typeid(basic_ios<char>::fmtflags).name() << '\n';
    cout << typeid(ios::fmtflags).name() << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte unsetf ve setf standart kütüphane fonksiyonları
gösterilmiştir. bu fonksiyonlar ios::boolalpha argümanıyla çağrılırsa
bu durumda setf için bool türünden ifadeler 1 ve 0(default değerler) yerine 
true ve false değerleri üretilecektir.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

int main()
{
    cout << (10 > 5) << '\n';
    cout.setf(ios::boolalpha);
    cout << (10 > 5) << '\n';
    cout << (10 > 5) << '\n';
    cout << (10 > 5) << '\n';
    cout << (10 < 5) << '\n';
    cout.unsetf(ios::boolalpha);
    cout << (10 < 5) << '\n';
    cout << (10 > 5) << '\n';
}
/*--------------------------------------------------------
default olarak yazma yapılırken pozitif sayıların işaretleri
yazdırılmaz ancak aşağıdaki örnekteki gibi bir setf fonksiyon
çağrısı gerçekleştirilse bu durumda pozitif sayıların işareti
de belirtilir.
--------------------------------------------------------*/
#include <iostream>

using namespace std;

int main()
{
    cout << 3456 << '\n';
    cout.setf(ios::showpos);
    cout << 3456 << '\n';
    cout.unsetf(ios::showpos);
    cout << 3456 << '\n';
}
/*--------------------------------------------------------
aşağıdaki örnekte hexadecimal için showbase set edildiği
zaman 0x ile birlikte yazdırılacaktır. default olarak bu
unset durumdadır.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

int main()
{
    cout << hex;

    int x = 47802;

    cout << x << '\n';
    cout.setf(ios::showbase);
    cout << x << '\n';
    cout.unsetf(ios::showbase);
    cout << x << '\n';

}
/*--------------------------------------------------------
setf fonksiyonuna argüman olarak bitsel veya işlem ile tek seferde
birden fazla özellik set edilebilir. aşağıdaki örnek için
hem 0x i göster hem de büyük harfle yaz anlamına gelmektedir.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

int main()
{
    cout << hex;

    int x = 47802;

    cout << x << '\n';
    cout.setf(ios::showbase | ios::uppercase);
    cout << x << '\n';
    cout.unsetf(ios::showbase);
    cout << x << '\n';

}
/*--------------------------------------------------------
setf fonksiyon ile pek çok özellik açımı gerçekleştirilebilir.
Bunun bir sınırı yoktur.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

int main()
{
    cout << hex;

    int x = 47802;

    cout << x << '\n';
    cout.setf(ios::showbase | ios::uppercase | ios::boolalpha | ios::showpoint);
    cout << x << '\n';
    cout.unsetf(ios::showbase);
    cout << x << '\n';

}
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
//ekleme yapılacak
-------------------------------------------------------*/
#include <iostream>
#include <bitset>

using namespace std;

int main()
{
    cout << bitset<32>(ios::boolalpha) << '\n';
    cout << bitset<32>(ios::showpos) << '\n';
    cout << bitset<32>(ios::uppercase) << '\n';
    cout << bitset<32>(ios::showbase) << '\n';
}
/*--------------------------------------------------------
//ekleme yapılacak
-------------------------------------------------------*/
#include <iostream>
#include <bitset>

using namespace std;

int main()
{
    cout << bitset<32>(cout.flags()) << '\n';
}

/*--------------------------------------------------------
heme flags hem get hem set fonksiyonu
-------------------------------------------------------*/
#include <iostream>
#include <bitset>

using namespace std;

int main()
{
    cout.setf(ios::boolalpha);//boolalpha'yı aktive et
    cout.flags(cout.flags() | ios::boolalpha); //boolalpha'yı aktive et

    cout.unsetf(ios::boolalpha); //boolalpha'yı kapat
    cout.flags(cout.flags() & ~ios::boolalpha); //boolalpha'yı kapat
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <bitset>

using namespace std;

int main()
{
    cout << bitset<32>(ios::dec) << '\n';
    cout << bitset<32>(ios::hex) << '\n';
    cout << bitset<32>(ios::oct) << '\n';
    cout << bitset<32>(ios::basefield) << '\n';
}
/*--------------------------------------------------------
aşağıdaki örnekte width fonksiyonuna argüman olarak gönderilen
değer kadar boşluk bırak anlamındadır.
-------------------------------------------------------*/
#include <iostream>
#include <bitset>

using namespace std;

int main()
{
    cout.width(20);
    cout << "ali";
    cout << 12 << 23;
}
/*--------------------------------------------------------
Aşağıdaki örnekte setf fonksiyonunun ikinci parametresi
adjustfield olduğundan dolayı burda boşluk sonra olacaktır.
basefield olsaydı eğer bu durumda boşluk önde bırakıcaktı
-------------------------------------------------------*/
#include <iostream>
#include <bitset>

using namespace std;

int main()
{
    cout.setf(ios::left, ios::adjustfield);
    cout << '|';
    cout.width(20);
    cout << "ali";
    cout << '|';
}
/*--------------------------------------------------------
aşağıdaki örnekte nhex kullanılarak hem büyük yaz hem
0x ile birlikte göster hem de 16 lık sistemde göster anlamındadır.
-------------------------------------------------------*/
#include <iostream>
#include <bitset>

using namespace std;

ostream& nhex(ostream& os)
{
    return os << hex << uppercase << showbase;
}

int main()
{
    cout << nhex << 47802 << '\n';
}

/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <ctime>
#include <iomanip>

using namespace std;

string get_current_time_str()
{
    time_t timer;
    time(&timer);
    auto tp = localtime(&timer);

    ostringstream oss;
    oss << setfill('0');
    oss << setw(2) << tp->tm_mday << '_' << setw(2)
        << tp->tm_mon + 1 << '_' << tp->tm_year + 1900 << '_'
        <<setw(2) << tp->tm_hour << '_' << setw(2) << tp->tm_min << '_' << setw(2) << tp->tm_sec;

    return oss.str();
}


int main()
{
    cout << get_current_time_str() << '\n';
}
/*--------------------------------------------------------
aşağıdaki örnekte setf fonkisyonunun 2.parametresine argüman
olarak geçilerek sona eklenesini söyleyen ve width ile sayısı
belirtilen fill fonksiyonu kullanılarak boşluk yerine
underscope karakteri ekle anlamına gelir.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

int main()
{
    cout.fill('_');
    cout.setf(ios::left, ios::adjustfield);
    cout << '|';
    cout.width(20);
    cout << "ali";
    cout << '|';
}
/*--------------------------------------------------------
Standart olan boolalpha fonksiyonunun manuel yazım şekli
-------------------------------------------------------*/
#include <iostream>

using namespace std;

ostream& Boolalpha(ostream& os)
{
    os.setf(ios::boolalpha);
    return os;
}

int main()
{
    cout << (10 > 5) << Boolalpha << (10 > 5);
}
/*--------------------------------------------------------
Aşağıdaki örnekte olduğu gibi nesneler bir ostringstream
referansı içerisine atılıt str fonksiyonu kullanılarak
ekrana cout ile basılabilir. Bu özellik bir dosyaya
toplu yazma işlerinde sıkça kullanılmaktadır.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <sstream>

using namespace std;

int main()
{
    int x = 10;
    double dval = 35.4;
    string str{"mustafa"};
    ostringstream oss;
    oss << hex << x << dval << str;
    cout << oss.str() << '\n';
}
/*--------------------------------------------------------
iostream kütüphanesinin standart precision fonksiyonu.
Bu fonksiyona argüman olarak geçilen sayı kadar noktadan
sonraki basamak ekrana basılır.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

int main()
{
    double dval = 17. / 3.;

    cout << fixed;

    cout.precision(9);

    cout << dval << '\n';
}
/*--------------------------------------------------------
standart iomanip kütüphanesinin setprecision fonksiyonu
-------------------------------------------------------*/
#include <iostream>
#include <iomanip>

using namespace std;

int main()
{
    double dval = 17. / 3.;

    cout << fixed << setprecision(5) << dval;
}
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

class nl{
public:
    nl(int n) : m_n(n) {}
    friend ostream& operator<<(ostream& os, const nl& x)
    {
        auto n = x.m_n;
        while (n--){
            os.put('\n');
        }
        return os;
    }
private:
    int m_n;
};

int main()
{
    int x = 19;

    cout << x << nl(4) << x << nl(2) << x << nl(4) << 5 << "berke";
}
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
Bu kodda standart left fonksiyonu ilk gelen elemanı sola doğru
hizala sonra 40 satır boşluk bırak en son da ay ve yıl değerlerini
ekrana yazdır anlamına gelmektedir.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <iomanip>

using namespace std;

class Date{
public:
    Date(int d,int m,int y) : md{d},mm{m},my{y} {}
    friend ostream& operator<<(ostream& os,const Date& date)
    {
        return os << date.md << '/' << date.mm << '/' << date.my;
    }
private:
    int md,mm,my;
};

int main()
{
    Date mydate{12,5,1987};

    cout << left;

    cout << '|' << setw(40) << mydate << '\n';
}
/*--------------------------------------------------------
C++'ta input işlemlerinin en temel öğreni cin fonksiyonudur.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

int main()
{
    int x;
    cout << "bir sayi giriniz?" << '\n';
    cin >> x;
    cout << "x : " << x << '\n';
}
/*--------------------------------------------------------
standart cin fonksiyonunun operator bool fonksiyonu kullanılarak
akımın sağlığı kontrol edilebilir. operator bool fonksiyonu
eğer akım sağlıklıysa true, akım sağlıklı değilde false
değerini döndürecektir.
-------------------------------------------------------*/
#include <iostream>
#include <string>

using namespace std;

int main()
{
    cout << (cin ? "iyi durumda " : "hata durumunda") << '\n';

    if(cin.operator bool()){
        cout << "yes it is ok";
    }
    else {
        cout << "no it is not ok";
    }
}
/*--------------------------------------------------------
Aşağıdaki örnekte eğer bir sayı girilirse bu durumda akım
sağlıklı durumdadır. ancak bir yazı girilmesi durumunda akım
sağlıksız durumda olacaktır.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

int main()
{
    int x;
    cout << "Bir sayi giriniz?\n";

    if(cin >> x){
        cout << "akim saglikli durumda" << '\n';
    }
    else{
        cout << "akim sagliksiz durumda" << '\n';
    }
}
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <sstream>

using namespace std;

int main()
{
    istringstream iss{"12 45 67 98 20, 5, 12, 678"};
    int x;

    int sum = 0;

    iss >> hex;

    while(iss >> x){
        cout << x << '\n';
        sum += x;
    }
    cout << "toplam = " << sum << '\n';
}
/*--------------------------------------------------------
standart exceptions fonksiyonunun ios::failbit parametresiyle
çağrılması durumunda akımın sağlıksız olması durumunda
exception throw edilmesi sağlanabilir.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <sstream>

using namespace std;

int main()
{
    cin.exceptions(ios::failbit);

    int x;

    cout << "bir tam sayi giriniz?\n";

    try{
        cin >> x;
    }
    catch(const exception& ex){
        cout << "exception caught : " << ex.what() << '\n';
    }
}
/*--------------------------------------------------------
C++'ta dosya işlemleri(file operations in C++)
C++ dilinde 3 farklı dosya nesnesi oluşturulma tipi
vardır bunlar:
1-)ifstream(sadece okuma)
2-)ofstream(sadece yazma)
3-)fstream(hem okuma hem yazma)
-------------------------------------------------------*/

/*--------------------------------------------------------
Bazı açma türü fonksiyonları:
1-)std::ios_base::trunc açma modu: Bu mod, dosyada var olan
ne varsa temizler ve dosyayı resetler.
2-)std::ios_base::out açma modu:Bu mod, dosyayı sadece yazma
amaçlı açmak için kullanılır.
3-)std::ios_base::in açma modu: Bu mod, dosyayı sadece okuma
amaçlı açmak için kullanılır.
4-)std::ios_base::binary açma modu: Bu mod, adından da anlaşılabileceği
gibi dosyayı binary yani 2'lik modda bitsel olarak okumak
için kullanılır.
5-)std::ios_base::app açma modu: Bu mod, bir dosyayı açarken,
dosyayı "append" (ekleme) modunda açar.
6-)std::ios_base::ate açma modu: Bu mod, bir dosyayı açarken,
dosyanın sonunda başlatır ve dosyanın içeriğine erişim sağlar.
Bu mod, bir dosyanın içeriğini değiştirirken kullanışlıdır.
ate modu, dosya işaretçisini dosyanın sonuna taşır ve böylece
dosyanın içeriğinin sonuna erişebilirsiniz. Bu nedenle,
dosyanın sonundan itibaren veri okuma veya yazma
işlemlerinde kullanılabilir.
Aşağıdaki örnekte std::ios_base::out ile std::ios_base::app
birlikte çalıştırıldığından hem dosyayı yazma modunda aç hem
de append yani ekleme modunda aç anlamına gelmektedir.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <fstream>

using namespace std;

int main()
{
    ofstream ifs{"ali.txt",ios_base::out | ios_base::app};
}
/*--------------------------------------------------------
Aşağıdaki örnekte standart outputa hata var yazısı yazdırılacaktır.
Bunun nedeni kapanmış bir dosyanın good durumda olmamasından
kaynaklanmaktadır.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <fstream>

using namespace std;

int main()
{
    ifstream ifs{"notlar.txt"};

    ifs.close();

    if(ifs){
        cout << "good durumunda\n";
    }
    else{
        cout << "hata var\n";
    }
}
/*--------------------------------------------------------
Aşağıdaki örnekte dosya kapanmadan önce if deyiminin true
bölümü çalıştırılacaktır.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <fstream>

using namespace std;

int main()
{
    ifstream ifs{"notlar.txt"};

    if(ifs.is_open()){
        cout << "good durumunda\n";
    }
    else{
        cout << "hata var\n";
    }

    ifs.close();

    if(ifs.is_open()){
        cout << "good durumunda\n";
    }
    else{
        cout << "hata var\n";
    }
}
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <fstream>
#include <sstream>

using namespace std;

int main()
{
    int x = 132;
    string s{"ali"};
    int y = 56;

    auto str = (ostringstream{} << x << s << y ).str();

    cout << str << '\n';
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <fstream>
#include <sstream>

using namespace std;

int main()
{
    ofstream ofs{"out.txt"};

    if(!ofs){
        cerr << "out.txt dosyasi olusturulamadi\n";
        exit(EXIT_FAILURE);
    }

    ofs << showbase << hex << uppercase;

    for(int i = 0;i < 100;++i){
        ofs << i << '\n';
    }
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <fstream>

using namespace std;

bool isPrime(int val)
{
    if(val <= 1)
        return false;
    if(val % 2 == 0)
        return val == 2;
    if(val % 3 == 0)
        return val == 3;
    if(val % 5 == 0)
        return val == 5;
    if(val % 7 == 0)
        return val == 7;
    for(int i = 11;i * i < val;i+=2){
        if(val % i == 0)
            return false;
    }
    return true;
}

int main()
{
    ofstream ofs{"asal.txt"};
    if(!ofs){
        cerr << "out.txt dosyasi olusturulamadi\n";
        exit(EXIT_FAILURE);
    }
    int x = 2;
    int prime_count{};

    while(prime_count < 1000){
        if(isPrime(x)) {
            ofs << x << " ";
            ++prime_count;
        }
        ++x;
    }
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <fstream>
#include <iomanip>

using namespace std;

bool isPrime(int val)
{
    if(val <= 1)
        return false;
    if(val % 2 == 0)
        return val == 2;
    if(val % 3 == 0)
        return val == 3;
    if(val % 5 == 0)
        return val == 5;
    if(val % 7 == 0)
        return val == 7;
    for(int i = 11;i * i < val;i+=2){
        if(val % i == 0)
            return false;
    }
    return true;
}

int main()
{
    ofstream ofs{"asal.txt"};
    if(!ofs){
        cerr << "out.txt dosyasi olusturulamadi\n";
        exit(EXIT_FAILURE);
    }
    int x = 2;
    int prime_count{};

    while(prime_count < 1'000'000){
        if(isPrime(x)) {
            if(prime_count && prime_count % 10 == 0)
                ofs << "\n";
            ofs << setw(12) << x;
            ++prime_count;
        }
        ++x;
    }
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <fstream>

using namespace std;

ofstream creat_file(const string filename)
{
    ofstream ofs{filename};
    if(!ofs){
        throw runtime_error{filename + " cannot be created"};
    }
    return ofs;
}

ifstream open_file_read(const string filename)
{
    ifstream ifs{filename};
    if(!ifs){
        throw runtime_error{filename + " cannot be opened"};
    }
    return ifs;
}

int main()
{
    auto ifs{"main.cpp"};
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <fstream>

using namespace std;

ofstream creat_file(const string filename)
{
    ofstream ofs{filename};
    if(!ofs){
        throw runtime_error{filename + " cannot be created"};
    }
    return ofs;
}

ifstream open_file_read(const string filename)
{
    ifstream ifs{filename};
    if(!ifs){
        throw runtime_error{filename + " cannot be opened"};
    }
    return ifs;
}

int main()
{
    auto ifs{open_file_read("asal.txt")};
    int x;

    while(ifs >> x){
        cout << x << '\n';
    }
}
/*--------------------------------------------------------
Aşağıdaki örnekte C++11 ile gelen random standart kütüphanesini
kullanarak [10,20] aralığında değer üretilecektir.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <fstream>
#include <random>

using namespace std;

int main()
{
    ofstream ofs{"out.txt"};
    if(!ofs){
        cerr << "out.txt dosyasi olusturulamadi\n";
        exit(EXIT_FAILURE);
    }
    mt19937 eng{random_device{}()};
    uniform_int_distribution<int> dist{10,20};

    for(int i = 0;i < 1000;++i){
        ofs << dist(eng) << " ";
    }
}
/*--------------------------------------------------------
Aşağıdaki örnekte dosyasa bir ID bir isim ve soyad
yazımı gerçekleştirilmiştir.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <fstream>
#include <random>

using namespace std;

string rname()
{
    vector<string> names = { "John", "Jane", "Michael", "Emily", "David", "Sophie", "William", "Olivia", "James", "Isabella" };
    mt19937 rng(random_device{}());
    uniform_int_distribution<int> dist(0, names.size() - 1);
    return names[dist(rng)];
}

string rsurname()
{
    vector<string> surnames = { "Smith", "Johnson", "Williams", "Jones", "Brown", "Davis", "Miller", "Wilson", "Moore", "Taylor" };
    mt19937 rng(random_device{}());
    uniform_int_distribution<int> dist(0, surnames.size() - 1);
    return surnames[dist(rng)];
}

int main()
{
    ofstream ofs{"out.txt"};
    if(!ofs){
        cerr << "out.txt dosyasi olusturulamadi\n";
        exit(EXIT_FAILURE);
    }
    mt19937 eng{random_device{}()};
    uniform_int_distribution<int> dist{0,999'999};

    for(int i = 0;i < 1000;++i){
        ofs << dist(eng) << ' ' << rname() << ' ' << rsurname() << ' ' << '\n';
    }
}
/*--------------------------------------------------------
int ve double türden iki tane sayının dosyaya yazdırılması
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <fstream>
#include <sstream>
#include <random>

using namespace std;

int main()
{
    ofstream ofs{ "out.txt" };
    
    if (!ofs) {
        cerr << "out.txt dosyasi olusturulamadi\n";
        exit(EXIT_FAILURE);
    }
    mt19937 eng{ random_device{}()};
    uniform_int_distribution<int> i_dist{0,999'999};
    uniform_real_distribution<double> r_dist{0, 9.99};

    for (int i = 0; i < 1000; ++i) {
        ofs << i_dist(eng) << ' ' << r_dist << '\n';
    }

}
/*--------------------------------------------------------
Yazılan dosyadan okuma yapma
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <fstream>
#include <random>

using namespace std;

int main()
{
    ifstream ifs{"out.txt"};
    if(!ifs){
        cerr << "out.txt dosyasi olusturulamadi\n";
        exit(EXIT_FAILURE);
    }
    int ID;
    string name,surname;

    while(ifs >> ID >> name >> surname){
        cout << ID << ' ' << name << ' ' << surname << '\n';
    }
}
/*--------------------------------------------------------
Dosyada bulunanm elemanlar bir vector containerına aşağıdaki
örnekte olduğu gibi yazdırılabilir.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <fstream>
#include <random>
#include <chrono>

using namespace std;

int main()
{
    ifstream ifs{"out.txt"};
    if(!ifs){
        cerr << "out.txt dosyasi olusturulamadi\n";
        exit(EXIT_FAILURE);
    }

    vector<int> prime_vec;

    int x;

    auto tp_start = chrono::steady_clock::now();

    while(ifs >> x){
        prime_vec.push_back(x);
    }
    auto tp_end = chrono::steady_clock::now();

    cout << chrono::duration<double>(tp_end - tp_start).count() << '\n';

    cout << "size = " << prime_vec.size() << '\n';
}
/*--------------------------------------------------------
copy_if kullanılarak dosyadaki elemanları vectore yazdırılabilir.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <fstream>
#include <random>
#include <chrono>
#include <iterator>

using namespace std;

template<class Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    fstream ofs{"out1.txt"};
    if(!ofs){
        cerr << "out.txt dosyasi olusturulamadi\n";
        exit(EXIT_FAILURE);
    }

    vector<int> ivec;
    ivec.reserve(1'000'000);

    mt19937 eng{ random_device{}()};
    uniform_int_distribution<int> i_dist{0,100};

    for (int i = 0; i < 1'000'000; ++i) {
        ofs << i_dist(eng) << ' ';
    }

    int ival;
    while(ofs >> ival){
        ivec.push_back(ival);
    }
    ofstream ofs2{"out2.txt"};
    if(!ofs2){
        cerr << "out2.txt dosyasi olusturulamadi\n";
        exit(EXIT_FAILURE);
    }
    copy_if(ivec.begin(),ivec.end(), ostream_iterator<int>{ofs2,"\n"},[](int x){return x % 10 == 3;});
}
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <fstream>
#include <iterator>
#include <vector>

using namespace std;

template<class Iter>
void print(Iter beg,Iter end)
{
    while(beg != end){
        cout << *beg++ << ' ';
    }
    cout << '\n';
}

int main()
{
    ifstream ifs{"asal.txt"};
    if(!ifs){
        cerr << "dosya acilamadi\n";
        return 1;
    }

    vector<int> ivec{istream_iterator<int>{ifs},istream_iterator<int>{}};

    cout << "ivec.size() = " << ivec.size() << '\n';
    print(ivec.begin(),ivec.end());
}
/*--------------------------------------------------------
Aşağıdaki örnekte olduğu gibi max_element standart kütüphane
fonksiyonu dereferencing operatörünün operandı yapılarak
cour ile birlikte kullanılabilir.
-------------------------------------------------------*/
#include <iostream>
#include <iterator>
#include <vector>

using namespace std;

int main()
{
    cout << *max_element(istream_iterator<int>{cin},{}) << '\n';
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <iterator>
#include <vector>

using namespace std;

int main()
{
    ofstream ifs{"out.txt"};
    if(!ifs){
        cerr << "dosya acilamadi\n";
        exit(EXIT_FAILURE);
    }

    vector<string> svec{istream_iterator<string>{},{}};

    for(auto& s : svec){
        cout << s << '\n';
    }
}
/*--------------------------------------------------------
Aşağıdaki örnektwe olduğu gibi dosyadan okuma yapılabilir.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <fstream>
#include <iterator>
#include <vector>
#include <iomanip>

using namespace std;

int main()
{
    ifstream ifs{"out2.txt"};
    if(!ifs){
        cerr << "dosya acilamadi\n";
        exit(EXIT_FAILURE);
    }
    string word;
    int cnt{};

    cout << left << setfill('0');

    while(ifs >> word){
        cout << setw(4) << ' '<< ++cnt << word << '\n';
    }
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <fstream>
#include <vector>

using namespace std;

int main()
{
   ifstream ifs{"asal.txt"};
   if(!ifs){
       cerr << "dosya acilamadi\n";
       return 1;
   }

   string sline;

   while(getline(ifs,sline)){
       cout << sline;
       (void)getchar();
   }
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <fstream>
#include <vector>

using namespace std;

int main()
{
   ifstream ifs{"out.txt"};
   if(!ifs){
       cerr << "dosya acilamadi\n";
       return 1;
   }

   char c;

   while((c = ifs.get(c)) != EOF){
       cout << stat,c_cast<char>(c);
       (void)getchar();
   }
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <fstream>
#include <ostream>
#include <iterator>
#include <vector>

using namespace std;

int main()
{
   ifstream ifs{"main.cpp",ios::binary};
   if(!ifs){
       cerr << "dosya acilamadi\n";
       return 1;
   }

   ofstream ofs{"main.txt",ios::binary};
   if(!ofs){
       cerr << "main.txt dosyasi olusturulmadi\n";
       exit(EXIT_FAILURE);
   }
   char c = 0;

   while(ifs.get()){
       ofs.put(c);
   }
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <fstream>
#include <ostream>
#include <iterator>
#include <vector>

using namespace std;

int main()
{
   ifstream ifs{"main.cpp",ios::binary};
   if(!ifs){
       cerr << "dosya acilamadi\n";
       return 1;
   }

   ofstream ofs{"main.txt",ios::binary};
   if(!ofs){
       cerr << "main.txt dosyasi olusturulmadi\n";
       exit(EXIT_FAILURE);
   }

   ofs << ifs.rdbuf();
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <fstream>
#include <ostream>
#include <iterator>
#include <vector>
#include <sstream>

using namespace std;

int main()
{
   ifstream ifs{"main.cpp",ios::binary};
   if(!ifs){
       cerr << "dosya acilamadi\n";
       return 1;
   }

   ostringstream oss;

   oss << ifs.rdbuf();

   auto str = oss.str();

   reverse(str.begin(),str.end());

   cout << str;
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <fstream>
#include <ostream>
#include <iterator>
#include <vector>
#include <sstream>

using namespace std;

int main()
{
   ifstream ifs{"main.cpp",ios::binary};
   if(!ifs){
       cerr << "dosya acilamadi\n";
       return 1;
   }

   ostringstream oss;

   oss << ifs.rdbuf();

   auto str = oss.str();

    erase_if(str,[](char c){return isspace(c);});

   cout << str;
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <fstream>
#include <ostream>
#include <iterator>
#include <vector>
#include <sstream>

using namespace std;

auto create_file(auto name){
    ofstream ofs{name, ios::binary};
    if(!ofs){
        throw runtime_error{name + "cannot be created!"};
    }
    return ofs;
}

ifstream open_file(const string& name)
{
    ifstream ifs{name, ios::binary};
    if(!ifs){
        throw runtime_error{name + "cannot be opened!"};
    }
    return ifs;
}

int main()
{
   ifstream ifs = open_file("primes.dat");

   int x;

    while(ifs.read(reinterpret_cast<char*>(&x),sizeof x)){
        cout << x << ' ';
        (void)getchar();
    }
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <fstream>
#include <ostream>
#include <iterator>
#include <vector>
#include <sstream>

using namespace std;

auto create_file(auto name){
    ofstream ofs{name, ios::binary};
    if(!ofs){
        throw runtime_error{name + "cannot be created!"};
    }
    return ofs;
}

ifstream open_file(const string& name)
{
    ifstream ifs{name, ios::binary};
    if(!ifs){
        throw runtime_error{name + "cannot be opened!"};
    }
    return ifs;
}

int main()
{
   ifstream ifs = open_file("primes.dat");

   int x;

    vector<int> ivec(1'000'000);

    if(!ifs.read(reinterpret_cast<char*>(ivec.data()),1'000'000 * sizeof(int))){
        cout << "okuma basarisiz" << '\n';
    }
    else {
        cout << "okunan byte sayisi : " << ifs.gcount() << '\n';
    }
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <fstream>
#include <ostream>
#include <iterator>
#include <vector>
#include <sstream>

using namespace std;

bool isPrime(const int val)
{
    if(val <= 1)
        return false;
    if(val % 2 == 0)
        return val == 2;
    if(val % 3 == 0)
        return val == 3;
    if(val % 5 == 0)
        return val == 5;
    if(val % 7 == 0)
        return val == 7;
    for(int i = 11;i * i < val;i+=2){
        if(val % i == 0)
            return false;
    }
    return true;
}

auto create_file(const string& name){
    ofstream ofs{name, ios::binary};
    if(!ofs){
        throw runtime_error{name + "cannot be created!"};
    }
    return ofs;
}

ifstream open_file(const string& name)
{
    ifstream ifs{name, ios::binary};
    if(!ifs){
        throw runtime_error{name + "cannot be opened!"};
    }
    return ifs;
}
constexpr size_t n = 1'000'000;

int main()
{
   auto ofs = create_file("primes.dat");

   int val = 2;
   size_t prime_count{};

   while(prime_count < n){
       if(isPrime(val)){
           ofs.write(reinterpret_cast<const char*>(&val), sizeof(val));
           ++prime_count;
       }
       ++val;
   }
   ifstream ifs = open_file("primes.dat");

   int x;

    vector<int> ivec(1'000'000);

    if(!ifs.read(reinterpret_cast<char*>(ivec.data()),1'000'000 * sizeof(int))){
        cout << "okuma basarisiz" << '\n';
    }
    else {
        cout << "okunan byte sayisi : " << ifs.gcount() << '\n';
    }
}
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <fstream>
#include <ostream>
#include <iterator>
#include <vector>
#include <sstream>

using namespace std;

bool isPrime(const int val)
{
    if(val <= 1)
        return false;
    if(val % 2 == 0)
        return val == 2;
    if(val % 3 == 0)
        return val == 3;
    if(val % 5 == 0)
        return val == 5;
    if(val % 7 == 0)
        return val == 7;
    for(int i = 11;i * i < val;i+=2){
        if(val % i == 0)
            return false;
    }
    return true;
}

auto create_file(const string& name){
    ofstream ofs{name, ios::binary};
    if(!ofs){
        throw runtime_error{name + "cannot be created!"};
    }
    return ofs;
}

ifstream open_file(const string& name)
{
    ifstream ifs{name, ios::binary};
    if(!ifs){
        throw runtime_error{name + "cannot be opened!"};
    }
    return ifs;
}
constexpr size_t n = 1'000'000;

int main()
{
   ifstream ifs = open_file("primes.dat");
   int x;

   vector<int> ivec(1'000'000);

    if(!ifs.read(reinterpret_cast<char*>(ivec.data()),1'000'000 * sizeof(int))){
        cout << "okuma basarisiz" << '\n';
    }
    else {
        cout << "okunan byte sayisi : " << ifs.gcount() << '\n';
    }

    int n;

    cout << "kacinci asal sayi: ";
    cin >> n;
    cout << n << ". asal sayi : " << ivec[n - 1] << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <fstream>
#include <ostream>
#include <iterator>
#include <vector>
#include <sstream>

using namespace std;

template<typename Container>
void print(Container con)
{
    for(auto iter = con.begin();iter != con.end();++iter){
        cout << *iter << ' ';
    }
    cout << '\n';
}

auto create_file(const string& name){
    ofstream ofs{name, ios::binary};
    if(!ofs){
        throw runtime_error{name + "cannot be created!"};
    }
    return ofs;
}

ifstream open_file(const string& name)
{
    ifstream ifs{name, ios::binary};
    if(!ifs){
        throw runtime_error{name + "cannot be opened!"};
    }
    return ifs;
}
constexpr size_t n = 1'000'000;

int main()
{
   ifstream ifs = open_file("primes.dat");
   int x;

   vector<int> ivec(1'000'000);

    if(!ifs.read(reinterpret_cast<char*>(ivec.data()),1'000'000 * sizeof(int))){
        cout << "okuma basarisiz" << '\n';
    }
    else {
        cout << "okunan byte sayisi : " << ifs.gcount() << '\n';
    }

    copy_if(ivec.begin(),ivec.end(),ostream_iterator<int>{std::cout," "}, [](const int x){return x % 10 == 3;});

    print(ivec);
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <fstream>
#include <ostream>
#include <iterator>
#include <vector>
#include <sstream>

using namespace std;

template<typename Container>
void print(Container con)
{
    for(auto iter = con.begin();iter != con.end();++iter){
        cout << *iter << ' ';
    }
    cout << '\n';
}

auto create_file(const string& name){
    ofstream ofs{name, ios::binary};
    if(!ofs){
        throw runtime_error{name + "cannot be created!"};
    }
    return ofs;
}

ifstream open_file(const string& name)
{
    ifstream ifs{name, ios::binary};
    if(!ifs){
        throw runtime_error{name + "cannot be opened!"};
    }
    return ifs;
}
bool mypred(int val)
{
    auto s = to_string(val);
    return s[0] == '3' && s.size() > 7 && s.find('0') != string::npos;
}

constexpr size_t n = 1'000'000;

int main()
{
   ifstream ifs = open_file("primes.dat");
   int x;

   vector<int> ivec(1'000'000);

    if(!ifs.read(reinterpret_cast<char*>(ivec.data()),1'000'000 * sizeof(int))){
        cout << "okuma basarisiz" << '\n';
    }
    else {
        cout << "okunan byte sayisi : " << ifs.gcount() << '\n';
    }

    copy_if(ivec.begin(),ivec.end(),ostream_iterator<int>{std::cout," "}, mypred);

    print(ivec);
}
/*--------------------------------------------------------
aşağıdaki örnekte dosyaya binary modda rastgele sayılar
yazdırılmıştır.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <fstream>
#include <ostream>
#include <iterator>
#include <random>

using namespace std;


int main()
{
    ofstream ofs{"sayilar.dat",ios::binary};
    if(!ofs){
        cerr << "dosya olusturulamadi\n";
        return 1;
    }

    int x;
    mt19937 eng;
    uniform_int_distribution dist{0,1000};

    for(int i = 0;i < 100;++i){
        x = dist(eng);
        cout << x << " ";
        ofs.write(reinterpret_cast<const char*>(&x),sizeof(x));
    }
}

/*--------------------------------------------------------
Aşağıdaki örnekte gcount fonksiyonu kullanılarak dosyadaki
toplam byte sayısı elde edilebilir eleman sayısı da bunun
intin sizeof değerine bölünmesiyle elde edilebilir.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <fstream>
#include <ostream>
#include <iterator>
#include <random>

using namespace std;


int main()
{
    ifstream ifs{"sayilar.dat",ios::binary};
    if(!ifs){
        cerr << "dosya olusturulamadi\n";
        return 1;
    }

    constexpr int size{500};

    int a[size];
    ifs.read(reinterpret_cast<char*>(a),size * sizeof(int));
    cout << "okunan tam sayi adedi : ";
    cout << ifs.gcount() / sizeof(int) << '\n';

}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <fstream>
#include <ostream>
#include <iterator>
#include <random>

using namespace std;


int main()
{
    ifstream ifs{"primes.dat",ios::binary};
    if(!ifs){
        cerr << "dosya olusturulamadi\n";
        return 1;
    }

    ifs.seekg(40u);
    int x;

    ifs.read(reinterpret_cast<char*>(&x), sizeof(x));

    cout << "x = " << x << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte seekg fonksiyonuna argüman olarak asal
sayının pozisyon değeri argüman olarak geçilerek n. asal
sayı elde edilebilir.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <fstream>
#include <ostream>
#include <iterator>
#include <random>

using namespace std;


int main()
{
    ifstream ifs{"primes.dat",ios::binary};
    if(!ifs){
        cerr << "dosya olusturulamadi\n";
        return 1;
    }

    int x;

    for(;;){

        size_t n;
        cout << "kacinci asal sayi : ";
        cin >> n;
        if(n == 0)
            break;
        ifs.seekg((n - 1)* sizeof(int));
        ifs.read(reinterpret_cast<char*>(&x),sizeof x);
        cout << n << ". asal sayi " << x << '\n';
    }
}
/*--------------------------------------------------------
Aşağıdaki örnekte seekg fonksiyonuyla baştan sona dosya gezilebilir.
tellg fonksiyonu kullanılarak da toplam byte sayısı elde edilebilir.
-------------------------------------------------------*/
#include <iostream>
#include <string>
#include <fstream>
#include <ostream>
#include <iterator>
#include <random>

using namespace std;


int main()
{
    ifstream ifs{"primes.dat",ios::binary};
    if(!ifs){
        cerr << "dosya olusturulamadi\n";
        return 1;
    }

    int x;

    ifs.seekg(0,ios::end);
    cout << ifs.tellg() << " byte";
}
/*--------------------------------------------------------
Aşağıdaki örnekte get_fila_size fonksiyonu kullanılarak
dosyaya ait dosya uzunluğu elde edilecektir.
-------------------------------------------------------*/
#include <string>
#include <fstream>
#include <iostream>

auto get_file_size(const std::string& filename)
{
    std::ifstream ifs{filename,std::ios::binary};
    if(!ifs){
        throw std::runtime_error{filename + " acilamadi!"};
    }
    ifs.seekg(0,std::ios::end);
    return ifs.tellg();
}


int main()
{
    using namespace std;

    cout << get_file_size("primes.dat") << '\n';
    cout << get_file_size("sayilar.dat") << '\n';
    cout << get_file_size("C++_Notlar.txt") << '\n';
}
/*--------------------------------------------------------
standart kütüphanenin fail ve starts_with fonksiyonları
-------------------------------------------------------*/
#include <string>
#include <fstream>
#include <iostream>

int main()
{
    using namespace std;

    ifstream ifs{"C++_Notlar"};
    if(ifs.fail()){
        cerr << "dosya acilamadi\n";
        return 1;
    }
    string sline;

    while(getline(ifs,sline)){
        if(sline.starts_with("iphone")){
            cout << sline << '\n';
        }
    }

}
/*--------------------------------------------------------
Aşağıdaki örnekte söz konusu dosyada o harfi bulunan tüm satırlar
ekrana yazdırılacaktır.
-------------------------------------------------------*/
#include <string>
#include <fstream>
#include <iostream>

int main()
{
    using namespace std;

    ifstream ifs{"C++_Notlar.txt"};
    if(ifs.fail()){
        cerr << "dosya acilamadi\n";
        return 1;
    }
    string sline;
    while(getline(ifs,sline,'o')){
        cout << sline << '\n';
    }
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <string>
#include <fstream>
#include <iostream>

int main()
{
    using namespace std;

    ifstream ifs{"C++_Notlar.txt"};
    if(ifs.fail()){
        cerr << "dosya acilamadi\n";
        return 1;
    }
    string sline;

    ifs.ignore(7);
    getline(ifs,sline);
    cout << sline << '\n';

}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <string>
#include <fstream>
#include <iostream>

int main()
{
    using namespace std;

    ifstream ifs{"C++_Notlar.txt"};
    if(ifs.fail()){
        cerr << "dosya acilamadi\n";
        return 1;
    }
    string sline;

    ifs.ignore(10000,'s');
    getline(ifs,sline);
    cout << sline << '\n';

}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <string>
#include <fstream>
#include <iostream>

int main()
{
    using namespace std;

    cout << numeric_limits<streamsize>::max() << '\n';

}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <string>
#include <fstream>
#include <iostream>

int main()
{
    using namespace std;

    cin.ignore(numeric_limits<streamsize>::max(),'a');
}
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
#include <string>
#include <fstream>
#include <iostream>
#include <iomanip>

int main(int argc,char** argv)
{
    using namespace std;

    if(argc != 3){
        cerr << "kullanim : <bol> <dosya ismi> <byte>\n";
        return 1;
    }

    ifstream ifs{argv[1],ios::binary};
    if(!ifs){
        cerr << argv[1] << " dosyasi acilamadi\n";
        return 2;
    }

    char c;

    int file_count{};
    int byte_count{};
    int chunk = atoi(argv[2]);
    ofstream ofs;



    while(ifs.get(c)){
        if(!ofs.is_open()){
            ostringstream oss;
            oss << setfill('0');
            oss << "parca " << setw(3) << file_count + 1 << ".par";
            ofs.open(oss.str(), ios::binary);
            if(!ofs){
                cerr << oss.str() << " dosyasi olusturulamadi\n";
                return 1;
            }
            ++file_count;
        }
        ofs.put(c);
    }

}
/*--------------------------------------------------------
C++11 ile eklenen random kütüphanesi C'den gelen stdlib.h
başlık dosyasının içinde bulunan srand ve rand fonksiyonlarının
bir alternatifi niteliğindedir. Ayrıca bunlardan daha iyi
bir alternatiftir denilebilir.
-------------------------------------------------------*/
#include <random>
#include <iostream>


int main()
{
    using namespace std;
    mt19937 eng;

    cout << mt19937::min() << '\n';
    cout << mt19937::max() << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte for döngüsü kullanılarak eng() ile
-------------------------------------------------------*/
#include <random>
#include <iostream>


int main()
{
    using namespace std;
    mt19937 eng;

    for(int i = 0;i < 100;++i){
        cout << eng() << '\n';
    }
}
/*--------------------------------------------------------
Aşağıdaki örnekte gösterildiği gibi default_seed kullanılarak
default olarak belirlenen tohum değeri standart output a
yazdırılabilir.
-------------------------------------------------------*/
#include <random>
#include <iostream>

int main()
{
    using namespace std;

    mt19937_64 eng;

    cout << eng.default_seed << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte tohum değeri programcı tarafından belirlenmiştir.
-------------------------------------------------------*/
#include <random>

int main()
{
    using namespace std;

    mt19937_64 eng(8626534u);
}
/*--------------------------------------------------------
Aşağıdaki örnekte tohum değerinin 468 olduğundan elde edilen
rastgele sayı dizisi bu tohum değeri için hep aynı olacaktır.
-------------------------------------------------------*/
#include <random>
#include <iostream>

int main()
{
    using namespace std;

    mt19937_64 eng(468);

    for(int i = 0;i < 10;++i){
        cout << eng() << '\n';
    }
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <random>
#include <iostream>

int main()
{
    using namespace std;

    mt19937_64 eng(765123);

    for(int i = 0;i < 1'000'000;++i){
        auto x = eng();
    }
    cout << eng() << '\n';
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <random>
#include <iostream>

int main()
{
    using namespace std;

    mt19937_64 eng;

    for(int i = 1000;i < 1010;++i){
        eng.seed(i);
        cout << "seed value : " << i << '\n';
        for(int i = 0;i < 10;++i){
            cout << eng() << '\n';
        }
        (void)getchar();
        system("cls");
    }
}
/*--------------------------------------------------------
Aşağıdaki örnekte zamana bağlı değişen bir tohum değeri
olacağından program her çalıştırıldığında farklı değerler
elde edilecektir.
-------------------------------------------------------*/
#include <random>
#include <iostream>

int main()
{
    using namespace std;

    mt19937_64 eng(time(nullptr));

    for(int i = 0;i < 10;++i){
        cout << eng() << '\n';
    }
}
/*--------------------------------------------------------
Aşağıdaki örnekte rastgele sayı üretimi için bazı farklı
örnekler gösterilmiştir.
-------------------------------------------------------*/
#include <random>
#include <iostream>
#include <ctime>
#include <cstdlib>
#include <chrono>

using namespace std;
using namespace std::chrono;

int main()
{
    mt19937 eng1;
    mt19937 eng2{87932812u};
    mt19937 eng3{std::chrono::system_clock::now().time_since_epoch().count()};
    mt19937 eng4{random_device{}()};
}
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
#include <random>
#include <iostream>
#include <sstream>

using namespace std;

int main()
{
    mt19937 eng;

    for(int i = 0;i < 10;++i){
        cout << eng() << " ";
    }

    stringstream ss;

    ss << eng << '\n';

    for(int i = 0;i < 1000;++i){
        eng();
    }
    for(int i = 0;i < 10;++i){
        cout << eng() << '\n';
    }
}
/*--------------------------------------------------------
Aşağıdaki örnekte ifin true bölümü çalıştırılacaktır.
-------------------------------------------------------*/
#include <random>
#include <iostream>

using namespace std;

int main()
{
    mt19937 eng1;
    mt19937 eng2;

    if(eng1 == eng2){
        cout << "ayni durumdalar\n";
    }
    else{
        cout << "farkli durumdalar\n";
    }
}
/*--------------------------------------------------------
Aşağıdaki örnekte ise 2. if deyimi için false bölüm
çalıştırılacaktır. ancak 3. if deyiminde ise tekrardan aynı
durumda olacaktır.
-------------------------------------------------------*/
#include <random>
#include <iostream>

using namespace std;

int main()
{
    mt19937 eng1;
    mt19937 eng2;

    if(eng1 == eng2){
        cout << "ayni durumdalar\n";
    }
    else{
        cout << "farkli durumdalar\n";
    }
    for(int i = 0;i < 10;++i){
        auto x = eng1();
    }
    if(eng1 == eng2){
        cout << "ayni durumdalar\n";
    }
    else{
        cout << "farkli durumdalar\n";
    }
     for(int i = 0;i < 10;++i){
        auto x = eng2();
     }
     if(eng1 == eng2){
        cout << "ayni durumdalar\n";
     }
     else{
        cout << "farkli durumdalar\n";
     }
}
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
#include <random>
#include <iostream>
#include <map>

using namespace std;

int main()
{
    mt19937 eng{random_device{}()};
    uniform_int_distribution dist{1,6};

    map<int,int> cmap;

    for(int i = 0;i < 1'000'000;++i){
        ++cmap[dist(eng)];
    }
    for(const auto [value,count] : cmap){
        cout << value << " " << count << '\n';
    }
}
/*--------------------------------------------------------
Aşağıdaki örnekte rastgele gerçek sayı üretimi gösterilmiştir.
-------------------------------------------------------*/
#include <random>
#include <iostream>
#include <map>
#include <iomanip>

using namespace std;

int main()
{
    mt19937 eng{random_device{}()};
    uniform_real_distribution dist{3.54,4.87};

    for(int i = 0;i < 100;++i){
        cout << fixed << setprecision(4) << dist(eng) << '\n';
    }
}
/*--------------------------------------------------------
Aşağıdaki örnekte rastgele karakter üretimi yapılmaktadır.
-------------------------------------------------------*/
#include <random>
#include <iostream>

using namespace std;

int main()
{
    mt19937 eng{random_device{}()};
    uniform_int_distribution dist{0,25};

    for(int i = 0;i < 100;++i){
        cout << static_cast<char>(dist(eng) + 'A');
    }
}
/*--------------------------------------------------------
Aşağıdaki örnekte dizinin rastgele elemanları elde edilmiştir.
-------------------------------------------------------*/
#include <random>
#include <iostream>

using namespace std;

int main()
{
    const char* p[] = {"ali","zeynep","ayse","nur","demir","salim","murat"};
    mt19937 eng{random_device{}()};
    uniform_int_distribution dist{0,6};

    for(;;){
        cout << p[dist(eng)];
        (void)getchar();
    }
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <random>
#include <iostream>
#include <map>

using namespace std;

int main()
{
    mt19937 eng{random_device{}()};
    normal_distribution dist{50.,10.};

    map<int,int> cmap;

    for(int i = 0;i < 1000;++i){
        ++cmap[lround(dist(eng))];
    }
    for(const auto [val,count] : cmap){
        cout << val << " " << count << '\n';
    }
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <random>
#include <iostream>
#include <map>
#include <iomanip>
#include <string>

using namespace std;

int main()
{
    mt19937 eng{random_device{}()};
    normal_distribution dist{50.,10.};

    map<int,int> cmap;

    for(int i = 0;i < 1000;++i){
        ++cmap[lround(dist(eng))];
    }
    cout << left;

    for(const auto [val,count] : cmap){
        cout << setw(2) << val << string(count / 10, '*') << '\n';
    }
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <random>
#include <iostream>
#include <map>
#include <iomanip>
#include <string>
#include <fstream>

using namespace std;

int main()
{
    mt19937 eng{random_device{}()};
    normal_distribution dist{50.,10.};

    map<int,int> cmap;

    for(int i = 0;i < 1000;++i){
        ++cmap[lround(dist(eng))];
    }
    ofstream ofs{"out.txt"};
    if(!ofs){
        cerr << "out.txt dosyasi olusturulamadi" << '\n';
        exit(EXIT_FAILURE);
    }
    ofs << left;

    for(const auto [val,count] : cmap){
        ofs << setw(2) << val << string(count / 10, '*') << '\n';
    }
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <random>
#include <iostream>
#include <map>

using namespace std;

int main()
{
   discrete_distribution<int> dist{0,10,10,10,10,10,10,10.3};
   mt19937 eng;
   map<int,int> cmap;

   for(int i = 0;i < 100'000;++i){
       ++cmap[dist(eng)];
   }
   for(const auto [value,count] : cmap){
       cout << value << " " << count << '\n';
   }
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <random>
#include <iostream>
#include <map>

using namespace std;

int main()
{
   discrete_distribution<int> dist{0,3.4,3.4,3.4,3.4,3.5,3.4};
   mt19937 eng;
   map<int,int> cmap;

   for(int i = 0;i < 100'000;++i){
       ++cmap[dist(eng)];
   }
   for(const auto [value,count] : cmap){
       cout << value << " " << count << '\n';
   }
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <random>
#include <iostream>
#include <map>

using namespace std;

int main()
{
   discrete_distribution<int> dist{0,25.,75.};
   mt19937 eng;
   map<int,int> cmap;

   for(int i = 0;i < 100'000;++i){
       ++cmap[dist(eng)];
   }
   for(const auto [value,count] : cmap){
       cout << value << " " << count << '\n';
   }
}
/*--------------------------------------------------------
standart random kütüphanesinin bernoulli distribution fonksiyonu
-------------------------------------------------------*/
#include <random>
#include <iostream>

using namespace std;

int main()
{
   bernoulli_distribution dist{0.5};
   mt19937 eng;

   for(int i = 0;i < 1000;++i){
       cout.put(dist(eng) ? 'e' : 'h');
   }
}
/*--------------------------------------------------------
Aşağıdaki örnekte yüzde 99 oranında true ve yüzde 1 oranında
h verilecektir.
-------------------------------------------------------*/
#include <random>
#include <iostream>

using namespace std;

int main()
{
   bernoulli_distribution dist{0.99};
   mt19937 eng;

   for(int i = 0;i < 5000;++i){
       cout.put(dist(eng) ? 'e' : 'h');
   }
}
/*--------------------------------------------------------
standart kütüphanenin generate_n fonksiyonu
-------------------------------------------------------*/
#include <random>
#include <vector>

using namespace std;

int main()
{
   vector<int> ivec;
   mt19937 eng;
   uniform_int_distribution dist{1200,1500};

    generate_n(back_inserter(ivec),100,[&]{return dist(eng);});
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <random>
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <thread>

using namespace std;

int main()
{
   string name{"darthvader"};

   mt19937 eng;

   for(;;){
       cout << name <<'\n';
       std::this_thread::sleep_for(500ms);
       shuffle(name.begin(),name.end(),eng);
       system("cls");
   }
}
/*--------------------------------------------------------
RAII:ctor bir kaynak edinsin ve hayatı bitince dtorla
yok edilsin.
-------------------------------------------------------*/
/*--------------------------------------------------------
AAA:almost always auto
-------------------------------------------------------*/
/*--------------------------------------------------------
concurrency:aynı anda birden fazla iş yapılması
Bir programin concurrent olmasi:İki işi aynı yapılması
durumunda bir program concurrent denilebilir.
Paralel Programlama ile Concurrent programlama arasındaki
fark: Paralel programlama şuna benzetilebilir kişi bir yandan
yemek yiyor bir yandan televizyon izliyor olabilir ve bu iki
işi daima eş zamanlı olarak yapmaması zamana yayarak bir o
bir bu işi yapması durumunda buna paralel programlama adı verilir.
Ancak diğer bir yandan kişi iki tane işi aynı zamanda yapıyorsa
örneğin kişinin yürürken telefonla konuşması buna verilebilecek
güzel bir örnektir. Bir program concurrent olurken aynı zamanda
paralel olabilir aynı şekilde bir program paralel olurken
aynı zamanda concurrent da olabilir.
-------------------------------------------------------*/
/*--------------------------------------------------------
Bir threadin bir iş yapıp yapmadığı standart kütüphanenin joinable
fonksiyonuyla sorgulanabilir. Eğer thread bir iş yapılıyor
joinable fonksiyonu true değer döndürür, bir iş yapmıyorsa
false değer döndürür.
-------------------------------------------------------*/
#include <iostream>
#include <thread>

using namespace std;

int main()
{
   thread t;

   cout << boolalpha;

   cout << t.joinable() << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte thread bir iş yaptığı için joinable
fonksiyonu true değer elde edecektir.
-------------------------------------------------------*/
#include <iostream>
#include <thread>

using namespace std;

void func()
{
    cout << "func called\n";

    this_thread::sleep_for(chrono::seconds(5));
}

int main()
{
   thread t{func};

   cout << boolalpha;

   cout << t.joinable() << '\n';
}
/*--------------------------------------------------------
Bir thread'in işi bittikten sonra mutlaka standart thread
kütüphanesinin join fonksiyonu çağrılmalıdır. Eğer join
fonksiyonu çağrılmaz ise bu durumda terminate fonksiyonu 
çağrılır ve bu da bir programcı için oldukça kötü bir durumdur.
join fonksiyonu çağrıldıktan sonra joinable fonksiyonu
false değer üretecektir.
-------------------------------------------------------*/
#include <iostream>
#include <thread>

using namespace std;

void func()
{
    cout << "func called\n";

    this_thread::sleep_for(chrono::seconds(5));
}

int main()
{
   thread t{func};

   cout << boolalpha;

   cout << t.joinable() << '\n';
   t.join();
   cout << t.joinable() << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte 3 farklı thread ile beraber main içerisinde 
bulunan for aynı anda koşturulucağından ne zaman hangi ifadelerin 
ekrana basılacağı tam olarak kestirilemez.
-------------------------------------------------------*/
#include <iostream>
#include <thread>

using namespace std;

void func()
{
    for (int i = 0; i < 100'000; ++i)
        cout << "*";
}

void foo()
{
    for (int i = 0; i < 100'000; ++i)
        cout << "-";
}

void bar()
{
    for (int i = 0; i < 100'000; ++i)
        cout << "?";
}

int main()
{
    thread t1{ func };
    thread t2{ foo };
    thread t3{ bar };

    for (int i = 0; i < 100'000; ++i)
        cout << ".";

    t1.join();
    t2.join();
    t3.join();
}
/*--------------------------------------------------------
join fonksiyonu aşağıdaki örnekte olduğu gibi 2.defa çağrıldığında
exception throw edilir. eğer join hiç çağrılmasa exception
throw edilmeyecekti bunun yerine terminate çağrılacaktı.
-------------------------------------------------------*/

#include <iostream>
#include <thread>

using namespace std;

void func(){ }

int main()
{
    thread t{ func };

    t.join();
    try {
        t.join();
    }
    catch(const exception & ex) {
        cout << "exception caught : " << ex.what() << '\n';
    }
}
/*--------------------------------------------------------
thread'e aşağıdaki örnekte olduğu gibi bir diğer parametreler 
fonksiyona argüman olarak geçilmektedir.
-------------------------------------------------------*/
#include <iostream>
#include <thread>

using namespace std;

void foo(int x,int y,int z)
{
    cout << "foo x = " << x << '\n';
    cout << "foo y = " << y << '\n';
    cout << "foo z = " << z << '\n';
}



int main()
{
    thread tx{ foo, 10, 20, 30 };

    tx.join();
}
/*--------------------------------------------------------
fonksiyona argüman olarak bir const vector& türünden bir 
parametre değişkenine çağrı geçerlidir.
-------------------------------------------------------*/
#include <iostream>
#include <thread>
#include <vector>

using namespace std;

void foo(const vector<int> & ivec)
{
    for (const auto val : ivec)
        cout << val << ' ';
}



int main()
{
    vector<int> ivec{1,2,3,4,5};

    thread tx{foo,ivec};

    tx.join();
}
/*--------------------------------------------------------
Aşağıdaki örnekte nesne const olmadığı için syntax hatası 
oluşmuştur.
-------------------------------------------------------*/
#include <iostream>
#include <thread>
#include <vector>

using namespace std;

void foo(vector<int> & ivec)
{
    for (const auto val : ivec)
        cout << val << ' ';
}



int main()
{
    vector<int> ivec{1,2,3,4,5};

    thread tx{foo,ivec}; //error

    tx.join();
}
/*--------------------------------------------------------
Yukarıdaki örnekteki sorun const anahatar sözcüğü ile 
çözülebileceği gibi reference wrapper sınıfı kullanılarak
da düzeltilebilir.
-------------------------------------------------------*/
#include <iostream>
#include <thread>
#include <vector>

using namespace std;

void foo(vector<int> & ivec)
{
    for (const auto val : ivec)
        cout << val << ' ';
}



int main()
{
    vector<int> ivec{1,2,3,4,5};

    thread tx{ foo,ref(ivec) };

    tx.join();
}
/*--------------------------------------------------------
eğer aşağıdaki örnekte olduğu gibi vector bir r value 
reference ile bağlanılmak istenirse bu durumda std::move 
fonksiyonu kullanılmalıdır.
-------------------------------------------------------*/
#include <iostream>
#include <thread>
#include <vector>

using namespace std;

void foo(vector<int> && ivec)
{
    for (const auto val : ivec)
        cout << val << ' ';
}



int main()
{
    vector<int> ivec{1,2,3,4,5};

    thread tx{ foo,std::move(ivec)};

    tx.join();
}

/*--------------------------------------------------------
Eğer eleman düz vector ise bu durumda argüman olarak vector 
doğrudan geçilebilir.
-------------------------------------------------------*/
#include <iostream>
#include <thread>
#include <vector>

using namespace std;

void foo(vector<int> ivec)
{
    for (const auto val : ivec)
        cout << val << ' ';
}



int main()
{
    vector<int> ivec{1,2,3,4,5};

    thread tx{ foo,ivec};

    tx.join();
}
/*--------------------------------------------------------
Aşağıdaki örnekte x'in değeri son durumda 44 olarak elde 
edilecek
-------------------------------------------------------*/
#include <iostream>
#include <thread>

using namespace std;

void foo(int& r)
{
    r++;
}



int main()
{
    int x{ 43 };

    thread tx{foo,ref(x)};

    tx.join();

    cout << "x = " << x << '\n';
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <thread>

using namespace std;

void foo(int x)
{
    cout << "x : " << x << '\n';
}



int main()
{
    auto fp = foo;

    thread tx{fp,23};

    tx.join();
}
/*--------------------------------------------------------
Bir non-static üye fonksiyon için sınıf nesnesi kullanılarak 
aşağıdaki örnekte olduğu thread işlemi yapılabilir.
-------------------------------------------------------*/
#include <iostream>
#include <thread>

using namespace std;

class Functor {
public:
    void operator()(int x)const
    {
        cout << "x = " << x << '\n';
    }
};



int main()
{
    Functor f;

    thread tx{ f,12 };

    tx.join();
}
/*--------------------------------------------------------
Aşağıdaki örnekte most-vexing parse söz konusudur bunun
engellenmesi için {} kullanılması gerekmektedir. Bu durumda
bu bir fonksiyon bildirimi olarak değerlendirilmez.
-------------------------------------------------------*/
#include <iostream>
#include <thread>

using namespace std;

class Functor {
public:
    void operator()()const
    {
        cout << "Functor::operator() "<< '\n';
    }
};

int main()
{
    thread tx(Functor ()); //fonksiyon bildirimi

    tx.join();//error
}

/*--------------------------------------------------------
Yukarıdaki sorunun çözümü aşağıdaki gibi olabilir
-------------------------------------------------------*/
#include <iostream>
#include <thread>

using namespace std;

class Functor {
public:
    void operator()()const
    {
        cout << "Functor::operator() "<< '\n';
    }
};


int main()
{
    thread tx(Functor{});

    tx.join();
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <thread>

using namespace std;

class Functor {
public:
    void operator()()const
    {
        cout << "Functor::operator()()"<< '\n';
    }
};



int main()
{


    Functor fx;

    thread tx{fx};

    tx.join();
}
/*--------------------------------------------------------
Bir thread bir lamda ifadesiyle birlikte kullanılabilir.
Bu durum aynı bir fonksiyonun bir thread'e bağlanması gibi 
düşünülebilir.Örneğin aşağıdaki örnek için parametre değişkeni 
de 10 olarak fonksiyona gönderilmiştir.
-------------------------------------------------------*/
#include <iostream>
#include <thread>

using namespace std;



int main()
{


    thread t{ [](int x) {
        std::cout << x << "\n"; },10 };

    t.join();
}
/*--------------------------------------------------------
Aşağıdaki örnekte olduğu gibi bir non-static üye fonksiyona 
sınıf neysesiyle argüman thread kullanılarak gönderilebilir.
-------------------------------------------------------*/
#include <iostream>
#include <thread>

using namespace std;

class Ber {
public:
    void func()
    {
        cout << "Ber::func()" << '\n';
    }
};



int main()
{


    Ber myber;

    thread t{&Ber::func,myber};

    t.join();
}
/*--------------------------------------------------------
Aşağıdaki örnekte arka planda kopyalama semantiği devreye 
girdiği için bu örnek için Ber sınıfının copy ctoru çağrılır.
-------------------------------------------------------*/
#include <iostream>
#include <thread>

using namespace std;

class Ber {
public:
    Ber() = default;
    Ber(const Ber&)
    {
        cout << "copy ctor" << '\n';
    }
    void func()
    {
        cout << "Ber::func()" << '\n';
    }
};



int main()
{


    Ber myber;

    thread t{&Ber::func,myber};

    t.join();
}
/*--------------------------------------------------------
Eğer bu işlem ref ile yapılsaydı kopyalama semantiği devreye 
girmeyeceği için copy ctor çağrısı gerçekleşmeyecekti.
-------------------------------------------------------*/
#include <iostream>
#include <thread>

using namespace std;

class Ber {
public:
    Ber() = default;
    Ber(const Ber&)
    {
        cout << "copy ctor" << '\n';
    }
    void func()
    {
        cout << "Ber::func()" << '\n';
    }
};



int main()
{


    Ber myber;

    thread t{&Ber::func,ref(myber)};

    t.join();
}
/*--------------------------------------------------------
Aşağıdaki örnekte syntax hatasının nedeni ostreom sınıfının
copy ctorunun olmamasından kaynaklanmaktadır. Bu hatası 
çözmenin yolu reference wrapper sınıfını kullanmaktır.
-------------------------------------------------------*/
#include <iostream>
#include <thread>

using namespace std;


void func(const ostream& os);

int main()
{

    thread t{func,cout};
   
    t.join();
}

/*--------------------------------------------------------
Yukarıdaki problemin çözümü aşağıdaki gibi yapılabilir.
-------------------------------------------------------*/
#include <iostream>
#include <thread>

using namespace std;


void func(const ostream& os) {
    
}

int main()
{

    thread t{func,ref(cout)};
   
    t.join();
}
/*--------------------------------------------------------
thread nesnelerinin birbirine kopyalanması syntax hatasına 
neden olur.
-------------------------------------------------------*/
#include <iostream>
#include <thread>

using namespace std;



int main()
{

    thread tx;
    thread ty;

    tx = ty; //error
}
/*--------------------------------------------------------
thread nesnelerinin birbirine kopyalanması geçersizdir ancak 
birbirine taşınması geçerlidir.
Anahtar notlar:Taşınmış bir thread nesnesinin joinable fonksiyonu
false değer elde eder.
-------------------------------------------------------*/
#include <iostream>
#include <thread>

using namespace std;

void func(){}

int main()
{

    thread tx{func};

    cout << boolalpha << tx.joinable() << '\n';

    thread ty{ move(tx) };

    cout << boolalpha << tx.joinable() << '\n'; //false
    cout << boolalpha << ty.joinable() << '\n'; //true

    ty.join();
}
/*--------------------------------------------------------
Bir fonksiyonun paramtere değişkeni bir thread nesnesi olabilir.
-------------------------------------------------------*/
#include <iostream>
#include <thread>

using namespace std;

void func(thread t)
{
    t.join();
}

void workload() {}

int main()
{
    thread tx{ workload };

    func(move(tx));
}
/*--------------------------------------------------------
Bir thread parametre değişkenine başka bir thread nesnesi 
aşağıdaki gibi move fonksiyonu kullanılmadan da yapılabilir.
-------------------------------------------------------*/
#include <iostream>
#include <thread>

using namespace std;

void func(thread t)
{
    t.join();
}

void workload() {}

int main()
{
    func(thread{ workload });
}
/*--------------------------------------------------------
Bir fonksiyonun geri dönüş değeri de aşağıdaki örnekte 
olduğu gibi thread nesnesi olabilir.
-------------------------------------------------------*/
#include <iostream>
#include <thread>

using namespace std;

thread make_thread()
{
    thread t{ [] {
        cout << "func()" << '\n'; }};

    return t;
}

void workload() {}

int main()
{
    thread t;

    t = make_thread();

    t.join();
}
/*--------------------------------------------------------
Aşağıdaki örnekte fonksiyona argüman olarak geçilen ifade
move ile işleme sokulduğu için taşıma yapılmış gibi 
gözükse de böyle bir durum söz konusu değildir sadece tx 
nesnesi t, r value referansına bağlanmıştır.
-------------------------------------------------------*/
#include <iostream>
#include <thread>

using namespace std;

void func(thread&& t)
{
    auto tx = move(t);

    tx.join();
}

int main()
{
    thread tx{ [] {} };

    func(move(tx));
}
/*--------------------------------------------------------
typeid operatörü kullanılarak id türü class std::thread::id
olarak elde edilir.
-------------------------------------------------------*/
#include <iostream>
#include <thread>

using namespace std;

void func()
{
    cout << this_thread::get_id() << '\n';
}

int main()
{
    thread tx{func};

    auto id = tx.get_id();

    cout << typeid(id).name() << '\n';
    cout << "thread_id : " << id << '\n';

    tx.join();
}
/*--------------------------------------------------------
Aşağıdaki örnekte olduğu gibi bir kodla fonksiyonun ana thread 
ile mi yoksa chills ile çalıştırıldığı get_id operatörü 
kullanılarak bulunabilir.
-------------------------------------------------------*/
#include <iostream>
#include <thread>

using namespace std;

decltype(this_thread::get_id()) g_id;

void func()
{
    auto id = this_thread::get_id();

    if (id == g_id) {
        cout << "fonksiyon ana thread tarafindan calistiriliyor" << '\n';
    }
    else {
        cout << "fonksiyon chills tarafindan calistiriliyor" <<'\n';
    }
}

int main()
{
    g_id = this_thread::get_id();

    func();

    thread tx{ func };

    tx.join();
}
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------*/
#include <iostream>
#include <chrono>
#include <thread>

using namespace std;

auto now() { return chrono::steady_clock::now(); }

auto awake_time()
{
	using chrono::operator""ms;
	return now() + 2000ms;
}

int main()
{
	cout << "Hello\n" << flush;
	const auto start{now()};
	this_thread::sleep_until(awake_time());
	chrono::duration<double, milli> elapsed{now() - start};
	cout << "Waited " << elapsed.count() << " ms\n";
}
/*--------------------------------------------------------
Aşağıdaki örnekte join çağrılmadan bir exception throw edildiği için t thread i
için join fonksiyonu çağrılmayacaktır.
-------------------------------------------------------*/
#include <iostream>
#include <vector>
#include <algorithm>
#include <thread>

using namespace std;

void foo()
{
    cout << "foo called!\n";
}

void func()
{
    cout << "func called!\n";
    throw runtime_error{"runtime error exception from func\n"};
}

int main()
{
   thread t{foo};

   try{
       func();
       t.join();
   }
   catch(const exception& ex){
       cout << "exception caught : " << ex.what() << '\n';
       t.join(); //will not be executed
   }
}
/*--------------------------------------------------------
thread kullanılarak yapılan bir iş sırasında bir exception
throw edilirse bu durumda bu exception ana program tarafından
yakalanamaz ve terminate fonksiyonu çağrılır.
-------------------------------------------------------*/
#include <iostream>
#include <thread>

using namespace std;

void func()
{
    cout << "func cagrildi\n";
    if(1){
        throw runtime_error{"error from func"};
    }
}

int main()
{
    try{
        thread t{func};
        t.join();
    }
    catch(const exception& ex){
        cout << "exception caught" << ex.what() << '\n';
    }
}
/*--------------------------------------------------------
rethrow işlemi bir thread'te aşağıdaki örnekte görüldüğü
gibi yapılabilir.
Anahtar Notlar:catch bloğu içerisine ... yazılması durumunda
tüm fırlatılan exceptionlar yakalanıcaktır.
-------------------------------------------------------*/
#include <iostream>
#include <stdexcept>
#include <thread>

using namespace std;

exception_ptr exptr = nullptr;

void func(int x) {
    cout << "func(int x) cagrildi x = " << x << '\n';
    try{
        if(x % 2 == 0){
            throw invalid_argument{"gecersiz arguman"};
        }
    }
    catch (...) {
        exptr = current_exception();
    }
    cout << "func(int x) sona erdi x = " << x << '\n';
}

int main()
{
    thread t{func,10};

    try{
        if(exptr) {
            rethrow_exception(exptr);
        }
    }
    catch(const exception& ex){
        cout << "exception caught" << ex.what() << '\n';
    }
}
/*--------------------------------------------------------
thread ile arka planla yapılan işlerin aşağıdaki örnekte olduğu
gibi kendine ait bir exception handling mekanizması olmalıdır.
Çünkü thread nesnesinde throw edilen bir exception ana program
tarafından yakalanamaz.
-------------------------------------------------------*/
#include <iostream>
#include <stdexcept>
#include <thread>

using namespace std;

exception_ptr eptr{nullptr};

void foo()
{
    try{
        throw runtime_error{"error from foo"};
    }
    catch(...){
        eptr = current_exception();
    }
}

int main()
{
    thread t {foo};
    t.join();

    if(eptr){
        cout << "demek ki exception gonderilmis\n";
        rethrow_exception(eptr);
    }
    else{
        cout << "exception gonderilmis\n";
    }
}
/*--------------------------------------------------------
ana program içerisinde aşağıdaki örnekte bir rethrow söz
konusu olacağından bu exception ayrı olarak handle edilmelidir.
-------------------------------------------------------*/
#include <iostream>
#include <stdexcept>
#include <thread>

using namespace std;

exception_ptr eptr{nullptr};

void foo()
{
    try{
        throw runtime_error{"error from foo"};
    }
    catch(...){
        eptr = current_exception();
    }
}

int main()
{
    thread t {foo};
    t.join();
    try {
        if (eptr) {
            cout << "demek ki exception gonderilmis\n";
            rethrow_exception(eptr);
        } else {
            cout << "exception gonderilmemis\n";
        }
    }
    catch(const exception& ex){
        cout << "exception caught : " << ex.what() << '\n';
    }
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <stdexcept>
#include <thread>
#include <vector>
#include <exception>

using namespace std;

vector<exception_ptr> g_ex_vec;
mutex g_mutex;

void f1()
{
    throw runtime_error{"exception from f1"};
}
void f2()
{
    throw runtime_error{"exception from f2"};
}


int main()
{
    try{
        f1();
    }
    catch(...){
        lock_guard<mutex> guard{g_mutex};
        g_ex_vec.push_back(current_exception());
    }
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <thread>
#include <vector>
#include <chrono>
#include <syncstream>

using namespace std;

void func()
{
    using namespace std::literals;

    this_thread::sleep_for(2000ms);
    osyncstream os{cout};

    for(int i = 0;i < 10000;++i){
        os << 13 << "berke" << 34.7564 << "mustafa";
    }
}

void foo()
{
    using namespace std::literals;
    this_thread::sleep_for(2000ms);

    for(int i = 0;i < 1000;++i){
        osyncstream {cout} << 25 << "kaya" << 98.67171 << "sertel";
    }
}

int main()
{
    thread t1{func};
    thread t2{foo};

    t1.join();
    t2.join();
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <thread>
#include <vector>

using namespace std;

void cprint(char c)
{
    for(int i = 0;i < 1000;++i){
        cout << c;
    }
}



int main()
{
    thread ta[26];

    for(int i{};auto & t : ta){
        t = thread{cprint,'A' +  i++};
    }

    for(auto &t: ta){
        t.join();
    }
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <thread>
#include <vector>
#include <chrono>
#include <syncstream>

using namespace std;

void cprint(char c)
{
    for(int i = 0;i < 1000;++i){
        cout << c;
        this_thread::sleep_for(50ms);
    }
}



int main()
{
    vector<thread> tvec;

    for(int i = 0;i < 26;++i){
        tvec.emplace_back(cprint,i + 'A');
    }

    for(auto &t: tvec){
        t.join();
    }
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <thread>
#include <vector>
#include <chrono>
#include <fstream>

using namespace std;

int main()
{
    ifstream ifs{"async_01.txt"};
    if(!ifs){
        cerr << "cannot open file\n";
        exit(EXIT_FAILURE);
    }
    vector<string> svec;
    string sline;

    while(getline(ifs,sline)){
        svec.push_back(std::move(sline));
    }
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <thread>
#include <vector>
#include <fstream>

using namespace std;

int main()
{
    ifstream ifs{"async_01.txt"};
    if(!ifs){
        cerr << "cannot open file\n";
        exit(EXIT_FAILURE);
    }
    vector<string> svec;
    string sline;

    while(getline(ifs,sline)){
        svec.push_back(std::move(sline));
    }

    for(const auto& line : svec){
        cout << line << '\n';
    }
}
/*--------------------------------------------------------
thread idye bağlı olarak func çağrısının arka planda mı yoksa
ana program bloğu tarafından yapıldığı tespit edilebilir.
-------------------------------------------------------*/
#include <iostream>
#include <thread>
#include <vector>

using namespace std;

thread::id main_thread_id;

void func()
{
    //func'ın hangi thread'den çağrıldığına bağlı olarak farklı işler yapılıyor
    if(this_thread::get_id() == main_thread_id){
        cout << "cagri main thread'den yapildi\n";
    }
    else{
        cout << "cagri ikincil threadlerden yapildi\n";
    }
}

int main()
{
    main_thread_id = this_thread::get_id();

    func();
    thread t{func};
    t.join();
}
/*--------------------------------------------------------
standart kütüphanenin yield fonksiyonu beni çalıştırma beni
çizerge dışı bırak anlamına gelmektedir.
-------------------------------------------------------*/
#include <iostream>
#include <thread>
#include <vector>
#include <chrono>
#include <fstream>
#include <atomic>

using namespace std;

atomic<bool> ga_start{false};

void func(char id)
{
    using namespace std::chrono;
    while(!ga_start)
    {
        this_thread::yield();
    }
    this_thread::sleep_for(500ms);
    cout << id;
}

int main()
{
   thread ar_t[26];

   for(char i{'A'};auto& t : ar_t){
       t = thread(func,i++);
   }
   ga_start = true;

   for(auto& t : ar_t)
       t.join();
}
/*--------------------------------------------------------
automatic storage duration
static storage duration
dynamic storage duration
thread-local storage duration
thread local değişkenler thread içerisindeyken değeri
değiştirilirse bu durumdan sadece thread tarafı etkilenecektir.
Bu thread local değişkenlerin normal global değişkenlerden en
önemli farkı her thread için ayrı ayrı ele alınmasıdır.
Örneğin tx ty thread için değerlerin ikisi de 1 olarak
elde edilecektir.
-------------------------------------------------------*/
#include <iostream>
#include <thread>
#include <vector>
#include <fstream>
#include <atomic>
#include <syncstream>

using namespace std;

thread_local int tval{0};

void func(const string& thread_name)
{
    ++tval;
    osyncstream{cout} << "tval in thread " << thread_name << " is " << tval << '\n';
}
int main()
{
   thread tx{func,"a"};
   thread ty{func,"b"};

    {
        osyncstream {cout} << "tval in main : " << tval << '\n';
    }
    tx.join();
    ty.join();
}
/*--------------------------------------------------------
Aşağıdaki örnekte thread_func fonksiyonu içerisinde 0 değerinin
ekrana yazdırılması ival'in threade ait olan thread local nesnesi
olmasından kaynaklanmaktadır.Ancak main içerisindeki ival
ana threadin ival değişkeni olduğundan son durumda main
içerisinde ekrana yazılan değer 42 olacaktır.
-------------------------------------------------------*/
#include <iostream>
#include <thread>
#include <vector>

using namespace std;

thread_local int ival{0};

void thread_func(int* p)
{
    *p = 42;
    cout << "ival : " << ival << '\n';//0
}

int main()
{
    cout << "ival : " << ival << '\n'; //0
    ival = 9;
    cout << "ival : " << ival << '\n'; //9
    thread t{thread_func,&ival};
    t.join();
    cout << "ival : " << ival << '\n'; //42
}
/*--------------------------------------------------------
Aşağıdaki örnekte anlatılmak istenen otomatik ömürlü nesneler,
static ömürlü nesneler ve thread local nesneler arasında
farktır.
-------------------------------------------------------*/
#include <iostream>
#include <vector>
#include <algorithm>
#include <thread>
#include <random>
#include <climits>

using namespace std;

mutex mtx;

void func(int id)
{
    int x;
    static int y = 0;
    thread_local int z = 0;

    ++x;
    ++z;
    lock_guard guard(mtx);
    ++y;
    cout << "thread id : " << id << "x (automatic storage)" << x << '\n';
    cout << "thread id : " << id << "y (static storage)" << y << '\n';
    cout << "thread id : " << id << "z (thread local storage)" << z << '\n';
}

void foo(int id)
{
    func(id);
    func(id);
    func(id);
}

int main()
{
    thread tx{foo,0};
    thread ty{foo,1};
    thread tz{foo,2};

    tx.join();
    ty.join();
    tz.join();
}
/*--------------------------------------------------------
Aşağıdaki örnekte thread local nesnesi her thread'e özgü
olduğundan dolayı her thread için sıfırdan ele alınacaktır.
Bu durumda ekrana her thread için 1 değeri yazdırılacaktır.
-------------------------------------------------------*/
#include <iostream>
#include <vector>
#include <algorithm>
#include <thread>
#include <mutex>
#include <syncstream>

using namespace std;

thread_local int gt{};

void func(char c)
{
    ++gt;
    osyncstream {cout} << c << gt << '\n';
}

int main()
{
    vector<thread> tvec;

    for(char c = 'c';c <= 'z';++c){
        tvec.emplace_back(func,c);
    }

    for(auto& t : tvec){
        t.join();
    }
}
/*--------------------------------------------------------
Ancak aşağıdaki örnekteki gibi söz konusu nesne babadan kalma
bir global nesne olsaydı bu durumda bu nesne bir static ömürlü
bir nesne gibi davranacağından her thread için farklı bir
nesne ele alınmayacaktı.
-------------------------------------------------------*/
#include <iostream>
#include <vector>
#include <algorithm>
#include <thread>
#include <mutex>
#include <syncstream>

using namespace std;

int gt{};

mutex m;

void func(char c)
{
    lock_guard<mutex> myguard{m};
    ++gt;
    osyncstream {cout} << c << gt << '\n';
}

int main()
{
    vector<thread> tvec;

    for(char c = 'c';c <= 'z';++c){
        tvec.emplace_back(func,c);
    }

    for(auto& t : tvec){
        t.join();
    }
}
/*--------------------------------------------------------
Aşağıdaki örnekte çiftlerin toplamıyla teklerin toplamı farklı
thread nesnelerine bağlanmıştır.(7518 milisaniye)
-------------------------------------------------------*/
#include <iostream>
#include <vector>
#include <algorithm>
#include <thread>
#include <mutex>
#include <syncstream>

using namespace std;

uint64_t sum_odd = 0ull;
uint64_t sum_even = 0ull;

constexpr uint64_t n = 1'000;

void get_sum_odds()
{
    for(uint64_t i = 1;i < n;i += 2){
        this_thread::sleep_for(4ms);
        sum_odd += i;
    }

}

void get_sum_evens()
{
    for(uint64_t i = 0;i < n;i += 2){
        this_thread::sleep_for(4ms);
        sum_even += i;
    }
}



int main()
{
    using namespace std::chrono;

    auto start = steady_clock::now();
    thread t1{get_sum_evens};
    thread t2{get_sum_odds};

    t1.join();
    t2.join();

    auto end = steady_clock::now();
    cout << "hesaplama tamamlandi toplam sure : " << duration_cast<milliseconds>(end-start).count() << "milisaniye\n";
    cout << "teklerin toplami = " << sum_odd << '\n';
    cout << "ciftlerin toplami = " << sum_even << '\n';
}
/*--------------------------------------------------------
Eğer fonksiyonlar threadlere bağlanmak yerine doğrudan çağrılsaydı
bu durumda paralel olarak yürütülmeyeceğinden dolayı optimizasyon
anlamında oldukça kötü bir durum oluşacaktı.(15636 milisaniye)
-------------------------------------------------------*/
#include <iostream>
#include <vector>
#include <thread>
#include <mutex>

using namespace std;

uint64_t sum_odd = 0ull;
uint64_t sum_even = 0ull;

constexpr uint64_t n = 1'000;

void get_sum_odds()
{
    for(uint64_t i = 1;i < n;i += 2){
        this_thread::sleep_for(2ms);
        sum_odd += i;
    }

}

void get_sum_evens()
{
    for(uint64_t i = 0;i < n;i += 2){
        this_thread::sleep_for(2ms);
        sum_even += i;
    }
}



int main()
{
    using namespace std::chrono;

    auto start = steady_clock::now();
    get_sum_evens();
    get_sum_odds();

    auto end = steady_clock::now();
    cout << "hesaplama tamamlandi toplam sure : " << duration_cast<milliseconds>(end-start).count() << "milisaniye\n";
    cout << "teklerin toplami = " << sum_odd << '\n';
    cout << "ciftlerin toplami = " << sum_even << '\n';
}
/*--------------------------------------------------------

-------------------------------------------------------*/
#include <iostream>
#include <vector>
#include <thread>
#include <mutex>

using namespace std;

uint64_t sum_odd = 0ull;
uint64_t sum_even = 0ull;

constexpr uint64_t n = 1'000;

void get_sum_odds()
{
    for(uint64_t i = 1;i < n;i += 2){
        this_thread::sleep_for(4ms);
        sum_odd += i;
    }

}

void get_sum_evens()
{
    for(uint64_t i = 0;i < n;i += 2){
        this_thread::sleep_for(4ms);
        sum_even += i;
    }
}



int main()
{
    thread t{get_sum_evens};

    cout << t.native_handle() << '\n';

    t.join();
}
/*--------------------------------------------------------
Aşağıdaki örnekte thread nesnelerine bir iş yükü verilmediği için
aşağıdaki gibi bir ekran çıktısı elde edilecektir.
thread::id of a non-executing thread
thread::id of a non-executing thread
thread::id of a non-executing thread
-------------------------------------------------------*/
#include <iostream>
#include <vector>
#include <algorithm>
#include <thread>
#include <mutex>
#include <syncstream>

using namespace std;

uint64_t sum_odd = 0ull;
uint64_t sum_even = 0ull;

constexpr uint64_t n = 1'000;

void get_sum_odds()
{
    for(uint64_t i = 1;i < n;i += 2){
        this_thread::sleep_for(2ms);
        sum_odd += i;
    }

}

void get_sum_evens()
{
    for(uint64_t i = 0;i < n;i += 2){
        this_thread::sleep_for(2ms);
        sum_even += i;
    }
}



int main()
{
    thread t1;
    thread t2;
    thread t3;

    cout << t1.get_id() << '\n';
    cout << t2.get_id() << '\n';
    cout << t3.get_id() << '\n';
}
/*--------------------------------------------------------
Aşağıdaki örnekte threadlerin farklı iş yükleri olduğundan
dolayı thread id değerleri birbirinden farklı olarak elde
edilecektir.
-------------------------------------------------------*/
#include <iostream>
#include <thread>

using namespace std;

void func(){}
void foo(){}
void bar(){}


int main()
{
    thread t1{func};
    thread t2{foo};
    thread t3{bar};

    cout << t1.get_id() << '\n';
    cout << t2.get_id() << '\n';
    cout << t3.get_id() << '\n';

    t1.join();
    t2.join();
    t3.join();
}
/*--------------------------------------------------------
get fonksiyonu aşağıdaki örnekte eğer fonksiyon hala çalışıyorsa
durdurulmasını sağlar. nesnelerin hayatları bittiği zaman zaten
bu nesneler için get fonksiyonu çağrılacaktır.
Anahtar Notlar:get fonksiyonu her nesne için bir kere çağrılmalıdır
aksi durumda exception throw edilir.
-------------------------------------------------------*/
#include <iostream>
#include <thread>
#include <future>

using namespace std;

int f1()
{
    //code
    return 1;
}
int f2()
{
    //code
    return 2;
}
int f3()
{
    //code
    return 3;
}


int main()
{
    auto ft1 = async(launch::async,f1);
    auto ft2 = async(launch::async,f2);
    auto ft3 = async(launch::async,f3);

    cout << ft1.get() << '\n';
    cout << ft2.get() << '\n';
    cout << ft3.get() << '\n';

}
/*--------------------------------------------------------
Aşağıdaki örnekte eğer future<int> türünden bir nesne yerine
bir thread nesnesi kullanılsaydı bu durumda exception throw edilmesiyle
terminate fonksiyonu çağrılacaktı. Ancak aşağıdaki örnekiçin exception
yakalanıcak.
-------------------------------------------------------*/
#include <iostream>
#include <thread>
#include <future>

using namespace std;

int func()
{
    throw runtime_error{"error from func"};
    return 1;
}


int main()
{
    try{
        future<int> fptr = async(launch::async,func);
        auto val = fptr.get();
        cout << "return value is : " << val << '\n';
    }
    catch (const exception& ex){
        cout << "exception caught : " << ex.what() << '\n';
    }
}
/*--------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
asekron şekilde çalışan deferred şekilde çalışana göre
daha hızlıdır. bunun nedeni sıralı şekilde değil aynı anda koşmalarından
kaynaklanmaktadır.
-------------------------------------------------------*/
#include <iostream>
#include <thread>
#include <string>
#include <future>

using namespace std;

string get_str_letters(int n)
{
    using namespace std::literals;
    string s(n,'\0');
    generate_n(s.begin(),n,[]{return rand() % 26 + 'A';});
    this_thread::sleep_for(3ms);
    return s;
}

string get_str_digits(int n)
{
    using namespace std::literals;

    string s(n,'\0');
    generate_n(s.begin(),n,[]{return rand() % 26 + '0';});
    this_thread::sleep_for(3ms);
    return s;
}


int main()
{
    auto start = std::chrono::steady_clock::now();

    //auto ftr1 = async(launch::deferred,get_str_letters,20);//0.0305947 saniye
    //auto ftr2 = async(launch::deferred,get_str_digits,20);

    auto ftr1 = async(launch::deferred,get_str_letters,20);//0.0249261 saniye
    auto ftr2 = async(launch::deferred,get_str_digits,20);

    auto s1 = ftr1.get();
    auto s2 = ftr2.get();
    auto end = chrono::steady_clock::now();
    cout << chrono::duration<double>(end-start).count() << " saniye\n";
    cout << s1 + s2 << '\n';
}
/*--------------------------------------------------------

-------------------------------------------------------*/
/*--------------------------------------------------------

-------------------------------------------------------*/
/*--------------------------------------------------------

-------------------------------------------------------*/
/*--------------------------------------------------------

-------------------------------------------------------*/
/*--------------------------------------------------------

-------------------------------------------------------*/
/*--------------------------------------------------------

-------------------------------------------------------*/
/*--------------------------------------------------------

-------------------------------------------------------*/
/*--------------------------------------------------------

-------------------------------------------------------*/
/*--------------------------------------------------------

-------------------------------------------------------*/
/*--------------------------------------------------------

-------------------------------------------------------*/
/*--------------------------------------------------------

-------------------------------------------------------*/
/*--------------------------------------------------------

-------------------------------------------------------*/
/*--------------------------------------------------------

-------------------------------------------------------*/
/*--------------------------------------------------------

-------------------------------------------------------*/
/*--------------------------------------------------------

-------------------------------------------------------*/
/*--------------------------------------------------------

-------------------------------------------------------*/
/*--------------------------------------------------------

-------------------------------------------------------*/
/*--------------------------------------------------------

-------------------------------------------------------*/
/*--------------------------------------------------------

-------------------------------------------------------*/

#include <iostream>
#include <vector>
#include <algorithm>
#include <thread>
#include <random>
#include <climits>

using namespace std;

void setRandomPassword(string& password,int size)
{
    random_device rd;
    mt19937 eng1(rd());
    mt19937 eng2(rd());
    uniform_int_distribution<int> dist1(CHAR_MIN,CHAR_MAX);
    uniform_int_distribution<int> dist2(0,2);
    while(size--) {
        switch (dist2(eng2)) {
            case 0:
                password += dist1(eng1);
                break;
            case 1:
                password += dist1(eng1) + '0';
                break;
            case 2:
                password += toupper(dist1(eng1));
                break;
        }


    }
}

template<typename Con>
void print(Con con)
{
    for(auto iter = con.begin();iter < con.end();++iter){
        cout << *iter << ' ';
    }
    cout << '\n';
}

int main()
{
   string password{};
    setRandomPassword(password,20);
    print(password);
}
//-------------------------------------------------------------------
#include <iostream>
#include <random>

using namespace std;

bool crapsGame()
{
    random_device rd;
    mt19937 m(rd());
    uniform_int_distribution<int> dice(1,6);
    int dice_sum = dice(m) + dice(m);
    if(dice_sum == 2 || dice_sum == 3 || dice_sum == 12)
        return false;
    if(dice_sum == 11 || dice_sum == 7)
        return true;
    int temp_dice = dice_sum;
    while(true){
        dice_sum = dice(m) + dice(m);
        if(dice_sum == 7)
            return false;
        if(dice_sum == temp_dice)
            return true;
    }
}

void crapsGameTest(int number_of_plays)
{
    int number_of_wins = 0;
    for(int i = 0; i < number_of_plays; i++){
        if(crapsGame()){
            number_of_wins++;
        }
    }
    std::cout << static_cast<double>(number_of_wins)/number_of_plays << '\n';
}

int main()
{
    crapsGameTest(100000);
}
/*------------------------------------------------------------------------------
Rastgele binary search tree(ikili arama ağacı) yani map üretimi
------------------------------------------------------------------------------*/
#include <iostream>
#include <map>
#include <string>
#include <random>
#include <fstream>

using namespace std;

class Person{
public:
    static string getRandomName()
    {
        string person[]{"Mehmet","Berke","Mustafa","Necati","Zeynep","Su","Cemre","Banu","Bade","Romy","Olga","Zack"};
        mt19937 m(rd());
        uniform_int_distribution<int> dist(0,person->size());
        return person[dist(m)];
    }
    static int getRandomID()
    {
        mt19937 m(rd());
        uniform_int_distribution<int> dist(0,100000);
        return dist(m);
    }
private:
    static random_device rd;
};

random_device Person::rd;

void setRandomMap(map<string,int>& mymap,const size_t& size)
{
    for(int i = 0;i < size;++i){
        mymap.insert(make_pair(Person::getRandomName(),Person::getRandomID()));
    }
}

template<typename Con>
void print(Con con)
{
    for(auto iter = con.begin();iter!= con.end();++iter){
        cout << *iter << ' ';
    }
    cout << '\n';
}

template<>
void print(const map<string,int> mymap)
{
    for(auto const&[name,ID]:mymap){
        cout << "Name : " << name << " ID : " << ID << '\n';
    }
}

void print(const map<string,int> mymap,ofstream& ifs)
{
    for(auto const&[name,ID]:mymap){
        ifs << "Name : " << name << " ID : " << ID << '\n';
    }
}

int main()
{
    map<string,int> people;
    ofstream ifs{"people.txt"};
    setRandomMap(people,10);
    print(people);
    print(people,ifs);
}
//-----------------------------------------------------------

#include <iostream>
#include <random>
#include <climits>




void selectionSort(int* arr,size_t size)
{
    int min = INT_MAX;
    int max = INT_MIN;
    for(int i = 0;i < size;++i){
        for(int k = 0;k < size - i - 1;++k){

        }
    }
}

void setRandomArray(int* arr,size_t size)
{
    std::random_device rd;
    std::mt19937 mt{rd()};
    std::uniform_int_distribution<int>dist{0,100};
    for(int i = 0;i < size;++i){
        arr[i] = dist(rd);
    }
}


int main()
{
    using namespace std;


}