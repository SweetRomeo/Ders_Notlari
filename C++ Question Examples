/*-----------------------------------------------------------------
Aşağıdaki örnekte ekran çıktısı aB2b2 şeklinde olacaktır.
---------------------------------------------------------------------*/
#include <iostream>

struct A {
    A() { std::cout << "a"; }

    void foo() { std::cout << "1"; }
};

struct B {
    B() { std::cout << "b"; }
    B(const A&) { std::cout << "B"; }

    void foo() { std::cout << "2"; }
};

int main()
{
    auto L = [](auto flag) -> auto {return flag ? A{} : B{};};
    L(true).foo();
    L(false).foo();
}
/*-------------------------------------------------------
Aşağıdaki örnekteki kod geçerlidir. Yapılar illa eleman
sayısı kadar değişkenle init. edilecek diye bir zorunluluk
yoktur.
-------------------------------------------------------*/
#include <iostream>

struct S {
    int one;
    int two;
    int three;
};

int main() {
    S s{1,2};
    std::cout << s.one;
}
/*-------------------------------------------------------
Aşağıdaki örnekte ekran çıktısı 10 olacaktır. virgül operatörünün
ürettiği değer her ne kadar sağ operand olsa da öncelik
seviyesi olarak son sıradadır. Bu sebeple x = a, b; ifadesi
aslında x = a ve b anlamına gelmektedir.
-------------------------------------------------------*/
#include <iostream>

int main() {
  int a = 10;
  int b = 20;
  int x;
  x = a, b;
  std::cout << x;
}
/*-------------------------------------------------------
Aşağıdaki örnekte numeric_limits'in unsigned int açılımının
maks değeri tahmin edilebileceği gibi unsigned int'in maksimum
değeri anlamına gelmektedir.
-------------------------------------------------------*/
#include <iostream>
#include <limits>

int main() {
  unsigned int i = std::numeric_limits<unsigned int>::max();
  std::cout << ++i;
}
/*-------------------------------------------------------
Aşağıdaki örnekteki kod geçerli olmakla birlikte 1 değerini
üretir. Bunun nedeni null pointer olmamasından kaynaklanmaktadır.
Herhangi bir void pointer kendine bağlanması geçerli bir ifade olmasının 
yanı sıra bildirimi de yapıldığından dolayı bir dangling pointer 
durumu da söz konusu değildir.
-------------------------------------------------------*/
#include <iostream>

int main() {
  void * p = &p;
  std::cout << bool(p);
}
/*-------------------------------------------------------
Aşağıdaki örnekte f fonksiyonuna a,a argümanlarının gönderildiğine
dikkat edilmelidir. Bu sebeple fonksiyon içerisinde değiştirilen
b değeri aslında maindeki a değeridir. fonksiyon çağrısı
sonrasında a değeri 4 olurken b'nin değeri değişmez. Fonksiyonun
geri dönüş değeri ise 4 + 4'ten 8 olarak elde edilir. Son
durumda ekran çıktısı 428 şeklinde olacaktır.
-------------------------------------------------------*/
#include <iostream>

int f(int &a, int &b) {
  a = 3;
  b = 4;
  return a + b;
}

int main() {
  int a = 1;
  int b = 2;
  int c = f(a, a);
  std::cout << a << b << c;
}
