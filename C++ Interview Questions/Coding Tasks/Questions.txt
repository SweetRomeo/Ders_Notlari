C++ ile Programlama Çalışma Soruları
1-) Kullanıcı Adı doğrulaması
Kendisine gönderilen kullanıcı adı yazısı için aşağıdaki koşullar sağlanacaktır:

1- Kullanıcı adı minimum 4 maksimum 25 karakterden oluşabilir.
2- Kullanıcı adı harf ile başlamalıdır.
3- Kullanıcı adı harf, sayı veya underscore(alttire(_))  karakteri içerebilir. Ancak başka karakter içeremez.
4- Kullanıcı adı underscore karakteri ile bitemez.

Fonksiyon kullanııcı adının geçerli olması durumunda "true" yazısı olmaması durumunda "false" yazısını döndürecektir.
Bu koşulların tamamını sağlayan UsernameValidation isimli fonksiyonu yazınız ve test ediniz.

2-) Faktöriyel 
Faktöriyel 1 sayısından başlayarak o sayıya kadar sayıların çarpımını ifade eden bir matematiksel gösterimdir. 
a-) Buna göre kendisine gönderilen sayının faktöriyelini hesaplayıp geri döndüren CalculateFactorial isimli fonksiyonu yazınız ve test ediniz.
b-) e sayısı: 
e = 1/0! + 1/1! + 1/2! + ......
seri toplamından elde edilen bir gerçek sayıdır. Buna göre e sayısını geri dönen getEulerNumber isimli fonksiyonu yazınız ve test ediniz.

3-) Letter Changes
Bu program fonksiyon:
- Bir yazı parametresi alacak ve karakterler alfabetik karakterler ise onları değiştirecek.
- Harf karakterleri değiştirilirken ingilizce alfabeye göre bir sonraki karakteri alacaktır.(Eğer alfabenin son karakteri ise bu durumda başa dönüşüm ilk karakter olarak alınacaktır. 
Örneğin karakter z ise a, b ise c olacaktır.)
- Harfler değiştirilirken son durumda elde edilen harfler "a", "e", "i", "o", "u" karakterlerinden herhangi biriyse bu durumda bu karakterler büyütülecektir. (Örneğin "a" karakteri "A" olacaktır.)

koşulları sağlayan LetterChanges isimli fonksiyonu yazınız ve test ediniz.

4-) Soru: BracketMatcher fonksiyonu parametre olarak string alan,
aç ve kapa parantez sayıları birbirine eşit olduğunda "1" yazısını
döndürürken, aç ve kapa parantezler birbirine eşit olmadığı durumda
ise "0" yazısını döndürecektir.
İstisna durumlar: eğer yazıda hiçbir parantez bulunmuyorsa bu durumda
gene "1" yazısı döndürülecektir.
Bazı örnek girişler:
Giriş: (hello (world))
Çıktı: 1
çünkü burada aç ve kapa parantezler birbirine eşittir.
Giriş: ((hello (world))
Çıktı: 0
çünkü açılan parantezlerle kapanan parantezler eşit değil.
Bu örneklere göre yukarıda açıklanan BracketMatcher fonksiyonunu yazınız ve test ediniz.

5-) Soru: MeanMode isimli fonksiyon kendisine gönderilen dizinin
moduyla ortalamasının eşit olup olmadığı kontrol
edicek. Eğer eşit ise bu durumda 1 eşit değilse
0 değişkenini döndürecektir. Bu açıklamalara göre MeanMode fonksiyonunu yazınız ve test ediniz.

6-) Soru: Dizinin elemanları eğer belirli bir ilişkiye göre artıyorsa bu artış iki farklı şekilde gerçekleşebilir.
Geometrik olarak veya Aritmetik olarak. Eğer artık geometrik bir şekilde gerçekleşiyorsa bu durumda elemanların kendisinden 
bir önce gelen elemanlara oranı her zaman sabittir. Ancak söz konusu olan aritmetik artış ise bu durumda elemanların kendisinden
önce gelen elemanlara olan farkları sabittir. Örneğin: [2, 4, 6, 8] dizisi bir aritmetik artış gösterirken (4 - 2 = 6 - 4 olduğu için) [2, 6, 18, 54] dizisi 
geometrik artış gösterir(6 / 2 = 18 / 6 olduğu için). 
Yukarıdaki açıklamalara göre kendisine gönderilen dizi Aritmetikse string olarak "Arithmetic", geometrik ise string olarak "Geometric", eğer bunların
ikisi de söz konusu değilse bu durumda -1 yazısını geri dönen ArithGeo isimli fonksiyonu yazınız ve test ediniz.

7-) Açıklama : Mutlu sayılar basamaklarının sayı değerlerinin kareleri toplamı 1'e eşit olan sayılar. Ancak bu toplamın 10 veya 10'dan büyük olması durumunda
o toplam için yeni bir toplam değeri elde edilir. Elde edilen toplam değeri tek basamaklı oluncaya kadar bu durum devam eder. Eğer tek basamaklı kaldığında elde edilen sayı 
1 ise bu durumda ancak buna mutlu sayı denilebilir. 

Yukarıdaki açıklamaya göre bir sayının mutlu sayı olup olmadığını geri döndüren isHappyNumber isimli fonksiyonu yazınız ve test ediniz.
Örneğin burada 5552, 2555 gibi sayılara için fonksiyon true değer dönecektir.

8-) UpperCamelCase standardı pek çok pek firmada fonksiyon isimlendirmelerinde kullanılan bir yöntemdir. 
Yukarıdaki açıklamaya göre kendisine gönderilen ve alfabetik karakterler hariç(boşluk karakteri(" "), alttire karakteri("_") veya özel karakterler) karakterlerle ayrılmış 
yazılardan bir UpperCamelCase yazısı geri döndüren toUpperCamelCase isimli fonksiyonu yazınız ve test ediniz. İşte bazı örnekler:
Giriş: "cats AND*Dogs-are Awesome"
Çıkış: CatsAndDogsAreAwesome

Giriş: "a b c d-e-f%g"
Çıkış: ABCDEFG

9-) OneDecremented fonksiyon bir yazı alacak ve sırasıyla gelen rakamlarda kaç adet rakamın bir önceki rakamın 1 azı olduğu hesaplayıp geri döndürecektir.
Örneğin eğer giriş "5655984" olduğu durumda geri dönüş değeri 2 olacaktır. Çünkü 9 dan sonra 8 ve 6 dan sonra 5 gelmiştir. 

10-) Kendisine gönderilen yazıda bulunan en uzun alfanümerik karakterlerden oluşan kelimeyi geri döndüren LongestWord isimli fonksiyonu yazınız ve test ediniz.
Örnek bazı girişler aşağıdaki gibidir:
Giriş: fun&%* time 
Çıktı: time
Çıktının time olmasının nedeni fun&%* kelimesi daha uzun olsa bile numara veya harflerinin uzunluğu olarak time yazısından daha uzun değildir. Bu sebeple time çıktısı elde 
edilir. 

11-) Her harfin ascii tablosunda bir değeri bulunmaktadır. Örneğin 65 sayı değeri aslında 'A' karakterinin Tablo değerini ifade etmektedir. Bu açıklamalara göre 
kendisine gönderilen yazıyı ascii tablo değerine göre dönüştüren ASCIIConversion isimli fonksiyonu yazınız ve test ediniz.
Örneğin:
Giriş: dog
Çıkış: 100111103
Bunun nedeni d = 100, o = 111 ve g = 103 olmasından kaynaklanmaktadır.

12-) Kendine gönderilen sayıya 1 den başlarak ardışık şekilde yazdıran fonksiyonu yazınız. 
    - Fonksiyonda 3 ile kalansız bölünebilen sayılar yerine Fizz
    - 5 ile kalansız bölünebilen sayıların yerine Buzz 
    - Hem 5 hem de 3 ile kalansız bölünebilen sayıların yerine de FizzBuzz basılacaktır. 
Örneğin klavyeden 16 girildiğinde ekran çıktısı aşağıdaki gibi olacaktır.
Girdi : 16
Çıktı : 1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz 16

13-) Dash Insert
Have the function DashInsert(str) insert dashes ('-') between each two odd numbers in str. For example: if str is 454793 the output should be 4547-9-3. Don't count zero as an odd number.
Examples
Input: 99946
Output: 9-9-946
Input: 56730
Output: 567-30

14-) Dash Insert
Have the function DashInsert(str) insert dashes ('-') between each two odd numbers in str. For example: if str is 454793 the output should be 4547-9-3. Don't count zero as an odd number.
Examples
Input: 99946
Output: 9-9-946
Input: 56730
Output: 567-30

15-) Other products
Bu fonksiyon kendisine gönderilen dizinin tüm elemanlarının
çarpımını elde edip sırasıyla tüm elemanlarına bölümünü
bulup elde edilen sonuçların arasına "-" ekleyip bu yazıyı
geri döndürecek. Aşağıda bununla ilgili bazı örnekler verilmiştir:
Giriş: [1, 2, 3, 4, 5]
Çıktı: 120-60-40-30-24

Giriş: {3,1,2,6}
Çıktı: 12-36-18-6

Giriş: {1,4,3}
Çıktı: 12-3-4

16-) Basic Roman Numerals
Romen rakamları sırasıyla I = 1, V = 5, X = 10, L = 50,
C = 100, D = 500, M = 1000 şeklinde ifade edilir. I

17-) Three Numbers isimli fonksiyon bir string parametre alarak
kendisine gönderilen yazının her bir cümlesinde eşsiz
karakterler arayacak. Eğer cümlelerin hepsinde en az 3 tane eşşiz karakter(sayı) bulunuyorsa
fonksiyon bu durumda true döndürecektir. Ancak 3'ün altında eşsiz
karakter bulunduğu takdirde veya 3 eşsiz karakter olmasına karşın
bu karakterlerin yan yana olması durumunda false geri döndürecektir.
İşte bazı örnekler:
Giriş: "2hell6o3 wor6l7d2"
Çıktı: true(tüm cümlelerdeki eşsiz rakam karakterleri 3 ten fazla)
Giriş: "hell268o w6or2l4d"
Çıktı: false(her kelimede en az 3 eşsiz rakam var ancak bunların hepsi peş peşe)

18-) Hamming Distance
Kendisine gönderilen iki yazıdan ilkinde olup ikincisinde olmayanlarının
sayısını geri döndüren HammingDistance isimli fonksiyonu yazınız
ve test ediniz. Karakterlerin diğer yazının sadece içinde bulunması
değil aynı konumda olması durumunda ancak toplam etkilenmecektir.
Örneğin:
Giriş: {"codec", "coder"}
Çıktı: 1(çünkü ikinci yazıda c'nin olduğu yerde r karakteri var.)

19-) Third Greatest
Kendisine gönderilen string türünden elemanlardan oluşan bir
dizinin en büyük üçüncü elemanını geri döndüren thirdGreatest isimli fonksiyonu
yaınız ve test ediniz.
Not: Büyüklük yazı uzunluğuna göre olacaktır. Lexi. compare kullanılmayacaktır. 

20-) Kendisine gönderilen cümledeki kelimelerden en çok tekrar
eden karaktere sahip olan yazıyı geri döndüren LetterCount
isimli fonksiyonu yazınız ve test ediniz. Program tekrar
eden karakter içermeyen durumlarda -1 döndürecektir.                          
Giriş: Hello world
Çıktı: Hello
Giriş: No words
Çıktı: -1

21-) Even Pairs
Hide Question
Have the function EvenPairs(str) take the str parameter
 being passed and determine if a pair of adjacent even
 numbers exists anywhere in the string. If a pair exists,
 return the string true, otherwise return false. For example:
 if str is "f178svg3k19k46" then there are two even numbers at the
 end of the string, "46" so your program should return the string true.
 Another example: if str is "7r5gg812" then the pair is "812" (8 and 12)
 so your program should return the string true.

22-) LargestFour
Kendisine gönderilen dizinin en büyük 4 elemanının
toplamını geri döndüren LargestFour isimli fonkisyonu yazınız ve
test ediniz.

23-) Bitwise Two
Kendisine gönderilen iki yazıya sahip olan dizilerin
elemanlarının birer birer bitsel ve işlemine sokarak
sonucu döndüren Bitwisetwo isimli fonksiyonu yazınız
ve test ediniz.

24-) StarRating
Kendisine gönderilen yazı şeklinde yıldız reyting değerine
bağlı aşağıdaki yazıları döndüren StarRating isimli fonksiyonu
yazınız ve test ediniz.
- Reyting minimum 0.00 maksimum 5.00 şeklinde olacaktır.
- Reyting yazısı 5 ana bölümden oluşacak ve bu yazı tipi
boş olan yıldızlar için "empty", bir kısmı boş olan yıldızlar
içim "half" ve tamamı dolu olan yıldızlar için "full" yazısı
olarak ifade edilecektir.
- Bir yıldızın "half" olması için noktadan sonraki kısmının
0.1 den büyük ve 0.75 ten küçük olması gerekmektedir.
- 0.1'den küçük olan yıldızlar empty olarak sayılırken
0.75 ten büyük olan yıldızlar full sayılacaktır.
İşte bazı örnekler:
Giriş: "0.38"
Çıktı: half empty empty empty empty
Çıktı: "1.02"
Çıktı: full empty empty empty empty
Giriş: "4.5"
Çıktı: full full full full half

25-) CaesarCipher
Kendisine gönderilen yazıya ve sayıya göre yazının alfabetik
karakterlerini kendisine gönderilen sayı kadar alfabede ileri
götürüp o karakter ile değiştiren CaesarCipher isimli fonksiyonu
yazınız ve test ediniz.
Not: karakter alfabenin sonunu aştığı takdirde baştan başlayarak
gidilmektedir. Örneğin karakter z karakteri ve 2 adım kaydırma
yapılacaksa b karakteri elde edilecektir.

Not2: Karakter değiştirilken karakterin büyüklük küçüklüğü
değiştirilmeli ayrıca alfabetik olmayan karakterler değiştirilmeyecektir.

26-) Word Split
Kendisine gönderilen iki yazıdan ikincinin içerisinde bulunan
yazıların kombinasyonundan ilk yazıyı elde edebiliyorsa
bu durumda o yazıları aralarında virgülle birlikte döndüren
WordSplit isimli fonksiyonu yazınız. Fonksiyon ilk yazının
elde edilememesi durumunda "not possiible" yazısını döndürecektir.
Bazı örnek girişler aşağıdaki gibidir:
Giriş : {"hellocat", "apple,bat,cat,goodbye,hello,yellow,why"}
Çıktı : base,ball
Giriş : {"abcgefd", "a,ab,abc,abcg,b,c,dog,e,efd,zzzz"}
Çıktı : abcg,efd
Giriş: {"hellocat", "apple,bat,cat,goodbye,hello,yellow,why"}

27-) ArrayAdditionI
Fonksiyon kendisine gönderilen dizinin en büyük elemanın
diğer herhangi eleman toplamıyla elde edilip edilemeyeceğini
inceleyecektir. Fonksiyon elde edilebilmesi durumunda
true edilememesi durumunda false döndürecektir.

28-) MultiplicativePersistence
Kendisine gönderilen int türünden bir sayının basamaklarının
çarpımlarını tek basamaklı olana kadar hesaplayıp tek
basamaklı hale kaç adımda geldiğini geri döndüren MultiplicativePersistence
isimli fonksiyonu yazınız ve test ediniz.
Giriş: 39
Çıktı: 3(3 * 9 = 27 => 2 * 7 = 14 => 1 * 4 = 0)
3 aşamada 4(tek basamaklı sayı) elde edildi.
Giriş: 25
Çıktı: 2(2 * 5 = 10 => 1 * 0 = 0)

29-) AdditivePersistence
Kendisine gönderilen int türden bir sayının
rakamları toplamını sayı tek basamaklı hale gelene
kadar hesaplayıp, bu işlemin kaç adımda yapıldığını
geri döndüren AdditivePersistence isimli fonksiyonu
yazınız ve test ediniz.
Giriş: 2718
Çıktı: 2(2 + 7 + 1 + 8 = 18 => 1 + 8 = 9
bu operasyon iki adımda gerçekleştiği için 2)

30-) GCF
Kendisine gönderilen iki elemanlı bir dizinin
elemanlarının en büyük ortak çarpanını geri döndüren
GCF fonksiyonunu yazınız ve test ediniz.
Giriş: {45, 12}
Çıktı: 3(en büyük ortak çarpanları 3)

31-) DistinctCharacters
Kendisine gönderilen string türünden bir yazının içerisinde
eşsiz karakter sayısını bulup, eğer eşsiz karakter sayısı
en az 10 ise true yazısını eğer 10'dan küçük ise false yazısını
geri döndüren DistinctCharacters isimli fonksiyonu yazınız ve test
ediniz.
Giriş: 12334bbmma:=6
Çıktı: true(10 adet eşsiz karakter var.)
Giriş: eeeemmmmmmmmm1000
Çıktı: false(10'dan az eşsiz karakter var.)
Giriş: abc123kkmmmm?
Çıktı: false(10'dan az eşsiz karakter var.)

32-) Closest Enemy
Kendisine gönderilen int türünden aşağıdaki
açıklamaya göre bir int türünden değer döndürecektir:
- Dizi yaşmızca 0,1 ve 2 rakamlarından oluşacaktır.
- Dizi içerisinde 1 tek bir tane olucak ve kişinin konumunu
belirtecek.
- Dizi içerisindeki 0 lar boşluk anlamına gelmektedir.
- Dizi içerisindeki 2 ler ise düşmanı belirtmektedir.
Buna göre fonksiyon 1 sayısına en yakın olan 2 rakamına
olan uzaklığı geri döndürecektir. Fonksiyon 2 hiç olmaması
durumunda 0 döndürecektir. Örneğin:
Giriş: {0, 1, 0}
Çıktı: 0
Giriş: {0, 0, 1, 0, 0, 2, 0, 2}
Çıktı: 3
Giriş: {1, 0, 0, 0, 2, 2, 0, 0}
Çıktı: 4

33-) Number Stream
Have the function NumberStream(str) take the str parameter being passed
which will contain the numbers 2 through 9, and determine if there is
a consecutive stream of digits of at least N length where N is the actual
digit value. If so, return the string true, otherwise return the string false.
For example: if str is "6539923335" then your program should return the string true because
there is a consecutive stream of 3's of length 3. The input string will always contain at least one digit.

34-) String Merge
Kendisine gönderilen string türden yazının yıldız ile ayrılmış iki yazıya
bölüp elemanlarını sırayla ekleyerek birleştirip oluşan yazıyı
geri döndüren StringMerge isimli fonksiyonu yazınız ve test ediniz.

35-) Group Totals
Kendisine gönderilen string türden koordinat elemanlarına sahip olan
toplam koordinat değeri 0 dan büyük olan elemanlar toplamını aralarında virgül olacak
şekilde geri döndüren GroupTotals isimli fonksiyonu yazınız
ve test ediniz. Aşağıdaki bunla ilgili örnek girişler verilmiştir:
Giriş: {"X:-1", "Y:1", "X:-4", "B:3", "X:5"}
Çıktı: B:3,Y:1
Giriş: {"P:6", "PI:1396", "PI:20", "P:-3"}
Çıktı: P:3,PI:1416

36-) Fibonacci Checker
Fibonacci serisi 1 1 2 3 5 8 13... şeklinde devam eden
bir seridir. FibonacciChecker fonksiyonu kendisine gönderilen
sayının bir fibonacci sayısına eşit olup olmadığını göre
yes veya no yazısını geri döndüren fonksiyonu yazınız ve test ediniz.
Giriş: 1
Çıktı: yes
Giriş: 5
Çıktı: yes
Giriş: 112
Çıktı: no

37-) Overlapping Ranges
Kendisine gönderilen 5 elemanlı bir dizinin ilk iki elemanındaki
range ile 3. ve 4. elemanları arasındaki range değerlerinden
ortak olanlarını alıp bunun son elemana en azından eşit olması
durumunda true döndürecektir. Örneğin dizi [4, 10, 2, 6, 3]
şeklinde olsun burada 4-10 aralığında: 4,5,6,7,8,9 ve 10
saıyları bulunmaktadır. diğer taraftan 2-6 aralığında ise
2,3,4,5 ve 6 sayıları bulunmaktadır. Bu iki aralığın ortak
elemanlarının sayısı en fazla son eleman kadar olması gerekmektedir.
Burada bu eleman sayısı 4,5 ve 6 olmak üzere 3 adettir. Bu da son elemana
eşit olduğundan sonuç true olarak döner. Aşağı buna benzer 2 örnek daha verilmiştir:
Giriş: {5,11,1,5,1}
Çıktı: true
Giriş: {1,8,2,4,4}
Çıktı: false

38-) Rectangle Area
Kendisine gönderilen 4 adet koordinatı verilen dörtgenin alanını
hesaplayan rectangeArea isimli fonksiyonu yazınız ve test ediniz.
Giriş: ["(0 0)", "(3 0)", "(0 2)", "(3 2)"]
Çıktı: 6

39-) Number Search
NumberSearch(str) fonksiyonunu yazın. Bu fonksiyon, str
 parametresindeki tüm sayıları bulmalı, bunları toplayıp
 ardından bu toplamı, metindeki harflerin sayısına bölerek
 sonucu döndürmelidir. Örneğin: eğer str "Hello6 9World 2, Nic8e D7ay!"
 ise, çıktı 2 olmalıdır. İlk olarak tüm sayıları topladığımızda,
 6 + 9 + 2 + 8 + 7 = 32 elde ederiz. Ardından metinde 17 harf vardır.
 32 / 17 = 1.882 sonucunu elde ederiz ve bu sonuç en yakın tam sayıya
 yuvarlandığında cevap 2 olur. Metin boyunca yalnızca boşluklarla ayrılmış
tek haneli sayılar kullanılacaktır (Bu nedenle hello44444 world gibi bir durum olmayacaktır).
Her string'de en az bir harf bulunacaktır.
Giriş: "Hello6 9World 2, Nic8e D7ay!"
Çıktı: 2

40-) Array Addition
Dizideki herhangi bir sayı kombinasyonu (en büyük sayı hariç)
dizideki en büyük sayıya eşit olacak şekilde toplanabiliyorsa,
ArrayAddition(arr) işlevinin arrr'da saklanan sayı dizisini
almasını ve dizeyi true döndürmesini sağlayın. aksi takdirde
diziyi false döndürür. Örneğin: eğer arr [4, 6, 23, 10, 1, 3]
içeriyorsa çıktı true döndürmelidir çünkü 4 + 6 + 10 + 3 = 23.
Dizi boş olmayacak, aynı öğelerin tümünü içermeyecek ve negatif sayılar içerebilir.
Örneğin:
Giriş: {5,7,16,1,2}
Çıktı: false
Giriş: {3,5,-1,8,12}
Çıktı: true

41-) Coin Determiner
kendisine gönderilen 1-250 arası bir sayıyı belli
değerlere sahip olan(1,5,7,9,11) paralardan minimum kaç tane kullanılarak
elde edilebileceği geri döndüren CoinDeterminer isimli fonksiyonu yazınız
ve test ediniz. Örneğin:
Giriş: 25
Çıktı: 3(çünkü 25 -> 11, 9 ve 5)
Giriş: 16
Çıktı: 2(16 -> 11 + 5)

42-) Dash InsertII
Kendisine gönderilen long türden bir sayıda eğer ard arda
gelen rakamların ikisi de tek ise aralarına kısa çizgi('-')
karakterini, eğer ikisi de çift ise asteriks karakterini('*')
ekleyen DashInsertII isimli fonksiyonu yazınız ve test ediniz.
Fonksiyon sayılardan herhangi birinin 0 olması durumunda veya
birinin tek birinin çift olması durumunda aralarına herhangi bir karakter eklemiycektir.
Bazı örnek çıktılar aşağıdaki gibidir:
Giriş: 99946
Çıktı: 9-9-94*6
Giriş: 56647304
Çıktı: 56*6*47-304

43-) Shortest Path

ShortestPath(strArr) fonksiyonunu yazın. Bu fonksiyon, bir döngü içermeyen bir grafiği modelleyen bir dizi dizeyi (strArr) girdi olarak alacaktır. Dizinin yapısı şu şekilde 
olacaktır: Dizideki ilk eleman dizideki düğüm sayısı N (noktalar) olacaktır. Bu değer bir dize olarak gelecektir. Sonraki N eleman düğümleri temsil edecek ve bunlar 
herhangi bir şey olabilir (A, B, C .. Brick Street, Main Street vb.). Daha sonra N. elemandan sonra, dizideki geri kalan elemanlar düğümler arasındaki bağlantıları 
gösterecektir. Bağlantılar şu şekilde görünecektir: (A-B, B-C .. Brick Street-Main Street vb.). Bununla birlikte, hiç bağlantı bulunmayabilir.

strArr için bir örnek: ["4", "A", "B", "C", "D", "A-B", "B-D", "B-C", "C-D"]. Programınız, dizideki ilk düğümden son düğüme kadar en kısa yolu, tire işaretleriyle ayırarak 
döndürmelidir. Yukarıdaki örnekte, çıktı A-B-D olmalıdır. İşte başka bir örnek: ["7", "A", "B", "C", "D", "E", "F", "G", "A-B", "A-E", "B-C", "C-D", "D-F", "E-D", "F-G"]. 
Bu dizi için çıktı A-E-D-F-G olmalıdır. Dizi için her zaman yalnızca bir tane en kısa yol olacaktır. Eğer ilk ve son düğüm arasında herhangi bir yol yoksa, -1 döndürün. 
Dizi en az iki düğüme sahip olacaktır. Ayrıca, örneğin A-B bağlantısı Anın Bye ve Bnin de Aya ulaşabileceği anlamına gelir.

Örnekler

Girdi: {"5", "A", "B", "C", "D", "F", "A-B", "A-C", "B-C", "C-D", "D-F"}
Çıktı: A-C-D-F

Girdi: {"4", "X", "Y", "Z", "W", "X-Y", "Y-Z", "X-W"}
Çıktı: X-W
Çözüm:
#include <iostream>
#include <string>
#include <queue>
#include <unordered_map>
#include <sstream>
#include <vector>
#include <algorithm>

using namespace std;

string ShortestPath(string strArr[], int arrLength) {
    int N = stoi(strArr[0]); // İlk eleman düğüm sayısıdır
    vector<string> nodes(strArr + 1, strArr + 1 + N); // Düğümleri alırız
    unordered_map<string, vector<string>> graph; // Grafiği saklayacağımız map
    
    // Bağlantıları okuyup grafiği oluşturuyoruz
    for (int i = N + 1; i < arrLength; ++i) {
        string edge = strArr[i];
        size_t pos = edge.find("-");
        string node1 = edge.substr(0, pos);
        string node2 = edge.substr(pos + 1);
        graph[node1].push_back(node2);
        graph[node2].push_back(node1);
    }

    // BFS (Genişlik Öncelikli Arama) kullanarak en kısa yolu buluyoruz
    unordered_map<string, string> parent; // Yol takibi için parent map'i
    queue<string> q;
    q.push(nodes[0]);
    parent[nodes[0]] = ""; // Başlangıç düğümü için parent yok

    while (!q.empty()) {
        string current = q.front();
        q.pop();

        if (current == nodes.back()) { // Son düğüme ulaşırsak
            vector<string> path;
            while (!current.empty()) {
                path.push_back(current);
                current = parent[current];
            }
            reverse(path.begin(), path.end()); // En kısa yolu ters çeviriyoruz
            stringstream result;
            for (int i = 0; i < path.size(); ++i) {
                result << path[i];
                if (i < path.size() - 1) result << "-";
            }
            return result.str();
        }

        for (string neighbor : graph[current]) {
            if (parent.find(neighbor) == parent.end()) {
                parent[neighbor] = current;
                q.push(neighbor);
            }
        }
    }

    // Eğer son düğüme ulaşılamıyorsa -1 döndür
    return "-1";
}

int main(void) { 
   
  // keep this function call here
  string A[] = coderbyteInternalStdinFunction(stdin);
  int arrLength = sizeof(A) / sizeof(*A);
  cout << ShortestPath(A, arrLength);
  return 0;
    
}
//--------------------------------------------------------------
44-) Calculator
Have the function Calculator(str) take the str parameter being passed and evaluate the mathematical expression within in. For example, if str were "2+(3-1)*3" the output 
should be 8. Another example: if str were "(2-0)(6/2)" the output should be 6. There can be parenthesis within the string so you must evaluate it properly according to the 
rules of arithmetic. The string will contain the operators: +, -, /, *, (, and ). If you have a string like this: #/#*# or #+#(#)/#, then evaluate from left to right. So 
divide then multiply, and for the second one multiply, divide, then add. The evaluations will be such that there will not be any decimal operations, so you do not need to 
account for rounding and whatnot.
Examples

Input: "6*(4/2)+3*1"
Output: 15

Input: "6/3-1"
Output: 1

Çözüm:
#include <iostream>
#include <string>
#include <sstream>
#include <vector>
using namespace std;

// Operation function that performs the specified calculation depending on the operator
int operation(int x, int y, char symbol)
{
	if (symbol == '+')
	{
		return x + y;
	}
	else if (symbol == '-')
	{
		return x - y;
	}
	else if (symbol == '/')
	{
		return x / y;
	}
	else if (symbol == '*')
	{
		return x * y;
	}
	else
		return -1;
}

string Calculator(string str) {
	int index, start, end;
	start = end = 0;
	char symbol;
	vector <int> list; 
	bool analyzed, analyzed2;
	string num;
	int number;

	// Creating a list of int numbers that will be parallel to the string argument
	// This will aid with the calculations
	// Example numList = 2,-1,3 would be stringArg = "2+3"
	for (int x = 0; x <= str.length(); x++)
	{
		if (str[x] >= '0' && str[x] <= '9')
		{
			num += str[x];
		}
		else
		{
			// inserting a misc value if the character is a symbol/non digit
			if (num.empty())
			{
				list.push_back(-1);
			}
			else
			{
				// If is the digit is multiple ex.23,100,etc manipulate the string to stay parallel to the number list
				if (num.length() > 1)
				{
					str.erase(x - num.length(), num.length() - 1);
					x -= num.length() - 1;
				}
				// Converting to an int to include to the number list
				istringstream(num) >> number;
				list.push_back(number);
				if (x < str.length()-1)
				{
					list.push_back(-1);
				}
				num.clear();
			}
		}
	}

	do
	{
		index = 0;
		for (index; index < str.length(); index++)
		{
			analyzed = false;
			analyzed2 = false;
			// Find the start of any parenthesis
			if (str[index] == '(')
			{
				start = index + 1;
			}
			// Find the end of any parenthesis
			if (str[index] == ')')
			{
				end = index;
			}
			// Analyze the inside content when both parenthesis have been found
			// Once the content has been analyzed search for any other parenthesis
			if (start && end)
			{
				for (start; start < end && !analyzed && !analyzed2; start++)
				{
					// In the case of calculating multiple operations ex. (2+3*4+4)
					if (end - start > 3)
					{
						number = start;
						while (start < end) // Multiply or Divide
						{
							if (str[start] == '*' || str[start] == '/')
							{
								symbol = str[start];
								list[start - 1] = operation(list[start - 1], list[start + 1], symbol);
								list.erase(list.begin() + start, list.begin() + (start + 2));
								str.erase(str.begin() + start, str.begin() + (start + 2));
								end -= 2;
							}
							else
								start++;
						}
						// Reset back to the start of the parenthesis to now check for adding or subtracting
						start = number;
						while (start < end) //  Add or Subtract
						{
							if (str[start] == '-' || str[start] == '+')
							{
								symbol = str[start];
								list[start - 1] = operation(list[start - 1], list[start + 1], symbol);
								list.erase(list.begin() + start, list.begin() + (start + 2));
								str.erase(str.begin() + start, str.begin() + (start + 2));
							}
							else
								start++;
						}
						analyzed2 = true;
						start = number;
					}
					else if (str[start] == '*' || str[start] == '/')
					{
						symbol = str[start];
						// perform the calculation inside the parenthesis
						list[start - 2] = operation(list[start - 1], list[start + 1], symbol);
						str[start - 2] = 'x';
						// remove parenthesis and values involved in the operation
						list.erase(list.begin() + start - 1, list.begin() + (start + 3));
						str.erase(str.begin() + start - 1, str.begin() + (start + 3));
						index -= 4;
						// signal that the parenthesis has been analyzed
						analyzed = true;
					}
					else if (str[start] == '-' || str[start] == '+')
					{
						symbol = str[start];
						list[start - 2] = operation(list[start - 1], list[start + 1], symbol);
						str[start - 2] = 'x';
						list.erase(list.begin() + start - 1, list.begin() + (start + 3));
						str.erase(str.begin() + start - 1, str.begin() + (start + 3));
						index -= 4;
						analyzed = true;
					}
				}

				// In the case that there were no operations to perform inside
				// Remove parenthesis
				if (analyzed2)
				{
					list[start - 2] = list[start - 1];
					str[start - 2] = 'x';
					list.erase(list.begin() + start - 1, list.begin() + (start + 1));
					str.erase(str.begin() + start - 1, str.begin() + (start + 1));
				}
				else if (!analyzed)
				{
					list[end - 2] = list[end - 1];
					str[end - 2] = 'x';
					list.erase(list.begin() + start - 1, list.begin() + (start + 1));
					str.erase(str.begin() + start - 1, str.begin() + (start + 1));
				}
				start = end = 0; // Reset back in case there are multiple parenthesis
			}
		}

		index = 0;
		// Solve for any multiplication or division operations after no parenthesis
		while (index < str.length())
		{
			if (str[index] == '*' || str[index] == '/')
			{
				symbol = str[index];
				// calculate the operation
				list[index - 1] = operation(list[index - 1], list[index + 1], symbol); 
				// remove the values involved in the operation
				list.erase(list.begin() + index, list.begin() + (index + 2)); 
				str.erase(str.begin() + index, str.begin() + (index + 2));
			}
			// Calculating when there are neighbor parenthesis ex. (2)(3) = 6
			else if ((str[index] >= '0' && str[index] <= '9' && str[index + 1] == 'x') || (str[index] == 'x' && str[index+1] == 'x'))
			{
				symbol = '*';
				list[index+1] = operation(list[index], list[index + 1], symbol);
				list.erase(list.begin() + index, list.begin() + index + 1);
				str.erase(str.begin() + index, str.begin() + index + 1);
			}
			else
				index++;
		}

		index = 0;
		// Solve for any adding or subtracting operations after no parenthesis
		while (index < str.length())
		{
			if (str[index] == '-' || str[index] == '+') 
			{
				symbol = str[index];
				list[index - 1] = operation(list[index - 1], list[index + 1], symbol);
				list.erase(list.begin() + index, list.begin() + (index + 2));
				str.erase(str.begin() + index, str.begin() + (index + 2));
			}
			else
				index++;
		}
	} while (str.length() > 1);
	
	// Converting the number value to a string
	stringstream convert;
	convert << list[0];
	str = convert.str();
	return str;
}

int main() { 
  
  // keep this function call here
  cout << Calculator(gets(stdin));
  return 0;
    
}
//--------------------------------------------
45-) Pattern Chaser
Have the function PatternChaser(str) take str which will be a string and return the longest pattern within the string. A pattern for this challenge will be defined as: if 
at least 2 or more adjacent characters within the string repeat at least twice. So for example "aabecaa" contains the pattern aa, on the other hand "abbbaac" doesn't 
contain any pattern. Your program should return yes/no pattern/null. So if str were "aabejiabkfabed" the output should be yes abe. If str were "123224" the output should 
return no null. The string may either contain all characters (a through z only), integers, or both. But the parameter will always be a string type. The maximum length for 
the string being passed in will be 20 characters. If a string for example is "aa2bbbaacbbb" the pattern is "bbb" and not "aa". You must always return the longest pattern 
possible.

Examples

Input: "da2kr32a2"
Output: yes a2

Input: "sskfssbbb9bbb"
Output: yes bbb

Çözüm:
#include <iostream>
#include <string>
using namespace std;

// loop and take a substring to compare
// loop again from the corresponding index and compare with the original substring
// Keep track of the longest pattern
// Repeat the process and replace if another longer pattern has been found

string PatternChaser(string str) {

	string pattern, pattern2, result;
	int count,high, index,index2;
	index = high = 0;

	// Loop to analyze any patterns within the string
	do
	{
		for (int x = index; x < str.length(); x++)
		{
			pattern.push_back(str[x]); // begin analyzing the string to find a pattern to compare

			// Once we have a pattern ex. ab
			// Analyze the other values of the string to check if the pattern repeats
			if (pattern.length() > 1) 
			{
				index2 = x + 1;
				do
				{
					for (int y = index2; y < str.length(); y++)
					{
						pattern2.push_back(str[y]);

						if (pattern2 == pattern && pattern.length() > high)
						{
							high = pattern.length();
							result = pattern;
						}
						else if (pattern2.length() == pattern.length())
						{
							// reset back to analyze the other patterns and see if they match to the original
							pattern2.clear(); 
						}
					}
					pattern2.clear();
					index2++;
				} while (index2 < str.length());
			}
		}
		pattern.clear();
		index++;
	} while (index < str.length());
	
	if (high)
	{
		return "yes " + result;
	}
	else
	{
		return "no null";
	}
}

int main() { 
  // keep this function call here
  cout << PatternChaser(gets(stdin));
  return 0;
}

46-) Weighted Path
Have the function WeightedPath(strArr) take strArr which will be an array of strings which models a non-looping weighted Graph. The structure of the array will be as 
follows: The first element in the array will be the number of nodes N (points) in the array as a string. The next N elements will be the nodes which can be anything (A, B, 
C .. Brick Street, Main Street .. etc.). Then after the Nth element, the rest of the elements in the array will be the connections between all of the nodes along with their 
weights (integers) separated by the pipe symbol (|). They will look like this: (A|B|3, B|C|12 .. Brick Street|Main Street|14 .. etc.). Although, there may exist no 
connections at all.

An example of strArr may be: ["4","A","B","C","D","A|B|1","B|D|9","B|C|3","C|D|4"]. Your program should return the shortest path when the weights are added up from node to 
node from the first Node to the last Node in the array separated by dashes. So in the example above the output should be A-B-C-D. Here is another example with strArr being 
["7","A","B","C","D","E","F","G","A|B|1","A|E|9","B|C|2","C|D|1","D|F|2","E|D|6","F|G|2"]. The output for this array should be A-B-C-D-F-G. There will only ever be one 
shortest path for the array. If no path between the first and last node exists, return -1. The array will at minimum have two nodes. Also, the connection A-B for example, 
means that A can get to B and B can get to A. A path may not go through any Node more than once.

Examples

Input: {"4","A","B","C","D", "A|B|2", "C|B|11", "C|D|3", "B|D|2"}
Output: A-B-D

Input: {"4","x","y","z","w","x|y|2","y|z|14", "z|y|31"}
Output: -1

Solution:

#include <iostream>
#include <string>
#include <vector>
#include <queue>
#include <map>
#include <sstream>
#include <algorithm>
using namespace std;

/*
For this problem we can utilize the concept of single source shortest path by implementing Dijkstra's algorithm
Reusing BFS as a base, we now need to perform an edge relaxation on the most optimal path for each node
When an optimal path is found we have to update its cost and its parent

Before starting each node will have a cost of infinity and for each iteration of BFS we are checking if the current path is a better choice than the previous path found for 
this node. 
*/

// global variables
const string defaultParent = "unknown";
const int defaultCost = 1000 * 100;

map <string, int> hashTable; // hash table to quickly reference the nodes

// structure representing a weighted connection in our graph
struct edgeConnection
{
	string neighbor;
	int edgeWeight;
};

// structure representing a node in our graph
struct node
{
	string name;
	int cost;
	string parent;
	vector <edgeConnection> connections;
};


// method to create our nodes for our graph
void createGraph(vector <node*>& graph, string nodeValues[], int size)
{
	for (int x = 1; x <= size; x++)
	{
		// creating the nodes
		graph.push_back(new node);
		graph[x - 1]->name = nodeValues[x];
		graph[x - 1]->cost = defaultCost;
		graph[x - 1]->parent = defaultParent;

		// adding to our hash table
		hashTable[nodeValues[x]] = x - 1;
	}
}

// method to make the connections
void makeConnections(vector <node*>& graph, string neighbors[], int index, int size)
{
	for (int x = index; x < size; x++)
	{
		// extracting the contents from the string
		// we take the 2 nodes that are connecting and the edge weight value
		int breakpoint = neighbors[x].find('|');
		string node1 = neighbors[x].substr(0, breakpoint);
		int breakpoint2 = neighbors[x].find('|', breakpoint + 1);
		string node2 = neighbors[x].substr(breakpoint + 1, breakpoint2 - (breakpoint + 1));

		// getting the edge value
		string value = neighbors[x].substr(breakpoint2 + 1);
		stringstream convert(value);
		int edge;
		convert >> edge;

		// adding the neighbors to the corresponding nodes
		int pair1 = hashTable[node1];
		int pair2 = hashTable[node2];

		edgeConnection temp1;
		temp1.neighbor = node2;
		temp1.edgeWeight = edge;

		edgeConnection temp2;
		temp2.neighbor = node1;
		temp2.edgeWeight = edge;

		graph[pair1]->connections.push_back(temp1);
		graph[pair2]->connections.push_back(temp2);
	}
}


string WeightedPath(string strArr[], int size)
{
	// getting the total number of nodes for our graph
	int nodeSize;
	istringstream value(strArr[0]);
	value >> nodeSize;

	// creating our graph with default values
	vector <node*> graph;
	createGraph(graph, strArr, nodeSize);

	// making the edge connections
	makeConnections(graph, strArr, nodeSize + 1, size);


	string source = graph[0]->name;
	string destination = graph[graph.size() - 1]->name;

	// doing our operations for the single source shortest path
	// first we set up a queue and insert the source node
	// note the cost of our source is set to zero
	queue <node*> list;
	graph[0]->cost = 0;
	list.push(graph[0]);

	while (!list.empty())
	{
		// get current node from our queue to analyze
		node* current = list.front();
		list.pop();

		// loop to check the neighbors of the current node
		if (current->name != destination)
		{
			for (int x = 0; x < current->connections.size(); x++)
			{
				int index = hashTable[current->connections[x].neighbor];
				int edgecost = current->connections[x].edgeWeight;

				if (graph[index]->name != current->parent)
				{
					// condition to check if the current path is more optimal than the last
					// if true we perform edge relaxation and update its parent
					if (current->cost + edgecost < graph[index]->cost)
					{
						// here we update its cost and parent
						graph[index]->cost = current->cost + edgecost;
						graph[index]->parent = current->name;


						// adding to our queue
						list.push(graph[index]);
					}
				}
			}
		}
	}

	// condition to check if we were able to reach the destination
	if (graph[hashTable[destination]]->parent == defaultParent)
	{
		return "-1";
	}
	else
	{
		// collecting our shortest path
		string result;

		node* current = graph[hashTable[destination]];

		// we start at the destination and collect the parents in each iteration
		while (current)
		{
			result += current->name;
			result += '-';

			if (current->parent == defaultParent)
			{
				result.pop_back();
				reverse(result.begin(), result.end());
				return result;
			}
			else
			{
				current = graph[hashTable[current->parent]];
			}
		}
	}
}

int main() { 
  // keep this function call here
  /* Note: In C++ you first have to initialize an array and set 
     it equal to the stdin to test your code with arrays. */

  string A[] = gets(stdin);
  cout << WeightedPath(A, sizeof(A)/sizeof(A[0]));
  return 0;
}

47-) Gas Station
Have the function GasStation(strArr) take strArr which will be an an array consisting of the following elements: N which will be the number of gas stations in a circular 
route and each subsequent element will be the string g:c where g is the amount of gas in gallons at that gas station and c will be the amount of gallons of gas needed to 
get to the following gas station.

For example strArr may be: ["4","3:1","2:2","1:2","0:1"]. Your goal is to return the index of the starting gas station that will allow you to travel around the whole route 
once, otherwise return the string impossible. For the example above, there are 4 gas stations, and your program should return the string 1 because starting at station 1 you 
receive 3 gallons of gas and spend 1 getting to the next station. Then you have 2 gallons + 2 more at the next station and you spend 2 so you have 2 gallons when you get to 
the 3rd station. You then have 3 but you spend 2 getting to the final station, and at the final station you receive 0 gallons and you spend your final gallon getting to 
your starting point. Starting at any other gas station would make getting around the route impossible, so the answer is 1. If there are multiple gas stations that are 
possible to start at, return the smallest index (of the gas station). N will be >= 2.
Examples

Input: {"4","1:1","2:2","1:2","0:1"}
Output: impossible

Input: {"4","0:1","2:2","1:2","3:1"}
Output: 4

Solution:

#include <iostream>
#include <string>
using namespace std;

string GasStation(string strArr[], int arrLength) {
  
  int totalGas = 0;
int totalCost = 0;
int currGas = 0;
int index = -1;

for(int i = 1; i < arrLength; i++)
{
    auto pos = strArr[i].find(":");
	string gasStr = strArr[i];
	string costStr = "0";
	
	if(pos != std::string::npos){
	  gasStr = gasStr.substr(0, pos);
	  costStr = strArr[i].substr(pos+1);
	}
	
	int gas = atoi(gasStr.c_str());
	int cost = atoi(costStr.c_str());
	
	totalGas += gas;
	totalCost += cost;
	
	currGas += gas - cost;

	if(currGas < 0)
	{
	   currGas = 0;
	   index = i+1;
	}
  else if(index == -1)
	  index = i;
}

  if(totalGas < totalCost) return "impossible" ;
  
  return std::to_string(index);

  // code goes here  

}

int main(void) { 
   
  // keep this function call here
  string A[] = coderbyteInternalStdinFunction(stdin);
  int arrLength = sizeof(A) / sizeof(*A);
  cout << GasStation(A, arrLength);
  return 0;
}

48-) Queen Check
Have the function QueenCheck(strArr) read strArr which will be an array consisting of the locations of a Queen and King on a standard 8x8 chess board with no other pieces on the board. The structure of strArr will be the following: ["(x1,y1)","(x2,y2)"] with (x1,y1) representing the position of the queen and (x2,y2) representing the location of the king with x and y ranging from 1 to 8. Your program should determine if the king is in check based on the current positions of the pieces, and if so, return the number of spaces it can move to in order to get out of check. If the king is not in check, return -1. For example: if strArr is ["(4,4)","(6,6)"] then your program should output 6. Remember, because only the queen and king are on the board, if the queen is checking the king by being directly adjacent to it, technically the king can capture the queen.
Examples

Input: {"(1,1)","(1,4)"}
Output: 3

Input: {"(3,1)","(4,4)"}
Output: -1

Solution:

#include <iostream>
#include <string>
#include <vector>

using namespace std;

struct Loc {
  const int X;
  const int Y;
  inline Loc(const string& ToSerializedLoc);
  inline Loc(const int InX, const int InY);
};

inline Loc::Loc(const string& ToSerializedLoc) :
  X(ToSerializedLoc[1] - '0'), Y(ToSerializedLoc[3] - '0') {}

inline Loc::Loc(const int InX, const int InY) : X(InX), Y(InY) {}

inline bool operator==(const Loc& ToLhs, const Loc& ToRhs) {
  return (ToLhs.X == ToRhs.X) && (ToLhs.Y == ToRhs.Y);
}

inline Loc operator+(const Loc& ToLhs, const Loc& ToRhs) {
  return Loc(ToLhs.X + ToRhs.X, ToLhs.Y + ToRhs.Y);
}

const vector<Loc> RelKingMoves {Loc(0, -1), Loc(1, -1), Loc(1, 0), Loc(1, 1),
Loc(0, 1), Loc(-1, 1), Loc(-1, 0), Loc(-1, -1)};

bool isInCheck(const Loc& ToKing, const Loc& ToQueen) {
  if (ToKing == ToQueen) return false;

  if ((ToKing.X == ToQueen.X) || (ToKing.Y == ToQueen.Y)
    || ((ToQueen.X - ToKing.X) == (ToQueen.Y - ToKing.Y))
    || ((ToQueen.X - ToKing.X) == (ToKing.Y - ToQueen.Y))) return true;

  return false;
}

bool isOnBoard(const Loc& ToPiece) {
  return (ToPiece.X >= 1) && (ToPiece.X <= 8) && (ToPiece.Y >= 1)
    && (ToPiece.Y <= 8);
}

int QueenCheck(const string SerializedLocs[]) {
  const Loc Queen(SerializedLocs[0]);
  const Loc KingStart(SerializedLocs[1]);

  if (!isInCheck(KingStart, Queen)) return -1;

  int safeKingMovesTot = 0;

  for (const Loc& ToRelKingMove : RelKingMoves) {
    const Loc King = KingStart + ToRelKingMove;
    if (isOnBoard(King) && !isInCheck(King, Queen)) ++safeKingMovesTot;
  }

  return safeKingMovesTot;
}

int main() {
  string SomeSerializedLocs[] = gets(stdin);
  cout << QueenCheck(SomeSerializedLocs);
  return 0;
}

49-) Simple Mode
Kendisine gönderilen int türden bir dizinin en çok tekrar eden elemanını geri döndüren Simple Mode isimli fonksiyonu yazınız ve test ediniz.
Fonksiyon mod olmaması durumunda -1 döndürecektir.
Örnekler:
Input: {5,5,2,2,1}
Output: 5
Input: {3,4,1,6,10}
Output: -1
Input: {10, 4, 5, 2, 4}
Output: 4

Çözüm: 
#include <iostream>
#include <string>
using namespace std;

int SimpleMode(int arr[], int arrLength) {

  int mode = -1;
  int modeCount = 0;
  int count;
  for (int i = 0; i < arrLength - 1; ++i) {
    count = 0;
    for (int k = i + 1; k < arrLength; ++k) {
        if (arr[i] == arr[k])
           count++;
    }
    if (modeCount < count) {
      mode = arr[i];
      modeCount = count;
    }
  }  
  return mode;
}

int main(void) { 
   
  // keep this function call here
  int A[] = coderbyteInternalStdinFunction(stdin);
  int arrLength = sizeof(A) / sizeof(*A);
  cout << SimpleMode(A, arrLength);
  return 0;  
}

50-) Noughts Determiner
Have the function NoughtsDeterminer(strArr) take the strArr parameter being passed which will be an array of size eleven. The array will take the shape of a Tic-tac-toe 
board with spaces strArr[3] and strArr[7] being the separators ("<>") between the rows, and the rest of the spaces will be either "X", "O", or "-" which signifies an empty 
space. So for example strArr may be ["X","O","-","<>","-","O","-","<>","O","X","-"]. This is a Tic-tac-toe board with each row separated double arrows ("<>"). Your program 
should output the space in the array by which any player could win by putting down either an "X" or "O". In the array above, the output should be 2 because if an "O" is 
placed in strArr[2] then one of the players wins. Each board will only have one solution for a win, not multiple wins. You output should never be 3 or 7 because those are 
the separator spaces.
Examples
Input: {"X","-","O","< >","-","-","O","< >","-","-","X"}
Output: 5
Input: {"X","O","X","< >","-","O","O","< >","X","X","O"}
Output: 4

Solution:

#include <algorithm>
#include <iostream>
#include <string>

using namespace std;

const size_t LinesOfCellIndices[8][3] {{0, 1, 2}, {4, 5, 6}, {8, 9, 10},
{0, 4, 8}, {1, 5, 9}, {2, 6, 10}, {0, 5, 10}, {2, 5, 8}};

size_t NoughtsDeterminer(const string Cells[]) {
  for (size_t lineIndex = 0; lineIndex < 8; ++lineIndex) {
    const string LineOfCells[] {
      Cells[LinesOfCellIndices[lineIndex][0]],
      Cells[LinesOfCellIndices[lineIndex][1]],
      Cells[LinesOfCellIndices[lineIndex][2]]
    };

    if (count(LineOfCells, LineOfCells + 3, "-") == 1
      && (count(LineOfCells, LineOfCells + 3, "X") == 2
      || count(LineOfCells, LineOfCells + 3, "O") == 2)) {
      for (size_t cellIndexIndex = 0; cellIndexIndex < 3; ++cellIndexIndex) {
        if (LineOfCells[cellIndexIndex] == "-") {
          return LinesOfCellIndices[lineIndex][cellIndexIndex];
        }
      }
    }
  }

  //Returned if no winning cell index found.
  return numeric_limits<size_t>::max();
}

int main() {
  const string CellsA[] = gets(stdin);
  
  cout << NoughtsDeterminer(CellsA);
  
  return 0;
}

51-) Palindrome Two
Kendisine gönderilen bir yazı palindrome ise true palindrome değilse false döndüren PalindromeTwo isimli fonksiyonu yazınız ve test ediniz.
Palindromların tam palindrom olması gibi bir zorunluluk yoktur. 
Örnek girişler:
Input: "Noel - sees Leon"
Output: true

Input: "A war at Tarawa!"
Output: true

Input: "at sahibi gibi hasta!"
Output: true

Çözüm: 
#include <iostream>
#include <string>
#include <cctype>
using namespace std;

bool PalindromeTwo(string str) {
  
  string text;
  for (int i = 0; i < str.size(); ++i) {
      if (isalpha(str[i])) {
        text += tolower(str[i]);
      }
  }  
  return text == string(text.rbegin(), text.rend());
}

int main(void) { 
   
  // keep this function call here
  cout << boolalpha << PalindromeTwo(coderbyteInternalStdinFunction(stdin));
  return 0;
}

52-) Prime Mover
Kendisine gönderilen int türden sayıncı asal sayıyı geri döndüren Prime Mover isimli fonksiyonu 
yazınız ve test ediniz. Aşağıda bununla ilgili bazı örnekler verilmiştir:

Input: 9
Output: 23

Input: 100
Output: 541

Input: 16
Output: 53

Çözüm:

#include <iostream>
#include <string>
using namespace std;

bool isPrime(const long val)
{
  if (val <= 1)
    return false;
  if (val % 2 == 0) 
    return val == 2;
  if (val % 3 == 0)
    return val == 3;
  if (val % 5 == 0)
    return val == 5;
  if (val % 7 == 0)
    return val == 7;
  for (long i = 11; i * i <= val; i += 2) {
    if (val % i == 0) 
      return false;
  }
  return true;        
}

int PrimeMover(int num) {
  int nthPrimeNum;
  int count = 0;
  for (int i = 2; i < 10000; ++i) {
    if (isPrime(i)) {
      count++;
    }
    if (num == count) {
      nthPrimeNum = i;
      break;
    }
  }
  return nthPrimeNum;
}

int main(void) { 
  // keep this function call here
  cout << PrimeMover(coderbyteInternalStdinFunction(stdin));
  return 0;  
}

53-) Swap II
Have the function SwapII(str) take the str parameter and swap the case of each character. Then, if a letter is between two numbers (without separation), switch the places 
of the two numbers. For example: if str is "6Hello4 -8World, 7 yes3" the output should be 4hELLO6 -8wORLD, 7 YES3.

Examples
Input: "Hello -5LOL6"
Output: hELLO -6lol5
Input: "2S 6 du5d4e"
Output: 2s 6 DU4D5E

Solution:

#include <iostream>
#include <string>
#include <cctype>
using namespace std;

std::string SwapII(std::string str) {
  int prev_digit = -1;
  for (int i = 0; i < str.length(); i++) {
    char c = str[i];
    // SWAP CASE
    if (std::isalpha(str[i])) {
      str[i] = (std::isupper(str[i])) ? std::tolower(str[i]) : std::toupper(str[i]);
    }
    //SWAP DIGITS
    if (std::isdigit(c) && prev_digit > -1) {
      if (i - prev_digit == 1) {
        prev_digit = i;
        continue;
      }
      std::swap(str[i], str[prev_digit]);
      prev_digit = -1;
    } else if (!std::isalpha(c) && !std::isdigit(c)) {
      prev_digit = -1;
    } else if (std::isdigit(str[i])) {
      prev_digit = i;
    }
  }

 return str;
}


int main(void) { 
   
  // keep this function call here
  cout << SwapII(coderbyteInternalStdinFunction(stdin));
  return 0;
    
}

54-) Counting Minutes I
Have the function CountingMinutesI(str) take the str parameter being passed which will be two times (each properly formatted with a colon and am or pm) separated by a 
hyphen and return the total number of minutes between the two times. The time will be in a 12 hour clock format. For example: if str is 9:00am-10:00am then the output 
should be 60. If str is 1:00pm-11:00am the output should be 1320.
Examples
Input: "12:30pm-12:00am"
Output: 690
Input: "1:23am-1:08am"
Output: 1425

Solution:

#include <iostream>
#include <string>
using namespace std;

string CountingMinutesI(string str) {
  
  // code goes here  
  size_t pos = str.find("-");
  string start = str.substr(0,pos);
  string end = str.substr(pos+1,str.length()-pos);

  int startHours = atoi(start.substr(0,start.find(":")).c_str());
  int startMinutes = atoi(start.substr(start.find(":")+1,str.length()-start.find(":")).c_str());

  int startFrom = startHours*60 + startMinutes;
  if(start.find("pm")!=string::npos)
  {
    startHours = startHours + 12;
    startFrom = startHours*60 + startMinutes - 24*60;
  }
  

  int endHours = atoi(end.substr(0,end.find(":")).c_str());
  int endMinutes = atoi(end.substr(end.find(":")+1,str.length()-end.find(":")).c_str());

  int endUntil = endHours*60 +endMinutes;
  if(end.find("pm")!=string::npos)
  {
    endHours = endHours + 12;
    endUntil = endHours*60 +endMinutes -24*60;
  }
  
  string ret = std::to_string(abs(endUntil-startFrom));
  if (endUntil < startFrom)
    ret = std::to_string(24*60-abs(endUntil-startFrom));
  return ret;

}

int main(void) { 
  // keep this function call here
  cout << CountingMinutesI(coderbyteInternalStdinFunction(stdin));
  return 0;
}

55-) Off Line Minimum
Have the function OffLineMinimum(strArr) take the strArr parameter being passed which will be an array of integers ranging from 1...n and the letter "E" and return the 
correct subset based on the following rules. The input will be in the following format: ["I","I","E","I",...,"E",...,"I"] where the I's stand for integers and the E means 
take out the smallest integer currently in the whole set. When finished, your program should return that new set with integers separated by commas. For example: if strArr 
is ["5","4","6","E","1","7","E","E","3","2"] then your program should return 4,1,5.
Examples

Input: {"1","2","E","E","3"}
Output: 1,2

Input: {"4","E","1","E","2","E","3","E"}
Output: 4,1,2,3

Solutions:
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

string OffLineMinimum(string strArr[], int arrLength) {
  
  // code goes here
  vector <int> iVec;
  string result;
  int idx = 0;
  for (int i = 0; i < arrLength; ++i) {
    sort(iVec.begin(), iVec.end());
    if (strArr[i] == "E") {
       result += to_string(iVec[idx]);
       result += ",";
       iVec.erase(iVec.begin());
    }
    else {
      iVec.emplace_back(stoi(strArr[i]));
    }
  }


  return string(result.begin(), result.end() - 1);
}

int main(void) { 
   
  // keep this function call here
  string A[] = coderbyteInternalStdinFunction(stdin);
  int arrLength = sizeof(A) / sizeof(*A);
  cout << OffLineMinimum(A, arrLength);
  return 0;
    
}
//-------------------------------------------------

