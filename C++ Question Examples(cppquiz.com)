/*-----------------------------------------------------------------
Aşağıdaki örnekte ekran çıktısı aB2b2 şeklinde olacaktır.
---------------------------------------------------------------------*/
#include <iostream>

struct A {
    A() { std::cout << "a"; }

    void foo() { std::cout << "1"; }
};

struct B {
    B() { std::cout << "b"; }
    B(const A&) { std::cout << "B"; }

    void foo() { std::cout << "2"; }
};

int main()
{
    auto L = [](auto flag) -> auto {return flag ? A{} : B{};};
    L(true).foo();
    L(false).foo();
}
/*-------------------------------------------------------
Aşağıdaki örnekteki kod geçerlidir. Yapılar illa eleman
sayısı kadar değişkenle init. edilecek diye bir zorunluluk
yoktur.
-------------------------------------------------------*/
#include <iostream>

struct S {
    int one;
    int two;
    int three;
};

int main() {
    S s{1,2};
    std::cout << s.one;
}
/*-------------------------------------------------------
Aşağıdaki örnekte ekran çıktısı 10 olacaktır. virgül operatörünün
ürettiği değer her ne kadar sağ operand olsa da öncelik
seviyesi olarak son sıradadır. Bu sebeple x = a, b; ifadesi
aslında x = a ve b anlamına gelmektedir.
-------------------------------------------------------*/
#include <iostream>

int main() {
  int a = 10;
  int b = 20;
  int x;
  x = a, b;
  std::cout << x;
}
/*-------------------------------------------------------
Aşağıdaki örnekte numeric_limits'in unsigned int açılımının
maks değeri tahmin edilebileceği gibi unsigned int'in maksimum
değeri anlamına gelmektedir.
-------------------------------------------------------*/
#include <iostream>
#include <limits>

int main() {
  unsigned int i = std::numeric_limits<unsigned int>::max();
  std::cout << ++i;
}
/*-------------------------------------------------------
Aşağıdaki örnekteki kod geçerli olmakla birlikte 1 değerini
üretir. Bunun nedeni null pointer olmamasından kaynaklanmaktadır.
Herhangi bir void pointer kendine bağlanması geçerli bir ifade olmasının 
yanı sıra bildirimi de yapıldığından dolayı bir dangling pointer 
durumu da söz konusu değildir.
-------------------------------------------------------*/
#include <iostream>

int main() {
  void * p = &p;
  std::cout << bool(p);
}
/*-------------------------------------------------------
Aşağıdaki örnekte f fonksiyonuna a,a argümanlarının gönderildiğine
dikkat edilmelidir. Bu sebeple fonksiyon içerisinde değiştirilen
b değeri aslında maindeki a değeridir. fonksiyon çağrısı
sonrasında a değeri 4 olurken b'nin değeri değişmez. Fonksiyonun
geri dönüş değeri ise 4 + 4'ten 8 olarak elde edilir. Son
durumda ekran çıktısı 428 şeklinde olacaktır.
-------------------------------------------------------*/
#include <iostream>

int f(int &a, int &b) {
  a = 3;
  b = 4;
  return a + b;
}

int main() {
  int a = 1;
  int b = 2;
  int c = f(a, a);
  std::cout << a << b << c;
}
/*-------------------------------------------------------
Eğer char türünden '3' ten '2' çıkarılırsa son durumda
elde edilen değer int türünden 1 olacaktır.
-------------------------------------------------------*/
#include <iostream>

int main() {
    int i = '3' - '2';
    std::cout << i;
}
/*-------------------------------------------------------
Aşağıdaki örnekte f fonksiyonunun 3 tane overloadı bulunmaktadır.
1.0 sabitinin türü double olduğundan double parametreli func
exact match olmaktadır. Sonuç olarak ekran çıktısı d olacaktır.
-------------------------------------------------------*/
#include <iostream>

void f(int) { std::cout << "i"; }
void f(double) { std::cout << "d"; }
void f(float) { std::cout << "f"; }

int main() {
  f(1.0);
}
/*-------------------------------------------------------
Aşağıdaki örnekte bir belirsiz davrnış söz konusudur.
-------------------------------------------------------*/
#include <limits>
#include <iostream>

int main() {
    std::cout << std::numeric_limits<unsigned char>::digits;
}
/*-------------------------------------------------------
Aşağıdaki örnekte ekran çıktısı main olacaktır.
sizeof operatörü kullanılırken bir ctor çağrısı gerçekleştirilmez.
-------------------------------------------------------*/
#include <iostream>

struct A {
    A() { std::cout << "A"; }
    ~A() { std::cout << "a"; }
};

int main() {
    std::cout << "main";
    return sizeof new A;
}
/*-------------------------------------------------------
Aşağıdaki örnekte argv[argc] ifadesi 0 olarak elde edilir.
Bu sebeple ekran çıktısı 1 olacaktır.
-------------------------------------------------------*/
#include <iostream>

int main(int argc, char* argv[]) {
    std::cout << (argv[argc] == nullptr);
}
/*-------------------------------------------------------
Aşağıdaki örnekte c.x = 3; deyimi bir sentaks hatasına neden
olur. Burada bilinmesi gereken en önemli bilgi sınıflarda
bir default kalıtım söz konusu olduğunda sınıflar için
default kalıtım tipi private kalıtımıdır. structlarda(yapılar)
ise default kalıtımın public kalıtımı olmasıdır.
-------------------------------------------------------*/
#include <iostream>

class A {};

class B {
public:
    int x = 0;
};

class C : public A, B {};

struct D : private A, B {};


int main()
{
    C c;
    c.x = 3;

    D d;
    d.x = 3;

    std::cout << c.x << d.x;
}
/*-------------------------------------------------------
Anahtar Notlar:C++ 11 ile dile eklenen override anahtar
sözcüğü eskiden yazılan kodlara istinaden override anahtar
sözcüğü değişken isimler dahil olmak üzere pek çok yerde isim
olarak kullanılabilir. Bu yüzden aşağıdaki kodda herhangi
şekilde bir sentaks hatası yoktur.
-------------------------------------------------------*/
#include <iostream>

struct override {};

struct Base {
    virtual override f() = 0;
};

struct Derived : Base {
    virtual auto f() -> override override{
        std::cout << "1";
        return override();
    }
};

int main() {
    Derived().f();
}
/*-------------------------------------------------------
Aşağıdaki örnekte ekran çıktısı 1133 şeklinde olacaktır.
Bunun nedeni uniform init yapıldığında init_list
parametrelinin seçilebilirlikte daha üsütün olmasından
kaynaklanmaktadır. Bu durumda ilk iki nesne için
default ctor çağrılırken, diğerleri için ise init_list parametreli
çağrılacaktır.
-------------------------------------------------------*/
#include <initializer_list>
#include <iostream>

struct A {
  A() { std::cout << "1"; }

  A(int) { std::cout << "2"; }

  A(std::initializer_list<int>) { std::cout << "3"; }
};

int main(int argc, char *argv[]) {
  A a1;
  A a2{};
  A a3{ 1 };
  A a4{ 1, 2 };
}
/*-------------------------------------------------------
Aşağıdaki örnekte ekran çıktısı 1 olacaktır.
-------------------------------------------------------*/
#include <iostream>

namespace x {
  class C {};
  void f(const C& i) {
    std::cout << "1";
  }
}

namespace y {
  void f(const x::C& i) {
    std::cout << "2";
  }
}

int main() {
  f(x::C());
}
/*-------------------------------------------------------
Özel üye fonksiyonlarla ilgili güzel bir örnek
-------------------------------------------------------*/
#include <iostream>

struct X {
  X() { std::cout << "a"; }
  X(const X &x) { std::cout << "b"; }
  const X &operator=(const X &x) {
    std::cout << "c";
    return *this;
  }
};

int main() {
  X x;
  X y(x);
  X z = y;
  z = x;
}
/*-------------------------------------------------------
Global değişkenler default olarak 0 değerini alır.
-------------------------------------------------------*/
#include <iostream>

int a;

int main () {
    std::cout << a;
}
/*-------------------------------------------------------
Aşağıdaki örnekte boşluk geçerli bir ifade olduğundan dolayı
değilinin değili 1'e eşit olacaktır.
-------------------------------------------------------*/
#include <iostream>

int main() {
    std::cout << +!!"";
}
/*-------------------------------------------------------
Aşağıdaki örnekte n1 nesnesi 3 olurken n2 nesnesi 2 olarak
elde edilecektir. Bunun nedeni n1 için yapılan sum çağrısında
tür çıkarımı double olarak yapılıp toplanan sayıların noktadan
sonraki kısımları atılmaz iken n2 için yapılan çağrıda
tür çıkarımı int olarak yapılır bu durumda, toplanacak
sayıların noktadan sonraki kısımları
-------------------------------------------------------*/
#include <iostream>

template<typename T>
T sum(T arg) {
    return arg;
}

template<typename T, typename ...Args>
T sum(T arg, Args... args) {
    return arg + sum<T>(args...);
}

int main() {
    auto n1 = sum(0.5, 1, 0.5, 1);
    auto n2 = sum(1, 0.5, 1, 0.5);
    std::cout << n1 << n2;
}
/*-------------------------------------------------------
Aşağıdaki örnekte hem aggregation hem de inheritance yapılmıştır.
Burada ilk önce taban sınıf hayata gelecektir. Sonrasında
o sınıfın elemanları hayata gelecektir. Son olarak da Söz konusu
sınıfın ctoru çağrılacaktır. Temel bir kural olarak benimsenebilecek
bir kural ise ilk ctoru çağrılan sınıfın ctorunun son çağrılacağıdır.
Bu durumda ilk türemiş sınıfın dtoru çağrılır sonrasında üye
elemanın sınıfı, son olarak da taban sınıfın ctoru çağrılacaktır.
Ekran çıktısı:
Base ctor -> Member ctor -> Derived ctor -> Derived dtor
-> Member ctor -> Base dtor
-------------------------------------------------------*/
#include <iostream>

class Base {
public:
    Base() {
        std::cout << "Base ctor\n";
    }
    ~Base() {
        std::cout << "Base dtor\n";
    }
};

class Member {
public:
    Member() {
        std::cout << "Member ctor\n";
    }
    ~Member() {
        std::cout << "Member dtor\n";
    }
};

class Derived : public Base {
public:
    Derived() {
        std::cout << "Derived ctor\n";
    }
    ~Derived() {
        std::cout << "Derived dtor\n";
    }
private:
    Member mx;
};

int main()
{
    Derived d;
    return 0;
}
/*-------------------------------------------------------
Aşağıdaki örnekte f overload edilmemiştir. Bu sebeple
double parametreli f çağrısı gerçekleştirilecektir.
-------------------------------------------------------*/
#include <iostream>

struct Base {
  void f(int) { std::cout << "i"; }
};

struct Derived : Base {
  void f(double) { std::cout << "d"; }
};

int main() {
  Derived d;
  int i = 0;
  d.f(i);
}
/*-------------------------------------------------------
Aşağıdaki örnekte virtual dispatch mekanizması devreye girecektir.
bu sebeple türemiş sınıfa ait olan func çağrısı yapılacaktır.
Burada ek bir bilgi verilmesi gerekirse taban sınıfın
dtrounun virtual yapılamsı güvenlik olarak son derece önemlidir.

-------------------------------------------------------*/
#include <iostream>

class Base {
public:
    Base() {
        std::cout << "Base ctor\n";
    }

    virtual void func() {
        std::cout << "Base func()\n";
    }

    ~Base() {
        std::cout << "Base dtor\n";
    }
};

class Derived : public Base {
public:
    Derived() {
        std::cout << "Derived ctor\n";
    }

    void func() final {
        std::cout << "Derived func()\n";
    }

    ~Derived() {
        std::cout << "Derived dtor\n";
    }
};

int main()
{
    Base* bptr = new Derived();
    bptr->func();
    delete bptr;
    return 0;
}
/*-------------------------------------------------------
Aşağıdaki örnekte ekran çıktısı 1 olarak elde edilecektir.
-------------------------------------------------------*/
#include <iostream>

void f(char*&&) { std::cout << 1; }
void f(char*&) { std::cout << 2; }

int main() {
   char c = 'a';
   f(&c);
}
/*-------------------------------------------------------
Aşağıdaki örnekte ekran çıktısı AAABAA şeklinde olacaktır.
-------------------------------------------------------*/
#include <iostream>
#include <memory>
#include <vector>

class C {
public:
  void foo()       { std::cout << "A"; }
  void foo() const { std::cout << "B"; }
};

struct S {
  std::vector<C> v;
  std::unique_ptr<C> u;
  C *const p;

  S()
    : v(1)
    , u(new C())
    , p(u.get())
  {}
};

int main() {
  S s;
  const S &r = s;

  s.v[0].foo();
  s.u->foo();
  s.p->foo();

  r.v[0].foo();
  r.u->foo();
  r.p->foo();
}
/*-------------------------------------------------------
Anahtar Notlar: Bit field olarak bildirilmiş struct elemanları
birbiriyle karşılaştırılması doğrudan sentaks hatasına neden olur.
-------------------------------------------------------*/
#include <iostream>

struct X {
    int var1 : 3;
    int var2;
};

int main() {
    X x;
    std::cout << (&x.var1 < &x.var2);
}
/*-------------------------------------------------------
Aşağıdaki örnekte bir sentaks hatası söz konusudur.
a+++++b ifadesi a++ + ++b şekiinde ele alınmaz.
-------------------------------------------------------*/
#include <iostream>

int main() {
 int a = 5,b = 2;
 std::cout << a+++++b;
}
/*-------------------------------------------------------
Eğer bir anahtar belirtimemiş ise bu durumda anahtar sıfır olarak alınır.
-------------------------------------------------------*/
#include <iostream>
#include <map>
using namespace std;

int main() {
    map<int, int> m;
    cout << m[42];
}
/*-------------------------------------------------------
Diamond sorunu multi level inheritance durumunda aynı taban
sınıftan iki tane olamsı durumunu ifade etmektedir. Bu sorunun
çözümü virtual inheritance kullanılmaktır. Bu durumda
söz konusu sınıftan iki adet taban sınıf bulunmayacaktır.
Bundan yola çıkarak D sınıfı türünden bir nesne için
sadece 1 defa A sınıfının ctoru çağrılacaktır. Elbette
bir sınıfın ctoru çağrılmadan o sınıfın taban sınıfının(Base class)
ctorunun çağrılacağı da unutulmamalıdır. Bu durumda d1
nesnesi için ekran çıktısı ABCD şeklinde olacaktır.
Diğer taraftan d2 içinse durum biraz daha farklıdır. Burada
bir kopyalama söz konusu olacağından Burada ABCd şeklinde
bir ekran çıktısı alınacaktır.
-------------------------------------------------------*/
#include <iostream>
using namespace std;

class A
{
public:
    A() { cout << "A"; }
    A(const A &) { cout << "a"; }
};

class B: public virtual A
{
public:
    B() { cout << "B"; }
    B(const B &) { cout<< "b"; }
};

class C: public virtual A
{
public:
    C() { cout<< "C"; }
    C(const C &) { cout << "c"; }
};

class D:B,C
{
public:
    D() { cout<< "D"; }
    D(const D &) { cout << "d"; }
};

int main()
{
    D d1;
    D d2(d1);
}
/*-------------------------------------------------------
Aşağıdaki örnekte sadece diziler ve dizi dizileri için
1 değeri üretilecektir.
-------------------------------------------------------*/
#include <iostream>
#include <type_traits>
using namespace std;

int main() {
    cout << is_const_v<const int *>
         << is_const_v<const int [1]>
         << is_const_v<const int **>
         << is_const_v<const int (*)[1]>
         << is_const_v<const int *[1]>
         << is_const_v<const int [1][1]>;
}
/*-------------------------------------------------------
aşağıdaki örnekte ekran çıktısı 11422 olacaktır.
-------------------------------------------------------*/
#include <iostream>

struct X {
    X() { std::cout << "1"; }
    X(const X &) { std::cout << "3"; }
    ~X() { std::cout << "2"; }

    void f() { std::cout << "4"; }

} object;

int main() {
    X(object);
    object.f();
}
/*-------------------------------------------------------
Aşağıdaki örnekte bir copy elision söz konusu olacağından
copy constructor çağrılmaz. Bu sebeple ekran çıktısı 13
şeklinde olacaktır.
-------------------------------------------------------*/
#include <iostream>

struct E
{
  E() { std::cout << "1"; }
  E(const E&) { std::cout << "2"; }
  ~E() { std::cout << "3"; }
};

E f()
{
  return E();
}

int main()
{
  f();
}
/*-------------------------------------------------------
 Aşağıdaki örnekte ekran çıktısı 00 olarak elde edilecektir.
-------------------------------------------------------*/
#include <type_traits>
#include <iostream>

using namespace std;

struct X {
    int f() const&&{
        return 0;
    }
};

int main() {
    auto ptr = &X::f;
    cout << is_same_v<decltype(ptr), int()>
         << is_same_v<decltype(ptr), int(X::*)()>;
}
/*-------------------------------------------------------
 top level const(nesnenin kendisinin const olması) türü
 değişmesine neden olmaz bu sebeple const int ile int
 aynı tür olarak alınacaktır. Ancak int* ve const int*
 türleri birbirinden farklıdır. Burada low level constluk söz
 konusu olacağından bu türler birbirinden farklı türlerdir.
 Açıklamaya göre son durumda ekran çıktısı 10 şeklinde olacaktır.
-------------------------------------------------------*/
#include <iostream>
#include <type_traits>

int main() {
    std::cout << std::is_same_v<
        void(int),
        void(const int)>;

    std::cout << std::is_same_v<
        void(int*),
        void(const int*)>;
}
/*-------------------------------------------------------
  Aşağıdaki örnekte bitsel sola kaydırma operatörün overload
  edilmiştir. Burada ek olarak virtual dispatch mekanizması da
  devreye girecektir. Nesnenin türü b olduğu için runtime
  polimofzim devreye girecek B yapısına ait olan put fonksiyonu
  çağrılacaktır. Ekran çıktısı B şeklinde olacaktır.
-------------------------------------------------------*/
#include <iostream>

struct A {
  virtual std::ostream &put(std::ostream &o) const {
    return o << 'A';
  }
};

struct B : A {
  virtual std::ostream &put(std::ostream &o) const {
    return o << 'B';
  }
};

std::ostream &operator<<(std::ostream &o, const A &a) {
  return a.put(o);
}

int main() {
  B b;
  std::cout << b;
}
/*-------------------------------------------------------
  Aşağıdaki örnekte ekran çıktısı D0C0 şwklinde olacaktır.
-------------------------------------------------------*/
#include <iostream>
#include <functional>

class Q{
    int v=0;
    public:
        Q(Q&&){
            std::cout << "M";
        }
        Q(const Q&){
            std::cout << "C";
        }
        Q(){
            std::cout << "D";
        }
        void change(){
            ++v;
        }
        void func(){
            std::cout << v;
        }
};
void takeQfunc(std::function<void(Q)> qfunc){
    Q q;
    q.func();
    qfunc(q);
    q.func();
}
int main(){
    takeQfunc([](Q&& q){
        q.change();
    });
    return 0;
}
/*-------------------------------------------------------
    decltype((a)) ifadesi için tür çıkarımı int& olarak yapılacaktır.
    Bu sebeple ekran çıktısı 11 olarak elde edilecektir.
-------------------------------------------------------*/
#include <iostream>

int main() {
  int a = 0;
  decltype((a)) b = a;
  b++;
  std::cout << a << b;
}
/*-------------------------------------------------------
  Aşağıdaki örnekte bir ambiguity söz konusudur.
-------------------------------------------------------*/
#include <iostream>

void f(int) { std::cout << 1; }
void f(unsigned) { std::cout << 2; }

int main() {
  f(-2.5);
}
/*-------------------------------------------------------
  Aşağıdaki örnekte ekran çıktısı 1R2L şeklinde olacaktır.
-------------------------------------------------------*/
#include <iostream>
#include <type_traits>

void g(int&) { std::cout << 'L'; }
void g(int&&) { std::cout << 'R'; }

template<typename T>
void f(T&& t) {
    if (std::is_same_v<T, int>) { std::cout << 1; }
    if (std::is_same_v<T, int&>) { std::cout << 2; }
    if (std::is_same_v<T, int&&>) { std::cout << 3; }
    g(std::forward<T>(t));
}

int main() {
    f(42);
    int i = 0;
    f(i);
}
/*-------------------------------------------------------
  Aşağıdaki örnekte önce 2 defa default ctor sonrasında

-------------------------------------------------------*/
#include <iostream>

struct A {
  A() { std::cout << "A"; }
  A(const A &a) { std::cout << "B"; }
  virtual void f() { std::cout << "C"; }
};

int main() {
  A a[2];
  for (auto x : a) {
    x.f();
  }
}
/*-------------------------------------------------------
 Aşağıdaki örnekte ekran çıktısı 21 şeklinde olacaktır.
-------------------------------------------------------*/
#include <iostream>

struct A {
  A(int i) : m_i(i) {}
  operator bool() const { return m_i > 0; }
  int m_i;
};

int main() {
  A a1(1), a2(2);
  std::cout << a1 + a2 << (a1 == a2);
}
/*-------------------------------------------------------
 Burada ekran çıktısı 01 şeklinde elde edilecektir.
-------------------------------------------------------*/
#include <iostream>

int main() {
  int a = 0;
  decltype(a) b = a;
  b++;
  std::cout << a << b;
}

/*-------------------------------------------------------
Aşağıdaki örnekte ub söz konusudur.
-------------------------------------------------------*/
template <typename ...Ts>
struct X {
  X(Ts ...args) : Var(0, args...) {}
  int Var;
};

int main() {
  X<> x;
}
/*-------------------------------------------------------
  Aşağıdaki örnekte ekran çıktısı 11 şeklinde olacaktır.
-------------------------------------------------------*/
#include<iostream>

int foo()
{
  return 10;
}

struct foobar
{
  static int x;
  static int foo()
  {
    return 11;
  }
};

int foobar::x = foo();

int main()
{
    std::cout << foobar::x;
}
/*-------------------------------------------------------
  Aşağıdaki örnekte extern "C" bildirimi dolaysıyla
  A::x ve B::x aynı anlamı taşımaktadır. Bundan dolayı A::x'te
  yapılan herhangi bir değişiklik doğrudan B::x'i de etkileyecektir.
-------------------------------------------------------*/
#include<iostream>

namespace A{
  extern "C" int x;
};

namespace B{
  extern "C" int x;
};

int A::x = 0;

int main(){
  std::cout << B::x;
  A::x = 1;
  std::cout << B::x;
}
/*-------------------------------------------------------
    Aşağıdaki örnekte b referansı bir geçici nesneye bağlanmaktadır.
    Bu yüzden a nesnesinin arttırılması b nesnesini hiçbir şekilde
    etkilemez. Sonuç olarak ekran çıktısı 00 olarak elde edilecektir.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

int main() {
    int a = '0';
    char const &b = a;
    cout << b;
    a++;
    cout << b;
}
/*-------------------------------------------------------
  Aşağıdaki örnekte operator auto ifadesi otomatik tür dönüşümüne
  sebep olur. Bu yüzden a'nın değerinin 1 olacağını söyleyebiliriz
-------------------------------------------------------*/
#include <iostream>

struct Foo {
  operator auto() {
    std::cout << "A";
    return 1;
  }
};

int main() {
  int a = Foo();
  std::cout << a;
}
/*-------------------------------------------------------
  C++ ta çift tırnak içerisindeki ifadeler, const char[]
  türündendir. Bu sebeple "" ifadesi de const char[] türündendir.
  string literallerinin sonunda null karakter(\0) olduğunu
  C dilinden biliyorduk. Demekki bu yazı aslında boş yazı değildir.
  Sadece null karakterden oluşan bir yazıdır. Bu durumda
  sizeof tarafından elde edilecek değer sizeof(char) ifadesinin
  sonucuna eşit olacaktır. Bu durumda elde edilen sonuç 1 byte olacaktır.
-------------------------------------------------------*/
#include <iostream>

int main() {
    std::cout << sizeof("");
}
/*-------------------------------------------------------
  Aşağıdaki örnekte bir tanımsız davranış söz konusudur.
-------------------------------------------------------*/
#include <iostream>

volatile int a;

int main() {
  std::cout << (a + a);
}
/*-------------------------------------------------------
  Aşağıdaki örnekte ekran çıktısı 210 şeklinde olacaktır.
-------------------------------------------------------*/
#include <iostream>

class show_id
{
public:
    ~show_id() { std::cout << id; }
    int id;
};

int main()
{
    delete[] new show_id[3]{ {0}, {1}, {2} };
}
/*-------------------------------------------------------
  Aşağıdaki örnekte bar için tür çıkarımı referanslık düşeceğinden
  dolayı int olarak yapılacaktır. 
-------------------------------------------------------*/
#include <iostream>

class A {
  int foo = 0;

public:
  int& getFoo() { return foo; }
  void printFoo() { std::cout << foo; }
};

int main() {
  A a;

  auto bar = a.getFoo();
  ++bar;

  a.printFoo();
}
/*-------------------------------------------------------
  Aşağıdaki örnekte 2.5 double türünden bir sabit olduğu 
  için double parametreli f çağrısı gerçekleştirilecektir.
  Diğer taraftan 2.5f sabiti ise float türünden olduğundan 
  dolayı float parametreli f çağrısı gerçekleştirilecektir.
-------------------------------------------------------*/
#include <iostream>

void f(float) { std::cout << 1; }
void f(double) { std::cout << 2; }

int main() {
  f(2.5);
  f(2.5f);
}

