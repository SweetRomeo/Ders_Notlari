/*-----------------------------------------------------------------
Aşağıdaki örnekte ekran çıktısı aB2b2 şeklinde olacaktır.
---------------------------------------------------------------------*/
#include <iostream>

struct A {
    A() { std::cout << "a"; }

    void foo() { std::cout << "1"; }
};

struct B {
    B() { std::cout << "b"; }
    B(const A&) { std::cout << "B"; }

    void foo() { std::cout << "2"; }
};

int main()
{
    auto L = [](auto flag) -> auto {return flag ? A{} : B{};};
    L(true).foo();
    L(false).foo();
}
/*-------------------------------------------------------
Aşağıdaki örnekteki kod geçerlidir. Yapılar illa eleman
sayısı kadar değişkenle init. edilecek diye bir zorunluluk
yoktur.
-------------------------------------------------------*/
#include <iostream>

struct S {
    int one;
    int two;
    int three;
};

int main() {
    S s{1,2};
    std::cout << s.one;
}
/*-------------------------------------------------------
Aşağıdaki örnekte ekran çıktısı 10 olacaktır. virgül operatörünün
ürettiği değer her ne kadar sağ operand olsa da öncelik
seviyesi olarak son sıradadır. Bu sebeple x = a, b; ifadesi
aslında x = a ve b anlamına gelmektedir.
-------------------------------------------------------*/
#include <iostream>

int main() {
  int a = 10;
  int b = 20;
  int x;
  x = a, b;
  std::cout << x;
}
/*-------------------------------------------------------
Aşağıdaki örnekte numeric_limits'in unsigned int açılımının
maks değeri tahmin edilebileceği gibi unsigned int'in maksimum
değeri anlamına gelmektedir.
-------------------------------------------------------*/
#include <iostream>
#include <limits>

int main() {
  unsigned int i = std::numeric_limits<unsigned int>::max();
  std::cout << ++i;
}
/*-------------------------------------------------------
Aşağıdaki örnekteki kod geçerli olmakla birlikte 1 değerini
üretir. Bunun nedeni null pointer olmamasından kaynaklanmaktadır.
Herhangi bir void pointer kendine bağlanması geçerli bir ifade olmasının 
yanı sıra bildirimi de yapıldığından dolayı bir dangling pointer 
durumu da söz konusu değildir.
-------------------------------------------------------*/
#include <iostream>

int main() {
  void * p = &p;
  std::cout << bool(p);
}
/*-------------------------------------------------------
Aşağıdaki örnekte f fonksiyonuna a,a argümanlarının gönderildiğine
dikkat edilmelidir. Bu sebeple fonksiyon içerisinde değiştirilen
b değeri aslında maindeki a değeridir. fonksiyon çağrısı
sonrasında a değeri 4 olurken b'nin değeri değişmez. Fonksiyonun
geri dönüş değeri ise 4 + 4'ten 8 olarak elde edilir. Son
durumda ekran çıktısı 428 şeklinde olacaktır.
-------------------------------------------------------*/
#include <iostream>

int f(int &a, int &b) {
  a = 3;
  b = 4;
  return a + b;
}

int main() {
  int a = 1;
  int b = 2;
  int c = f(a, a);
  std::cout << a << b << c;
}
/*-------------------------------------------------------
Eğer char türünden '3' ten '2' çıkarılırsa son durumda
elde edilen değer int türünden 1 olacaktır.
-------------------------------------------------------*/
#include <iostream>

int main() {
    int i = '3' - '2';
    std::cout << i;
}
/*-------------------------------------------------------
Aşağıdaki örnekte f fonksiyonunun 3 tane overloadı bulunmaktadır.
1.0 sabitinin türü double olduğundan double parametreli func
exact match olmaktadır. Sonuç olarak ekran çıktısı d olacaktır.
-------------------------------------------------------*/
#include <iostream>

void f(int) { std::cout << "i"; }
void f(double) { std::cout << "d"; }
void f(float) { std::cout << "f"; }

int main() {
  f(1.0);
}
/*-------------------------------------------------------
Aşağıdaki örnekte bir belirsiz davrnış söz konusudur.
-------------------------------------------------------*/
#include <limits>
#include <iostream>

int main() {
    std::cout << std::numeric_limits<unsigned char>::digits;
}
/*-------------------------------------------------------
Aşağıdaki örnekte ekran çıktısı main olacaktır.
sizeof operatörü kullanılırken bir ctor çağrısı gerçekleştirilmez.
-------------------------------------------------------*/
#include <iostream>

struct A {
    A() { std::cout << "A"; }
    ~A() { std::cout << "a"; }
};

int main() {
    std::cout << "main";
    return sizeof new A;
}
/*-------------------------------------------------------
Aşağıdaki örnekte argv[argc] ifadesi 0 olarak elde edilir.
Bu sebeple ekran çıktısı 1 olacaktır.
-------------------------------------------------------*/
#include <iostream>

int main(int argc, char* argv[]) {
    std::cout << (argv[argc] == nullptr);
}
/*-------------------------------------------------------
Aşağıdaki örnekte c.x = 3; deyimi bir sentaks hatasına neden
olur. Burada bilinmesi gereken en önemli bilgi sınıflarda
bir default kalıtım söz konusu olduğunda sınıflar için
default kalıtım tipi private kalıtımıdır. structlarda(yapılar)
ise default kalıtımın public kalıtımı olmasıdır.
-------------------------------------------------------*/
#include <iostream>

class A {};

class B {
public:
    int x = 0;
};

class C : public A, B {};

struct D : private A, B {};


int main()
{
    C c;
    c.x = 3;

    D d;
    d.x = 3;

    std::cout << c.x << d.x;
}
/*-------------------------------------------------------
Anahtar Notlar:C++ 11 ile dile eklenen override anahtar
sözcüğü eskiden yazılan kodlara istinaden override anahtar
sözcüğü değişken isimler dahil olmak üzere pek çok yerde isim
olarak kullanılabilir. Bu yüzden aşağıdaki kodda herhangi
şekilde bir sentaks hatası yoktur.
-------------------------------------------------------*/
#include <iostream>

struct override {};

struct Base {
    virtual override f() = 0;
};

struct Derived : Base {
    virtual auto f() -> override override{
        std::cout << "1";
        return override();
    }
};

int main() {
    Derived().f();
}
/*-------------------------------------------------------
Aşağıdaki örnekte ekran çıktısı 1133 şeklinde olacaktır.
Bunun nedeni uniform init yapıldığında init_list
parametrelinin seçilebilirlikte daha üsütün olmasından
kaynaklanmaktadır. Bu durumda ilk iki nesne için
default ctor çağrılırken, diğerleri için ise init_list parametreli
çağrılacaktır.
-------------------------------------------------------*/
#include <initializer_list>
#include <iostream>

struct A {
  A() { std::cout << "1"; }

  A(int) { std::cout << "2"; }

  A(std::initializer_list<int>) { std::cout << "3"; }
};

int main(int argc, char *argv[]) {
  A a1;
  A a2{};
  A a3{ 1 };
  A a4{ 1, 2 };
}
/*-------------------------------------------------------
Aşağıdaki örnekte ekran çıktısı 1 olacaktır.
-------------------------------------------------------*/
#include <iostream>

namespace x {
  class C {};
  void f(const C& i) {
    std::cout << "1";
  }
}

namespace y {
  void f(const x::C& i) {
    std::cout << "2";
  }
}

int main() {
  f(x::C());
}
/*-------------------------------------------------------
Özel üye fonksiyonlarla ilgili güzel bir örnek
-------------------------------------------------------*/
#include <iostream>

struct X {
  X() { std::cout << "a"; }
  X(const X &x) { std::cout << "b"; }
  const X &operator=(const X &x) {
    std::cout << "c";
    return *this;
  }
};

int main() {
  X x;
  X y(x);
  X z = y;
  z = x;
}
/*-------------------------------------------------------
Global değişkenler default olarak 0 değerini alır.
-------------------------------------------------------*/
#include <iostream>

int a;

int main () {
    std::cout << a;
}
/*-------------------------------------------------------
Aşağıdaki örnekte boşluk geçerli bir ifade olduğundan dolayı
değilinin değili 1'e eşit olacaktır.
-------------------------------------------------------*/
#include <iostream>

int main() {
    std::cout << +!!"";
}
/*-------------------------------------------------------
Aşağıdaki örnekte n1 nesnesi 3 olurken n2 nesnesi 2 olarak
elde edilecektir. Bunun nedeni n1 için yapılan sum çağrısında
tür çıkarımı double olarak yapılıp toplanan sayıların noktadan
sonraki kısımları atılmaz iken n2 için yapılan çağrıda
tür çıkarımı int olarak yapılır bu durumda, toplanacak
sayıların noktadan sonraki kısımları
-------------------------------------------------------*/
#include <iostream>

template<typename T>
T sum(T arg) {
    return arg;
}

template<typename T, typename ...Args>
T sum(T arg, Args... args) {
    return arg + sum<T>(args...);
}

int main() {
    auto n1 = sum(0.5, 1, 0.5, 1);
    auto n2 = sum(1, 0.5, 1, 0.5);
    std::cout << n1 << n2;
}
/*-------------------------------------------------------
Aşağıdaki örnekte hem aggregation hem de inheritance yapılmıştır.
Burada ilk önce taban sınıf hayata gelecektir. Sonrasında
o sınıfın elemanları hayata gelecektir. Son olarak da Söz konusu
sınıfın ctoru çağrılacaktır. Temel bir kural olarak benimsenebilecek
bir kural ise ilk ctoru çağrılan sınıfın ctorunun son çağrılacağıdır.
Bu durumda ilk türemiş sınıfın dtoru çağrılır sonrasında üye
elemanın sınıfı, son olarak da taban sınıfın ctoru çağrılacaktır.
Ekran çıktısı:
Base ctor -> Member ctor -> Derived ctor -> Derived dtor
-> Member ctor -> Base dtor
-------------------------------------------------------*/
#include <iostream>

class Base {
public:
    Base() {
        std::cout << "Base ctor\n";
    }
    ~Base() {
        std::cout << "Base dtor\n";
    }
};

class Member {
public:
    Member() {
        std::cout << "Member ctor\n";
    }
    ~Member() {
        std::cout << "Member dtor\n";
    }
};

class Derived : public Base {
public:
    Derived() {
        std::cout << "Derived ctor\n";
    }
    ~Derived() {
        std::cout << "Derived dtor\n";
    }
private:
    Member mx;
};

int main()
{
    Derived d;
    return 0;
}
/*-------------------------------------------------------
Aşağıdaki örnekte f overload edilmemiştir. Bu sebeple
double parametreli f çağrısı gerçekleştirilecektir.
-------------------------------------------------------*/
#include <iostream>

struct Base {
  void f(int) { std::cout << "i"; }
};

struct Derived : Base {
  void f(double) { std::cout << "d"; }
};

int main() {
  Derived d;
  int i = 0;
  d.f(i);
}
/*-------------------------------------------------------
Aşağıdaki örnekte virtual dispatch mekanizması devreye girecektir.
bu sebeple türemiş sınıfa ait olan func çağrısı yapılacaktır.
Burada ek bir bilgi verilmesi gerekirse taban sınıfın
dtrounun virtual yapılamsı güvenlik olarak son derece önemlidir.

-------------------------------------------------------*/
#include <iostream>

class Base {
public:
    Base() {
        std::cout << "Base ctor\n";
    }

    virtual void func() {
        std::cout << "Base func()\n";
    }

    ~Base() {
        std::cout << "Base dtor\n";
    }
};

class Derived : public Base {
public:
    Derived() {
        std::cout << "Derived ctor\n";
    }

    void func() final {
        std::cout << "Derived func()\n";
    }

    ~Derived() {
        std::cout << "Derived dtor\n";
    }
};

int main()
{
    Base* bptr = new Derived();
    bptr->func();
    delete bptr;
    return 0;
}
/*-------------------------------------------------------
Aşağıdaki örnekte ekran çıktısı 1 olarak elde edilecektir.
-------------------------------------------------------*/
#include <iostream>

void f(char*&&) { std::cout << 1; }
void f(char*&) { std::cout << 2; }

int main() {
   char c = 'a';
   f(&c);
}
/*-------------------------------------------------------
Aşağıdaki örnekte ekran çıktısı AAABAA şeklinde olacaktır.
-------------------------------------------------------*/
#include <iostream>
#include <memory>
#include <vector>

class C {
public:
  void foo()       { std::cout << "A"; }
  void foo() const { std::cout << "B"; }
};

struct S {
  std::vector<C> v;
  std::unique_ptr<C> u;
  C *const p;

  S()
    : v(1)
    , u(new C())
    , p(u.get())
  {}
};

int main() {
  S s;
  const S &r = s;

  s.v[0].foo();
  s.u->foo();
  s.p->foo();

  r.v[0].foo();
  r.u->foo();
  r.p->foo();
}
/*-------------------------------------------------------
Anahtar Notlar: Bit field olarak bildirilmiş struct elemanları
birbiriyle karşılaştırılması doğrudan sentaks hatasına neden olur.
-------------------------------------------------------*/
#include <iostream>

struct X {
    int var1 : 3;
    int var2;
};

int main() {
    X x;
    std::cout << (&x.var1 < &x.var2);
}
/*-------------------------------------------------------
Aşağıdaki örnekte bir sentaks hatası söz konusudur.
a+++++b ifadesi a++ + ++b şekiinde ele alınmaz.
-------------------------------------------------------*/
#include <iostream>

int main() {
 int a = 5,b = 2;
 std::cout << a+++++b;
}
/*-------------------------------------------------------
Eğer bir anahtar belirtimemiş ise bu durumda anahtar sıfır olarak alınır.
-------------------------------------------------------*/
#include <iostream>
#include <map>
using namespace std;

int main() {
    map<int, int> m;
    cout << m[42];
}
/*-------------------------------------------------------
Diamond sorunu multi level inheritance durumunda aynı taban
sınıftan iki tane olamsı durumunu ifade etmektedir. Bu sorunun
çözümü virtual inheritance kullanılmaktır. Bu durumda
söz konusu sınıftan iki adet taban sınıf bulunmayacaktır.
Bundan yola çıkarak D sınıfı türünden bir nesne için
sadece 1 defa A sınıfının ctoru çağrılacaktır. Elbette
bir sınıfın ctoru çağrılmadan o sınıfın taban sınıfının(Base class)
ctorunun çağrılacağı da unutulmamalıdır. Bu durumda d1
nesnesi için ekran çıktısı ABCD şeklinde olacaktır.
Diğer taraftan d2 içinse durum biraz daha farklıdır. Burada
bir kopyalama söz konusu olacağından Burada ABCd şeklinde
bir ekran çıktısı alınacaktır.
-------------------------------------------------------*/
#include <iostream>
using namespace std;

class A
{
public:
    A() { cout << "A"; }
    A(const A &) { cout << "a"; }
};

class B: public virtual A
{
public:
    B() { cout << "B"; }
    B(const B &) { cout<< "b"; }
};

class C: public virtual A
{
public:
    C() { cout<< "C"; }
    C(const C &) { cout << "c"; }
};

class D:B,C
{
public:
    D() { cout<< "D"; }
    D(const D &) { cout << "d"; }
};

int main()
{
    D d1;
    D d2(d1);
}
/*-------------------------------------------------------
Aşağıdaki örnekte sadece diziler ve dizi dizileri için
1 değeri üretilecektir.
-------------------------------------------------------*/
#include <iostream>
#include <type_traits>
using namespace std;

int main() {
    cout << is_const_v<const int *>
         << is_const_v<const int [1]>
         << is_const_v<const int **>
         << is_const_v<const int (*)[1]>
         << is_const_v<const int *[1]>
         << is_const_v<const int [1][1]>;
}
/*-------------------------------------------------------
aşağıdaki örnekte ekran çıktısı 11422 olacaktır.
-------------------------------------------------------*/
#include <iostream>

struct X {
    X() { std::cout << "1"; }
    X(const X &) { std::cout << "3"; }
    ~X() { std::cout << "2"; }

    void f() { std::cout << "4"; }

} object;

int main() {
    X(object);
    object.f();
}
/*-------------------------------------------------------
Aşağıdaki örnekte bir copy elision söz konusu olacağından
copy constructor çağrılmaz. Bu sebeple ekran çıktısı 13
şeklinde olacaktır.
-------------------------------------------------------*/
#include <iostream>

struct E
{
  E() { std::cout << "1"; }
  E(const E&) { std::cout << "2"; }
  ~E() { std::cout << "3"; }
};

E f()
{
  return E();
}

int main()
{
  f();
}
/*-------------------------------------------------------
 Aşağıdaki örnekte ekran çıktısı 00 olarak elde edilecektir.
-------------------------------------------------------*/
#include <type_traits>
#include <iostream>

using namespace std;

struct X {
    int f() const&&{
        return 0;
    }
};

int main() {
    auto ptr = &X::f;
    cout << is_same_v<decltype(ptr), int()>
         << is_same_v<decltype(ptr), int(X::*)()>;
}
/*-------------------------------------------------------
 top level const(nesnenin kendisinin const olması) türü
 değişmesine neden olmaz bu sebeple const int ile int
 aynı tür olarak alınacaktır. Ancak int* ve const int*
 türleri birbirinden farklıdır. Burada low level constluk söz
 konusu olacağından bu türler birbirinden farklı türlerdir.
 Açıklamaya göre son durumda ekran çıktısı 10 şeklinde olacaktır.
-------------------------------------------------------*/
#include <iostream>
#include <type_traits>

int main() {
    std::cout << std::is_same_v<
        void(int),
        void(const int)>;

    std::cout << std::is_same_v<
        void(int*),
        void(const int*)>;
}
/*-------------------------------------------------------
  Aşağıdaki örnekte bitsel sola kaydırma operatörün overload
  edilmiştir. Burada ek olarak virtual dispatch mekanizması da
  devreye girecektir. Nesnenin türü b olduğu için runtime
  polimofzim devreye girecek B yapısına ait olan put fonksiyonu
  çağrılacaktır. Ekran çıktısı B şeklinde olacaktır.
-------------------------------------------------------*/
#include <iostream>

struct A {
  virtual std::ostream &put(std::ostream &o) const {
    return o << 'A';
  }
};

struct B : A {
  virtual std::ostream &put(std::ostream &o) const {
    return o << 'B';
  }
};

std::ostream &operator<<(std::ostream &o, const A &a) {
  return a.put(o);
}

int main() {
  B b;
  std::cout << b;
}
/*-------------------------------------------------------
  Aşağıdaki örnekte ekran çıktısı D0C0 şwklinde olacaktır.
-------------------------------------------------------*/
#include <iostream>
#include <functional>

class Q{
    int v=0;
    public:
        Q(Q&&){
            std::cout << "M";
        }
        Q(const Q&){
            std::cout << "C";
        }
        Q(){
            std::cout << "D";
        }
        void change(){
            ++v;
        }
        void func(){
            std::cout << v;
        }
};
void takeQfunc(std::function<void(Q)> qfunc){
    Q q;
    q.func();
    qfunc(q);
    q.func();
}
int main(){
    takeQfunc([](Q&& q){
        q.change();
    });
    return 0;
}
/*-------------------------------------------------------
    decltype((a)) ifadesi için tür çıkarımı int& olarak yapılacaktır.
    Bu sebeple ekran çıktısı 11 olarak elde edilecektir.
-------------------------------------------------------*/
#include <iostream>

int main() {
  int a = 0;
  decltype((a)) b = a;
  b++;
  std::cout << a << b;
}
/*-------------------------------------------------------
  Aşağıdaki örnekte bir ambiguity söz konusudur.
-------------------------------------------------------*/
#include <iostream>

void f(int) { std::cout << 1; }
void f(unsigned) { std::cout << 2; }

int main() {
  f(-2.5);
}
/*-------------------------------------------------------
  Aşağıdaki örnekte ekran çıktısı 1R2L şeklinde olacaktır.
-------------------------------------------------------*/
#include <iostream>
#include <type_traits>

void g(int&) { std::cout << 'L'; }
void g(int&&) { std::cout << 'R'; }

template<typename T>
void f(T&& t) {
    if (std::is_same_v<T, int>) { std::cout << 1; }
    if (std::is_same_v<T, int&>) { std::cout << 2; }
    if (std::is_same_v<T, int&&>) { std::cout << 3; }
    g(std::forward<T>(t));
}

int main() {
    f(42);
    int i = 0;
    f(i);
}
/*-------------------------------------------------------
  Aşağıdaki örnekte önce 2 defa default ctor sonrasında

-------------------------------------------------------*/
#include <iostream>

struct A {
  A() { std::cout << "A"; }
  A(const A &a) { std::cout << "B"; }
  virtual void f() { std::cout << "C"; }
};

int main() {
  A a[2];
  for (auto x : a) {
    x.f();
  }
}
/*-------------------------------------------------------
 Aşağıdaki örnekte ekran çıktısı 21 şeklinde olacaktır.
-------------------------------------------------------*/
#include <iostream>

struct A {
  A(int i) : m_i(i) {}
  operator bool() const { return m_i > 0; }
  int m_i;
};

int main() {
  A a1(1), a2(2);
  std::cout << a1 + a2 << (a1 == a2);
}
/*-------------------------------------------------------
 Burada ekran çıktısı 01 şeklinde elde edilecektir.
-------------------------------------------------------*/
#include <iostream>

int main() {
  int a = 0;
  decltype(a) b = a;
  b++;
  std::cout << a << b;
}

/*-------------------------------------------------------
Aşağıdaki örnekte ub söz konusudur.
-------------------------------------------------------*/
template <typename ...Ts>
struct X {
  X(Ts ...args) : Var(0, args...) {}
  int Var;
};

int main() {
  X<> x;
}
/*-------------------------------------------------------
  Aşağıdaki örnekte ekran çıktısı 11 şeklinde olacaktır.
-------------------------------------------------------*/
#include<iostream>

int foo()
{
  return 10;
}

struct foobar
{
  static int x;
  static int foo()
  {
    return 11;
  }
};

int foobar::x = foo();

int main()
{
    std::cout << foobar::x;
}
/*-------------------------------------------------------
  Aşağıdaki örnekte extern "C" bildirimi dolaysıyla
  A::x ve B::x aynı anlamı taşımaktadır. Bundan dolayı A::x'te
  yapılan herhangi bir değişiklik doğrudan B::x'i de etkileyecektir.
-------------------------------------------------------*/
#include<iostream>

namespace A{
  extern "C" int x;
};

namespace B{
  extern "C" int x;
};

int A::x = 0;

int main(){
  std::cout << B::x;
  A::x = 1;
  std::cout << B::x;
}
/*-------------------------------------------------------
    Aşağıdaki örnekte b referansı bir geçici nesneye bağlanmaktadır.
    Bu yüzden a nesnesinin arttırılması b nesnesini hiçbir şekilde
    etkilemez. Sonuç olarak ekran çıktısı 00 olarak elde edilecektir.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

int main() {
    int a = '0';
    char const &b = a;
    cout << b;
    a++;
    cout << b;
}
/*-------------------------------------------------------
  Aşağıdaki örnekte operator auto ifadesi otomatik tür dönüşümüne
  sebep olur. Bu yüzden a'nın değerinin 1 olacağını söyleyebiliriz
-------------------------------------------------------*/
#include <iostream>

struct Foo {
  operator auto() {
    std::cout << "A";
    return 1;
  }
};

int main() {
  int a = Foo();
  std::cout << a;
}
/*-------------------------------------------------------
  C++ ta çift tırnak içerisindeki ifadeler, const char[]
  türündendir. Bu sebeple "" ifadesi de const char[] türündendir.
  string literallerinin sonunda null karakter(\0) olduğunu
  C dilinden biliyorduk. Demekki bu yazı aslında boş yazı değildir.
  Sadece null karakterden oluşan bir yazıdır. Bu durumda
  sizeof tarafından elde edilecek değer sizeof(char) ifadesinin
  sonucuna eşit olacaktır. Bu durumda elde edilen sonuç 1 byte olacaktır.
-------------------------------------------------------*/
#include <iostream>

int main() {
    std::cout << sizeof("");
}
/*-------------------------------------------------------
  Aşağıdaki örnekte bir tanımsız davranış söz konusudur.
-------------------------------------------------------*/
#include <iostream>

volatile int a;

int main() {
  std::cout << (a + a);
}
/*-------------------------------------------------------
  Aşağıdaki örnekte ekran çıktısı 210 şeklinde olacaktır.
-------------------------------------------------------*/
#include <iostream>

class show_id
{
public:
    ~show_id() { std::cout << id; }
    int id;
};

int main()
{
    delete[] new show_id[3]{ {0}, {1}, {2} };
}
/*-------------------------------------------------------
  Aşağıdaki örnekte bar için tür çıkarımı referanslık düşeceğinden
  dolayı int olarak yapılacaktır. 
-------------------------------------------------------*/
#include <iostream>

class A {
  int foo = 0;

public:
  int& getFoo() { return foo; }
  void printFoo() { std::cout << foo; }
};

int main() {
  A a;

  auto bar = a.getFoo();
  ++bar;

  a.printFoo();
}
/*-------------------------------------------------------
  Aşağıdaki örnekte 2.5 double türünden bir sabit olduğu 
  için double parametreli f çağrısı gerçekleştirilecektir.
  Diğer taraftan 2.5f sabiti ise float türünden olduğundan 
  dolayı float parametreli f çağrısı gerçekleştirilecektir.
-------------------------------------------------------*/
#include <iostream>

void f(float) { std::cout << 1; }
void f(double) { std::cout << 2; }

int main() {
  f(2.5);
  f(2.5f);
}
/*-------------------------------------------------------
 Aşağıdaki örnekte ekran çıktısı aaaaa şeklinde olacaktır.
 Bunun nedeni 5 elemanlı bir vector containerı oluşturulacağından
 dolayı Foo sınıfının ctoru 5 defa çağrılacaktır. Sonuç olarak 
 ekran çıktısı aaaaa olacaktır.
-------------------------------------------------------*/
#include <iostream>
#include <vector>

struct Foo
{
    Foo() { std::cout<<"a"; }
    Foo(const Foo&) { std::cout<<"b"; }
};

int main()
{
    std::vector<Foo> bar(5);
}
/*-------------------------------------------------------
  Aşağıdaki örnekte bir belirsiz davranış söz konusudur.
  Bunun nedeni f1 ve f2 fonksiyonları çağrılırken hangisinin
  önce çağrılacağının bilinememesinden kaynaklanmaktadır.
-------------------------------------------------------*/
#include <vector>
#include <iostream>

std::vector<int> v;

int f1() {
  v.push_back(1);
  return 0;
}

int f2() {
  v.push_back(2);
  return 0;
}

void g(int, int) {}

void h() {
 g(f1(), f2());
}

int main() {
  h();
  h();
  std::cout << (v[0] == v[2]);
}
/*-------------------------------------------------------
  Aşağıdaki örnekte ekran çıktısı 3 olarak elde edilecektir.
-------------------------------------------------------*/
#include <iostream>

auto sum(int i)
{
  if (i == 1)
    return i;
  else
    return sum(i-1)+i;
}

int main()
{
    std::cout << sum(2);
}
/*-------------------------------------------------------
  Aşağıdaki örnekte bir syntax hatası söz konusudur. friend olarak
  bildirilen fonksiyonlar friend bildirimin yapıldığı sınıf
  içerisinde yazılmak zorunda aksi durumda error oluşur. 
  Burada A sınıfının tanımı eğer B sınıfının üzerinde yapılsaydı 
  hata ortadan kalkardı.
-------------------------------------------------------*/
#include <iostream>

class A;

class B {
public:
  B() { std::cout << "B"; }
  friend B A::createB();
};

class A {
public:
  A() { std::cout << "A"; }

  B createB() { return B(); }
};

int main() {
  A a;
  B b = a.createB();
}

/*-------------------------------------------------------
  Aşağıdaki örnekte ekran çıktısı 1 olarak elde edilecektir.
-------------------------------------------------------*/
#include <iostream>

using Func = int();

struct S {
    Func f;
};

int S::f() { return 1; }

int main() {
    S s;
    std::cout << s.f();
}
/*-------------------------------------------------------
 Virgül operatörünün ürettiği değer bu operatörün sağ operandı
 olacaktır.
-------------------------------------------------------*/
#include <iostream>

int main() {
  int a = 10;
  int b = 20;
  int x;
  x = (a, b);
  std::cout << x;
}
/*-------------------------------------------------------
  Aşağıdaki örnekte ekran çıktısı 1 olacaktır.
-------------------------------------------------------*/
#include <iostream>

void f()
{
    std::cout << "1";
}

template<typename T>
struct B
{
    void f()
    {
        std::cout << "2";
    }
};

template<typename T>
struct D : B<T>
{
    void g()
    {
        f();
    }
};

int main()
{
    D<int> d;
    d.g();
}
/*-------------------------------------------------------
  Aşağıdaki örnekte ekran çıktısı fhh şeklinde olacaktır.
-------------------------------------------------------*/
#include <iostream>

bool f() { std::cout << 'f'; return false; }
char g() { std::cout << 'g'; return 'g'; }
char h() { std::cout << 'h'; return 'h'; }

int main() {
    char result = f() ? g() : h();
    std::cout << result;
}
/*-------------------------------------------------------
  future nesnesi promise nesnesinden yalnız bir tanesine bağlanabilir.
  Bu yüzden aşağıdaki örnekte bir sentaks hatası söz konusudur.
-------------------------------------------------------*/
#include <future>
#include <iostream>

int main()
{
    try {
        std::promise<int> p;
        std::future<int> f1 = p.get_future();
        std::future<int> f2 = p.get_future();
        p.set_value(1);
        std::cout << f1.get() << f2.get();
    } catch(const std::exception& e)
    {
        std::cout << 2;
    }
}
/*-------------------------------------------------------
  Aşağıdaki örnekte bir sentaks hatası söz konusudur.
-------------------------------------------------------*/

#include <iostream>

namespace A {
  extern "C" { int x; }
};

namespace B {
  extern "C" { int x; }
};

int A::x = 0;

int main() {
  std::cout << B::x;
  A::x = 1;
  std::cout << B::x;
}
/*-------------------------------------------------------
  Aşağıdaki örnekte herhangi şekilde bir sentaks hatası yoktur.
  Ekrana 5 basılır.
-------------------------------------------------------*/
#include <iostream>

int main() {
    int n = 3;
    int i = 0;

    switch (n % 2) {
    case 0:
    do {
    ++i;
    case 1: ++i;
    } while (--n > 0);
    }

    std::cout << i;
}
/*-------------------------------------------------------
  Aşağıdaki örnekte bir sentaks hatası yoktur. Bunun nedeni
  static_assert fonksiyonunun bir class template içerisinde
  bulunmaısından kaynaklanmaktadır. Burada eğer A sınıfı türünden
  bir nesne oluşturulsaydı bu durumda sentaks hatasından bahsedilebilirdi.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

template <typename T>
struct A {
    static_assert(false);
};

int main() {
    cout << 1;
}

/*-------------------------------------------------------
  static olarak bildirilen değişkenler default olarak 0 değerini
  alacaktır. Bu sebeple aşağıdaki örnekte ekran çıktısı 0 olacaktır.
-------------------------------------------------------*/
#include <iostream>

int main() {
  static int a;
  std::cout << a;
}
/*-------------------------------------------------------
  Aşağıdaki örnekte const bir nesnenin değiştirilme girişiminden
  kaynaklı bir tanımsız söz konusudur.
-------------------------------------------------------*/
#include <iostream>

int main() {
    const int i = 0;
    int& r = const_cast<int&>(i);
    r = 1;
    std::cout << r;
}
/*-------------------------------------------------------
  Aşağıdaki örnekte int ve const int için farklı fonksiyonlar
  yazılacağından burada static olan nesne tekrardan hayata gelecektir.
  Bu sebeple ekran çıktısı 010 şeklinde olacaktır.
-------------------------------------------------------*/
#include <iostream>

template <typename T> void f() {
  static int stat = 0;
  std::cout << stat++;
}

int main() {
  f<int>();
  f<int>();
  f<const int>();
}
/*-------------------------------------------------------
  variant herhangi bir türü de tutabilir, hiçbir değer de
  almayabilir. Bu durumda indeks değeri 0 olarak elde edilir.
-------------------------------------------------------*/
#include <variant>
#include <iostream>

using namespace std;

int main() {
   variant<int, double, char> v;
   cout << v.index();
}
/*-------------------------------------------------------
  Aşağıdaki örnekte default ctor ve copy ctor çağrılacağından,
  ekran çıktısı 12 şeklinde olacaktır.
-------------------------------------------------------*/
#include <iostream>

struct C {
  C() { std::cout << "1"; }
  C(const C& other) { std::cout << "2"; }
  C& operator=(const C& other) { std::cout << "3"; return *this;}
};

int main() {
  C c1;
  C c2 = c1;
}
/*-------------------------------------------------------
  Aşağıdaki örnekte ekran çıktısı B olarak elde edilir. Burada
  tahmin edilebileceği gibi ABC yazısının 0 indisli elemanı
  elde edilmektedir.
-------------------------------------------------------*/
#include <iostream>

int main() {
  std::cout << 1["ABC"];
}
/*-------------------------------------------------------
  Aşağıdaki örnekte ekran çıktısı ab şeklinde olacaktır.
-------------------------------------------------------*/
#include <iostream>
#include <sstream>

int main() {
  std::stringstream ss("a");
  std::cout << ss.str();
  ss << "b";
  std::cout << ss.str();
}
/*-------------------------------------------------------
  Aşağıdaki örnekte bir belirsiz davranış söz konusudur.
  Çünkü int ile long türleri bazı derleyicilerde aynı uzunlukta
  iken bazı derleyicilerde long türü uzundur.
-------------------------------------------------------*/
#include <iostream>

int main()
{
    std::cout << (sizeof(long) > sizeof(int));
}
/*-------------------------------------------------------
  Aşağıdaki örnekte default ctor default init edildiğinden
  c.i nesnesi herhangi bir değer almaz bu sebeple const C c;
  ifadesi bir sentaks hatasına neden olur. Bildiğimiz gibi
  C++ dilinde const nesneler default init. edilemezler.
-------------------------------------------------------*/
#include <iostream>

struct C {
    C() = default;
    int i;
};

int main() {
    const C c;
    std::cout << c.i;
}

/*-------------------------------------------------------
  Aşağıdaki örnekte ekran çıktısı 11 şeklinde olacaktır. Varsayılan
  argümanda bulunan fonksiyonlar şüphesiz ki çağrılır.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

int foo() {
  cout << 1;
  return 1;
}

void bar(int i = foo()) {}

int main() {
  bar();
  bar();
}
/*-------------------------------------------------------
  Aşağıdaki örnekte ekran çıktısı 11 şeklinde olacaktır. Varsayılan
  argümanda bulunan fonksiyonlar şüphesiz ki çağrılır.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

int foo() {
  cout << 1;
  return 1;
}

void bar(int i = foo()) {}

int main() {
  bar();
  bar();
}
/*-------------------------------------------------------
  Aşağıdaki örnekte ekran çıktısı 1426 şeklinde elde
  edilecektir. Burada B'nin default ctorundan önce Aggregation söz konusu
  olduğu için önce A'nın default ctoru çağrılacaktır. O sebeple
  öncelikle 14 ekrana basılacaktır. Sonrasında ise B sınıfının
  move ctoru çağrılacak burada ctor init. list ile a nesnesi
  init. edilecektir. Bundan dolayı buradan da 26 ekrana 
  basılacaktır.
-------------------------------------------------------*/
#include <iostream>
#include <utility>

struct A
{
	A() { std::cout << "1"; }
	A(const A&) { std::cout << "2"; }
	A(A&&) { std::cout << "3"; }
};

struct B
{
	A a;
	B() { std::cout << "4"; }
	B(const B& b) : a(b.a) { std::cout << "5"; }
	B(B&& b) : a(b.a) { std::cout << "6"; }
};

int main()
{
	B b1;
	B b2 = std::move(b1);
}
/*-------------------------------------------------------
    Aşağıdaki örnekte continue deyimi bir işe yaramaz
    bunun nedeni do-while döngü deyiminde henüz kontrol
    yapılmamasından kaynaklanmaktadır.
-------------------------------------------------------*/
#include <iostream>

int main() {
    int i=1;
    do {
        std::cout << i;
        i++;
        if(i < 3) continue;
    } while(false);
    return 0;
}
/*-------------------------------------------------------
  templatelerde tam özelleştirme overload sete dahil edilmez.
  Yani burada eğer f(T) overloadı seçilmiş olsaydı bu durumda
  eğer tür çıkarımı int türünden yapılmaya uygunda bu durumda
  ekrana 2 bastırılacaktı. f<>(0); ifadesi ise doğrudan
  full specialization kullanımını temsil etmektedir. Bu sebeple
  burada ekran çıktısı 132 şeklinde olacaktır.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

template<typename T>
void f(T) {
    cout << 1;
}

template<>
void f(int) {
    cout << 2;
}

void f(int) {
    cout << 3;
}

int main() {
    f(0.0);
    f(0);
    f<>(0);
}
/*-------------------------------------------------------
  Aşağıdaki örnekte bir syntax hatası söz konusudur.
-------------------------------------------------------*/
#include <iostream>

struct S {
    template <typename Callable>
    void operator[](Callable f) {
        f();
    }
};

int main() {
    auto caller = S{};
    caller[ []{ std::cout << "C";} ];
}
/*-------------------------------------------------------
 Aşağıdaki örnekte her ne kadar virtual dispatch ile B sınıfının
 f fonksiyonu çağrılacak gibi görünse de bu durum
 ancak g fonksiyonunun parametre değişkeninin A türünden
 bir pointer veya referans olması durumu için geçerlidir.
 Burada nesne doğrudan A sınıfı türünden olduğu için A sınıfının
 f fonksiyonu çağrılacaktır.
-------------------------------------------------------*/
#include <iostream>

class A {
public:
  virtual void f() { std::cout << "A"; }
};

class B : public A {
public:
  void f() { std::cout << "B"; }
};

void g(A a) { a.f(); }

int main() {
  B b;
  g(b);
}
/*-------------------------------------------------------
  Aşağıdaki örnekte ekran çıktısı 1255 şeklinde olacaktır.
-------------------------------------------------------*/
#include <iostream>
#include <utility>

struct X {
    X() { std::cout << "1"; }
    X(X &) { std::cout << "2"; }
    X(const X &) { std::cout << "3"; }
    X(X &&) { std::cout << "4"; }
    ~X() { std::cout << "5"; }
};

struct Y {
    mutable X x;
    Y() = default;
    Y(const Y &) = default;
};

int main() {
    Y y1;
    Y y2 = std::move(y1);
}
/*-------------------------------------------------------
  Standartlara göre goto ile gidilecek olan yerde programın
  o anki akışında hayatta olup goto'nun götüreceği akışta henüz
  o değişken hayatta değilse bu durumda o değişken bellekten
  atılır. Bu durumun bu nesnesin sadece otomatik ömürlü olduğu
  durumlar için geçerli olduğu unutulmamalıdır.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

class A {
public:
  A() { cout << "a"; }
  ~A() { cout << "A"; }
};

int i = 1;

int main() {
label:
  A a;
  if (i--)
    goto label;
}
/*-------------------------------------------------------
  Aşağıdaki örnekte a'nın tür çıkarımı const char* olarak
  yapılacaktır. Diğer "Hello world!" yazısı ise const char[14]
  türüdür. decltype ile tür çıkarımı bu durumda const char(&)[14]
  olarak alınmaktadır.
-------------------------------------------------------*/
#include <iostream>
#include <type_traits>

int main() {
    auto a = "Hello, World!";
    std::cout << std::is_same_v<decltype("Hello, World!"), decltype(a)>;

    return 0;
}
/*-------------------------------------------------------
    Aşağıdaki örnekte ekran çıktısı b olacaktır.
-------------------------------------------------------*/
#include <iostream>

class A {
public:
  virtual void f() { std::cout << "A"; }
};

class B : public A {
private:
  void f() { std::cout << "B"; }
};

void g(A &a) { a.f(); }

int main() {
  B b;
  g(b);
}
/*-------------------------------------------------------
 Aşağıdaki örnekte ekran çıktısı B1 şeklinde olacaktır.
-------------------------------------------------------*/
#include <iostream>

struct A {
    virtual void foo (int a = 1) {
        std::cout << "A" << a;
    }
};

struct B : A {
    virtual void foo (int a = 2) {
        std::cout << "B" << a;
    }
};

int main () {
    A *b = new B;
    b->foo();
}
/*-------------------------------------------------------
 Aşağıdaki örnekte ekran çıktısı 34 şeklinde olacaktır.
-------------------------------------------------------*/
#include <iostream>

int i;

void f(int x) {
    std::cout << x << i;
}

int main() {
    i = 3;
    f(i++);
}
/*-------------------------------------------------------
 Aşağıdaki örnekte ekran çıktısı pp0 olarak elde edilecektir.
-------------------------------------------------------*/
#include <iostream>
#include <typeinfo>

void takes_pointer(int* pointer) {
  if (typeid(pointer) == typeid(int[])) std::cout << 'a';
  if (typeid(pointer) == typeid(int*)) std::cout << 'p';
}

void takes_array(int array[]) {
  if (typeid(array) == typeid(int[])) std::cout << 'a';
  if (typeid(array) == typeid(int*)) std::cout << 'p';
}

int main() {
  int* pointer = nullptr;
  int array[1];

  takes_pointer(array);
  takes_array(pointer);

  std::cout << (typeid(int*) == typeid(int[]));
}
/*-------------------------------------------------------
 Aşağıdaki örnekte herhangi sentaks hatası söz konusu değildir
 öte yandan ekran çıktısı G olarak elde edilecektir.
-------------------------------------------------------*/
#include <iostream>

struct GeneralException {
  virtual void print() { std::cout << "G"; }
};

struct SpecialException : public GeneralException {
  void print() override { std::cout << "S"; }
};

void f() { throw SpecialException(); }

int main() {
  try {
    f();
  }
  catch (GeneralException e) {
    e.print();
  }
}
/*-------------------------------------------------------
  Aşağıdaki örnekte herhangi şekilde bir sentaks hatası yoktur.
-------------------------------------------------------*/
#include <iostream>

struct S
{
  S() = delete;
  int x;
};

int main()
{
  auto s = S{};
  std::cout << s.x;
}
/*-------------------------------------------------------
  Aşağıdaki örnekte ekran çıktısı 0 olacaktır.
-------------------------------------------------------*/
#include <iostream>
#include <type_traits>

int main() {
    if(std::is_signed<char>::value){
        std::cout << std::is_same<char, signed char>::value;
    }else{
        std::cout << std::is_same<char, unsigned char>::value;
    }
}
/*-------------------------------------------------------
  Aşağıdaki örnekte ekran çıktısı 101 olacaktır.
-------------------------------------------------------*/
#include <iostream>

char a[2] = "0";

struct a_string {
   a_string() { *a='1'; }
   ~a_string() { *a='0'; }
   const char* c_str() const { return a; }
};

void print(const char* s) { std::cout << s; }
a_string make_string() { return a_string{}; }

int main() {
   a_string s1 = make_string();
   print(s1.c_str());

   const char* s2 = make_string().c_str();
   print(s2);

   print(make_string().c_str());
}
/*-------------------------------------------------------
  Aşağıdaki örnekte ekran çıktısı TS şeklinde olacaktır.
-------------------------------------------------------*/
#include <iostream>
using namespace std;

template<typename T>
void adl(T)
{
  cout << "T";
}

struct S
{
};

template<typename T>
void call_adl(T t)
{
  adl(S());
  adl(t);
}

void adl(S)
{
  cout << "S";
}

int main ()
{
  call_adl(S());
}

/*-------------------------------------------------------
 Aşağıdaki örnekte sadece init-listin <C> açılımı ilk kullanıldığında
 copy ctor çağrılacaktır. Bunun haricinde copy ctor. çağrısı söz
 konusu olmayacaktır. Bu yüzden ekran çıktısı 1 olarak elde edilir.
-------------------------------------------------------*/
#include <initializer_list>
#include <iostream>

class C {
public:
    C() = default;
    C(const C&) { std::cout << 1; }
};

void f(std::initializer_list<C> i) {}

int main() {
    C c;
    std::initializer_list<C> i{c};
    f(i);
    f(i);
}
/*-------------------------------------------------------
  Aşağıdaki örnekte ekran çıktısı YX şeklinde olacaktır.
-------------------------------------------------------*/
#include <iostream>
struct X {
  virtual void f() const { std::cout << "X"; }
};

struct Y : public X {
  void f() const { std::cout << "Y"; }
};

void print(const X &x) { x.f(); }

int main() {
  X arr[1];
  Y y1;
  arr[0] = y1;
  print(y1);
  print(arr[0]);
}
/*-------------------------------------------------------
  Aşağıdaki örnekte ekran çıktısı 222 şeklinde olacaktır.
-------------------------------------------------------*/
#include <iostream>

struct C {
    int& i;
};

int main() {
    int x = 1;
    int y = 2;

    C c{x};
    c.i = y;

    std::cout << x << y << c.i;
}
/*-------------------------------------------------------
  Aşağıdaki örnekte ekran çıktısı if olarak elde edilecektir.
-------------------------------------------------------*/
#include <iostream>

void f(float &&) { std::cout << "f"; }
void f(int &&) { std::cout << "i"; }

template <typename... T>
void g(T &&... v)
{
    (f(v), ...);
}

int main()
{
    g(1.0f, 2);
}
/*-------------------------------------------------------
  global nesnelerin isimlendirilmesinde başta underscore(_)
  karakterinin kullanımı tanımsız davranışa sebep olur.
-------------------------------------------------------*/
#include <iostream>

int _global = 1;

int main() {
  std::cout << _global;
}
/*-------------------------------------------------------
  Bir sayının sıfıra bölünmesi durumunda tanımsız davranış oluşur.
-------------------------------------------------------*/
#include <iostream>

int main() {
  int i = 42;
  int j = 1;
  std::cout << i / --j;
}
/*-------------------------------------------------------
   Aşağıdaki örnekte hem  default ctor hem int parametreli ctor,
   hem de copy assignment çağrılacağından dolayı 1,2 ve 3
   nolu satırlardaki değişkenlerin hepsinin değeri değişicektir.
   Bu durumda ekran çıktısı 111 şeklinde olacaktır.
-------------------------------------------------------*/
#include <iostream>
#include <map>
using namespace std;

bool default_constructed = false; //1
bool constructed = false; //2
bool assigned = false; //3

class C {
public:
    C() { default_constructed = true; }
    C(int) { constructed = true; }
    C& operator=(const C&) { assigned = true; return *this;}
};

int main() {
    map<int, C> m;
    m[7] = C(1);

    cout << default_constructed << constructed << assigned;
}
/*-------------------------------------------------------
  Aşağıdaki örnekte bir tanımsız davranış söz konusudur.
  Bunun nedeni get bir future nesnesinin bir defa elde
  edilebileceğidir.
-------------------------------------------------------*/
#include <future>
#include <iostream>

int main()
{
    std::promise<int> p;
    std::future<int> f = p.get_future();
    p.set_value(1);
    std::cout << f.get();
    std::cout << f.get();
}
/*-------------------------------------------------------
  Most vexing parse kuralı burada devreye gireceğinden
  Y y(X()); ifadesi bir fonksiyon bildirimi olarak yorumlanacaktır.
-------------------------------------------------------*/
#include <iostream>

struct X {
  X() { std::cout << "X"; }
};

struct Y {
  Y(const X &x) { std::cout << "Y"; }
  void f() { std::cout << "f"; }
};

int main() {
  Y y(X());
  y.f();
}

/*-------------------------------------------------------
  Aşağıdaki örnekte bir tanımsız davranış söz konusudur.
-------------------------------------------------------*/
#include<iostream>

int main()
{
    unsigned short x=0xFFFF;
    unsigned short y=0xFFFF;
    auto z=x*y;
    std::cout << (z > 0);
}
/*-------------------------------------------------------
  Aşağıdaki örnekte ekran çıktısı 1000 şeklinde elde edilecektir.
-------------------------------------------------------*/
#include <iostream>
#include <type_traits>

template <typename T>
void foo(T& x)
{
    std::cout << std::is_same_v<const int, T>;
}

template <typename T>
void bar(const T& x)
{
    std::cout << std::is_same_v<const int, T>;
}

int main()
{
    const int i{};
    int j{};

    foo(i);
    foo(j);
    bar(i);
    bar(j);
}
/*-------------------------------------------------------
  Aşağıdaki örnekte ekran çıktısı 112 şeklinde elde edilecektir.
  Bunun nedeni tür çıkarımının int olarak yapılması durumunda
  derleyici tarafından başka bir fonksiyon yazılırken, tür
  çıkarımının double türünden yapılması durumunda başka
  bir fonksiyon yazılacaktır. Bu sebeple sıfırdan başka bir
  static değişken hayata geliyormuş gibi düşünülebilir.
  Bunlardan yola çıkılarak ekran çıktısı son durumda 112 şeklinde
  olacaktır.
-------------------------------------------------------*/
#include <iostream>

using namespace std;

template <class T> void f(T) {
  static int i = 0;
  cout << ++i;
}

int main() {
  f(1);
  f(1.0);
  f(1);
}
/*-------------------------------------------------------
  Aşağıdaki örnekte ekran çıktısı 1 olarak elde edilecektir.
-------------------------------------------------------*/
#include <iostream>

template <class T> void f(T &i) { std::cout << 1; }

template <> void f(const int &i) { std::cout << 2; }

int main() {
  int i = 42;
  f(i);
}
/*-------------------------------------------------------
  Aşağıdaki örnekte ekran çıktısı 1 olarak elde edilir.
-------------------------------------------------------*/
#include <iostream>

int main() {
   int n = sizeof(0)["abcdefghij"];
   std::cout << n;
}
/*-------------------------------------------------------
  Türemiş sınıf(Derived class) türünden bir nesne oluşturulurken öncelikle
  Taban sınıfın ctoru çağrılır. Bu durum aggregation içinse
  yine aynıdır. Bu durumda ekran çıktısı abBA şeklinde elde edilir.
-------------------------------------------------------*/
#include <iostream>

class A {
public:
  A() { std::cout << 'a'; }
  ~A() { std::cout << 'A'; }
};

class B : public A {
public:
  B() { std::cout << 'b'; }
  ~B() { std::cout << 'B'; }
};

int main() { B b;
/*-------------------------------------------------------
  Aşağıdaki örnekte bir belirsiz davranış söz konusudur.
-------------------------------------------------------*/
#include <iostream>

void print(int x, int y)
{
    std::cout << x << y;
}

int main() {
    int i = 0;
    print(++i, ++i);
    return 0;
}
/*-------------------------------------------------------
  Aşağıdaki örnekte ekran çıktısı 22 olarak elde edilecektir.
-------------------------------------------------------*/
#include <iostream>

struct Base {
    virtual int f() = 0;
};

int Base::f() { return 1; }

struct Derived : Base {
    int f() override;
};

int Derived::f() { return 2; }

int main() {
    Derived object;
    std::cout << object.f();
    std::cout << ((Base&)object).f();
}

/*-------------------------------------------------------
  Aşağıdaki örnekte bir tanımsız davranış söz konusudur.
-------------------------------------------------------*/
#include <iostream>

extern "C" int x;
extern "C" { int y; }

int main() {

	std::cout << x << y;

	return 0;
}
/*-------------------------------------------------------
  nullptr aslında bir pointer değildir. Bu sebeple aşağıdaki
  örnekte ekran çıktısı 0 olarak elde edilecektir. 
-------------------------------------------------------*/
#include <iostream>
#include <cstddef>
#include <type_traits>

int main() {
  std::cout << std::is_pointer_v<decltype(nullptr)>;
}
