
/*----------------------------------------------------------------------------------------------------------------------
	Java Platformunun Temel Özellikleri:
	Arakodlu Çalışma Sistemi:
		C ve C++ gibi dillerde yazılan kodlardan çalışabilen bir dosya (executable file) elde
		edildiğinde bu dosyanın içerisinde çalıştırılacak sisteme özgü (genel işletim sistemi, donanım vb.) doğrudan
		çalıştırılabilecek makine kodları bulunur. Oysa Java programlama dili ile yazılan bir program "derlendiğinde (compilation)"
		oluşan dosyanın içerisinde hiç bir sistemin dili olmayan yapay bir arakod bulunur. Bu arakoda "byte code" denir.
		"Byte code" doğrudan çalıştırılamaz. Byte code bir başka uygulama (program) tarafından çalıştırılır. İşte program
		çalışma sırasında byte code içerisindekileri makine koduna dönüştürür. Bu dönştürme işlemine genel olarak
		"Just In Time Compilation (JIT Compilation)" denir. Geliştirme ve çalıştırma anlamında şu temel kavramlar önemlidir:
			JVM (Java Virtual Machine): Byte code'u derleyerek (JIT) sisteme ilikin aşağı seviyeli koda dönüştürür. JVM
			aslında "byte code'un nasıl yorumlanacağına yönelik soyutlanmış bir kavramdır.

			JRE (Java Runtime Environment): Genel olarak Java ile yazılmış bir uygulamayı bir uygulamayı çelıştırmak (run)
			için gereken araçları ve uygulamaları içeren bir pakettir. Yani program Java ile yazıldığında edildiğinde bu
			programın çalıştırılabilmesi için JRE'ye ihtiyaç vardır.

			JDK (Java Development Kit): Geliştirme (development) araçlarını bve çalıştırma araçlarının da birçoğunu barındıran
			bir pakettir. Buradaki çalıştırma araçları geliştirme aşamasında kullanılabilir.

		Ticari kullanımlarda özellikle Java 11 ile birlikte bir takım değişiklikler yapılmıştır. Genel olarak şöyle
		söylenebilir: Java'da geliştirme ortamı ücretsiz, çalıştırma araçları kullanılan araca göre ücretlendirilebilir. Tamamen
		ücretsiz olan "Open JRE" denilen ayrı bir ürün de vardır. Bu kavramdır zamanla anlaşılacaktır. Burada anlatılanlar
		geneldir.

		Arakodlu çalışma sisteminin en önemli avantajı, geliştirilen uygulamalar genel olarak sistemden bağımsız olarak
		çalıştırılabilir. Dolayısıyla sistemden bağımsız olarak yazılır. Bu kavrama "Write Once Run Anywhere (WORA)" denir.

		Ayrıca unutulmamalıdır ki, arakodlu çalışma sistemi ufak da olsa bir performans kaybına yol açar. Ancak Java'nın
		hedefi olan uygulamalar için bu kayıp gözardı edilebilir. Bu durumda bir çok araç da kullanılabilir.

	Geniş bi sınıf kütüphanesi: Java'da geniş bir sınıf kütüphanesi bulunur. Veritabanı, web programlama, dosya işlemleri vb.
	işlemler için hazır sınıflar vardır.

	Hızlı uygulama geliştirme ortamı: Java hızlı uygulama geliştirme (rapid application development) ortamı sunar. Bu anlamda
	hem öğrenmesi kolaydır, hem de ürün daha çabuk elde edilir.

	Güvenli çalışma ortamı: Java'da yazılmış olan programların sisteme zarar verme olasılıkları çok daha azdır. Yazılan bir
	program yüzünden yanlışlıkla makinede bir problem çıkma olasılığı çok daha azdır.
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Programlama Dillerinin Sınıflandırılması:
	1. Seviyelerine (level) göre sınıflandırma: Seviye bir programlama dilinin insan algısına yakınlığının bir ölçüsüdür.
	Yüksek seviyeli (high level) diller hem dil özellikleri hem de uygulama geliştirme olarak kolay öğrenilebilen, insan
	algısına yakın dillerdir. Aşağı seviyeli (low level) diller makinenin doğal çalışmasına daha yakındır. Olabilecek en aşağı
	seviyeli dil saf mekine dilidir.
    makine dili -> düşük seviyeli diller -> prosedürel diller -> yüksek seviyeli diller -> insan dili
	2. Kullanım alanlarına göre sınıflandırma: Dilin hangi alanlarda kullanılabileceğinin sınıflandırılmasıdır. Bazı diller
	birden fazla alanda kullanılabilirler. Bu anlamda genel amaçlı diller, bilimsel ve mühendislik dilleri, oyun ve animasyon
	dilleri, veritabanı dilleri vb.

	3. Programlama modeline göre sınıflandırma: Bir programı yazarken kullanılan genel model (paradigm) önemlidir. Bazı
	dillerde sınıf yoktur. Program çeşitli alt programların (function) birbirlerini çağırması yoluyla yazılır. Bu tekniğe
	"procedurel model" denir. Bazı dillerde sınıf vardır. Program sınıflar kullanılarak yazılır. Başka bir çok kavramla
	birlikte sınıflar da kullanılarak yazılan modele "object oriented" model denir. Bazı dillerde programlar matematiksel
	formül yazıyormuş gibi yazılır. Bu programlama modeline de "functional" model denir. Bazı diller birden fazla modeli
	destekler. Bu tip dillere "multi paradigm" diller denir. Burada birden fazla modeli desteklemesi, modelin her özelliğini
	desteklemesi anlamına gelmeyebilir. object base, object oriented

	Buna göre Java, genel amaçlı, web programlama, yapay zeka, bilimsel ve mühendislik vb alanlarında kullanılabilen,
	nesne yönelimli, özellikle Java 8 ile birlikte fonksiyonel programlama özelliklerinin de geliştirilmiş olduğu yüksek
	seviyeli bir programlama dilidir.

	Makine dili(byte code)..........Assembly.................Prosedürel(C)..............Yüksek seviyeli diller...........insan dili
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Yukarıda anlatılan kavramların detayları vardır. Bunlar zaman içerisinde ele alınacaktır.
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Temel Kavramlar:
	Çevirici program (translater), derleyici (compiler), yorumlayıcı (interpreter): Bir programlama dilinde yazılmış olan
	programı eşdeğer olarak başkabir programlama diline dönüştüren programlara "translater" denir. Çevirici programlarda
	kaynak dil (source language) ve hedef dil (target/destination language) söz konusudur. Örneğin, Java'dan Kotlin'e dönüştürme
	yapan program bir çevirici programdır. Bir çevirici programda hedef dil aşağı seviyeli bir dil (saf makine dili, sembolik
	makine dili, arakod vb) ise bu durumda çevirici programa özel olarak "derleyici (compiler)" denir. JVM'in byte code'u
	makine koduna dönüştürme faaliyeti de bir derleme işlemidir. Bu işlem çalışma ortamı içerisinde JIT derleyicisi tarafından
	yapılır. Bazı programlar hiç kod üretmeden doğrudan çalıştırılırlar. Bunları çalıştıran programlara da "yorumlayıcı (interpreter)"
	denir. Bazı diller yalnızca yorumnlayıcı ile, bazı diller yalnızca derleyici ile, bazı diller ise her ikisi ile de
	kullanılabilmektedir. Java 11 ile "java" programı yorumlayıcı olarak da çalışabilmektedir. Ancak pratikte Java programları
	ile derleyici kullanılır.

	Anahtar Notlar: Bir uygulama tekl bir java dosyasından oluşmak zorunda değildir. İleride anlatılacağı gibi her java
	dosyası (hatta her sınıf) ayrı derlenir. Bir ürün aslında tüm birimlerinin uygun şekilde derlenmesi veya ele alınmasıyla
	elde edilir. Bu işleme genel olarak "build" işlemi denir. Build işlemi sadece derleme işlemi değildir. Yani bir
	uygulamanın ürün olarak elde edilemesi süreci "build" işlemidir.

	İşletim Sistemi (operating system): Makinenin donanımını yöneten, bilgisayar ile kullanıcı arasında köprü görevi
	gören sistem yazılımıdır. Bir işletim sisteminin pek çok görevi vardır. Örneğin, programları çalıştırmak, çeşitli
	donanım aygıtlarını yönetmek vb. İşletim sistemleri genel olarak "masaüstü (desktop)" ve "mobil (mobile)" olmak
	üzere iki gruba ayrılabilir.

	Açık kaynak kodlu yazılım, özgür yazılım ve mülkiyete sahip yazılım: Özgür yazılım (free software)  ve açık kaynak kodlu
	yazılımın (open source) aralarında farklar olsa da genel olarak aşağıdaki özelliklere sahiptir:

	- Bedavadır. Kullanılabilmesi için bir lisans ücreti ödenmesi gerekmez.
	- Kaynak kodlar sahiplenilmez. Kaynak koda ekleme yapıldığında kodlar kapatılamaz. Onların da açılması gerekir.
	- Çoğaltılabilir, izin almadan kullanılabilir.

	Bunun tam tersi "mülkiyete sahip (propriatery)" yazılımlardır. Bu yazılımlar para verilerek kullanılırlar. Çoğaltılamazlar
	ya da çoğaltılması için belirli koşulları olur.
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	IDE (Integrated Development Environment): Derleyiciler komut satırından çalışan basit arayüzlere sahip programlardır.
	Aslında teorik olarak Java ile geliştirilecek bir uygulama içerisinde tüm java dosyaları (ve hatta diğer proje dosyları bile)
	"notepad" gibi basit bir editör program ile yazılıp, komut satırından derlenip çalıştırılabilir. Fakat pratikte bu şekilde
	program yazmak fazlaca zaman kaybettirir. Yazılım geliştirmeyi kolaylaştırmak için IDE programlar kullanılır. IDE'ler
	içerisinde editörler, test araçları, çeşitli kodlar üreten araçlar vb. bulunur. IDE bir derleyici değildir. IDE derleme işlemi
	için derleyiciyi de çalıştırabilir. Uygulamayı çalıştırmak için de JRE araçlarını kullanabilir. Java ile uygulama geliştirirken
	kullanılabilecek çeşitli IDE'ler bulunmaktadır. Bunlardan en yaygın olarak kullanılanları "Eclipse" ve "IntelliJ IDEA"
	IDE'leridir. Önceleri Netbeans isminde bir IDE de kullanılmaktaydı. Ancak son yıllarda kullanımı oldukça azalmıştır.
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Dil Kavramı: Dil iletişimde kullanılan semboller topluluğudur. Bir dilin kurallarına gramer denir. Gramerin birçok
	alanı vardır. Bunlardan en önemlileri "sentaks (syntax)" ve "semantik (semantic)" alanlarıdır. Bir olgunun dil
	olabilmesi için en azından sentaks ve semantiğe sahip olması gerekir.

	Sentaks doğru yazma ve doğru dizilime ilişkin kurallardır. Örneğin
		"I go to will school"
	cümlesinde sentaks hatası yapılmıştır. Java ile örneklersek:
		System.out.println("Hello, World";
	deyiminde kapanan parantez olmadığı için sentaks hatası yapılmıştır.

	Dildeki doğru dizilmiş öğelerin ne anlam ifade ettğine yönelik kurallara semantik denir.

	Bilgisayar Dilleri ve Programlama Dilleri: Bilgisayar bilimlerinde kullanılmak üzere tasarlanmış dillere
	"bilgisayar dilleri (computer language)" denir. Bir bilgisayar dilinde "akış (flow)" da varsa o zaman
	"programlama dili (programming language)" denir. Örneğin XML, HTML dilleri programlama dili değildir. Bilgisayar dilleridir.
	Java, C++, C vb dillerde akış da olduğundan programlama dilleridir.
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Hello, World programı
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.println("Hello, World");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Atom (Token):
	Bir programlama dilinde kendi başına anlamlı olan en küçük birime atom denir. Atomlar Java'da 6(altı) gruba ayrılırlar:
	1. Anahtar Sözcükler (keywords, reserved words): Dil için özel bir anlamı olan, yani dil tarafından bilinen ve birçoğu
	doğrudan değişken ismi olarak kullanılamayan atomlardır. Örneğin: package, class, public, static, void,for,int vb.

	2. Değişken atomlar (identifiers, variables): İsmini programcının belirlediği ve isimlendirmeye yönelik kuralları olan
	atomlardır. Örneğin: String, csd, App vb.

	3. Operatörler (operators): Bir işleme yola açan ve bu işlem sonucunda bir değer üreten atomlardır. Örneğin a + b
	ifadesinde + bir operatördür. instanceof new, >> << ~ % & &&

	4. Sabitler (literals, constants): Program içerisinde doğrudan yazılan sayılara denir. Örneğin a - 2 ifadesinde
	2 bir sabittir. 100 20.4 34.5F 23D 190L 'A'

	5. String'ler (Strings, String literals): İki tırnak içeriside bulunan yazılar tırnaklarıyla birlikte String atomudur.
	Örneğin: "Hello, World" String str = "Murat";

	6. Ayraçlar (delimiters, punctuator): Yukarıdaki gruplar dışında kalan tüm atomlardır. Örneğin: {} vb.
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Boşluk karakterleri (whitespaces): Klavyeden basıldığında boşluk algısı yaratan karakterlerdir. Klavyeden basılabilen
	boşluk karakterleri tipik olarak şunlardır: space, tab, enter.
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Java'da kod yazım kuralları şunlardır
	1. Atomlar arasında istenildiği kadar boşluk (whitespace) bırakılabilir.
	2. Anahtar sözcükler ve değişkenler dışından kalan atomlar istenildiği kadar bitişik yazılabilirler. Anahtar sözcükler
	ve değişken atomlar arasında en az bir tane boşluk (whitespace) karakteri olmalıdır
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Atomlar arasında istenildiği kadar boşluk (whitespace) bırakılabilir.
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App








				{
	public static 					void main(String [] args)
	{
		System



		.


		out




		.



		println("Hello, World");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Anahtar sözcükler ve değişkenler dışından kalan atomlar istenildiği kadar bitişik yazılabilirler.
-----------------------------------------------------------------------------------------------------------------------*/
package csd;class App{public static void main(String[]args){System.out.println("Hello, World");}}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar sözcükler ve değişken atomlar arasında en az bir tane boşluk (whitespace) karakteri olmalıdır
-----------------------------------------------------------------------------------------------------------------------*/
packagecsd;class App{public static void main(String[]args){System.out.println("Hello, World");}} //error


/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Java'da "derleme zamanı (compile time)" ve "çalışma zamanı (run time)" denilen birbiriyle ilişkili
	ancak ayrı olan iki kavram vardır. "Derleme zamanı" derleme sürecinde yapılan işlemlere denir. Çalışma zamanı ise
	programın çalışması sürecinde yapılan işlemlere denir.
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Derleyicinin hata mesajları (diagnostics)
	1. Gerçek hatalar (error veya compile time error): Dilin sentaks ya da semantik kurallarına uyulmamasından dolayı verilen mesajlardır.
	Bu durumda "byte code" üretilmez. Programcının bu hataları düzeltip derlemesi gerekir.

	2. Uyarılar (warnings): Byte code'un üretimine engel olmayan, olası programlama ve mantık hatalarının bildirilmesi
	için verilen mesajlardır. Programcı bu uyarılar kesinlikle dikkate almalıdır. Özel bir durum yoksa uyarı mesajlarının
	oluşumuna yol açan kodlar düzeltilmeldir. Bazı durumlarda derleyicinin uyarı mesajı vermediği ancak IDE'nin kullandığı
	bir "static kod analizi aracı" konfigürasyonları gereği uyarı verebilir. Bunlar da dikkate alınmalıdır. Ancak hepsinin
	düzeltilmesi gerekmez.

	3. Ölümcül hatalar (fatal errors): Derleme işleminin bile tamamlanmasını engelleyen hatalardır. Bu durumda programcının
	yazdığı kod açısından yapacak birşeyi yoktur. Çünkü kod henüz derlenmemiş bile olabilir. Programcının ölümcül hataya
	yol açan durumu ortadan kaldırması gerekir. Örneğin diskte yer kalmaması, derlenecek dosyanın bulunanaması gibi durumlar
	ölümcül hatalara yol açar.

	Programın çalışma zamanı sırasında oluşan hatalı durumlara genel olarak "exception" denir. Exception işlemleri
	ileride "exception handling" isimli bölümde ele alınacaktır. Bu konu ele alınana kadar exception oluştuğunda
	"program sonlanır" olarak anlaşılacaktır. Exception terimi yerine "runtime error" da kullanılmaktadır. "error" dendiğinde
	"compile-time error" anlaşılır.
------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------
	Bildirim (declaration): Bir ismin derleyice tanıtılmasıdır. Derleyici bildirim ile o ismin ne anlama geldiğini anlar
	ve derleme işlemini ona göre yapar.
	User defined types:
	1-)enums
	2-)interfaces
	int a;
	double b;
	String str;
	enum Color{
	Red,Brown,Purple
	};
	Myclass m1;
	interface Person{
	}
	Myclass m = new Myclass();
	m.x = 10;
	delete m;
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Java'da yorum satırları (comment lines)
-----------------------------------------------------------------------------------------------------------------------*/

package csd;

class App {
	public static void main(String [] args)
	{
		System.out.println("Hello, World"); // Burası derleyici tarafından dikkate alınmayacak
	}
}

/*
	Bu bölge de derleyici tarafında dikkate
	alınmayacak
 */

// Burası da derleyici tarafından dikkate alınmayacak

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Java'da 1(bir)'den fazla java dosyası ile çalışmanın bir takım ayrıntıları vardır. Bu sebeple o
	ayrıntılara gelene kadar hep tek bir java dosyası ile çalışacağız
-----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Bir Java programı genel olarak paketlerden, paketler sınıflardan, sınıflar da metotlardan oluşur.

	paket bildiriminin genel biçimi:

	package <isim>;

	Örneğin:
	package csd;

	Paketler konusuna kadar yalnızca csd paketi altında çalışacağız. Paketler konusu ileride detaylı olarak ele alınacaktır

	Sınıf bildiriminin (bazı detaylar hariç) genel biçimi:

	class <isim> {
		//...
	}

	örneğin:
	class Sample {
		//...
	}

	Sınıf nesne programlama tekniğinin temel taşlarından biridir. Kurs boyunca sınıflar detaylı bir biçimde ele alınacaktır.

	Java'da alt programlamlara "metot (method)" denir. Alt programın ne yapacağının yazılmasına "metot bildirimi (method declaration)"
	denir. Alt programın (yani metodun) kodlarının çalıştırılmasına ise "metot çağırma (method call)" denir. Metot çağrısı başka
	bir metodun içerisinde yapılabilir. Metot bildirimi ise genel olarak sınıf içerisinde yapılabilir.

	Metot bildiriminin genel biçimi:

	[erişim belirleyici] [static] <geri dönüş değeri bilgisi> <metot ismi>([parametreler])
	{
		//...
	}

	Açıklamalar:
	car -> Bmw -> BmwCoupe
	- Erişim belirleyici şunlardan biri olabilir: public, private, protected, no-modifier (hiç bir şey yazmamak), private
	Metotların erişim belirleyicileri konusuna gelene kadar tüm metotları public olarak bildireceğiz.

	- Bir metot static veya non-static olabilir. static anahtar sözcüğü bildirimde yazılmazsa metot non-static olur. İlgili
	konuya gelene kadar tüm metotları static olarak bildireceğiz.

	- Erişim belirleyici ve static anahtar sözcükleri aynı sentaks seviyesinde olduğundan yerleri değiştirilebilir. Ancak
	okunabilirlik/algılanabilirlik açısından bir erişim belirleyiciyi static anahtar sözcüğünden önce yazacağız.

	- Metodun geri dönüş değeri bilgisi metot isminden önce yazılmalıdır.  Metodun geri dönüş değerinin olmaması durumunda
	buraya void yazılması gerekir. Geri dönüş değeri kavramı ileride ele alınacaktır.

	- Metodun ismi bir değişken atomdur. Tüm değişken atomlarda olduğu gibi "değişken isimlendirme kuralları"'na uygun
	olarak isimlendirilir.

	- Metot bildiriminde metot isminde sonra parantezler içerisinde ismine "metot parametre değişkeni (method parameter)"
	denilen değişkenler bildirilebilir. Metodun herhangi bir parametresi yoksa parantezler içi boş bırakılır. Metot
	parametre değişkenleri ileride ele alınacaktır.

	- Metot bildiriminde küme parantezleri arasında metodun kodları yazılır. Küme parantezleri ve içerisindeki kodlara
	"metodun gövdesi (method body)" denir.

	- static bir metodun çağrılmasının genel biçimi:

	[paket ismi].[sınıf ismi].<metot ismi>([argümanlar]);

	Bir program main metodunun çağrılmasıyla başlar. Programcının main içerisinde çağırdığı metotlar ve metotların
	içerisinde  çağrılan metotlar ile akış (flow) devam eder. main metodu JVM tarafından çağrılır. Bu anlamda java
	programına (kabaca JVM'e) verilen "byte code"'a ilişkin sınıfın main metoduna "giriş noktası (entry point)" denir.
	Özel bazı durumlar dışında main sonlandığında program sonlanır. Bir metot çağrıldığında akış metodun kodlarına
	dallanır (call) ve metodun kodları çalıştırılır. Şüphesiz metot içerisinde de başka bir metot çağrılıyor olabilir.Yine
	bu çağırma noktasında akış metoun kodlarına dallanır. Metot çağrısı bittiğinde akış çağrıldığı noktaya geri döner ve
	bir sonraki koddan çalışmaya devam eder.

	Anahtar Notlar: System.out.println("Hello, World"); çağrısında System bir sınıf, out bir referans ve println de
	non-static bir metottur. Bu kavramlar ileride ele alınacaktır.
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.println("Hello, World");
		csd.Sample.foo();
		csd.Sample.bar();
		csd.Mample.tar();
		System.out.println("Goodbye, World");
	}
}

class Sample {
	public static void foo()
	{
		System.out.println("Sample.foo");
	}

	public static void bar()
	{
		System.out.println("Sample.bar");
	}
}


class Mample {
	public static void tar()
	{
		System.out.println("Mample.tar");
		csd.Sample.foo();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Çağıran metodun (caller) ait olduğu sınıf ile çağrılan metodun (callee) ait olduğu sınıf aynı pakette ise paket ismi
	yazılmayabilir. Çağıran metot ile çağrılan metot aynı sınıfta ise bu durumda çağırma sırasında paket ismi yazılmayacaksa
	sınıf ismi de yazılmayabilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.println("App.main");
		System.out.println("Hello, World");
		Sample.foo();
		Sample.bar();
		csd.Mample.tar();
		System.out.println("Goodbye, World");
	}
}

class Sample {
	public static void foo()
	{
		System.out.println("Sample.foo");
		bar();
	}

	public static void bar()
	{
		System.out.println("Sample.bar");
	}
}


class Mample {
	public static void tar()
	{
		System.out.println("Mample.tar");
		Sample.foo();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	04.09.2022
	Tür (type): Bir değişken için bellekte ne kadar yer ayrılacağını ve içerisindeki verinin hangi yöntemle tutulacağını
	belirten kavramdır.
    Javada 2 tip tür vardır:
    1-)Primitive types(int,boolean,float...)
    2-)User-defined types:
        a-)enums
        b-)interface
        c-)class types
	Java'da türler genel olarak iki gruba ayrılır:
	Temel türler (primitive/built-in/predefined types), programcının tanımladığı türler (user defined types)

	Her temel tür ismi bir anahtar sözcük ile temsil edilir:

	Temel türler aşağıdaki tabloda belirtilmiştir:

	Tür ismi				Uzunluğu (byte)
	short						2
   *int							4 => 2^32
	long						8 => 2^64
	byte						1

	float						4
   *double						8

	char						2
	boolean						-

	Açıklamalar:

	- Java'da türlerin uzunlukları boolean türü dışında sistemden sisteme değişmez

	- Tüm tamsayı türleri işaretlidir. (signed)

	- Tamsayı türleri (integer/integral types) için ikiye tümleme yöntemi kullanılır. Java'da işaretsiz tamsayı türü
	yoktur. Ancak Java 8 ile birlikte belirli koşullar altında işaretsiz tamsayı işlemleri yapılabilmektedir.

	- long en uzun tamsayı türüdür.

	- Gerçek sayı türleri (real/floating point types) için "IEEE 754 standardı" kullanılır. float ve double türleri
	sırasıyla tek hassasiyetli (single precision) ve çift hassasiyetli (double precision) değerleri tutar. Bu türlerde
	bazı sayılar tam olarak ifade edilemezler. O sayıya en yakın bir sayı ile ifade edilebilirler. Bir noktalı sayının
	tam olarak ifade edilemeyip en yakın sayı olarak ifade edilmesine "yuvarlama hatası (rounding error)" denir. Yuvarlama
	hataları bir değer yerleştirilirken de oluşabilir, bir işlemin sonucunda da oluşabilir

	- Gerçek sayı türleri işaretli türlerdir.

	- float türünün yuvarlama hatalarına karşı direnci daha zayıftır. Yani yuvarlama hatası daha çok olmaktadır.

	- Yuvarlama hataları parasal ve finansal uygulamalarda hatalı değerlerin oluşmasına sebep olabilir. Parasal
	ve finansal uygulamalar için tasarlanmış özel türler vardır. Bunlar temel türler değildir. Programcı böylesi
	uygulamalar için bu türü (sınıfı) tercih eder. Ancak bu sınıflar yuvarlama hatası yapmamak için yüzlerce makine
	komutu kullanarak bu işlemleri yaparlar. Bu durumda programcı için parasal ve finansal uygulamalar gibi yuvarlama
	hatasının olmaması gereken durumlar dışında double ya da duruma göre float türü tercih edilmelidir.

	- Yazılar içerisinde her bir karakter aslında bir sayı ile temsil edilir. Hangi karakterin hangi sayı ile ifade
	edildiği karakter tablosuna bağlıdır. ASCII tablosu 1(bir) byte'lık yani 256 tane satırdan oluşur. UNICODE tablo
	2 byte'lık yani 65536 tane satırdan oluşur. Karakter tabloları bunlarla sınırlı değildir. Detaylar ileride ele
	alınacaktır.
	1 2 3 4 5 6 7 8 9 A B C D E F

	3F -> 0000 0000 -> 0011 1111

	- char türü Java'da UNICODE tablo dikkate alınarak belirlenmiştir. Bu nedenler char türü 2 byte'tır. char türden
	değişken içeriisnde bir karakterin UNICODE (ya da başka tablodaki) sıra numarası tutulur. UNICODE tablo dünyadaki
	dillerde kullanılan hemen hemen tüm karakterleri ve bazı özel karakterleri ifade edebilir.

	- boolean türünün alabileceği iki tane değer vardır: true ve false. boolean türünün uzunluğu "Java Language Specification"'da
	belirtilmemiştir. Sistemden sisteme değişebilir. Ancak bu değişim programcı açısından problem oluşturmaz.

	Anahtar Notlar: int türüne "integer" demek yanlış bir terim kullanmak demektir. integer terimi tamsayılar için
	kullanılan genel bir terimdir. Ayrıca "Integer" isimli bir sınıf da bulunmaktadır.

	Anahtar Notlar: Java'da en çok kullanılan tamsayı türü int türüdür, en çok kullanılan gerçek sayı türü de double
	türüdür. Programcı öncelikle bu türleri tercih etmelidir. Eğer geçerli bir neden varsa diğer türleri kullanmalıdır.
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği çalıştırıp yuvarlama hatalarını gözlemleyiniz. Örnekteki detayları şu an önemsemeyiniz. İleride
	hepsi ele alınacaktır.
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		double a = 0.1, b = 0.2;
		double c;

		c = a + b;

		System.out.printf("a = %.20f%n", a);
		System.out.printf("b = %.20f%n", b);
		System.out.printf("c = %.20f%n", c);


		if (c == 0.3)
			System.out.println("Eşit");
		else
			System.out.println("Eşit değil");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği çalıştırıp yuvarlama hatalarını gözlemleyiniz. Örnekteki detayları şu an önemsemeyiniz. İleride
	hepsi ele alınacaktır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		float a = 0.1F, b = 0.2F;
		float c;

		c = a + b;

		System.out.printf("a = %.20f%n", a);
		System.out.printf("b = %.20f%n", b);
		System.out.printf("c = %.20f%n", c);


		if (c == 0.3)
			System.out.println("Eşit");
		else
			System.out.println("Eşit değil");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir değişken kullanılmadan önce bildirilmelidir. Değişken bildiriminin genel biçimi:
		<tür> <değişken ismi>;
	Örneğin:
		int a;
		boolean b;
		float c;
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Java'da 3 çeşit değişken vardır:
	1. Yerel değişkenler (local variables)
	2. Parametre değişkenleri (parameter variables)
	3. Sınıf veri elemanları (class member variables)

	Değişkenler için temel kavramlar:
	İsim (name): Belli kurallara göre yazılan karakterler topluluğudur.

	Tür (type): Değişken için bellekte ne kadar yer ayrılacağını ve içerisindeki verinin hangi yöntemle tutulacağını
	belirtir.
	1-)Primitive Types
	2-)user defined types
	 a-)enums
	 b-)interfaces
	Faaliyet alanı (scope): Bir değişken isminin derleyici tarafından görülebildiği kod aralığıdır. Derleme zamanına
	ilişkindir.

	Ömür (storage duration): Bir değişkenin bellekte kalma süresine denir. Çalışma zamanına ilişkindir.

	Temel bazı kavramlar:
	Blok (block): Bir metot içerisinde { ve } küme parantezleri arasında kalan kod bölümüdür. Metodun gövdesi de bir bloktur

	İlk değer verme (initialization): Bir değişkene bildirim noktasında verilen değere denir.
	int a = 10;
	int b;
	b = 45;
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Bir metot içerisinde istenildiği kadar ayrık veya içiçe bloklar olabilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		{
			//...

			{
				//...
			}
		}

		{
			//...
		}


		{

			//...
			{
				//...
			}
		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir blok içerisinde herhangi bir yerde bildirilen değişkenlere "yerel değişkenler (local variables)" denir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10; //initialization

		a = 20;
		{
			//...

			int b;

			{
				//...
			}

			float c;
		}

		{
			//...
		}

		int d;

		{

			//...
			{
				//...
			}
		}
	}
}

class Sample {
	public static void foo()
	{
		int x;

		{
			double y;

			//...
		}

	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aynı türden yerel değişkenler aralarına virgül konarak bildirilebilir.
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a, b;

		//...
	}
}

class Sample {
	public static void foo()
	{
		int x = 10, y = 30, z;

		//...

	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yerel bir değişkenin faaliyet alanı bildirildiği yerden bildirildiği bloğun sonuna kadardır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public static void foo()
	{
		{
			int x;

			x = 20;

			{
				x = x + 10;
				int y = x;


				//...
			}

			y = 23; //error
		}

		x = 34; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aynı faaliyet alanı içerisinde aynı isimde yerel değişken bildirimi geçersizdir. Farklı faaaliyet alanları içerisinde
	aynı isimde yerel değişken bildirimi geçerlidir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a, b;

		//...
	}
}

class Sample {
	public static void foo()
	{
		int x;
		double x; //error

		{
			{
				int a;

				//...

				{
					float a; //error
				}
			}

			{
				int a;

				//...
			}
		}

		int a;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki iki kural dolayısıyla aşağıdaki foo ve bar metotlarında x ismi bildirilebilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public static void foo()
	{
		int x;

		//...
	}

	public static void bar()
	{
		int x;


		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	println metodu aldığı karakterleri ekrana bastıktan sonra imleci (cursor) bir sonraki satırın başına çeker. print
	metodu ise ekrana basma işleminde sonra imleci son yazdığı karakterden sonrasına çeker
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.println("Hello, World");
		System.out.print("How are you?");
		System.out.print("Are you ok?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	print ve println metotları değişkenlerin değerlerini ekrana basarlar
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		double b = 20;

		System.out.println(a);
		System.out.println(b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Java'da değer verilmemiş hiçbir değişken kullanılamaz. Yani içerisindeki değer işleme sokulamaz. Yerel değişkenlere
	değer verilmesi programcının sorumluluğundadır. Yani değer verilmeden kullanımı error oluşturur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a;
		int b;

		b = 2 * a; //error
		System.out.println(a); //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Değişkenleri ve diğer değişken atomları isimlendirmek için bir takım kurallar vardır. Bu kurallar aslında tüm
	 bildirilen isimler için geçerlidir.
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	 Değişken isimleri sayısal bir karakter ile başlatılamaz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int 1number; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Değişken isimleri hehangi bir uygun karakter ile başlatılıp istenildiği kadar sayısal karakter içerebilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a1234 = 10;

		System.out.println(a1234);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	 Değişken isimlendirmede UNICODE alfabetik karakterler geçerlidir. Örneğin Türkçe karakterler kullanılabilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int öğrencisayısı = 100;

		System.out.println(öğrencisayısı);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Her ne kadar değişken isimlendirmede UNIOCODE karakterler kullanılabilse de programlamada yalnızca
	İngilizce alfabedeki karakterlerin kullanılması iyi bir tekniktir. Biz de bu "convention"'a uygun kodlar yazacağız
-----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	10.09.2022
-----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	 Değişken isimlendirmede boşluk (whitespace) karakterler geçersizdir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int numberOfStudents = 100; //error

	}
}
/*----------------------------------------------------------------------------------------------------------------------
	 Değişken isimleri büyük-küçük harf duyarlıdır (case sensitive). Aslında Java programlama dili sentaks olarak
	 büyük-küçük harf duyarlıdır.
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int Number, NuMBer, NUMBER;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Değişken isimlendirmede _ (alttire, underscore) karakteri kullanılabilir.Hatta değişken ismi _ karakteri ile
	 başlatılabilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int _1234 = 20;
		int _val = 30;
		int number_of_devices = 34;

		System.out.println(_1234);
		System.out.println(_val);
		System.out.println(number_of_devices);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Anahtar Notlar: Programlamada "artık kullanılması tavsiye edilmeyen" durumlar için "deprecated" terimi kullanılır.
	 Bu durumun gerekçeleri çok çeşitli olabilir. Programcı açısından genel olarak "deprecated" olan bir durum özel bir
	 takım nedenler yoksa tercih edilmemelidir."
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Java 9 ile birlikte alttire karakterinin tek başına değişken ismi olarak kullanılması geçersizdir. Java 8 ile birlikte
	deprecated olmuştur.
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int _ = 10;

		System.out.println(_);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Java'da değişken isimlendirmede $ karakteri kullanılabilir. Hatta isimler $ karakteri ile başlatılabilir. $ karakteri
	tek başına değişken ismi olabilir. Ancak programcı açısından değişken isimlendirmede  $ karakteri kullanılmamalıdır.
	Derleyici ismini kendisinin belirlediği durumlarda isimlendirmede bu karakteri kullanır. $ karakteri bu anlamda
	programcı tarafından kullanılırsa isim çakışması olabilir. Zaten $ karakterinin varlık sebebi de bu tip kod üretimlerinde
	kullanılmasıdır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int amountOf$s = 100;
		int $ = 10;
		double $1234 = 2.3;

		System.out.println(amountOf$s);
		System.out.println($);
		System.out.println($1234);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Anahtar sözcükler tek başına değişken ismi olarak kullanılamaz. Ancak Java'ya daha sonra eklenmiş, yerine göre
	 anahtar sözcük biçiminde kullanılan bazı atomlar vardır. Bu tarz kullanılan ve sonradan eklenen sözcükler tam anlamıyla
	 anahtar sözcük değildir. Bu sebeple değişken ismi olarak da kullanılabilir. Kullanıldığı yere göre derleyici değişken
	 ismi olup olmadığını tespit eder (inference, deduction). Bu tarz anahtar sözcüklere programlamada
	 "bağlamsal anahtar sözcükler (contextual keywords)" de denir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int class = 10; //error
		var a = 10;
		int var = 34;

		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Anahtar Notlar: Değişken isimlerinin kolay telaffuz edilebilir, anlamlı ve yeterince uzunlukta olması gerekir.
	 statement(deyim)
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	 Anahtar Notlar: Aşağıda anlatılan, klavyeden temel türden değerler okuma yöntemlerinin detayları ileride ele
	 alınacaktır. Bu sebeple bunları bir kalıp olarak görüp yalnızca klavyeden okuma kısmı ile ilgileniniz.
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	 Klavyeden int türden değer okunması
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Birinci sayı giriniz:");
		int a = Integer.parseInt(kb.nextLine());

		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		int c;

		c = a + b;

		System.out.println(c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Klavyeden int türden değer okunması
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int c;

		c = a + b;

		System.out.println(c);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	 Klavyeden long türden değer okunması
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Birinci sayı giriniz:");
		long a = Long.parseLong(kb.nextLine());

		System.out.print("İkinci sayıyı giriniz:");
		long b = Long.parseLong(kb.nextLine());
		long c;

		c = a + b;

		System.out.println(c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Klavyeden long türden değer okunması
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("İki sayı giriniz:");
		long a = kb.nextLong();
		long b = kb.nextLong();
		long c;

		c = a + b;

		System.out.println(c);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	 Klavyeden double türden değer okunması
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Birinci sayı giriniz:");
		double a = Double.parseDouble(kb.nextLine());

		System.out.print("İkinci sayıyı giriniz:");
		double b = Double.parseDouble(kb.nextLine());
		double c;

		c = a + b;

		System.out.println(c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Klavyeden double türden değer okunması
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("İki sayı giriniz:");
		double a = kb.nextDouble();
		double b = kb.nextDouble();
		double c;

		c = a + b;

		System.out.println(c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Klavyeden değer okurken girilen yazı ilgili türden bir değere dönüştürülemiyorsa exception oluşur.
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	İfade (expression): Sabitlerden, operatörlerden ve değişkenlerden oluşan herhangi bir dizilime denir. Değişkenler
	ve sabitler tek başına ifade belirtebilir. Operatörler tek başına ifade olamazlar. İstisna bir durum dışında tüm
	ifadeler hesaplandığında bir değer üretilir.
	c = a + b;
	c = 12;
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	 Bir metodun geri dönüş değeri bilgisi yerine bir tür ismi yazılırsa bu metodun "geri dönüş değeri" vardır denir.
	 Tersine bir metodun geri dönüş değeri varsa geri dönüş değeri bilgisi yerine bir tür yazılır. Bir metodun geri dönüş
	 değeri varsa, metot çağrısı bittikten sonra çağrıldığı noktaya bir değer ile geri döner. Bir metodun geri dönüş değeri
	 yoksa geri dönüş bilgisi yerine void anahtar sözcüğü yazılır. Bir metodun geri dönüş değeri metot içerisinde return
	 deyimi ile oluşturulur. return deyiminin genel biçimi şu şekildedir:

	 	return [ifade];
	 	return val % 2 == 0;

	 return deyimi nasıl kullanılırsa kullanılsın metodu sonlandırır. Yani metot içerisinde akış return deyimine
	 geldiğinde metot sonlanır ve akış çağrılan noktaya geri döner. return deyimine ilişkin ifadenin değeri çağıran
	 metoda aktarılır. Aşağıdaki örnekte sum metodunun geri dönüş değeri 2 ile çarpılmış ve sonuç result değişkenine
	 atanmıştır.
	 1-) Basit deyim(basic statement)
	 deyim1;
	 2-) birleşik deyim(Compound statement)
	 {
	 deyim1;
	 deyim2;
	 }
	 3-) Boş deyim(Empty statement)
	 ;
	 4-) Bildirim deyimleri(Declaration statement): int a, double d, String str;
	 5-) Kontrol deyimler(Control statement): return,if,for,break,continue,do-while,while,switch,for-each
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int result;

		result = Util.sum() * 2;
		System.out.println(result);
	}

}

class Util {
	public static int sum()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());

		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());

		return a * a + b * b; //int temp = result
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	11.09.2022
-----------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------
	Java derleyicisi genel olarak bir deyime akışın hiç bir zaman gelemeyeceğini anlarsa o yazılan deyim için error
	oluşturur (unreachable code/statement). Aşağıdaki örnekte return deyimi metodu sonlandırdığı için error oluşur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Util {
	public static int sum()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());

		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());

		int result = a + b;

		return result;
		System.out.println("Unreachable code"); //error
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Akış return deyimine geldiğinde return deyimine ilişkin ifade önce hesaplanır, elde edilen değer döndürülür
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int result;

		result = Util.sum() * 2;
		System.out.println(result);
	}
}

class Util {
	public static int sum()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());

		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());

		return a + b; //int temp = a + b;
	}
}
/*---------------------------------------------------------------------------------------------------------------------
	Geri dönüş değeri olan metotlarda return tek başına kullanılamaz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Util {
	public static int sum()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());

		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());

		return; //error
	}
}


/*---------------------------------------------------------------------------------------------------------------------
	Geri dönüş değeri olan metotlar akışın her noktasında bir değere dönmelidir. Aksi durumda error oluşur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Util {
	public static int sum()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());

		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());

	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Geri dönüş değeri olan metotlar akışın her noktasında bir değere dönmelidir. Aksi durumda error oluşur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;


class Util {
	public static int sum()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());

		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());

		int result = a + b;

		if (result > 20)
			return result * 2;
	}
}


/*---------------------------------------------------------------------------------------------------------------------
	Derleyici geri dönüş değerinin çağıran metoda aktarımını geçici değişken yaratan bir kod üreterek yapar. Aşağıdaki
	** ile belirtilen kod parçası için derleyicinin ürettiği temsili kod şu şekildedir:

		int temp = a + b;

		result = temp * 2;

	Yani aslında geri dönüş değeri geçici değişkene yapılan bir atama işlemidir. Geçici değişkenin türü metodun geri
	dönüş değerinin türü ile aynıdır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int result;

		result = Util.sum() * 2; //**
		System.out.println(result);
	}
}

class Util {
	public static int sum()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());

		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());

		return a + b;
	}
}


/*---------------------------------------------------------------------------------------------------------------------
	Derleyici geri dönüş değerinin çağıran metoda aktarımını geçici değişken yaratan bir kod üreterek yapar. Aşağıdaki
	** ile belirtilen kod parçası için derleyicinin ürettiği temsili kod şu şekildedir:

		int temp = a + b;

		result = temp;

	Yani aslında geri dönüş değeri geçici değişkene yapılan bir atama işlemidir. Geçici değişkenin türü metodun geri
	dönüş değerinin türü ile aynıdır.
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int result;

		result = Util.sum(); //**
		System.out.println(result);
	}
}

class Util {
	public static int sum()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());

		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());

		return a + b;
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Bir metodun geri dönüş değeri başka bir metodun geri dönüş değeri olarak verilebilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int result;

		result = Util.getSum();
		System.out.println(result);
	}
}

class Util {
	public static int getSum()
	{
		System.out.println("Toplama işlemi yapılıyor!...");

		return NumberUtil.sum(); //int temp2 = temp1;
	}
}

class NumberUtil {
	public static int sum()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());

		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());

		return a + b; //int temp1 = a + b
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Bir metodun geri dönüş değeri başka bir metodun geri dönüş değeri olarak verilebilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
    public static void main(String [] args)
    {
        int result;

        result = Util.getResult(); //result = temp1
        System.out.println(result);
    }
}

class Util {
    public static int getResult()
    {
        System.out.println("İşlemi yapılıyor!...");

        return NumberUtil.sum() * 2; //int temp1 = NumberUtil.sum() * 2;
        //int temp1 = temp2 * 2;
    }
}

class NumberUtil {
    public static int sum()
    {
        java.util.Scanner kb = new java.util.Scanner(System.in);

        System.out.print("Birinci sayıyı giriniz:");
        int a = Integer.parseInt(kb.nextLine());

        System.out.print("İkinci sayıyı giriniz:");
        int b = Integer.parseInt(kb.nextLine());

        return a + b; //int temp2 = a + b
    }
}

/*---------------------------------------------------------------------------------------------------------------------
	Geri dönüş değeri olan metotlar geri dönüş değeri işleme sokulmayacak şekilde çağrılabilirler. Şüphesiz metodun da
	tasarımı bu kullanım açısından anlamlı olmalıdır. Aşağıdaki örnekte sum metodu klavyeden alınan değerlerin toplamını
	ekrana basıp aynı zamanda da bu değere geri dönmektedir. Programcı kodda metodun ekrana basılmasıyla ilgilenmiş ve
	geri dönüş değerini kullanmamıştır. Şüphesiz başka bir senaryoda kullanabilir.

	Metot ekrana toplam değerini basmasaydı bu şekilde çağırma uygun olur muydu? İşimize yarar mıydı?
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		NumberUtil.sum();
		//code
	}
}

class NumberUtil {
	public static int sum()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());

		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());

		int result = a + b;

		System.out.println(result);

		return result;
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	void metotlarda return deyimi zorunluluğu yoktur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		NumberUtil.printSum();
	}
}

class NumberUtil {
	public static void printSum()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());

		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());

		int result = a + b;

		System.out.println(result);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	void metotlarda return deyimi istenirse metodu sonlandırmak için tek başına kullanılabilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		NumberUtil.printSum();
	}
}

class NumberUtil {
	public static void printSum()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());

		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());

		int result = a + b;

		if (result < 0)
			return;

		System.out.println(result);
	}
}


/*---------------------------------------------------------------------------------------------------------------------
	void metotlarda return deyimi ifade ile kullanılamaz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		NumberUtil.printSum();
	}
}

class NumberUtil {
	public static void printSum()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());

		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());

		int result = a + b;

		System.out.println(result);

		return result; //error
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	void metotlar geri dönüş değeri varmış gibi çağrılamaz. Yani void metot çağrısı geri dönüş değeri varmış gibi
	işleme sokulamaz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int result = NumberUtil.printSum();	//error
	}
}

class NumberUtil {
	public static void printSum()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());

		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());

		int result = a + b;

		System.out.println(result);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Metot bildiriminde metot isminden sonra parantezler arasında bildirilen değişkenlere "metot parametre değişkenleri"
	ya da "parametre değişkenleri" ya da "metodun parametreleri" denir. Bir metodun hiç parametresi olmayabilir ya da
	teorik olarak istenilen sayıda olabilir. Birden fazla parametresi olan metotların parametreleri virgül ile ayrılır.
	Metodun parametre değişkenleri faaliyet alanı (scope) bakımından metot başında bildirilen yerel değişkenler gibidir.
	Dikkat bu cümle faaliyet alanı bakımından aynı olduklarını söylemektedir. Sonuçta yerel değişken ve parametre değişkenleri
	aynı değildir.
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class NumberUtil {
	public static int sum(int a, int b) //NumberUtil.sum(12,34)
	{
		return a + b;
	}

	public static void printSquare(int a)
	{
		int result = a * a;

		System.out.println(result);
	}
}
//---------------------------------------------------------------------------------------------------------------------
package csd;

class App {
    public static void main(String [] args)
    {
        int x = 34;
        int y = 56;
        int z = 78;
        System.out.printf("%d%n",NumberUtil.sum(x,y,z));
        System.out.printf("%d%n",NumberUtil.calculateSquare(x));

    }
}

class NumberUtil {
    public static int sum(int a, int b,int c) //NumberUtil.sum(12,34)
    {
        return a + b + c;
    }

    public static int calculateSquare(int a)
    {
        return a * a;
    }
}
/*---------------------------------------------------------------------------------------------------------------------
	Metodun parametre değişkenlerine değerler metot çağrılırken verilir.  Metot çağrılırken bir parametresine verilen
	ifadeye "argüman (argument)" denir. Bir metot kaç tane parametreye sahipse o kadar sayıda argüman ile çağrılabilir.
	Argümanlardan parametrelere aktarım bir atama işlemidir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
    public static void main(String [] args)
    {
        java.util.Scanner kb = new java.util.Scanner(System.in);

        System.out.print("İki sayı giriniz:");
        int a = kb.nextInt();
        int b = kb.nextInt();
        int result = NumberUtil.sum(a, b); //NumberUtil.sum(12, 74)

        System.out.println(result);// 12 + 74 = 86
        NumberUtil.printSquare(result);
        NumberUtil.printSum(a, b);
    }
}

class NumberUtil {
    public static int sum(int a, int b)//int a = 12, int b = 74
    {
        return a + b;
    }

    public static void printSum(int a, int b)//int a = 12, int b = 74
    {
        int result = a + b;

        System.out.println(result);

    }

    public static void printSquare(int a)//int a = 86
    {
        int result = a * a;

        System.out.println(result);
    }
}

/*---------------------------------------------------------------------------------------------------------------------
	Bir metodun parametre değişkenleri aynı türden olsa bile tür yazılmalıdır. Aksi durumda error oluşur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;


class NumberUtil {
	public static int sum(int a, b) //error
	{
	    int a,b;
		return a + b;
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Metot çağrısında bir argümana ilişkin ifade önce hesaplanır, elde edilen değer argüman olarak metoda geçilir. Birden
	fazla parametreye sahip bir metot çağrısında tüm argümanlara ilişkin ifadeler hesaplanır, elde edilen değerler ile
	metot çağrılır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int result = NumberUtil.sum(a + 2, b - 8);

		System.out.println(result);
	}
}

class NumberUtil {
	public static int sum(int a, int b)//int a = a + 2
	{
		return a + b;
	}

	//...
}

/*---------------------------------------------------------------------------------------------------------------------
	Metot çağrısında bir argümana ilişkin ifade önce hesaplanır, elde edilen değer argüman olarak metoda geçilir. Birden
	fazla parametreye sahip bir metot çağrısında tüm argümanlara ilişkin ifadeler hesaplanır, elde edilen değerler ile
	metot çağrılır

	Anahtar Notlar: Aşağıdaki örnekte *** ile belirtilen deyime ilişkin ifadede kullanılan "compact" çözüm gibi kodlar
	okunabilirliği/algılanabilirliği etkilememelidir. Eğer böyle bir durum varsa ayrı ayrı hesaplanacak şekilde kodlar
	yazılmalıdır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();

		System.out.println(NumberUtil.sum(a + 2, b - 8)); //***
	}
}

class NumberUtil {
	public static int sum(int a, int b)
	{
		return a + b;
	}

	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	17.09.2022
-----------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte iki sum çağrısı arasında argümanlarda değişiklik olmamasına karşın programcı iki kere çağırmıştır.
	Bu durumda kod hem iki defa çağırmanın gereksizliği hem de okunabilirlik/algılanabilirlik açısından iyi yazılmamıştır.
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();

		System.out.println(NumberUtil.sum(a, b));

		//... (Burada a ve b değişkenlerinin değerleri değiştirilmiyor)

		System.out.println(NumberUtil.sum(a, b));
	}
}

class NumberUtil {
	public static int sum(int a, int b)
	{
		return a + b;
	}

	//...
}

/*---------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örnek aşağıdaki gibi bir çözümle daha iyi hale getirilebilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();

		int result = NumberUtil.sum(a, b);

		System.out.println(result);

		//... (Burada a ve b değişkenlerinin değerleri değiştirilmiyor)

		System.out.println(result);
	}
}

class NumberUtil {
	public static int sum(int a, int b)
	{
		return a + b;
	}

	//...
}

/*---------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte a değeri değiştiğinden sum metodu yeni a değeri için tekrar çağrılmıştır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();

		System.out.println(NumberUtil.sum(a, b));

		a = a - 3;
		//...

		System.out.println(NumberUtil.sum(a, b));
	}
}

class NumberUtil {
	public static int sum(int a, int b)
	{
		return a + b;//int temp = a + b;
	}

	//...
}

/*---------------------------------------------------------------------------------------------------------------------
	Metotlar ne işe yarar? Ya da başka bir deyişle bir problemin çözümünde neden metotlar yazalım? Bu sorular genel olarak
	aşağıdaki durumlar ile özetlenebilir:

	- Bir işi çok fazla yerde yapmak kod tekrarına yol açar. Yazılım geliştirmede temel prensip "zorunlu olmadıkça kod tekrarı
	yapılmamalıdır (do not repeat yourself)" şeklindedir. Bu durumda programcı bir metot yazarak ilgili yerlerde o metodu çağırır.

	- Bir problemin çözümü metot çağırma yerine her yerde kodun yazılması biçiminde "implemente" edilmişse, bu durumda
	programcı problemin çözümünde bir değişiklik yapmak isterse veya bir hata olduğunu görüp düzeltmek isterse her yerde
	bu değişiklikleri yapmak zorundadır. Bu da çoğu zaman zor olacaktır.

	- Bir problemin çözümü metot çağırma yerine her yerde kodun yazılması biçiminde "implemente" edilmişse, bu durumda
	kodun okunabilirliği/algılanabilirliği azalabilir. Yani metot çağırarak kodun okunabilirliği/algılanabilirliği artırılmış
	olur.

	- Metot yazıldığında başka projelere taşınarak da kullanılabilir (code re-usability).

	- Metodu çağıran programcı metodun nasıl yazıldığına ilişkin detayları bilmek zorunda değildir. Çünkü metodun
	çağrıldığı noktada metodun nasıl yazıldığının önemi yoktur. Ne yaptığı önemlidir.

	- Bir kod parçasının metot olarak yazılması onun bağımsız olarak test edilip doğrulanması veya varsa hataların
	düzeltilmesi açısından da önemlidir.

	Anahtar Notlar: İleride ele alacağımız "Nesne Yönelimli Programlama Tekniği (Object Oriented Programming Paradigm)"
	'ne ilişkin kavramlar ile kodun parçalara ayrılması metotlar dışında daha yüksek seviyede de yapılabilecektir. Yani
	kabaca bu tarz programlamanın temelinde metotlar vardır.
-----------------------------------------------------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------------------------------------------------
	printf metodu ekrana formatlı yazdırmak için kullanılan temel bir metottur. Metodun ilk argümanı bir String olmaldır.
	Metot bu argüman dışından istenildiği kadar argüman ile çağrılabilir. Metodun birinci parametresine ilişkin yazıda
	% karakteri ile birlikte geçerli bazı karakterler kullanıldığında "yer tutucu (place holder)" belirtilmiş olur. %
	ile birlikte kullanıma "format belirleyiciler (format specifiers)" denir. % ile birlikte kullılan karakterlere ise
	"format karakterleri (format characters)" denir.  Metot yer tutucular yerine diğer geçilen argümanlara ilişkin değerleri
	sırasıyla yerleştirir ve ekrana basar. Bazı format karakterleri bir argüman ilişkin değere karşılık gelmez. Bu tarz
	format karakterlerinin özel anlamları vardır. %d %f %b


	Anahtar Notlar: printf gibi değişken sayıda argüman alabilen metotlara "vararg methods" denir. Bu metotların nasıl
	yazılabildiği bu bölümde ele alınmayacaktır.

	Anahtar Notlar: printf metodu ve format karakterleri Java'da önemlidir. printf dışında format karakterlerini printf gibi
	kullanan başka yararlı metotlar da vardır.
	%d -> tamsayı türleri(long,int,short,byte)
	%f -> gerçek sayı türleri(float,double)
	%x,%h -> hexadecimal yazdırma(16'lık sistem) 1 2 3 ... 9 A B C D E F
	0x
	%o -> octal yazdırma(8'lik sistem)
	%b -> boolean türden yazdırma
	%c -> char türünden yazdırma
	%s -> string türünden
	Anahtar Notlar: Eğer bu türlerden herhangi biri kendisine uygun olmayan bir özel karakterle yazdırılmaya çalışılırsa
	exception throw edilir.
-----------------------------------------------------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------------------------------------------------
	Tamsayı türlerinin (short, int, long, byte) decimal formatlanması için d format karakteri kullanılır. printf metodu
	ile bir sonraki satırın başına geçmek için n format karakteri kullanılabilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
    public static void main(String [] args)
    {
        java.util.Scanner kb = new java.util.Scanner(System.in);

        System.out.print("Hava bugün kaç derece?");
        int today = Integer.parseInt(kb.nextLine());
        System.out.print("Yarın hava hava kaç derece?");
        int tomorrow = Integer.parseInt(kb.nextLine());

        System.out.printf("Bugün hava %d derece, yarın %d derece olacakmış%n", today, tomorrow);
        System.out.println("Tekrar yapıyor musunuz? " + today + " derece,yarın" + tomorrow + " derece olacaktır" );
    }
}


/*---------------------------------------------------------------------------------------------------------------------
	printf metodu ile x, X, h, H karakterleri kullanılarak tamsayı türlerine ilişkin değerler hexadecimal olarak
	formatlanabilir. Ayrıca o (küçük O) format karakteri ile tamsayı türlerine ilişkin değerler octal olarak formatlanabilir
	1 2 3 4 5 6 7 8 9 A B C D E F
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int a = Integer.parseInt(kb.nextLine());

		System.out.printf("a = %d%n", a);
		System.out.printf("a = %x%n", a);
		System.out.printf("a = %X%n", a);
		System.out.printf("a = %h%n", a);
		System.out.printf("a = %H%n", a);
		System.out.printf("a = %o%n", a);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	printf metodunda tamsayılar için hizalama yapılabilir. Aşağıdaki örnekte %08X yer tutucsu ile yazılan karakter sayısı
	8'den küçükse kalan karakterler sıfır yazılır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int a = Integer.parseInt(kb.nextLine());

		System.out.printf("a = %d%n", a);
		System.out.printf("a = %08X%n", a);
	}
}
/*---------------------------------------------------------------------------------------------------------------------
	printf metodunda tamsayılar için hizalama yapılabilir. Aşağıdaki örnekte %08X yer tutucsu ile yazılan karakter sayısı
	8'den küçükse kalan karakterler sıfır yazılır. Hizalamada %'den sonra sıfır yazılmazsa hizalama space karakteri ile
	yapılır. Şüphesiz aşağıdaki örnek için sıfır ile hizalanması daha uygundur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int a = Integer.parseInt(kb.nextLine());

		System.out.printf("a = %d%n", a);
		System.out.printf("a = %8X%n", a);
	}
}
/*---------------------------------------------------------------------------------------------------------------------
	printf metodunda tamsayılar için hizalama yapılabilir. Aşağıdaki örnekte tarih bilgisi hizalanarak gösterilmiştir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Gün ay ve yıl bilgilerini giriniz:");
		int day = kb.nextInt();
		int month = kb.nextInt();
		int year = kb.nextInt();

		System.out.printf("%02d/%02d/%04d%n", day, month, year);
	}
}
/*---------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Tamsayılar için formatlanın diğer ayrıntıları ileride ele alınacaktır.
-----------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------
	printf metodu ile gerçek sayılar (float ve double) f format karakteri ile formatlanabilir. f format karakteri
	% ile yalnız başına kullanıldığında sayının noktadan sonraki kısmını "bilimsel yuvarlama" ile yuvarlar
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		double a = kb.nextDouble();

		System.out.printf("a = %.20f%n", a);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	printf metodunda f format karakteri ile noktadan sonraki kısmın kaç basamak olarak formatlanacağı aşağıdaki gibi
	belirlenebilir. Geri kalan basamaklar yine bilimsel olarak yuvarlanır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		double a = kb.nextDouble();

		System.out.printf("a = %f%n", a);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Gerçek sayılar için formatlanın diğer ayrıntıları ileride ele alınacaktır.
-----------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------
	printf metodunda char türü için c format karakteri kullanılır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		char c = 46567;

		System.out.printf("c = %c%n", c);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	printf metodunda boolean türü için b format karakteri kullanılır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		boolean flag = true;

		System.out.printf("flag = %b%n", flag);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	printf metodunda uygun format karakteri kullanılmadığında genel olarak exception oluşur. Bu durumun istisnaları vardır.
	Ancak uygun format karakterini kullanmak gerekir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		char c = 46567;

		System.out.printf("c = %d%n", c);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Şüphesiz farklı türler uygun format karakterleri ile aynı printf metodunda kullanılabilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Numaranızı giriniz:");
		int number = Integer.parseInt(kb.nextLine());

		System.out.print("Notunuzu giriniz:");
		double grade = Double.parseDouble(kb.nextLine());

		System.out.printf("Numara: %d%nNot: %f%n", number, grade);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	printf metodunda s format karakteri ile tür ne olursa olsun formatlanabilir. Şüphesiz bu durumda türe özgü
	biçimler (hizalama vb.) kullanılamaz. Bu format karakterinin ayrıntıları ileride ele alınacaktır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Numaranızı giriniz:");
		int number = Integer.parseInt(kb.nextLine());

		System.out.print("Notunuzu giriniz:");
		double grade = Double.parseDouble(kb.nextLine());

		System.out.printf("Numara: %s%nNot: %s%n", number, grade);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	printf metodunda % karakterinden sonra uygun bir format karakter getirilmelidir. Bu durumda % karakteri yazı içerisinde
	gösterilecekse iki tane % karakteri bitişik olarak kullanılmalıdır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İndirim yüzdesini giriniz:");
		int ratio = Integer.parseInt(kb.nextLine());

		System.out.printf("Ürünlerimizde %% %d indirim yapılacaktır%n", ratio);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	printf metodunda % karakterinden sonra uygun bir format karakter getirilmelidir. Bu durumda % karakteri yazı içerisinde
	gösterilecekse iki tane % karakteri bitişik olarak kullanılmalıdır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İndirim yüzdesini giriniz:");
		int ratio = Integer.parseInt(kb.nextLine());

		System.out.printf("Ürünlerimizde %%%d indirim yapılacaktır%n", ratio);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar. printf metodunun format karakterleri ve kullanım biçimleri oldukça geniştir. Burada sadece temel olanlar
	ele alınmıştır. Diğer format karakterleri ve kullanım biçimleri konular içerisinde ele alınacaktır.
-----------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Klavyeden girilen 3 tane int türden değerin toplamını ve çarpımını aşağıdaki formatta ekrana
	basan programı yazınız:
	Girilen sayılar: 3 4 5 olsun

	  3 + 4 + 5 = 12
	  3 * 4 * 5 = 60
	şeklinde ekrana basılacaktır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
    public static void main(String[] args) {
        java.util.Scanner kb = new java.util.Scanner(System.in);
        System.out.println("Birinci sayıyı giriniz?");
        int a = Integer.parseInt(kb.nextLine());
        System.out.println("İkinci sayıyı giriniz?");
        int b = Integer.parseInt(kb.nextLine());
        System.out.println("Üçüncü sayıyı giriniz?");
        int c = Integer.parseInt(kb.nextLine());
        System.out.printf("%d + %d + %d = %d%n", a, b, c, a + b + c);
        System.out.printf("%d * %d * %d = %d%n", a, b, c, a * b * c);
    }
}
//-----------------------------------------------------------------------------------------------------------------------
package csd;

class App {
	public static void main(String [] args)
	{
		FindSumMultiplicationApp.run();
	}
}

class FindSumMultiplicationApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("3 tane sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int c = kb.nextInt();

		System.out.printf("%d + %d + %d = %d%n", a, b, c, a + b + c);
		System.out.printf("%d * %d * %d = %d%n", a, b, c, a * b * c);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Klavyeden girilen 3 tane int türden değerin toplamını ve çarpımını aşağıdaki formatta ekrana
	basan programı yazınız:
	Girilen sayılar: 3 4 5 olsun

	  3 + 4 + 5 = 12
	  3 * 4 * 5 = 60
	şeklinde ekrana basılacaktır.
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		FindSumMultiplicationApp.run();
	}
}


class FindSumMultiplicationApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("3 tane sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int c = kb.nextInt();

		System.out.printf("%d + %d + %d = %d%n", a, b, c, NumberUtil.sum(a, b, c));
		System.out.printf("%d * %d * %d = %d%n", a, b, c, NumberUtil.multiply(a, b, c));
	}
}

class NumberUtil {
	public static int sum(int a, int b, int c)
	{
		return a + b + c;
	}

	public static int multiply(int a, int b, int c)
	{
		return a * b * c;
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Bölme işlemi tamsayılar ile yapıldığında sonuç her zaman tamsayı türünden çıkar. Elde edilen değerin noktadan sonraki kısmı
	herhangi bir yuvarlama işlemi yapılmadan atılır. 10 / 3 = 3.33333  10 / 3 = 3

	Tamsayılar ile bölme işleminde paydanın sıfır olması durumunda exception oluşur.

	Bu durumların detayları ileride ele alınacaktır.

	Aşağıdaki örneği çeşitli değerler girerek çalıştırıp sonuçları gözlemleyiniz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("2 tane sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();

		double result = a / b;

		System.out.printf("%d / %d = %f%n", a, b, result);
	}
}
//-----------------------------------------------------------------------------------------------------------------------
package csd;

class App {
    public static void main(String [] args)
    {
        java.util.Scanner kb = new java.util.Scanner(System.in);
        System.out.println("birinci sayıyı giriniz?");
        int a = Integer.parseInt(kb.nextLine());
        System.out.println("İkinci sayıyı giriniz?");
        int b = Integer.parseInt(kb.nextLine());
        double result = a / b;
        System.out.printf("result : %f%n",result);
    }
}
/*---------------------------------------------------------------------------------------------------------------------
	Gerçek sayılar ile bölme işleminde payda sıfır olsa bile işlem yapılıyor. Yani exception oluşmaz. Gerçek sayılar
	içerisinde genel olarak Matematik'teki "belirsizlik" için kullanılan "Not a Number (NaN)" değeri vardır. Ayrıca
	genel olarak sonsuzluk (Matematik'teki tanımsızlık) için kullanılan -Infinity ve +Infinity değerleri de vardır.
	Bu özel değerler dışında da başka özel değerler bulunmaktadır. Bu durumda gerçek sayılar ile bölme işleminde pay
	sıfırdan farklı, payda sıfır ise payın işaretine göre +Infinity veya -Infinity, pay ve paydanın her ikisi birden
	sıfır ise NaN sonucu elde edilir.

	Aşağıdaki örneği çeşitli değerler girerek çalıştırıp sonuçları gözlemleyiniz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("2 tane sayı giriniz:");
		double a = kb.nextDouble();
		double b = kb.nextDouble();

		double result = a / b;

		System.out.printf("%f / %f = %f%n", a, b, result);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	18.09.2022
-----------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------
	Neden standart metotları kullanmalıyız? Standart olarak var olan metodu programcı yazmalı mıdır?
	Java'da standart olarak (JavaSE) bulunan metotların kullanılmasının bazı önemli avantajları şunlardır:
	- Okunabilir kodlar yazılır.

	- Testleri yapılmıştır ve yeterince etkin olarak yazılmıştır. Hatta zaman içerisinde duruma göre daha etkin hale
	getirilebilmektedir.

	- Taşınabilirdir.

	- Bazı metotları (ki bunların sayısı oldukça fazladır) yazmak için başka detay konuların da bilinmesi gerekir.

	- Programcının projede sadece kendi konusuna odaklanmasını sağlar.

	Bu durumda bir Java programcısı çözmesi gereken bir problem için JavaSE'de problemin çözümüne ilişkin metotlar varsa
	onları kullanmalıdır. Yoksa yazma işlemine yönelmelidir. Ancak bu durum programcının standart kullandığı metotların
	nasıl yazıldığını gözardı etmesi anlamına gelmez. Programcı proglama yaşamı boyunca hepsini olmasa da hazır olarak
	kullandıklarının nasıl "implemente" edilebileceğini öğrenmelidir. Bazı durumlarda JavaSE'de olmayan ancak önemli ve
	iyi yazılmış bazı kütüphanelerde istenen işlem bulunabilir. Bu durumda programcı bunları da kullanabilir.
-----------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------
	Math sınıfının abs metodu
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		double a = kb.nextDouble();

		System.out.printf("|%f| = %f%n", a, Math.abs(a));
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Math sınıfının sqrt metodu negatif değerler için NaN değerine geri döner
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		double a = kb.nextDouble();

		System.out.printf("sqrt(%f) = %f%n", a, Math.sqrt(a));
	}
}


/*---------------------------------------------------------------------------------------------------------------------
	Math sınıfının pow metodu
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Taban ve üs değerlerini giriniz:");
		double a = kb.nextDouble();
		double b = kb.nextDouble();

		System.out.printf("pow(%f, %f) = %f%n", a, b, Math.pow(a, b));
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı double türden x1, y1, x2, y2 koordinat bilgilerine göre iki nokta arasındaki
	((x1, y1) ve (x2, y2)) uzaklığa geri dönen distance isimli metodu PointUtil isimli bir sınıf içerisinde yazınız ve
	aşağıdaki kod ile test ediniz.
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		DistanceTest.run();
	}
}

class DistanceTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Noktaların koordinat bilgilerini giriniz:");
		double x1 = kb.nextDouble();
		double y1 = kb.nextDouble();
		double x2 = kb.nextDouble();
		double y2 = kb.nextDouble();
		System.out.printf("Distance:%f%n", PointUtil.distance(x1, y1, x2, y2));
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class PointUtil {
	public static double distance(double x1, double y1, double x2, double y2)
	{
		return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı double türden x1, y1, x2, y2 koordinat bilgilerine göre iki nokta arasındaki
	((x1, y1) ve (x2, y2)) uzaklığa geri dönen distance isimli metodu PointUtil isimli bir sınıf içerisinde yazınız ve
	aşağıdaki kod ile test ediniz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		DistanceTest.run();
	}
}

class DistanceTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Noktaların koordinat bilgilerini giriniz:");
		double x1 = kb.nextDouble();
		double y1 = kb.nextDouble();
		double x2 = kb.nextDouble();
		double y2 = kb.nextDouble();

		System.out.printf("Distance:%f%n", PointUtil.distance(x1, y1, x2, y2));
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


class PointUtil {
	public static double distance(double x1, double y1, double x2, double y2)
	{
		double dx = x1 - x2;
		double dy = y1 - y2;

		return Math.sqrt(dx * dx + dy * dy);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı double türden x1, y1, x2, y2 koordinat bilgilerine göre iki nokta arasındaki
	((x1, y1) ve (x2, y2)) uzaklığa geri dönen distance isimli metodu PointUtil isimli bir sınıf içerisinde yazınız ve
	aşağıdaki kod ile test ediniz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		DistanceTest.run();
	}
}

class DistanceTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Noktaların koordinat bilgilerini giriniz:");
		double x1 = kb.nextDouble();
		double y1 = kb.nextDouble();
		double x2 = kb.nextDouble();
		double y2 = kb.nextDouble();

		System.out.printf("Distance:%f%n", PointUtil.distance(x1, y1, x2, y2));
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


class PointUtil {
	public static double distance(double x1, double y1, double x2, double y2)
	{
		return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Math sınıfının PI ve E elemanları
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.println(Math.PI);
		System.out.println(Math.E);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Math sınıfının trigonometrik işlem yapan metotları radyan ölçü birimi ile çalışır. Radyan ve derece arasındaki
	dönüştürmeler için toRadians ve toDegrees metotları kullanılabilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		double a = kb.nextDouble();

		System.out.printf("sin(%f) = %f%n", a, Math.sin(Math.toRadians(a)));
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Math sınıfının min ve max metotları
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("İki sayı giriniz:");
		double a = kb.nextDouble();
		double b = kb.nextDouble();

		System.out.printf("min(%f, %f) = %f%n", a, b, Math.min(a, b));
		System.out.printf("max(%f, %f) = %f%n", a, b, Math.max(a, b));
	}
}
/*---------------------------------------------------------------------------------------------------------------------
	Math sınıfının min ve max metotları ile 3 tane sayının en büyüğünün bulunması
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Üç sayı giriniz:");
		double a = kb.nextDouble();
		double b = kb.nextDouble();
		double c = kb.nextDouble();
		double d = kb.nextDouble();

		System.out.printf("min(%f, %f, %f) = %f%n", a, b, c, Math.min(Math.min(a, b), c));
		System.out.printf("max(%f, %f, %f) = %f%n", a, b, c, Math.max(Math.max(Math.max(a, b), c),d));
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Math sınıfının min ve max metotları ile 3 tane sayının en büyüğünün bulunması
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Üç sayı giriniz:");
		double a = kb.nextDouble();
		double b = kb.nextDouble();
		double c = kb.nextDouble();

		System.out.printf("min(%f, %f, %f) = %f%n", a, b, c, NumberUtil.min(a, b, c));
		System.out.printf("max(%f, %f, %f) = %f%n", a, b, c, NumberUtil.max(a, b, c));
	}
}

class NumberUtil {
	public static double min(double a, double b, double c)
	{
		return Math.min(Math.min(a, b), c);
	}

	public static double max(double a, double b, double c)
	{
		return Math.max(Math.max(a, b), c);
	}

	//...
}

/*---------------------------------------------------------------------------------------------------------------------
	Math sınıfının logXXX metotları
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		double a = kb.nextDouble();

		System.out.printf("log(%f) = %f%n", a, Math.log(a));
		System.out.printf("log10(%f) = %f%n", a, Math.log10(a));
		System.out.printf("log1p(%f) = %f%n", a, Math.log1p(a));
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Math sınıfının yuvarlama işlemi yapan metotları
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		double a = kb.nextDouble();

		System.out.printf("round(%f) = %d%n", a, Math.round(a));
		System.out.printf("ceil(%f) = %f%n", a, Math.ceil(a));
		System.out.printf("floor(%f) = %f%n", a, Math.floor(a));
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Sabitler (literals, constants):
	Program içerisinde doğrudan yazılan değerlere denir. Sabitlerin de türleri vardır. Derleyici sabitlerin türlerini
	tespit ederek (inference, deduction) işlem yapar. 10D 12F

	Sabitlerin türlerinin tespitlerine ilişkin detaylar:
	- Sayı nokta içermiyorsa, sonuna herhangi bir ek almamışsa ve int türü sınırları içerisindeyse int türdendir. Sayı
	int türü sınırları dışındaysa error oluşur.
	Örneğin: 100, 200, 500

	- Sayı nokta içermiyorsa ve sonuna L l(küçük veya büyük) ekini almışsa long türdendir. Sayı long türü sınırları dışındaysa
	error oluşur.
	Örneğin:
	10L, 3000000000L

	Anahtar Notlar: Küçük harf L karakteri 1(bir) rakamına benzediği için programlamada tercih edilmez.

	- Java'da byte ve short türden sabitler yoktur.

	- Sayı nokta içeriyorsa ve sonuna bir ek almamışsa double türdendir. Sayı double olarak ifade edilemiyor ise error
	oluşur.
	Örneğin:
	2.3, 0.456

	- Sayı nokta içersin ya da içermesin sonuna D (küçük veya büyük) ekini almışsa double türdendir.
	Örneğin:
	3D, 4d, 4.5D

	- Sayı nokta içersin ya da içermesin sonuna F (küçük ya da büyük) ekini almışsa float türdendir
	Örneğin:
	3F, 4.5F

	- boolean türden iki tane sabit vardır: true, false

	- char türden sabitler: İki tane tek tırnak arasında yazılan bir karakter, karakter tablosunda sıra numarası
	belirtir. Bu şekilde yazılan sabitlere "karakter sabitleri (character literals)" denir ve bu sabitler char türdendir.
	İki tane tek tırnak arasında özel durumlar dışında 1'den fazla karakter yazılması error oluşturur

	Bazı karakterlerin klavyeden basılması doğrudan derleyici tarafından karakter olarak algılanamaz. Hatta bazı karakterler
	"non-printable"'dır. Örneğin bir sonraki satıra geçme karakterinin karakter sabiti doğrudan yazılamaz. Bu tarz karakterlerin
	karakter sabitleri iki tane tek tırnak içerisinde ters bölü karakteri ile onu takip eden özel bir karakter ile yazılır.
	Bu şekilde yazılan karakterlere "escape sequence" karakterler denir. Hatta bazı karakterler hem normal hem de ters
	bölü ile yazılabilirler:

	Java'da desteklenen escape sequence karakterler şunlardır:

	'\n' -> line feed (LF)
	'\r' -> carriage return (CR)
	'\t' -> horizontal tab
	'\b' -> backspace
	'\f' -> form feed
	'\0' -> null karakter
	'\"' -> double quote (optional)
	'\'' -> single quote
	'\\' -> back slash
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
    public static void main(String [] args)
    {
        float fval = 10F / 3;
        double dval = 10D / 3;
        System.out.printf("%.20f%n",fval);
        System.out.printf("%.20f%n",dval);
    }
}
/*---------------------------------------------------------------------------------------------------------------------
	Karakter sabitleri
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		char c = 'D';

		System.out.printf("c = %c%n", c);
	}
}


/*---------------------------------------------------------------------------------------------------------------------
	Karakter sabitleri
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
    public static void main(String [] args)
    {
        char c1 = 'D';
        char c2 = 68;
        System.out.printf("c1 = %c%n", c1);
        System.out.printf("c2 = %c%n",c2);
    }
}
/*---------------------------------------------------------------------------------------------------------------------
	İki tane tek tırnak arasında özel durumlar dışında 1'den fazla karakter yazılması error oluşturur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		char c = 'da'; //error

		System.out.printf("c = %c%n", c);
	}
}
/*----------------------------------------------------------------------------------------------------------------------
	24.09.2022
-----------------------------------------------------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------------------------------------------------
	Line feed
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		char c = '\n';

		System.out.print("Hello");
		System.out.print(c);
		System.out.println("World");
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Carriage return karakter sabiti: Aşağıdaki kodu işletimi sisteminin komut torumlayıcı/terminal programında çalıştırarak sonucu
	gözlemleyiniz. Eclipse IDE programının console'unda aynı sonucu elde edemeyebilirsiniz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		char c = '\r';

		System.out.print("Hello");
		System.out.print(c);
		System.out.println("Hi");
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Horizontal tab karakter sabiti
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		char c = '\t';

		System.out.print("Hello");
		System.out.print(c);
		System.out.println("Hi");
	}
}


/*---------------------------------------------------------------------------------------------------------------------
	Backspace karakter sabiti: Aşağıdaki kodu işletimi sisteminin komut torumlayıcı/terminal programında çalıştırarak sonucu
	gözlemleyiniz. Eclipse IDE programının console'unda aynı sonucu elde edemeyebilirsiniz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		char c = '\b';

		System.out.print("Hello");
		System.out.print(c);
		System.out.println("Hi");
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	İki tırnak karakterinin karakter sabiti iki şekilde yazılabilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		char c1 = '"';
		char c2 = '\"';

		System.out.println(c1);
		System.out.println(c2);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	İki tırnak karakteri "string literal" içerisinde ters bölü ile yazılmalıdır. Aksi durumda error oluşur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.println("\"Hello World\"");
	}
}


/*---------------------------------------------------------------------------------------------------------------------
	Tek tırnak karakteri "string literal" içerisinde iki şekilde yazılabilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.println("\'Hello World\'");
		System.out.println("'Hello World'");
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Tek tırnak karakter sabiti ters bölü ile yazılmalıdır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		char c = '\'';

		System.out.println(c);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Ters bölü karakterinin karakter sabiti ters bölü ile yazılmalıdır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		char c = '\\';

		System.out.println(c);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte escape sequence karakterlerden dolayı istenilen sonuç elde edilemez
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.println("C:\target\names.dat");
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Yukarıdaki problem aşağıdaki gibi çözülebilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.println("C:\\target\\names.dat");
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Ters bölü karakterinden sonra özel karakter dışında yazılan bir karakter için error oluşur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		char c = '\h'; //error

		System.out.println("C:\host\ips.txt"); //error
	}
}


/*---------------------------------------------------------------------------------------------------------------------
	\\192.168.1.123\target\names.dat yol ifadesinin "string literal" içerisinde yazılması
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.println("\\\\192.168.1.123\\target\\names.dat");
	}
}
/*---------------------------------------------------------------------------------------------------------------------
	Aşağıdaki karakter tek tırnak karakteri değildir (backtick)
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		char c = '`';

		System.out.println(c);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Ters bölü u karakteri ile bir karakterin sıra numarası hexadecimal olarak tek tırnak içerisinde yazıldığında
	o karaktere karaktere ilişkin karakter sabiti yazılmış olur. Burada hexadecimal sayı kesinlikle iki byte olarak
	yani 4 tane hex digit olarak yazılmalıdır. Aksi durumda error oluşur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		char c = '\u00C6';

		System.out.println(c);
	}
}
/*----------------------------------------------------------------------------------------------------------------------
	Ters bölü u karakteri ile yazılan karakter sabitleri "string literal" içerisinde de kullanılabilir.
	Otomotiv
	Banka
	Gömülü Yazılım -> ip tv,stm32,savunma sanayi, pos makineleri(Hugin)

-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.println("ab\u00C6def");
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Ters bölü u ile yazılan karakterler değişken isimlendirmede kullanılabilir. Şüphesiz pratik değildir. Örnek
	durumu anlatmak için yazılmıştır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int \u0041\u0042\u00C6 = 10;

		System.out.println(AB\u00C6);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Bir tamsayı sabitinin öneki yoksa bu durumda sabit "decimal" olarak ele alınır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;

		System.out.println(a);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Bir tamsayı sabitinin önüne bitişik olarak sıfır ve x (büyük veya küçük) yazıldığında bu ekten sonra gelen basamaklar
	"hexadecimal" olarak ele alınır.
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 0xA;//1010

		System.out.println(a);
	}
}
/*---------------------------------------------------------------------------------------------------------------------
	Bir tamsayı sabitinin önüne bitişik olarak sıfır yazıldığında bu ekten sonra gelen basamaklar "octal" olarak ele alınır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 012;

		System.out.println(a);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Bir tamsayı sabitinin önüne bitişik olarak sıfır ve b (büyük veya küçük) yazıldığında bu ekten sonra gelen basamaklar
	"binary" olarak ele alınır. İkilik sistemde yazılan sabitler Java 7 ile eklenmiştir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 0b1010; //Since Java 7

		System.out.println(a);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte DeviceUtil sınıfının out metou 16 tane pini olan bir elektronik devre için aldığı argüman değerine
	göre, değerin bit'lerine karşılık gelen pinleri 1 ya da sıfır için "high" ya da "low" seviyeye çekiyor olsun. Bu durumda
	böyle bir metodun alacağı sabit argümanın "binary" veya hexadecimal olarak yazılması okunabilirliği artırır. Ayrıca
	yazım kolaylığı da sağlar. Aşağıdaki demo örneği anlatılan senaryoya göre düşününüz.
	F    F
	1111 1111
	E    F
	1110 1111
	A    A
	1010 1010
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		short value = 0b10101;

		DeviceUtil.out(value);

		value = 0x15;

		DeviceUtil.out(value);
	}
}


class DeviceUtil {
	public static void out(short value)
	{
		System.out.printf("value = %04X%n", value);
		//...
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	 Gerçek sayıların üstel gösterilişi (bilimsel gösterilişi)
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		double a = 1.3E2;
		double b = 1.3e2;
		double c = 1.4E-2;
		double d = 1.4e-2;

		System.out.printf("a = %f%n", a);
		System.out.printf("b = %f%n", b);
		System.out.printf("c = %f%n", c);
		System.out.printf("d = %f%n", d);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Java 7 ile birlikte tamsayı ve gerçek sayı sabitlerinin basamakları arasında alttire karakteri kullanılabilmektedir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 0x00_FA_BC_D0;

		System.out.printf("a = %d%n", a);
		System.out.printf("a = %X%n", a);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Java 7 ile birlikte tamsayı ve gerçek sayı sabitlerinin basamakları arasında alttire karakteri kullanılabilmektedir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		double a = 56_789.3_456_789;

		System.out.printf("a = %f%n", a);

	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Alttire karakteri kullanılabildiği yerde istenildiği sayıda kullanılabilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 1_________________________________________0;

		System.out.printf("a = %d%n", a);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Java 7 ile birlikte tamsayı ve gerçek sayı sabitlerinin basamakları arasında alttire karakteri kullanılabilmektedir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		long a = 5_678_290_123L;

		System.out.printf("a = %d%n", a);
		System.out.printf("a = %X%n", a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Alttire kullanımı genel olarak sadece basamaklar arasında geçerlidir. Aksi durumda error oluşur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		long a = _5_678_290_123L; //error
		int b = 0x_1FC0; //error
		int c = 0x1FC0_; //error
		double d = 123_.345; //error
		long e = 5_678_290_123L_; //error


	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Octal sabitler için sıfır öneki ile sabit arasında alttire kullanımı geçerlidir. Bu bir istisna durumdur.
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 0_12;

		System.out.println(a);
	}
}
/*----------------------------------------------------------------------------------------------------------------------
    Soru: Aşağıdaki programın ekran çıktısı ne olur.(Huawei mülakat sorusu)
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
    public static void main(String [] args)
    {
        int x = 090;
        System.out.printf("%d",x);
    }
}
/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Alttire kullanımı okunabilirliği/algınabililiği artırmak için tercih edilir. Şüphesiz bu tercih
	anlamlı kullanılmalıdır. Anlamsız kullanımı okunabilirliği/algılanabilirliği azaltır.
-----------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------
	 Gerçek sayı sabitlerinin tamsayı kısmının değeri sıfır ise noktadan önce sıfır yazılmayabilir. Benzer şekilde
	 sayının noktadan sonraki kısmının değeri sıfır ise yine sıfır noktadan sonra yazılmayabilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		double a, b;

		a = .3;
		b = 3.;

		System.out.printf("a = %f%n", a);
		System.out.printf("b = %f%n", b);

	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Yalnızca sabitlerden ve operatörlerden oluşan yani içerisinde değişken olmayan ifadeşlere "sabit ifadesi (constant expression)"
	denir. Bu anlamda bir sabit de tek başına bir sabit ifadesidir.

	Anahtar Notlar: İleride aslında sabit ifadesi olarak kullanılabilen değişkenler de göreceğiz. Bu tarz değişkenler de
	bir ifade içerisinde sabit olarak ele alınır.
-----------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------
	01.10.2022
-----------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------
	Derleyiciler sabit ifadelerinin değerlerini hesaplayarak sonucu "byte code"'a yazarlar. Bu optimizasyona
	"constant folding optimization" denir. Bu sebeple 1000L * 60 * 60 * 24 * 365 ifadesinin değeri byte code'a
	31536000000 olarak yazılır. Aşağıdaki örnekte bilgi kaybı olmaması için 1000 sabiti long olarak yazılmıştır. Bu konu
	ileride ele alınacaktır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		long divider = 1000L * 60 * 60 * 24 * 365; //byte code karşılığı -> long divider = 31536000000L;

		System.out.println(divider);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Operatörler: Bir işleme yol açan ve işlem sonucunda bir değer üreten atomlara operatör denir. Operatör ile birlikte
	işleme giren ifadelere "operand" denir.

	Operatörler 3 biçimde sınıflandırılabilir:
	1. İşlevlerine göre sınıflandırma
		- Aritmetik (arithmetic) operatörler(* / % + -)
		- Karşılaştırma (comparison) operatörleri(<= >= == != < > )
		- Mantıksal (logical) operatörler(&& || !)
		- Bitsel (bitwise) operatörler(& | ^  << >> ~)
		- Özel amaçlı (special purpose) operatörler(instanceof)

	2. Operand sayısına göre sınıflandırma
		- Tek operandlı (unary) -a
		- İki operandlı (binary) a || b, a + b
		- Üç operandlı (ternary) <ifade1> ? <ifade2> : <ifade3>
	3. Operatörün konumuna göre sınıflandırma
		- önek (prefix)(++ --)
		- araek (infix)(!= == >= <= < >)
		- sonek (postfix)(++ --) a++ , b++

	Operatörün kısıtı (constraint)
	Operatörün ürettiği değer (product value)
	Operatörün yan etkisi (side effect) var mı? Operatör operand ya da operandlarının değerini değiştiriyor mu?
	Operatörün önceliği (precedence):
	a = b + c * d ifadesinin derleyicinin ürettiği kodda yapılma sırası şu şekildedir:

	i1: c * d
	i2: b + i1
	i3: a = i2

	a = (b + c) * d ifadesinin derleyicinin ürettiği kodda yapılma sırası şu şekildedir:

	i1: b + c
	i2: i1 * d
	i3: a = i2

	Anahtar Notlar: Java programcısı bir operatör için yukarıdaki durumları bilmelidir. Yani bir operatörün öğrenilmesi
	o operatör için yukarıdaki durumların bilinmesi anlamına gelir.

	Anahtar Notlar: Bazı operatörler öncelik kurallarına doğrudan uymazlar. Bu tarz operatörlerin de uymadıkları durum
	için nasıl çalıştığının bilinmesi gerekir. Bu operatörlerin öncelik kurallarına doğrudan uymamalarının da
	"gerekçeleri (rationale)" vardır.

	Anahtar Notlar: Operatör öncelik tablosu gruplandırma olarak düşünülebilir. Yani öncelik tablosundaki durumların
	istisnaları olabilir. Şüphesiz bunlarında bilinmesi gerekir. Operatör öncelik tablosu algısal bakımdan kolaylaştırmak
	için vardır.
-----------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------
	Aritmetik 4 işlem ve mod operatörleri iki operandlı (binary) ve araek (infix) operatörlerdir. Bu operatörlerin
	ürettikleri değer (product value) işlem sonucunda elde edilen değerdir. Bu operatörlerin yan etkisi (side effect) yoktur.
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İki tane sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();

		System.out.printf("%d + %d = %d%n", a, b, a + b);
		System.out.printf("%d * %d = %d%n", a, b, a * b);
		System.out.printf("%d - %d = %d%n", a, b, a - b);
		System.out.printf("%d / %d = %d%n", a, b, a / b);
		System.out.printf("%d %% %d = %d%n", a, b, a % b);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Mod operatörünün birinci operandı negatif ise sonuç negatif çıkar. İkinci operandının negatif olmasının bir önemi
	yoktur. Başka bir deyişle mod operatörünün sonucunun işareti birinci operandının işareti ile aynıdır. Adeta birinci
	operandının mutlak değeri ile işlem yapılır ve birinci operandın işareti sonucun işaretini belirler
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İki tane sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();

		System.out.printf("%d %% %d = %d%n", a, b, a % b);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Aynı seviyedeki operatörler işleme sokulduğunda genel olarak o seviyedeki operatörlerin hangi
	sırada işleme girdiğine "ilişkisi (associativity)" denir. Bazı operatörler "soldan sağa (left associative)", bazı
	operatörler "sağdan sola (right associative)" işleme girerler.
-----------------------------------------------------------------------------------------------------------------------*/
 a = b / c * d;
 i1 : x = b / c
 i2 : y = x * d
 i3 : a = y
/*---------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı en fazla 3 basamaklı int türden bir sayının basamakları toplamına geri
	dönen digitsSum isimli metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod test ediniz.

	Açıklamalar:
		- Metot aldığı argümana ilişkin değerin 3 basamaktan fazla olup olmama kontrolünü yapmayacaktır
		- Basamakları toplamı pozitif olarak döndürülecektir.
		abc 123 / 10 = 12
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
    public static void main(String [] args)
    {
        digitsSumTest.run(new java.util.Scanner(System.in));
    }
}

class digitsSumTest{
    public static void run(java.util.Scanner kb)
    {
        System.out.println("Üç basamaklı bir sayı giriniz?");
        int val = Integer.parseInt(kb.nextLine());
        System.out.printf("%d",NumberUtil.digitsSum(val));
    }
}

class NumberUtil{
    public static int digitsSum(int val)
    {
        int ones = val % 10;
        int tens = val / 10 % 10;
        int hundreds = val / 100;
        return Math.abs(ones + tens + hundreds);
    }
}
//---------------------------------------------------------------------------------------------------------------------
package csd;

class App {
	public static void main(String [] args)
	{
		DigitsSumTest.run();
	}
}

class DigitsSumTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = kb.nextInt();

		System.out.printf("%d sayısının basamakları toplamı: %d%n", val, NumberUtil.digitsSum(val));
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil {
	public static int digitsSum(int val)
	{
		int a, b, c;

		a = val / 100;
		b = val / 10 % 10; //val % 100 / 10;
		c = val % 10;

		return Math.abs(a + b + c);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	İşaret - operatörü tek operandlı (unary) ve önek (prefix) durumunda bir operatördür. Operatörün yan etkisi yoktur.
	Ürettiği değer operandının ters işaretlisidir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		int b;

		b = -a;

		System.out.printf("a = %d, b = %d%n", a, b);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	İşaret + operatörü tek operandlı (unary) ve önek (prefix) durumunda bir operatördür. Operatörün yan etkisi yoktur.
	Ürettiği değer operandının değeridir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		int b;

		b = +a;

		System.out.printf("a = %d, b = %d%n", a, b);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte ifade işaret - operatörünün sevisende bulunan operatörlerin sağdan sola (right associative) ele
	alınmasından dolayı geçerlidir. Programı çalıştırarak sonucu gözlemleyiniz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		int b;

		b = a - - - - - - - - - - - - 2;

		System.out.printf("a = %d, b = %d%n", a, b);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnek geçerlidir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a;

		a = - - - - - - - - - - - - 2;

		System.out.printf("a = %d%n", a);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	++ operatörü tek operandlı ve hem prefix hem de postfix olarak kullanılabilen bir operatördür. Bu operatör ister
	prefix ister postfix olarak kullanılsın operandına ilişkin değeri bir artırır. Yani operandının içerisindeki değerin
	1 fazlası ile değiştirir. Bu operatörün operandının değişken olması zorunludur.
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;

		++a; //a = a + 1;
		a++;// a += 1;
		System.out.printf("a = %d%n", a);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	++ operatörü tek operandlı ve hem prefix hem de postfix olarak kullanılabilen bir operatördür. Bu operatör ister
	prefix ister postfix olarak kullanılsın operandına ilişkin değeri bir artırır. Yani operandının içerisindeki değerin
	1 fazlası ile değiştirir. Bu operatörün operandının değişken olması zorunludur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;

		a++; //a = a + 1;

		System.out.printf("a = %d%n", a);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	++ operatörünün prefix kullanımında ürettiği değer yani işleme giren değer artırılmış değerdir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10, b;

		b = ++a;

		System.out.printf("a = %d, b = %d%n", a, b);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	++ operatörünün postfix kullanımında ürettiği değer yani işleme giren değer artırılMAmış değerdir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10, b;

		b = a++;

		System.out.printf("a = %d, b = %d%n", a, b);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	-- operatörü tek operandlı ve hem prefix hem de postfix olarak kullanılabilen bir operatördür. Bu operatör ister
	prefix ister postfix olarak kullanılsın operandına ilişkin değeri bir azaltır. Yani operandının içerisindeki değerin
	1 eksiği ile değiştirir. Bu operatörün operandının değişken olması zorunludur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;

		--a; //a = a - 1;

		System.out.printf("a = %d%n", a);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	-- operatörü tek operandlı ve hem prefix hem de postfix olarak kullanılabilen bir operatördür. Bu operatör ister
	prefix ister postfix olarak kullanılsın operandına ilişkin değeri bir azaltır. Yani operandının içerisindeki değerin
	1 eksiği ile değiştirir. Bu operatörün operandının değişken olması zorunludur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;

		a--; //a = a - 1;

		System.out.printf("a = %d%n", a);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	-- operatörünün prefix kullanımında ürettiği değer yani işleme giren değer azaltılmış değerdir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10, b;

		b = --a;

		System.out.printf("a = %d, b = %d%n", a, b);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	-- operatörünün postfix kullanımında ürettiği değer yani işleme giren değer azaltılMAmış değerdir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10, b;

		b = a--;

		System.out.printf("a = %d, b = %d%n", a, b);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	02.10.2022
-----------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte ++ ve -- operatörleri ve operandları aynı ifadede kullanılmıştır. Bu tarz ifadelerde
	okunabilirliğe/algılanabilirliğe dikkat edilmelidir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a, b;

		a = 10;

		b = a++ + a--;

		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}


/*---------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte ++ ve -- operatörleri ve operandları aynı ifadede kullanılmıştır. Bu tarz ifadelerde
	okunabilirliğe/algılanabilirliğe dikkat edilmelidir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a, b;

		a = 10;

		b = ++a + a--;

		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte ++ ve -- operatörleri ve operandları aynı ifadede kullanılmıştır. Bu tarz ifadelerde
	okunabilirliğe/algılanabilirliğe dikkat edilmelidir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a, b;

		a = 2;

		b = a-- + ++a * a;

		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Derleyici yukarıdan aşağıya ve soldan sağa olmak üzere anlamlı en uzun ifadeyi alacak şekilde atomlarına ayırma
	işlemi yapar (maximum munch). Aşağıdaki örnek bu kural dolayısıyla geçerlidir.
	a+++b -> a++ +b veya a+ ++b
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a, b, c;

		a = 2;
		b = 3;

		c = a+++b; //a++ + b;

		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
		System.out.printf("c = %d%n", c);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Derleyici yukarıdan aşağıya ve soldan sağa olmak üzere anlamlı en uzun ifadeyi alacak şekilde atomlarına ayırma
	işlemi yapar (maximum munch). Aşağıdaki örnek bu kural dolayısıyla geçersizdir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a, b, c;

		a = 2;
		b = 3;

		c = a++ + ++b; //error
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Okunabilirlik/algılanabilirlik açısından tek operandlı operatörleri genel olarak operandına bitişik
	biçimde yazacağız. İki operandlı operatörleri de özel ama önemli olan bazı operatörler dışında operandları ile
	operatör arasında yalnızca bir tane "space" karakteri olacak şekilde yazacağız
-----------------------------------------------------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a, b, c;

		a = 2;
		b = 3;

		c = a++-++b; // c = a++ - ++b;

		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
		System.out.printf("c = %d%n", c);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Temel karşılaştırma operatörleri 6 tanedir: <, >, <=, >=, ==, !=
	Bu operatörler iki operandlı ve araek durumunda operatörlerdir. Bu operatörlerin ürettiği değer boolean türdendir.
	Karşılaştırmanın sonucu doğru ise true, yanlış ise false değerini üretir. Bu operatörlerin yan etkisi yoktur.
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();

		System.out.printf("%d > %d -> %b%n", a, b, a > b);
		System.out.printf("%d < %d -> %b%n", a, b, a < b);
		System.out.printf("%d >= %d -> %b%n", a, b, a >= b);
		System.out.printf("%d <= %d -> %b%n", a, b, a <= b);
		System.out.printf("%d == %d -> %b%n", a, b, a == b);
		System.out.printf("%d != %d -> %b%n", a, b, a != b);
	}
}
/*---------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnek geçersizdir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
    public static void main(String [] args)
    {
        java.util.Scanner kb = new java.util.Scanner(System.in);
        System.out.print("İki sayı giriniz:");
        int a = kb.nextInt();
        int b = kb.nextInt();

        System.out.printf("%d > %d -> %b%n", a, b, 10 < b < 20); //error(true < 20)
    }
}
/*---------------------------------------------------------------------------------------------------------------------
	Metot çağırma operatörü
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int result;

		result = Util.sum(10, 20) * 2;

		System.out.printf("result = %d%n", result);
	}
}

class Util {
	public static int sum(int a, int b)
	{
		return a + b;
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	void bir metot çağrısı "void bir ifade (void expression)" olarak ele alınır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Util.print(10, 20);
	}
}

class Util {
	public static void print(int a, int b)
	{
		System.out.printf("a = %d, b = %d%n", a, b);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Mantıksal (Logical) Operatörler 3 tanedir: && (AND), || (OR), ! (NOT)

	&& ve || operatörleri iki operanlı ve arek durumunda, ! operatörü tek operandlı ve önek durumunda operatörlerdir.
	Bu 3 operatörün de operandları boolean türden olmalıdır. Bu 3 operatörün de ürettiği boolean türdendir. Bu operatörler
	matematikteki mantıksal operatörlere karşılık gelir.
	Ve operatörü(&&) : biri bile yanlışsa yanlış, her ikisi doğruysa doğru.
	Veya operatörü(||) : biri bile doğruysa doğru, ikisi de yanlışsa yanlış.
	1010 | 0101 = 1111
-----------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------
	&&  ve || operatörlerinin doğruluk tablosu aşağıdaki gibidir:

	op1			op2			op1 && op2			op1 || op2
	T			T				T					T
	T			F				F					T
	F			T				F					T
	F			F				F					F

	Yukarıdaki tabloya göre şu cümleler söylenebilir:
	"Mantıksal AND işlemi için, en az biri yanlışsa sonuç yanlıştır"
	"Mantıksal OR işlemi için, en az biri doğruysa sonuç doğrudur"
-----------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------
	&& ve || operatörlerine ilişkin aşağıdaki örneklerde yazılan metotlar tamamen durumu göstermek için yazılmıştır. Yani
	metotların geri dönüş değerlerinin sabit olması gerekmez. Operatörlerin davranışlarına odaklanınız
-----------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------
	&& operatörü
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		boolean result;

		result = Sample.foo() && Sample.bar();

		System.out.printf("result = %b%n", result);
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");

		return true;
	}

	public static boolean bar()
	{
		System.out.println("bar");

		return false;
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	|| operatörü
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		boolean result;

		result = Sample.bar() || Sample.foo();

		System.out.printf("result = %b%n", result);
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");

		return true;
	}

	public static boolean bar()
	{
		System.out.println("bar");

		return false;
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	|| operatörünün "kısa devre davranışı (short circuit behavior). Kısa devre davranışı doğru sonuca en kısa yoldan
	yani en çabuk biçimde ulaşacak şekilde çalışmaktadır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		boolean result;

		result = Sample.foo() || Sample.bar();

		System.out.printf("result = %b%n", result);
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");

		return true;
	}

	public static boolean bar()
	{
		System.out.println("bar");

		return false;
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	&& operatörünün "kısa devre davranışı (short circuit behavior). Kısa devre davranışı doğru sonuca en kısa yoldan
	yani en çabuk biçimde ulaşacak şekilde çalışmaktadır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		boolean result;

		result = Sample.bar() && Sample.foo();

		System.out.printf("result = %b%n", result);
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");

		return true;
	}

	public static boolean bar()
	{
		System.out.println("bar");

		return false;
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	&& ve || operatörlerinde doğru sonuca en kısa yoldan ulaşabilmek için (yani kısa devre davranışını uygulayabilmek için)
	ifadenin önce sol tarafı yapılır. Yani bu operatörler işlem sırasında işlem önceliğine uymazlar. Ancak operatör önceliğine
	uyulduğunda, yani matematiksel olarak (ya da kağıt üzerinde yapıldığında) elde edilen sonucu verirler. Şu cümle
	unutulmamalıdır:
	"&& ve || operatörleri doğru sonuca en kısa ve en çabuk yoldan erişirler". Yani derleyici bu operatörler için buna yönelik
	kod üretir.

	Aşağıdaki örnekte && operatörü || operatöründen yüksek öncelikli olmasına rağmen önce || işlemi yapılır. Ancak &&
	işlemi önce yapıldığında elde edilen sonucun aynısı elde edilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		boolean result;

		result = Sample.foo() || Sample.bar() && Sample.tar();

		System.out.printf("result = %b%n", result);
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");

		return true;
	}

	public static boolean bar()
	{
		System.out.println("bar");

		return false;
	}

	public static boolean tar()
	{
		System.out.println("tar");

		return false;
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte işlem sırası ile öncelik sırası aynıdır. Yine en soldaki önce yapılır. Yani Matematiksel olarak
	doğru sonuca en kısa ve çabuk yoldan ulaşılır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		boolean result;

		result = Sample.bar() && Sample.foo() || Sample.tar();

		System.out.printf("result = %b%n", result);
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");

		return true;
	}

	public static boolean bar()
	{
		System.out.println("bar");

		return false;
	}

	public static boolean tar()
	{
		System.out.println("tar");

		return false;
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz (Ömer Faruk CİN'in sorusu)
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		boolean result;

		result = Sample.bar() || Sample.tar() && Sample.bar() || Sample.foo();

		System.out.printf("result = %b%n", result);
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");

		return true;
	}

	public static boolean bar()
	{
		System.out.println("bar");

		return false;
	}

	public static boolean tar()
	{
		System.out.println("tar");

		return false;
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	"Bitwise AND (&)" ve "bitwise OR(|)" operatörleri tamsayılar ile kullanıldığında karşılıklı bit değerlerini işleme
	sokarak bir değer üretir. Bu operatörler de iki operandlı ve araek durumunda operatörlerdir. Bu operatörlerin de
	yan etkisi yoktur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10; //00000000000000000000000000001010
		int b = 11; //00000000000000000000000000001011
		int c;

		c = a & b; //00000000000000000000000000001010

		System.out.printf("c = %d%n", c);

		c = a | b; //00000000000000000000000000001011

		System.out.printf("c = %d%n", c);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	& ve | operatörleri özel olarak boolean türden ifadeler ile kullanıldıklarında kısa devre davranışı olmayan AND ve OR
	olarak düşünülmeldir. Yine bu operatörler için en soldaki ifade önce yapılır. Aşağıdaki örnekte && ve || operatörleri
	kullanıldığında elde edilen sonucun aynısı üretilir ancak tüm metotlar çağrılır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		boolean result;

		result = Sample.foo() | Sample.bar() & Sample.tar();

		System.out.printf("result = %b%n", result);
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");

		return true;
	}

	public static boolean bar()
	{
		System.out.println("bar");

		return false;
	}

	public static boolean tar()
	{
		System.out.println("tar");

		return false;
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Mantıksal DEĞİL (!) operatörünün doğruluk tablosu:

	op		!op
	T		 F
	F		 T
    !true = false;
    !false = true;
	! operatörü tek operandlı ve önek durumunda bir operatördür. Bu operatörün de operandının boolean türden olması
	zorunludur. Operatörün ürettiği değer operandına ilişkin ifadenin mantıksal değili olan boolean değerdir. Yani
	operandına ilişkin ifadenin değeri true ile false, false ise true değerini üretir
-----------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------
	! operatörü flag değişkenlerle aşağıdaki gibi kullanılabilir. Kod durumu göstermek için yazılmıştır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		boolean flag = true;

		//...

		flag = !flag;

		System.out.printf("flag = %b%n", flag);

		//...

		flag = !flag;

		System.out.printf("flag = %b%n", flag);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Atama (assignment)(=) operatörü iki operandlı araek durumunda bir operatördür. Bu operatörün birinci operandı değişken
	olmadır. Operatörün yan etkisi vardır. Bu operatör sağdan sola öncelikli (right associative) gruptadır. Atama
	operatörünün ürettiği değer ikinci operandının değeri yani atanan değerdir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a, b, c, d;

		a = b = c = d = 10;// a = 10 , b = 10, c = 10, d = 10;

		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
		System.out.printf("c = %d%n", c);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	 Aşağıdaki örnekte atama operatörünün operandının değişken olmamasından dolayı error oluşur. Burada ikinci atama
	 operatörünün operandının değişken olmaması durumu vardır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a, b = 2, c;

		(a = b) = c = 10; // error

		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
		System.out.printf("c = %d%n", c);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	 Aşağıdaki örnekte atama operatörünün operandının değişken olmamasından dolayı error oluşur. Burada üçüncü atama
	 operatörünün operandının değişken olmaması durumu vardır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a, b = 2, c;

		a = (b = c) = 10; // error

		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
		System.out.printf("c = %d%n", c);
	}
}


/*---------------------------------------------------------------------------------------------------------------------
	 Aşağıdaki örnekte error oluşmaz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a, b = 2, c;

		a =(b = (c = 10));

		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
		System.out.printf("c = %d%n", c);
	}
}


/*---------------------------------------------------------------------------------------------------------------------
	 Java'da bir grup işlemli atama operatörü vardır. Bu operatörlerin genel biçimi şu şekildedir:
	 	<ifade1> <op>= <ifade2> ifadesinin
	 yaklaşık karşılığı
	 	<ifade1> = <ifade1> <op> <ifade2>

	 Örneğin:
		 a += b; //a = a + b;
		 a -= b; //a = a - b;
		 a *= b; //a = a * b;
		 a /= b; //a = a / b;
		 a %= b; //a = a % b;

	İşlemli atama operatörlerinin ürettiği değer yine birinci opeandına atanan değerdir.

	Anahtar Notlar: Aslında işlemli atama operatörlerinin genel biçimi tam olarak yukarıdaki gibi değildir. Bu konu
	ileride ele alınacaktır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10, b = 20;

		a += b; // a = a + b;

		System.out.printf("a = %d%n", a);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	İşlemli atama operatörleri ifadeleri daha basit yazmak için tercih edilir. Aşağıdaki örneği inceleyiniz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10, b = 20, c = 30;

		a *= b + c; //a = a * (b + c);

		System.out.printf("a = %d%n", a);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte aynı seviyede olan *= ve += operatörleri "righ associative" olduğundan işlem sağdan sola doğru
	yapılır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10, b = 20, c = 30;

		a *= b += c; //a = a * (b = b + c);

		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
		System.out.printf("c = %d%n", c);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Şüphesiz yukarıdaki örnek aşağıdaki gibi de yapılabilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10, b = 20, c = 30;

		b += c;
		a *= b;

		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
		System.out.printf("c = %d%n", c);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Noktalı virgül sonlandırıcıdır (terminator). Genel olarak ifadeleri ayırmak için kullanılır. Java'da noktalı virgül
	dışında başka sonlandırıcı karakter yoktur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;

		++a;System.out.printf("a = %d%n", a);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Java'da genel olarak etkisiz (code has no effect) ifadeler geçersizdir, error oluşturur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;

		a + 2; //error
	}
}


/*---------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte error oluşmaz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample.foo();
	}
}

class Sample {
	public static void foo()
	{

	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte ++ operatörünün ürettiği değer artırılmamış değer olduğundan a 10 olur. İşlem sırası şu şekildedir:
	i1: a++
	i2: a = i1
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;

		a = a++;

		System.out.printf("a = %d%n", a);
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte ++ operatörünün ürettiği değer artırılmış değer olduğundan a sonuçta 11 olur. Doğrudan ++ uygulandığındaki
	değerle aynıdır. Bu anlamda aşağıdaki kodd atama işleminin etkisi yoktur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;

		a = ++a;

		System.out.printf("a = %d%n", a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	09.10.2022
-----------------------------------------------------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------------------------------------------------
	Deyimler (Statements): Bir programın çalıştırılan parçalarına denir. Bir program deyimlerin çalıştırılmasıyla çalışır.
	Java'da deyimler 5 gruba ayrılır:
	1. Basit deyimler (simple statements): Bir ifadenin sonuna noktalı virgül konduğunda artık basit deyimdir.
	++a;
	a += 4;
	2. Bileşik deyimler (compound statements): { ve } küme parantezi arasında kalan deyimlere küme parantezleri ile birlikte
	denir. Yani blok aslında bileşik deyimdir.
	{
	deyim1;
	deyim2;
	deyim3;
	}
	3. Bildirim deyimleri (declaration statements): Bildirime ilişkin deyimlerdir.
	int a;
	String town;
	char ch;
	Myclass m = new Myclass();//class object
	4. Kontrol deyimleri (control statements): Akışa yön veren deyimlerdir.
	return,break,continue,if,for,while,do-while,for-each,switch
	return val % 2 == 0;
	5. Boş deyim (null/empty statement): Tek başına noktalı virgüle denir.
	;
-----------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------
	Bir basit deyim çalıştırıldığında ilgili ifade hesaplanır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
    public static void main(String [] args)
    {
        int a = 10; //bildirim deyimi

        ++a; //basit deyim
        System.out.printf("a = %d%n", a); //basit deyim
    }
}

/*---------------------------------------------------------------------------------------------------------------------
	Bir bileşik deyim çalıştırıldığında ilgili bloğun içerisindeki tüm deyimler çalıştırılır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;

		{ //Bileşik deyim
			++a;
			System.out.printf("a = %d%n", a); //basit deyim

			{
				//...
			}
		}
	}
}


/*---------------------------------------------------------------------------------------------------------------------
	Bir bildirim deyimi çalıştırıldığında bellekte yer ayrılır.(stack bellek)
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10; //Bildirim deyimidir
		int b; //Bildirim deyimidir

		//...
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Boş deyim çalıştırıldığında hiç bir şey yapılmaz. Boş deyimin kullanıldığı durumlar zamanla ele alınacaktır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a;

		;;;;;;;


		;

		;
		;
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	if deyiminin genel biçimi:
	1 -> int
	0 -> int
	a != 0
	b >= 34
	a == 45
	if (<boolean türden bir ifade>)
		<deyim>
	[
	else
		<deyim>
	]

	if deyimi, varsa else kısmı ile birlikte tek bir deyimdir.
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int val = kb.nextInt();

		if (val % 2 == 0)
			System.out.println("Çift sayı girdiniz");
		else
			System.out.println("Tek sayı girdiniz");

		System.out.println("Tekrar yapıyor musunuz?");
	}
}
//----------------------------------------------------------------------------------------------------------------------
package csd;

class App {
    public static void main(String [] args)
    {
        java.util.Scanner kb = new java.util.Scanner(System.in);

        System.out.print("Bir sayı giriniz:");
        int val = Integer.parseInt(kb.nextLine());

        if (val % 2 == 0)
            System.out.println("Çift sayı girdiniz");
        else
            System.out.println("Tek sayı girdiniz");

        System.out.println("Tekrar yapıyor musunuz?");
    }
}
/*---------------------------------------------------------------------------------------------------------------------
	if deyiminde bileşik deyim kullanımı
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int val = kb.nextInt();

		if (val % 2 == 0) {
			System.out.println("Çift sayı girdiniz");
			val /= 2;
		}
		else {
			val *= 2;
			System.out.println("Tek sayı girdiniz");
		}

		System.out.printf("val = %d%n", val);
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*---------------------------------------------------------------------------------------------------------------------
	if deyiminde bileşik deyim kullanımı
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int val = kb.nextInt();

		if (val % 2 == 0) {
			System.out.println("Çift sayı girdiniz");
			val /= 2;
		}
		else
			System.out.println("Tek sayı girdiniz");


		System.out.printf("val = %d%n", val);
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	else kısmı olmayan if deyimi
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int val = kb.nextInt();

		if (val % 2 == 0)
			val /= 2;

		System.out.printf("val = %d%n", val);
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	if deyiminin parantezinden sonra yanlışlıkla noktalı virgül konması durumu
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int val = kb.nextInt();

		if (val % 2 == 0);
			val /= 2;

		System.out.printf("val = %d%n", val);
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte else bir if deyimine ait olmadığınmdan error oluşur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int val = kb.nextInt();

		if (val % 2 == 0);
			val /= 2;
		else //error
			val *= 2;

		System.out.printf("val = %d%n", val);
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte else kısmı içteki if deyimine ait olur (dangling else)
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int val = kb.nextInt();

		if (val > 0)
			if (val % 2 == 0)
				System.out.println("Pozitif ve çift sayı girdiniz");
		else
			System.out.println("Pozitif sayı girmelisiniz!...");


		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki "dangling else" durumu bileşik deyim kullanılarak çözülebilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int val = kb.nextInt();

		if (val > 0) {
			if (val % 2 == 0)
				System.out.println("Pozitif ve çift sayı girdiniz");
		}
		else
			System.out.println("Pozitif sayı girmelisiniz!...");

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte içteki if deyiminin de else kısmı olduğunda "dangling else" oluşmaz ve bileşik deyim kullanılması
	gerekmez
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int val = kb.nextInt();

		if (val > 0)
			if (val % 2 == 0)
				System.out.println("Pozitif ve çift sayı girdiniz");
			else
				System.out.println("Pozitif ve tek sayı girdiniz");
		else
			System.out.println("Pozitif sayı girmelisiniz!...");

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	if deyiminin  parantezinde boolean türden ifadeler için == ve != operatörleri kullanılması tavsiye edilmez
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int val = kb.nextInt();

		Util.printEvenStatus(val % 2 == 0);

		System.out.println("Tekrar yapıyor musunuz?");
	}
}


class Util {
	public static void printEvenStatus(boolean even)
	{
		if (even) //if (even == true)
			System.out.println("Çift sayı girdiniz");
		else
			System.out.println("Tek sayı girdiniz");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	if deyiminin  parantezinde boolean türden ifadeler için == ve != operatörleri kullanılması tavsiye edilmez
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int val = kb.nextInt();

		Util.printEvenStatus(val % 2 == 0);

		System.out.println("Tekrar yapıyor musunuz?");
	}
}


class Util {
	public static void printEvenStatus(boolean even)
	{
		if (!even) //if (even == false) ya da if (even != true)
			System.out.println("Tek sayı girdiniz");
		else
			System.out.println("Çift sayı girdiniz");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte isEven metodunda if deyiminin else kısmına gerek yoktur. Çünkü akış return deyimine geldiğinde
	metot sonlanır yani isEven içerisinde bir sonraki deyime geçmez. Bu durumda else yazılması iyi bir teknik değildir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int val = kb.nextInt();

		Util.printEvenStatus(NumberUtil.isEven(val));

		System.out.println("Tekrar yapıyor musunuz?");
	}
}


class Util {
	public static void printEvenStatus(boolean even)
	{
		if (even)
			System.out.println("Çift sayı girdiniz");
		else
			System.out.println("Tek sayı girdiniz");
	}
}

class NumberUtil {
	public static boolean isEven(int val)
	{
		if (val % 2 == 0)
			return true;
		else
			return false;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki isEven metodu if deyimi ile aşağıdaki gibi yazılabilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int val = kb.nextInt();

		Util.printEvenStatus(NumberUtil.isEven(val));

		System.out.println("Tekrar yapıyor musunuz?");
	}
}


class Util {
	public static void printEvenStatus(boolean even)
	{
		if (even)
			System.out.println("Çift sayı girdiniz");
		else
			System.out.println("Tek sayı girdiniz");
	}
}

class NumberUtil {
	public static boolean isEven(int val)
	{
		if (val % 2 == 0)
			return true;
		return false;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki isEven metodunun en iyi yazılışı aşağıdaki gibidir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int val = kb.nextInt();

		Util.printEvenStatus(NumberUtil.isEven(val));

		System.out.println("Tekrar yapıyor musunuz?");
	}
}


class Util {
	public static void printEvenStatus(boolean even)
	{
		if (even)
			System.out.println("Çift sayı girdiniz");
		else
			System.out.println("Tek sayı girdiniz");
	}
}

class NumberUtil {
	public static boolean isEven(int val)
	{
		return val % 2 == 0;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte geri dönüş değeri boolean olan bir metot çağrısı if deyiminde koşul ifadesi olarak kullanılmıştır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int val = kb.nextInt();

		if (NumberUtil.isEven(val))
			System.out.println("Çift sayı girdiniz");
		else
			System.out.println("Tek sayı girdiniz");

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil {
	public static boolean isEven(int val)
	{
		return val % 2 == 0;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int val = kb.nextInt();

		if (!NumberUtil.isEven(val))
			System.out.println("Tek sayı girdiniz");
		else
			System.out.println("Çift sayı girdiniz");

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil {
	public static boolean isEven(int val)
	{
		return val % 2 == 0;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte isOdd metodu için kod tekrarı yapılmadığına yani işi yapan başka bir metodun çağrıldığına dikkat ediniz.
	Yazılım geliştirmede "ZORUNLU OLMADIKÇA" kod tekrarı yapılmaması gerekir. Bu kavrama "DO NOT REPEAT YOURSELF" de denir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int val = kb.nextInt();

		if (NumberUtil.isOdd(val))
			System.out.println("Tek sayı girdiniz");
		else
			System.out.println("Çift sayı girdiniz");

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil {
	public static boolean isEven(int val)
	{
		return val % 2 == 0;
	}

	public static boolean isOdd(int val)
	{
		return !isEven(val);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte ** ile belirtilen if deyimi else kısmı ile birlikte tek bir deyimdir. Bu if deyiminin else kısmında
	başka bir if deyimi vardır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int val = kb.nextInt();

		if (val > 0) //**
			System.out.printf("%d sayısı pozitiftir%n", val);
		else
			if (val == 0)
				System.out.println("Sıfır sayısını girdiniz");
			else
				System.out.printf("%d sayısı negatiftir%n", val);


		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örnek daha okunabilir/algılanabilir olarak aşağıdaki gibi yazılabilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int val = kb.nextInt();

		if (val > 0)
			System.out.printf("%d sayısı pozitiftir%n", val);
		else if (val == 0)
			System.out.println("Sıfır sayısını girdiniz");
		else
			System.out.printf("%d sayısı nagatiftir%n", val);


		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki koşullar ayrıktır. Yani biri gerçekleştiğinde diğeri gerçekleşmez. Bu durumda kod doğru çalışsa bile
	aşağıdaki gibi yazılmamalıdır. else-if biçiminde yazılması (yukarıdaki gibi) hem okunabilir hem de gereksiz kontrollerin
	engellenmesi açısından önemlidir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int val = kb.nextInt();

		if (val > 0)
			System.out.printf("%d sayısı pozitiftir%n", val);
		if (val == 0)
			System.out.println("Sıfır sayısını girdiniz");
		if (val < 0)
			System.out.printf("%d sayısı negatiftir%n", val);

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki koşullar ayrık olmadığından örnek özelinde else-if biçiminde yazılması yanlış olur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int val = kb.nextInt();

		if (val > 11)
			System.out.println("val > 11");
		if (val > 6)
			System.out.println("val > 6");
		if (val > 10)
			System.out.println("val > 10");


		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	15.10.2022
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Katsayıları klavyeden alınan ikinci dereceden bir denklemin köklerini bulup ekrana yazdıran
	programı yazınız.
	a*x^2 + b*x + c = 0
	delta = b * b - 4*a*c
	Not: İleride daha iyisi yazılacaktır.
	delta > 0 -> iki tane farklı kök vardır.
	delta = 0 -> iki tane eşit kök vardır.
	delta < 0 -> Reel kök yok.
	x1 = (-b+sqrt(delta))/ (2 * a)
	x2 = (-b-sqrt(delta)) /(2 * a)
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
    public static void main(String [] args)
    {
        Operation.findRootsTest();
    }
}

class Operation{
    public static void findRootsTest()
    {
        java.util.Scanner kb = new java.util.Scanner(System.in);
        System.out.println("a katsayısını giriniz?");
        double a = Double.parseDouble(kb.nextLine());
        System.out.println("b katsayısını giriniz?");
        double b = Double.parseDouble(kb.nextLine());
        System.out.println("c katsayısını giriniz");
        double c = Double.parseDouble(kb.nextLine());
        findRoots(a,b,c);
    }
    public static void findRoots(double a,double b,double c)
    {
        double delta = calculateDelta(a,b,c);
        if(delta > 0){
            double sqrt_delta = Math.sqrt(delta);
            double x1 = (-b + sqrt_delta) / (2 * a);
            double x2 = (-b - sqrt_delta) / (2 * a);
            System.out.printf("x1 : %f%n",x1);
            System.out.printf("x2 : %f%n",x2);
        }
        else if(delta == 0){
            double x = -b / (2 * a);
            System.out.printf("x1 = x2 = %f%n",x);
        }
        else {
            System.out.println("Reel kök yok");
        }

    }
    public static double calculateDelta(double a,double b,double c)
    {
        return Math.pow(b,2) - 4 * a * c;
    }
}
//----------------------------------------------------------------------------------------------------------------------
package csd;

class App {
    public static void main(String [] args)
    {
        CalculateRootsTest.run(new java.util.Scanner(System.in));
    }
}

class CalculateRootsTest{
    public static void run(java.util.Scanner kb)
    {
        System.out.println("a katsayısını giriniz?");
        double a = Double.parseDouble(kb.nextLine());
        System.out.println("b katsayısını giriniz?");
        double b = Double.parseDouble(kb.nextLine());
        System.out.println("c katsayısını giriniz?");
        double c = Double.parseDouble(kb.nextLine());
        NumberUtil.CalculateRoots(a,b,c);

    }
}

class NumberUtil{
    public static void CalculateRoots(double a,double b,double c)
    {
        double delta = CalculateDelta(a,b,c);
        if(delta > 0){
            double sqrtDelta = Math.sqrt(delta);
            double x1 = (-b - sqrtDelta) / (2 * a);
            double x2 = (-b + sqrtDelta) / (2 * a);
            System.out.printf("x1 : %f%n",x1);
            System.out.printf("x2 : %f%n",x2);
        }
        else if(delta == 0){
            double x = -b / (2 * a);
            System.out.printf("x1 = x2 = %f%n",x);
        }
        else{
            System.out.println("Reel kök yok.");
        }
    }
    public static double CalculateDelta(double a,double b,double c)
    {
        return Math.pow(b,2) - 4 * a * c;
    }
}
/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki koşullar ayrık olmadığından örnek özelinde else-if biçiminde yazılması yanlış olur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
    public static void main(String [] args)
    {
        java.util.Scanner kb = new java.util.Scanner(System.in);
        System.out.println("a?");
        double a = Double.parseDouble(kb.nextLine());
        System.out.println("b?");
        double b = Double.parseDouble(kb.nextLine());
        System.out.println("c?");
        double c = Double.parseDouble(kb.nextLine());
        CalculateRoots.run(a,b,c);
    }
}

class CalculateRoots{
    public static void run(double a,double b,double c)
    {
        double delta = Math.pow(b,2) - 4 * a * c;
        if(delta > 0){
            double sqrt_delta = Math.sqrt(delta);
            double x1 = (-b + sqrt_delta) / (2 * a);
            double x2 = (-b - sqrt_delta) / (2 * a);
            System.out.printf("x1 : %f%n x2 : %f%n",x1,x2);
        }
        else if(delta == 0){
            double x = -b / (2 * a);
            System.out.printf("x1 = x2 = %f",x);
        }
        else{
            System.out.println("Reel kök yok");
        }
    }
}
//Başka bir çözüm
/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki koşullar ayrık olmadığından örnek özelinde else-if biçiminde yazılması yanlış olur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
    public static void main(String [] args)
    {
        CalculateRoots.calculateRootsTest();
    }
}
class CalculateRoots{
    public static void calculateRootsTest()
    {
        java.util.Scanner kb = new java.util.Scanner(System.in);
        System.out.println("a?");
        double a = Double.parseDouble(kb.nextLine());
        System.out.println("b?");
        double b = Double.parseDouble(kb.nextLine());
        System.out.println("c?");
        double c = Double.parseDouble(kb.nextLine());
        CalculateRoots.run(a,b,c);
    }
    public static void run(double a,double b,double c)
    {
        double delta = Math.pow(b,2) - 4 * a * c;
        if(delta > 0){
            double sqrt_delta = Math.sqrt(delta);
            double x1 = (-b + sqrt_delta) / (2 * a);
            double x2 = (-b - sqrt_delta) / (2 * a);
            System.out.printf("x1 : %f%n x2 : %f%n",x1,x2);
        }
        else if(delta == 0){
            double x = -b / (2 * a);
            System.out.printf("x1 = x2 = %f",x);
        }
        else{
            System.out.println("Reel kök yok");
        }
    }
}
//Başka bir çözüm
package csd;

class App {
	public static void main(String [] args)
	{
		QuadraticEquationSolverApp.run();
	}
}

class QuadraticEquationSolverApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Katsayıları giriniz:");
		double a = kb.nextDouble();
		double b = kb.nextDouble();
		double c = kb.nextDouble();

		QuadraticEquationSolver.printRoots(a, b, c);
	}
}

class QuadraticEquationSolver {
	public static void doWorkForDifferentRoots(double delta, double a, double b)
	{
		double sqrtDelta = Math.sqrt(delta);
		double x1, x2;

		x1 = (-b + sqrtDelta) / (2 * a);
		x2 = (-b - sqrtDelta) / (2 * a);

		System.out.printf("x1 = %f, x2 = %f%n", x1, x2);
	}

	public static void doWorkForSameRoots(double a, double b)
	{
		double x = -b / (2 * a);

		System.out.printf("x1 = x2 = %f%n", x);
	}

	public static double calculateDelta(double a, double b, double c)
	{
		return b * b - 4 * a * c;
	}

	public static void printRoots(double a, double b, double c)
	{
		double delta = calculateDelta(a, b, c);

		if (delta > 0)
			doWorkForDifferentRoots(delta, a, b);
		else if (delta == 0)
			doWorkForSameRoots(a, b);
		else
			System.out.println("Gerçek kök yok");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Katsayıları klavyeden alınan ikinci dereceden bir denklemin köklerini bulup ekrana yazdıran
	programı yazınız.
	Not: İleride daha iyisi yazılacaktır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		QuadraticEquationSolverApp.run();
	}
}

class QuadraticEquationSolverApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Katsayıları giriniz:");
		double a = kb.nextDouble();
		double b = kb.nextDouble();
		double c = kb.nextDouble();

		QuadraticEquationSolver.printRoots(a, b, c);
	}
}

class QuadraticEquationSolver {
	public static void doWorkForRoots(double delta, double a, double b)
	{
		double sqrtDelta = Math.sqrt(delta);
		double x1, x2;

		x1 = (-b + sqrtDelta) / (2 * a);
		x2 = (-b - sqrtDelta) / (2 * a);

		System.out.printf("x1 = %f, x2 = %f%n", x1, x2);
	}


	public static double calculateDelta(double a, double b, double c)
	{
		return b * b - 4 * a * c;
	}

	public static void printRoots(double a, double b, double c)
	{
		double delta = calculateDelta(a, b, c);

		if (delta >= 0)
			doWorkForRoots(delta, a, b);
		else
			System.out.println("Gerçek kök yok");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    for %50 while %40 do-while %10
	Döngü Deyimleri (Loop Statements):
	Bir işin yinelemeli olarak yapılması için kullanılan kontrol deyimlerine denir. Java'da döngü deyimleri şunlardır:
	1. while döngü deyimleri
		- Kontrolün başta yapıldığı while döngü deyimi (while döngüsü)
		- Kontrolün sonda yapıldığı while döngü deyimi (do-while deyimi)
		while(<boolean türden ifade>)// a > b a != b
		{
		    //code
		}
    do{
        //code
    }while(<boolean türden ifade>);
	2. for döngü deyimi
    for(;;)
	3. for-each döngü deyimi (enhanced for loop)

	Anahtar Notlar: Bu aşamadan itibaren tüm konular içerisinde "while döngüsü ya da while döngü deyimi" dediğimizde
	"kontrolün başta yapıldığı while döngü deyimi" anlaşılmalıdır. "Kontrolün sonda yapıldığı while döngü deyimi" için
	kısaca "do-while döngüsü" ya da "do-while döngü deyimi" diyeceğiz.
	%10 do-while
	%40 while
	%50 for deyimi
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Kontrolün başta yapıldığı while döngü deyiminin genel biçimi:

	while (<koşul ifadesi>)
		<deyim>

	Koşul ifadesi boolean türden olmalıdır. Bu döngü koşul ifadesi true olduğu sürece yinelenir. Akış while döngüsüne
	geldiğinde koşul kontrolü yapılır ve koşul gerçeklenmesze yani true değeri üretilmezse döngüye girilmez.
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
		int i = 0;

		while (i < n) {
			System.out.printf("%d ", i);
			++i;
		}

		System.out.println();
		System.out.printf("Döngü sonrası i = %d%n", i);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	while döngüsü ile n-kez dönen döngü
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
		int i = 0;

		while (i < n) {
			System.out.printf("%d ", i);
			++i;
		}

		System.out.println();
		System.out.printf("Döngü sonrası i = %d%n", i);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	while döngüsü ile n-kez dönen döngü
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
		int i = 1;

		while (i <= n) {
			System.out.printf("%d ", i);
			++i;
		}

		System.out.println();
		System.out.printf("Döngü sonrası i = %d%n", i);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	while döngüsü ile n-kez dönen döngü
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
		int i = n - 1;

		while (i >= 0) {
			System.out.printf("%d ", i);
			--i;
		}

		System.out.println();
		System.out.printf("Döngü sonrası i = %d%n", i);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	while döngüsü ile n-kez dönen döngü
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
		int i = n;

		while (i >= 1) {
			System.out.printf("%d ", i);
			--i;
		}

		System.out.println();
		System.out.printf("Döngü sonrası i = %d%n", i);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	while döngüsü ile n-kez dönen döngü:

	Örneğin n = 4 olsun
	Koşul kontrolleri							: 4 > 0 -> 3 > 0 -> 2 > 0 -> 1 > 0 -> 0 > 0
	Döngü içerisinde her adımda n'nin değeri	: 3 -> 2 -> 1 -> 0
	Sayaç									 	: 1 -> 2 -> 3 -> 4
	Döngü sonrası n'nin değeri					: -1

	Bu döngüde n-nin değerinin döngünün her adımında değiştiğine, dolayısıyla döngü sonrasında döngü öncesindeki değerin
	kaybedildiğine dikkat ediniz. Bu döngü kullanılacaksa ve döngüden sonra n-nin eski değerine ihtiyaç olacakse döngü
	öncesinde n-nin değeri saklanmalıdır. Bu kalıbın kullanılacağı zorunlu durumlar yoktur. Ancak bazı programcılar bu
	kalıbı kullanabilirler. Böyle bir kodun anlaşılmas açısında bu kalıp bilinmelidir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();

		while (n-- > 0)
			System.out.printf("%d ", n);

		System.out.println();
		System.out.printf("Döngü sonrası n = %d%n", n);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	while döngü deyiminde yanlışlıkla noktalı virgül konması durumu
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
		int i = 0;

		while (i < n); {
			System.out.printf("%d ", i);
			++i;
		}

		System.out.println();
		System.out.printf("Döngü sonrası i = %d%n", i);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	while döngüsünün parantezi içerisinde bir değişkene bir metodun geri dönüş değerinin atanıp, atanan değerin kontrolüne
	ilişkin algoritmalar yazılabilmektedir. Okunabilirliği/algılanabilirliği etkilemediği sürece aşağıdaki gibi while
	döngüleri yazılabilir.

	Aşağıdaki örnekte klavyeden sıfır girilen akadar alınan sayıların toplamı bulunmuştıor. while döngüsünün parantezi
	içerisindeki atama işlemine programcı tarafından öncelik verildiğine dikkat ediniz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("Sayıları girmeya başlayınız:");

		int sum = 0;
		int a;


		System.out.print("Bir sayı giriniz:");
		while ((a = Integer.parseInt(kb.nextLine())) != 0) {
			sum += a;
			System.out.print("Bir sayı giriniz:");
		}

		System.out.printf("Toplam: %d%n", sum);
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	while döngüsünün parantezi içerisinde bir değişkene bir metodun geri dönüş değerinin atanıp, atanan değerin kontrolüne
	ilişkin algoritmalar yazılabilmektedir. Okunabilirliği/algılanabilirliği etkilemediği sürece aşağıdaki gibi while
	döngüleri yazılabilir.

	Aşağıdaki örnekte klavyeden sıfır girilen akadar alınan sayıların toplamı bulunmuştıor. while döngüsünün parantezi
	içerisindeki atama işlemine programcı tarafından öncelik verildiğine dikkat ediniz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("Sayıları girmeya başlayınız:");

		int sum = 0;
		int a;


		while ((a = kb.nextInt()) != 0)
			sum += a;

		System.out.printf("Toplam: %d%n", sum);
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	while döngüsünün parantezi içerisinden değişken bildirimi geçersizdir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("Sayıları girmeya başlayınız:");

		int sum = 0;

		while ((int a = kb.nextInt()) != 0) //error
			sum += a;

		System.out.printf("Toplam: %d%n", sum);
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Klavyeden sıfır girilene kadar alınan sayıların pozitif ve negatif olanlarının ayrı ayrı toplamını ve
	pozitif ve negatif olanlarından kaçar tane girildiğini bulan ve ekrana uygun mesajları yazdıran programı yazınız
	Açıklamalar:
		- Hiç pozitif sayı ve/veya negatif girilmemişse, sayıların girilmediğine ilişkin mesajlar verilecektir. Örneğin:
		Hiç pozitif sayı girmediniz!...
		- Mesajları dilediğiniz gibi verebilirsiniz
		- Her adımda sayı isteme mesajı verilecektir. Örneğin: Bir sayı giriniz:
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
    public static void main(String [] args)
    {
        Operation.printNumbers(new java.util.Scanner(System.in));
    }
}

class Operation{
    public static void printNumbers(java.util.Scanner kb)
    {
        System.out.println("Sayıları girmeye başlayınız");
        int val;
        int posSum = 0, posCount = 0;
        int negSum = 0,negCount = 0;

        while((val = Integer.parseInt(kb.nextLine()))!= 0){
            if(val > 0){
                posSum += val;
                posCount++;
            }
            else{
                negSum += val;
                negCount++;
            }
        }
        printNegatives(negSum,negCount);
        printPositives(posSum,posCount);
    }
    public static void printNegatives(int negSum,int negCount)
    {
        if(negCount == 0){
            System.out.println("Hiç negatif sayı girmediniz!");
        }
        else {
            System.out.printf("%d tane negatif sayı girildi toplamları : %d%n",negCount,negSum);
        }
    }
    public static void printPositives(int posSum,int posCount)
    {
        if(posCount == 0){
            System.out.println("Hiç pozitif sayı girmediniz!");
        }
        else {
            System.out.printf("%d tane pozitif sayı girildi toplamları : %d%n",posCount,posSum);
        }
    }
}
//-----------------------------------------------------------------------------------------------------------------------
package csd;

class App {
	public static void main(String [] args)
	{
		FindPosNegSumCountsApp.run();
	}
}

class FindPosNegSumCountsApp {
	public static void printPositivesResult(int posSum, int posCount)
	{
		if (posCount != 0)
			System.out.printf("%d tane pozitif sayının toplamı:%d%n", posCount, posSum);
		else
			System.out.println("Hiç pozitif sayı girmediniz!...");
	}

	public static void printNegativesResult(int negSum, int negCount)
	{
		if (negCount != 0)
			System.out.printf("%d tane negatif sayının toplamı:%d%n", negCount, negSum);
		else
			System.out.println("Hiç negatif sayı girmediniz!...");
	}

	public static void printResult(int posSum, int posCount, int negSum, int negCount)
	{
		printPositivesResult(posSum, posCount);
		printNegativesResult(negSum, negCount);
	}

	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("Sayıları girmeye başlayınız:");

		int posCount, posSum, negCount, negSum;

		posCount = negCount = 0;
		posSum = negSum = 0;

		int val;

		System.out.print("Bir sayı giriniz:");
		while ((val = Integer.parseInt(kb.nextLine())) != 0) {
			if (val > 0) {
				posSum += val;
				++posCount;
			}
			else {
				negSum += val;
				++negCount;
			}

			System.out.print("Bir sayı giriniz:");
		}

		printResult(posSum, posCount, negSum, negCount);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	16.10.2022
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Klavyeden sıfır girilene kadar alınan sayıların pozitif ve negatif olanlarının ayrı ayrı toplamını ve
	pozitif ve negatif olanlarından kaçar tane girildiğini bulan ve ekrana uygun mesajları yazdıran programcı yazınız
	Açıklamalar:
		- Hiç pozitif sayı ve/veya negatif girilmemişse, sayıların girilmediğine ilişkin mesajlar verilecektir. Örneğin:
		Hiç pozitif sayı girmediniz!...
		- Mesajları dilediğiniz gibi verebilirsiniz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		FindPosNegSumCountsApp.run();
	}
}

class FindPosNegSumCountsApp {
	public static void printPositivesResult(int posSum, int posCount)
	{
		if (posCount != 0)
			System.out.printf("%d tane pozitif sayının toplamı:%d%n", posCount, posSum);
		else
			System.out.println("Hiç pozitif sayı girmediniz!...");
	}

	public static void printNegativesResult(int negSum, int negCount)
	{
		if (negCount != 0)
			System.out.printf("%d tane negatif sayının toplamı:%d%n", negCount, negSum);
		else
			System.out.println("Hiç negatif sayı girmediniz!...");
	}

	public static void printResult(int posSum, int posCount, int negSum, int negCount)
	{
		printPositivesResult(posSum, posCount);
		printNegativesResult(negSum, negCount);
	}

	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("Sayıları girmeye başlayınız:");

		int posCount, posSum, negCount, negSum;

		posCount = negCount = 0;
		posSum = negSum = 0;

		int val;

		while ((val = kb.nextInt()) != 0)
			if (val > 0) {
				posSum += val;
				++posCount;
			}
			else {
				negSum += val;
				++negCount;
			}

		printResult(posSum, posCount, negSum, negCount);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının basamak sayısını döndüren countDigits isimli metodu
	NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz.
	123 -> 3
	0 -> 1
	Not: İleride daha iyisi yazılacaktır.
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
    public static void main(String [] args)
    {
        java.util.Scanner kb = new java.util.Scanner(System.in);
        System.out.println("Bir sayı giriniz?");
        int val = Integer.parseInt(kb.nextLine());
        System.out.printf("%d sayısının basamak sayısı : %d%n",val,NumberUtil.countDigits(val));
    }
}

class NumberUtil{
    public static int countDigits(int val)
    {
        if(val == 0)
            return 1;
        int count = 0;
        while(val != 0){
            count++;
            val/= 10;
        }
        return count;
    }
}
//Başka bir çözüm
package csd;

class App {
	public static void main(String [] args)
	{
		CountDigitsTest.run();
	}
}

class CountDigitsTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int val;

		System.out.print("Bir sayı giriniz:");

		while ((val = Integer.parseInt(kb.nextLine())) != 0) {
			System.out.printf("%d sayısının basamak sayısı:%d%n", val, NumberUtil.countDigits(val));
			System.out.print("Bir sayı giriniz:");
		}

		System.out.printf("0 sayısının basamak sayısı:%d%n", NumberUtil.countDigits(0));

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil {
	public static int countDigits(int val)
	{
		if (val == 0)
			return 1;

		int count = 0;

		while (val != 0) {
			++count;
			val /= 10;
		}

		return count;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının basamakları toplamına geri dönen sumDigits isimli metodu
	NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz. Metot negatif sayılar için de basamakları toplamını
	pozitif olarak döndürecektir.
	123-> 6
	-123 -> 6
	0 -> 0
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
    public static void main(String [] args)
    {
        java.util.Scanner kb = new java.util.Scanner(System.in);
        System.out.println("Bir sayı giriniz?");
        int val = Integer.parseInt(kb.nextLine());
        System.out.printf("%d sayısının basamakları toplamı : %d%n",val,NumberUtil.sumDigits(val));
    }
}

class NumberUtil{
    public static int countDigits(int val)
    {
        if(val == 0)
            return 1;
        int count = 0;
        while(val != 0){
            count++;
            val/= 10;
        }
        return count;
    }
    public static int sumDigits(int val)
    {
        int sum = 0;
        while(val != 0){
            sum += val % 10;
            val /= 10;
        }
        return Math.abs(sum);
    }
    public static int reverse(int val)
    {
        int rev = 0;
        while(val != 0){
            rev *= 10;
            rev += val % 10;
            val /= 10;
        }
        return rev;
    }
}
//Başka bir çözüm
package csd;

class App {
	public static void main(String [] args)
	{
		SumDigitsTest.run();
	}
}

class SumDigitsTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int val;

		System.out.print("Bir sayı giriniz:");

		while ((val = Integer.parseInt(kb.nextLine())) != 0) {
			System.out.printf("%d sayısının basamakları toplamı:%d%n", val, NumberUtil.sumDigits(val));
			System.out.print("Bir sayı giriniz:");
		}

		System.out.printf("0 sayısının basamakları toplamı:%d%n", NumberUtil.sumDigits(0));

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil {
	public static int sumDigits(int val)
	{
		int sum = 0;

		while (val != 0) {
			sum += val % 10;
			val /= 10;
		}

		return Math.abs(sum);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının basamakları tersini döndüren reverse isimli metodu
	yazınız ve aşağıdaki kod ile test ediniz.

	Örneğin: 123 -> 3 * 10 + 2 = 32 -> 32 * 10 + 1 = 321
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
    public static void main(String [] args)
    {
        java.util.Scanner kb = new java.util.Scanner(System.in);
        System.out.println("Bir sayı giriniz?");
        int val = Integer.parseInt(kb.nextLine());
        System.out.printf("%d sayısının tersi : %d%n",val,NumberUtil.reverse(val));
    }
}

class NumberUtil{
    public static int countDigits(int val)
    {
        if(val == 0)
            return 1;
        int count = 0;
        while(val != 0){
            count++;
            val/= 10;
        }
        return count;
    }
    public static int sumDigits(int val)
    {
        int sum = 0;
        while(val != 0){
            sum += val % 10;
            val /= 10;
        }
        return Math.abs(sum);
    }
    public static int reverse(int val)
    {
        int rev = 0;
        while(val != 0){
            rev *= 10;
            rev += val % 10;
            val /= 10;
        }
        return rev;
    }
}
//Başka çözüm bir
package csd;

class App {
	public static void main(String [] args)
	{
		ReverseTest.run();
	}
}

class ReverseTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int val;

		System.out.print("Bir sayı giriniz:");

		while ((val = Integer.parseInt(kb.nextLine())) != 0) {
			System.out.printf("%d sayısının tersi:%d%n", val, NumberUtil.reverse(val));
			System.out.print("Bir sayı giriniz:");
		}

		System.out.printf("0 sayısının tersi:%d%n", NumberUtil.reverse(0));
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil {
	public static int reverse(int val)
	{
		int result = 0;

		while (val != 0) {
			result = result * 10 + val % 10;
			val /= 10;
		}

		return result;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Kontrolün sonda yapıldığı while döngü deyiminin (do-while döngüsü) genel biçimi:

		do
			<deyim>
		while (<boolean türden ifade>);

	Akış do-while döngüsüne geldiğinde koşul kontrolü yapılmaz. İlk adım çalıştırıldıktan sınra kontrol yapılmaya başlar.
	Yani bu döngü deyiminin en az bir kez çalıştırılacağı garanti altındadır. Diğer döngü deyimleri kadar sık kullanılmasa da
	okunabilirliği/algılanabilirliği artırmak ve algoritmanın sadeleştirilmesi için tercih edilebilir. Ancak bu döngü deyimi
	gereksiz yere kullanıldığında okunabilirliği/algılanabilirliği azaltır. Buna dikkat edilmelidir.
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int n = Integer.parseInt(kb.nextLine());
		int i = 0;

		do {
			System.out.printf("%d ", i);
			++i;
		} while (i < n);

		System.out.println();
		System.out.printf("Döngü sonrası i = %d%n", i);
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının basamak sayısını döndüren countDigits isimli metodu
	NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
	Not: İleride daha iyisi yazılacaktır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		CountDigitsTest.run();
	}
}

class CountDigitsTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int val;

		System.out.print("Bir sayı giriniz:");

		while ((val = Integer.parseInt(kb.nextLine())) != 0) {
			System.out.printf("%d sayısının basamak sayısı:%d%n", val, NumberUtil.countDigits(val));
			System.out.print("Bir sayı giriniz:");
		}

		System.out.printf("0 sayısının basamak sayısı:%d%n", NumberUtil.countDigits(0));

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil {
	public static int countDigits(int val)
	{
		int count = 0;

		do {
			++count;
			val /= 10;
		} while (val != 0);

		return count;
	}
}
//Başka bir çözüm
package csd;

class App {
    public static void main(String [] args)
    {
        java.util.Scanner kb = new java.util.Scanner(System.in);
        System.out.println("Bir sayı giriniz?");
        int val = Integer.parseInt(kb.nextLine());
        System.out.printf("%d sayısının basamak sayısı : %d%n",val,NumberUtil.countDigits(val));
    }
}

class NumberUtil{
    public static int countDigits(int val)
    {
        int count = 0;
        do{
            count++;
            val /= 10;
        }while(val != 0);
        return count;
    }
    public static int sumDigits(int val)
    {
        int sum = 0;
        while(val != 0){
            sum += val % 10;
            val /= 10;
        }
        return Math.abs(sum);
    }
    public static int reverse(int val)
    {
        int rev = 0;
        while(val != 0){
            rev *= 10;
            rev += val % 10;
            val /= 10;
        }
        return rev;
    }
}
/*----------------------------------------------------------------------------------------------------------------------
	do-while döngüsünün deyimi içerisinde bildirilen bir değişken faaliyet alanı kuralları gereği koşul ifadesi içerisinde
	kullanılamaz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		do {
			System.out.print("Bir sayı giriniz:");
			int val = Integer.parseInt(kb.nextLine());

			System.out.printf("%d * %d = %d%n", val, val, val * val);
		} while (val != 0); //error

	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki problem aşağıdaki gibi çözülebilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		int val;

		do {
			System.out.print("Bir sayı giriniz:");
			val = Integer.parseInt(kb.nextLine());

			System.out.printf("%d * %d = %d%n", val, val, val * val);
		} while (val != 0);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sonsuz Döngü (Infinite Loop): Koşul ifadesinden dolayı sonlanmayan döngülere denir. Bu durumda hiç sonlanmayan bir
	döngü de bir sonsuz döngüdür. Tersine sonsuz döngü olarak tasarlanmış bir dçngü sonlanabilecek şekilde de yazılabilir
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	while döngüsü ile sonsuz döngü kalıbı aşağıdaki gibi oluşturulabilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		while (true) {
			//...
		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının basamak sayısını döndüren countDigits isimli metodu
	NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
	Not: İleride daha iyisi yazılacaktır

	Aşağıdaki örnekte test kodunda sonsuz döngüye girilmiş ve bir koşula bağlı olarak run metodu sonlandırılmıştır. Bu
	durumda sonsuz döngüden de çıkılmış olur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		CountDigitsTest.run();
	}
}

class CountDigitsTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		while (true) {
			System.out.print("Bir sayı giriniz:");
			int val = Integer.parseInt(kb.nextLine());

			System.out.printf("%d sayısının basamak sayısı:%d%n", val, NumberUtil.countDigits(val));

			if (val == 0) {
				System.out.println("Tekrar yapıyor musunuz?");
				return;
			}
		}
	}
}

class NumberUtil {
	public static int countDigits(int val)
	{
		int count = 0;

		do {
			++count;
			val /= 10;
		} while (val != 0);

		return count;
	}
}
//----------------------------------------------------------------------------------------------------------------------
/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki problem aşağıdaki gibi çözülebilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
    public static void main(String [] args)
    {
        while(true) {
            java.util.Scanner kb = new java.util.Scanner(System.in);
            System.out.println("Bir sayı giriniz?");
            int val = Integer.parseInt(kb.nextLine());
            if(val == 0)
                return;
            System.out.printf("%d sayısının basamakları sayısı : %d%n",val,NumberUtil.countDigits(val));
            System.out.printf("%d sayısının basamakları toplamı : %d%n",val,NumberUtil.sumDigits(val));
            System.out.printf("%d sayısının tersi : %d%n",val,NumberUtil.reverse(val));
        }
    }
}

class NumberUtil{
       public static int countDigits(int val)
       {
           int count = 0;
           do{
               count++;
               val /= 10;
           }while (val != 0);
           return count;
       }
       public static int sumDigits(int val)
       {
           int sum = 0;
           while(val != 0){
               sum += val % 10;
               val /= 10;
           }
           return sum;
       }
       public static int reverse(int val)
       {
           int rev = 0;
           while(val != 0) {
               rev *= 10;
               rev += val % 10;
               val /= 10;
           }
           return rev;
       }
}
/*----------------------------------------------------------------------------------------------------------------------
	 for döngü deyiminin genel biçimi:
	 	for ([1.bölüm]; [2.bölüm]; [3.bölüm])
	 		<deyim>

	 1.bölüm: Akış for döngü deyimine geldiğinde yapılacak kısım

	 2.bölüm: for döngü deyiminin koşul ifadesine ilişkin bölümdür. Buraya yazılacak ifadenin boolean türden olması
	 gerekir. Bu ifade true olduğu sürece döngü yinelenir. Akış for döngü deyimine geldiğinde 1.bölüm yapıldıktan
	 sonra kontrol yapılır.

	 3.bölüm: Döngünün bir adımı tamamlandığında bir sonraki adıma geçmek için yapılacak kontrolden önce yapılan bölümdür

	 for döngü deyiminde bölümler boş bırakılsa da iki tane noktalı virgül kullanılmalıdır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		int i;

		for (i = 0; i < count; ++i)
			System.out.printf("%d ", i);

		System.out.println();
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	for döngü deyimi
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		int i;

		for (i = count - 1; i >= 0; --i)
			System.out.printf("%d ", i);

		System.out.println();
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	for döngü deyimi
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		int i;

		for (i = 0; i < count; i += 2)
			System.out.printf("%d ", i);

		System.out.println();
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	for döngü deyiminin 1.bölümünde değişken bildirimi yapılabilir. Buna genel olarak döngü değişkeni denir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		for (int i = 0; i < count; i += 2)
			System.out.printf("%d ", i);

		System.out.println();
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	for döngü deyiminin 1.bölümünde bildirilen değişken for döngü deyimi boyunca geçerlidir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		for (int i = 0; i < count; i += 2)
			System.out.printf("%d ", i);

		System.out.printf("i = %d%n", i); //error
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki for döngüsünde "aynı faaliyet alanı içerisinde aynı isimde birden fazla yerel değişken bildirimi geçersizdir"
	kuralı dolayısıyla error oluşur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		int i;

		for (int i = 0; i < count; i += 2) //error
			System.out.printf("%d ", i);


		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Döngü değişkeninin değeri döngüden sonra kullanılmayacaksa döngü değişkeni bildirimi for döngüsünün birinci bölümünde
	yapılması iyi bir tekniktir. Bu durumda döngü değişkeninin döngüden önce bildirilmesi durumunda, döngüden sonra bu
	değişkenin kullanılacağı algısı oluşur. Yani okunabilirlik/algılanabilirlik artırılmış olur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		for (int i = 0; i < count; i += 2)
			System.out.printf("%d ", i);

		System.out.println();

		for (int i = count - 1; i >= 0; i -= 2)
			System.out.printf("%d ", i);

		System.out.println();

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	for döngü deyiminde yanlışlıkla noktalı virgül konması durumu. Aşağıdaki örnekte error oluşmaz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		int i;

		for (i = 0; i < count; i += 2);
			System.out.printf("%d ", i);

		System.out.println();
		System.out.printf("i = %d%n", i);

		for (i = count - 1; i >= 0; i -= 2)
			System.out.printf("%d ", i);

		System.out.println();

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	for döngü deyiminde yanlışlıkla noktalı virgül konması durumu. Aşağıdaki örnekte neden error oluşur?
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		for (int i = 0; i < count; i += 2);
			System.out.printf("%d ", i); //error

		System.out.println();


		for (int i = count - 1; i >= 0; i -= 2)
			System.out.printf("%d ", i);

		System.out.println();

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	for döngü deyimi ile n-kez dönen döngü
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();

		for (int i = 0; i < n; ++i)
			System.out.printf("%d ", i);

		System.out.println();

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	for döngü deyimi ile n-kez dönen döngü
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();

		for (int i = n - 1; i >= 0; --i)
			System.out.printf("%d ", i);

		System.out.println();

		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	for döngüsünün birinci ve üçüncü kısmında virgül ayracı ile birden fazla ifade yazılabilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		for (int i = 0, k = 10; i <= 5 && k >= 0; ++i, --k)
			System.out.printf("(%d, %d)%n", i, k);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	for döngüsünün birinci kısmında değişken bildirimi yapılmışsa başka bir ifade yazılamaz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		for (System.out.println("Birinci kısım"), int i = 0, k = 10; i <= 5 && k >= 0; ++i, --k) //error
			System.out.printf("(%d, %d)%n", i, k);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	for döngüsünün birinci kısmında bildirilen değişkenler aynı türden olmalıdır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		for (int i = 0, double k = 10; i <= 5 && k >= 0; ++i, --k) //error
			System.out.printf("(%d, %d)%n", i, k);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki döngü deyimini inceleyiniz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int i;
		double k;

		for (i = 0, k = 56.78; i <= 5 && k >= 0; ++i, k -= 0.1)
			System.out.printf("(%d, %f)%n", i, k);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte for döngü deyiminin çalışması gösterilmiştir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int i = 0;

		for (System.out.println("Birinci kısım"); i < 10; ++i, System.out.println("Üçüncü kısım"))
			System.out.println("Deyim");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	for döngüsünün gücü: Aşağıdaki örnekte klavyeden sıfır girilene kadar alınan sayıların toplamı bulunmuştur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int sum = 0;
		int val;

		for (System.out.println("Sayıları girmeye başlayınız"), System.out.print("Bir sayı giriniz:"); (val = Integer.parseInt(kb.nextLine())) != 0;
				sum += val, System.out.print("Bir sayı giriniz:"))
			;

		System.out.printf("Toplam:%d%n", sum);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	for döngüsünün gücü: Aşağıdaki örnekte klavyeden sıfır girilene kadar alınan sayıların toplamı bulunmuştur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int sum = 0;
		int val;

		for (System.out.println("Sayıları girmeye başlayınız"); (val = kb.nextInt()) != 0; sum += val)
			;

		System.out.printf("Toplam:%d%n", sum);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Hiç sonlanmayacak sanılan ancak öyle olmayan bir döngü örneği. Örnekte i değeri azalarak -2147483648 değerine
	yani int türünün en küçük değerine geldiğinde artık bir azaltıldığında 2147483647 değeri yani int türünün en büyük
	değeri elde edilir ve döngüden çıkılır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int i;

		for (i = 0; i < 10; --i)
			; //System.out.println(i);

		System.out.printf("i = %d%n", i);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	22.10.2022
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	for döngü deyiminde birinci bölümün boş bırakılması durumu
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		int i = 0;

		for (; i < count; ++i)
			System.out.printf("%d ", i);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	for döngü deyiminde üçüncü bölümün boş bırakılması durumu
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		for (int i = 0; i < count;) {
			System.out.printf("%d ", i);
			++i;
		}

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	for döngü deyiminde birinci ve üçüncü kısmın boş bırakılması durumu while döngü deyimine benzetilebilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();
		int i = 0;

		for (; i < count;) {
			System.out.printf("%d ", i);
			++i;
		}

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	for döngü deyiminde ikinci bölümün boş bırakılması durumunda sonsuz döngü oluşur. Yani koşul her zaman gerçeklenir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		for (int i = 0; ; ++i)
			System.out.printf("%d%n", i);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	for döngüsü ile sonsuz döngü oluşturmak için okunabilirlik/algılanabilirlik açısından 3 kısmı da boş bırakılır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		for (;;) {
			//...
		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının basamak sayısını döndüren countDigits isimli metodu
	NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
	Not: İleride daha iyisi yazılacaktır

	Aşağıdaki örnekte test kodunda sonsuz döngüye girilmiş ve bir koşula bağlı olarak run metodu sonlandırılmıştır. Bu
	durumda sonsuz döngüden de çıkılmış olur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		CountDigitsTest.run();
	}
}

class CountDigitsTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int val = Integer.parseInt(kb.nextLine());

			System.out.printf("%d sayısının basamak sayısı:%d%n", val, NumberUtil.countDigits(val));

			if (val == 0) {
				System.out.println("Tekrar yapıyor musunuz?");
				return;
			}
		}
	}
}

class NumberUtil {
	public static int countDigits(int val)
	{
		int count = 0;

		do {
			++count;
			val /= 10;
		} while (val != 0);

		return count;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden a ve b değerleri için a-nın b-inci kuvvetini döndüren pow isimli
	metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz.
	Açıklamalar:
	  - Math sınıfının pow metodu kullanılmayacaktır.
	  - Metot negatif b değerleri için 1(bir) değerine geri dönecektir.
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		PowTest.run();
	}
}

class PowTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for (;;) {
			System.out.print("Tabanı giriniz:");
			int a = Integer.parseInt(kb.nextLine());

			System.out.print("Üssü giriniz:");
			int b = Integer.parseInt(kb.nextLine());

			System.out.printf("pow(%d, %d) = %d%n", a, b, NumberUtil.pow(a, b));

			if (b <= 0) {
				System.out.println("Tekrar yapıyor musunuz?");
				return;
			}
		}
	}
}

class NumberUtil {
	public static int pow(int a, int b)
	{
		int result = 1;

		for (int i = 0; i < b; ++i)
			result *= a;

		return result;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden a ve b değerleri için a-nın b-inci kuvvetini döndüren pow isimli
	metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz.
	Açıklamalr:
	  - Math sınıfının pow metodu kullanılmayacaktır
	  - Metot negatif b değerleri için 1(bir) değerine geri dönecektir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		PowTest.run();
	}
}

class PowTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for (;;) {
			System.out.print("Tabanı giriniz:");
			int a = Integer.parseInt(kb.nextLine());

			System.out.print("Üssü giriniz:");
			int b = Integer.parseInt(kb.nextLine());

			System.out.printf("pow(%d, %d) = %d%n", a, b, NumberUtil.pow(a, b));

			if (b <= 0) {
				System.out.println("Tekrar yapıyor musunuz?");
				return;
			}
		}
	}
}

class NumberUtil {
	public static int pow(int a, int b)
	{
		int result = 1;

		while (b-- > 0)
			result *= a;

		return result;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının Armstrong sayısı olup olmadığını test eden isArmstrong
	metodunu NumberUtil sınıfı içerisinde yazınız
	Açıklamalar:
		- Bir sayının her basamağının "basamak sayı"-ncı kuvvetleri toplanmı sayının kendisine eşitse bu sayıya Armstrong
		sayısı denit. Örneğin:
			153 -> 1 ^ 3 + 5 ^ 3 + 3 ^ 3 = 153
            371 -> 3 ^ 3 + 7 ^ 3 + 1 ^ 3 = 371
		- Kuvvet alma işlemi için bir önceki örnekte yazılmış olan pow metodu kullanılacaktır

		- Negatif sayılar Armstrong sayısı olarak kabul edilmeyecektir

		- Metodu, 1 basamaklı, 2 basamaklı, 3 basamaklı, 4 basamaklı, 5 basamaklı ve 6 basamaklı Armstrong sayılarını
		ekrana yazdırarak test ediniz.
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		IsArmstrongTest.run();
	}
}

class IsArmstrongTest {
	public static void run()
	{
		for (int n = -10; n <= 999999; ++n)
			if (NumberUtil.isArmstrong(n))
				System.out.println(n);

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil {
	public static boolean isArmstrong(int val)
	{
		return val >= 0 && getDigitsPowSum(val) == val;
	}

	public static int getDigitsPowSum(int val)
	{
		int n = countDigits(val);
		int total = 0;

		while (val != 0) {
			total += pow(val % 10, n);
			val /= 10;
		}

		return total;
	}

	public static int countDigits(int val)
	{
		int count = 0;

		do {
			++count;
			val /= 10;
		} while (val != 0);

		return count;
	}

	public static int pow(int a, int b)
	{
		int result = 1;

		while (b-- > 0)
			result *= a;

		return result;
	}
}
//----------------------------------------------------------------------------------------------------------------------
package csd;

class App {
    public static void main(String [] args)
    {
      isArmstrongTest.run(new java.util.Scanner(System.in));
    }
}

class isArmstrongTest{
    public static void run(java.util.Scanner kb)
    {
        for(int i = 0;i < 999999; ++i){
            if(NumberUtil.isArmstrong(i)){
                System.out.printf("%d ",i);
            }
        }
    }
}


class NumberUtil {
    public static int pow(int a,int b)
    {
        int result = 1;
        for(int i = 0;i < b; ++i)
            result *= a;
        return result;
    }
    public static int countDigits(int val)
    {
        int count = 0;

        do {
            ++count;
            val /= 10;
        } while (val != 0);

        return count;
    }
    public static boolean isArmstrong(int val)
    {
        int temp = val;
        int count = countDigits(val);
        int result = 0;
        while(temp != 0){
            result += pow(temp % 10,count);
            temp /= 10;
        }
        return result == val;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı long türden bir sayının asal olup olmadığını test eden isPrime isimli
	metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz.
	(Yavaş versiyon)
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		IsPrimeTest.run();
	}
}


class IsPrimeTest {
	public static void run()
	{
		for (int i = -10; i <= 100; ++i)
			if (NumberUtil.isPrime(i))
				System.out.printf("%d ", i);

		System.out.println();

		System.out.println(NumberUtil.isPrime(1_000_003));
	}
}

class NumberUtil {
	public static boolean isPrime(long val)
	{
		if (val <= 1)
			return false;

		long half = val / 2;

		for (long i = 2; i <= half; ++i)
			if (val % i == 0)
				return false;

		return true;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı long türden bir sayının asal olup olmadığını test eden isPrine isimli
	metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz

	Kural: Bir sayı karekökünden küçük olan asal sayıların hiç birisine bölünemiyorsa asaldır
	(Hızlı versiyon)
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		IsPrimeTest.run();
	}
}

class IsPrimeTest {
	public static void run()
	{
		for (int i = -10; i <= 100; ++i)
			if (NumberUtil.isPrime(i))
				System.out.printf("%d ", i);

		System.out.println();

		System.out.println(NumberUtil.isPrime(1_000_003));
	}
}

class NumberUtil {
	public static boolean isPrime(long val)
	{
		if (val <= 1)
			return false;

		if (val % 2 == 0)
			return val == 2;

		if (val % 3 == 0)
			return val == 3;

		if (val % 5 == 0)
			return val == 5;

		if (val % 7 == 0)
			return val == 7;

		for (long i = 11; i * i <= val; i += 2)
			if (val % i == 0)
				return false;

		return true;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	isPrime metotlarını test etmek için aşağıdaki büyük asal sayıları kullanabilirsiniz:
		6750161072220585911
		1603318868174368979
		6584583408148485263
		6245098347044246839
		6285871677077738093
		5697859706174583067
		710584055392819667
		4935060337471977161
		3728803592870153407
		4331452335614730577
		1386437196678024971
		1677990107453991593
		4765603950744460867
		4498306523077899307
		4434895834573449257
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	23.10.2022
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıda yazılan isPrime metotlarının basit bir karşılaştırması. isPrime metotlarına sayaçlar durumu göstermek için
	eklenmiştir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		IsPrimeTest.run();
	}
}

class IsPrimeTest {
	public static void run()
	{
		System.out.println(NumberUtil.isPrime(1_000_003));
		System.out.println(NumberUtil.isPrimeSlow(1_000_003));
	}
}

class NumberUtil {
	public static boolean isPrime(long val)
	{
		if (val <= 1)
			return false;

		if (val % 2 == 0)
			return val == 2;

		if (val % 3 == 0)
			return val == 3;

		if (val % 5 == 0)
			return val == 5;

		if (val % 7 == 0)
			return val == 7;

		int count = 0;

		for (long i = 11; i * i <= val; i += 2) {
			++count;
			if (val % i == 0)
				return false;
		}

		System.out.printf("isPrime:%d%n", count);

		return true;
	}

	public static boolean isPrimeSlow(long val)
	{
		if (val <= 1)
			return false;

		long half = val / 2;

		int count = 0;

		for (long i = 2; i <= half; ++i) {
			++count;
			if (val % i == 0)
				return false;
		}

		System.out.printf("isPrimeSlow:%d%n", count);

		return true;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir n değeri için n-inci asal sayıyı döndüren getPrime isimli
	metodu yazınız ve aşağıdaki kod ile test ediniz.

	Açıklamalar:
		- isPrime metodunun hızlı versiyonunu kullanınız
		- n değerinin pozitif olmaması durumu metot içerisinde kontrol edilmeyecektir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		GetPrimeTest.run();
	}
}

class GetPrimeTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);


		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int n = Integer.parseInt(kb.nextLine());

			if (n <= 0) {
				System.out.println("Tekrar yapıyor musunuz?");
				return;
			}


			System.out.printf("%d. asal sayı:%d%n", n, NumberUtil.getPrime(n));
		}
	}
}

class NumberUtil {
	public static long getPrime(int n)
	{
		long val = 2;
		int count = 0;

		for (long i = 2; count < n; ++i)
			if (isPrime(i)) {
				++count;
				val = i;
			}

		return val;
	}

	public static boolean isPrime(long val)
	{
		if (val <= 1)
			return false;

		if (val % 2 == 0)
			return val == 2;

		if (val % 3 == 0)
			return val == 3;

		if (val % 5 == 0)
			return val == 5;

		if (val % 7 == 0)
			return val == 7;

		for (long i = 11; i * i <= val; i += 2)
			if (val % i == 0)
				return false;

		return true;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir n değeri için n-inci asal sayıyı döndüren getPrime isimli
	metodu yazınız ve aşağıdaki kod ile test ediniz

	Açıklamalar:
		- isPrime metodunun hızlı versiyonunu kullanınız
		- n değerinin pozitif olmaması durumu metot içerisinde kontrol edilmeyecektir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		GetPrimeTest.run();
	}
}

class GetPrimeTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int n = Integer.parseInt(kb.nextLine());

			if (n <= 0) {
				System.out.println("Tekrar yapıyor musunuz?");
				return;
			}


			System.out.printf("%d. asal sayı:%d%n", n, NumberUtil.getPrime(n));
		}
	}
}

class NumberUtil {
	public static long getPrime(int n)
	{
		long val = 2;
		int count = 0;

		for (;;) {
			if (isPrime(val))
				++count;

			if (count == n)
				return val;

			++val;
		}
	}

	public static boolean isPrime(long val)
	{
		if (val <= 1)
			return false;

		if (val % 2 == 0)
			return val == 2;

		if (val % 3 == 0)
			return val == 3;

		if (val % 5 == 0)
			return val == 5;

		if (val % 7 == 0)
			return val == 7;

		for (long i = 11; i * i <= val; i += 2)
			if (val % i == 0)
				return false;

		return true;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının faktoriyel değerini döndüren factorial isimli metodu
	NumberUtil sınıfı içerisinde yazını ve aşağıdaki kod ile test ediniz.
	Açıklamalar:
		- Faktoriyel işleni aşağıdaki gibidir:
			0! = 1
			1! = 1
			2! = 1 * 2
			3! = 1 * 2 * 3

			...

			n! = 1 * 2 * ... * (n - 1) * n
		- Negatif sayılar için faktoriyel değeri 1 olarak döndürülecektir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		FactorialTest.run();
	}
}

class FactorialTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int val = kb.nextInt();

		for (int n = -10; n <= val; ++n)
			System.out.printf("%2d! = %d%n", n, NumberUtil.factorial(n));

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil {
	public static long factorial(int n)
	{
		if (n <= 1)
			return 1;

		long result = n;

		for (--n; n > 1; --n)
			result *= n;

		return result;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının faktoriyel değerini döndüren factorial isimli metodu
	NumberUtil sınıfı içerisinde yazını ve aşağıdaki kod ile test ediniz.
	Açıklamalar:
		- Faktoriyel işleni aşağıdaki gibidir:
			0! = 1
			1! = 1
			2! = 1 * 2
			3! = 1 * 2 * 3

			...

			n! = 1 * 2 * ... * (n - 1) * n
		- Negatif sayılar için faktoriyel değeri 1 olarak döndürülecektir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		FactorialTest.run();
	}
}

class FactorialTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int val = kb.nextInt();

		for (int n = -10; n <= val; ++n)
			System.out.printf("%2d! = %d%n", n, NumberUtil.factorial(n));

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil {
	public static long factorial(int n)
	{
		if (n <= 1)
			return 1;

		long result = n--;

		for (; n > 1; --n)
			result *= n;

		return result;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının faktoriyel değerini döndüren factorial isimli metodu
	NumberUtil sınıfı içerisinde yazını ve aşağıdaki kod ile test ediniz.
	Açıklamalar:
		- Faktoriyel işleni aşağıdaki gibidir:
			0! = 1
			1! = 1
			2! = 1 * 2
			3! = 1 * 2 * 3

			...

			n! = 1 * 2 * ... * (n - 1) * n
		- Negatif sayılar için faktoriyel değeri 1 olarak döndürülecektir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		FactorialTest.run();
	}
}

class FactorialTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int val = kb.nextInt();

		for (int n = -10; n <= val; ++n)
			System.out.printf("%2d! = %d%n", n, NumberUtil.factorial(n));

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil {
	public static long factorial(int n)
	{
		long result = 1;

		for (int i = 2; i <= n; ++i)
			result *= i;

		return result;
	}
}
package csd;

class App {
	public static void main(String [] args)
	{
		IsPrimeTest.run();
	}
}

class IsPrimeTest {
	public static void run()
	{
		System.out.println(NumberUtil.isPrime(1_000_003));
		System.out.println(NumberUtil.isPrimeSlow(1_000_003));
	}
}

class NumberUtil {
	public static boolean isPrime(long val)
	{
		if (val <= 1)
			return false;

		if (val % 2 == 0)
			return val == 2;

		if (val % 3 == 0)
			return val == 3;

		if (val % 5 == 0)
			return val == 5;

		if (val % 7 == 0)
			return val == 7;

		int count = 0;

		for (long i = 11; i * i <= val; i += 2) {
			++count;
			if (val % i == 0)
				return false;
		}

		System.out.printf("isPrime:%d%n", count);

		return true;
	}

	public static boolean isPrimeSlow(long val)
	{
		if (val <= 1)
			return false;

		long half = val / 2;

		int count = 0;

		for (long i = 2; i <= half; ++i) {
			++count;
			if (val % i == 0)
				return false;
		}

		System.out.printf("isPrimeSlow:%d%n", count);

		return true;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	İçiçe döngüler (nested loops)
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		for (int i = 0; i < 5; ++i)
			for (int k = 10; k >= 0; --k)
				System.out.printf("(%d, %d)%n", i, k);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Programcılar bazen tek bir döngü varsa da döngü içerisinde çağrılan metot veya metotlar içerisinde döngü kullanılmışsa
	dolaylı olarak içiçe döngü olacak şekilde bir kod yazmış olurlar
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		for (int i = 0; i < 5; ++i)
			Util.print(i);
	}
}


class Util {
	public static void print(int i)
	{
		for (int k = 10; k >= 0; --k)
			System.out.printf("(%d, %d)%n", i, k);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	3 basamaklı Armstrong sayılarının iç içe döngü ile bulunması. Örnek durumu göstermek için yazılmıştır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		for (int a = 1; a <= 9; ++a)
			for (int b = 0; b <= 9; ++b)
				for(int c = 0; c <= 9; ++c)
					if (a * a * a + b * b * b + c * c * c == 100 * a + 10 * b + c)
						System.out.printf("%d%d%d%n", a, b, c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	30.10.2022
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	break deyimi döngüyü, döngünün koşul ifadesinden bağımsız olarak sonlandırmak için kullanılır. break deyimi,
	döngü deyimleri dışında ileride göreceğimiz "switch" deyiminde de kullanılır. Bunlar dışında kullanımı error oluşturur.
	break deyiminin genel biçimi:

		break [etiket ismi];
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	break deyiminin etiketsiz kullanımında akış break deyimine geldiğinde döngü sonlandırılır. Akış döngüden sonraki
	koddan devam eder. break hangi döngü içerisinde etiketsiz kullanılmışsa o döngü sonlandırılır.
	Aşağıdaki örnekte klavyeden sıfır girilene kadar alınan sayıların toplamı bulunmuştur. Sıfır girildiğinde sonsuz döngü
	break deyimi ile sonlandırılmıştır.

	while(true){
	    deyim1;
	    deyim2;
	    continue;
	    deyim3;
	    deyim4;
	}
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		int sum = 0;

		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int a = Integer.parseInt(kb.nextLine());

			if (a == 0)
				break;

			sum += a;
		}

		System.out.printf("Toplam = %d%n", sum);
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: break deyimi ilgili döngüyü sonlandırır, return deyimi ise metodu sonlandırır
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir n değeri için n-inci asal sayıyı döndüren getPrime isimli
	metodu yazınız ve aşağıdaki kod ile test ediniz

	Açıklamalar:
		- isPrime metodunun hızlı versiyonunu kullanınız
		- n değerinin pozitif olmaması durumu metot içerisinde kontrol edilmeyecektir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		GetPrimeTest.run();
	}
}

class GetPrimeTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int n = Integer.parseInt(kb.nextLine());

			if (n <= 0)
				break;

			System.out.printf("%d. asal sayı:%d%n", n, NumberUtil.getPrime(n));
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil {
	public static long getPrime(int n)
	{
		long val = 2;
		int count = 0;

		for (;;) {
			if (isPrime(val))
				++count;

			if (count == n)
				return val;

			++val;
		}
	}

	public static boolean isPrime(long val)
	{
		if (val <= 1)
			return false;

		if (val % 2 == 0)
			return val == 2;

		if (val % 3 == 0)
			return val == 3;

		if (val % 5 == 0)
			return val == 5;

		if (val % 7 == 0)
			return val == 7;

		for (long i = 11; i * i <= val; i += 2)
			if (val % i == 0)
				return false;

		return true;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	break deyimi yalnızca kullanıldığı döngüyü sonlandırır. Aşağıdaki örnekte içteki döngüde bir koşul gerçeklendiğinde
	dıştaki döngünün de sonlandırılması flag değişken kullanılarak yapılmıştır. Örnek durumu göstermek için yazılmıştır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		boolean breakAllFlag = false;

		for (int i = 0; i < 10; ++i) {
			for (int k = 25; k >= 0; --k) {
				System.out.printf("(%d, %d)%n", i, k);

				if ((i + k) % 6 == 0) {
					breakAllFlag = true;
					break;
				}
			}

			if (breakAllFlag)
				break;
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Etiketli break (labeled break) deyiminde gerektiğinde sonlandırılacak deyiminin (döngü deyimi veya switch deyimi) başında
	bir etiket bildirimi yapılır. Etiket bildiriminin genel biçimi:

		<etiket ismi>:

	Etiket ismi değişken isimlendirme kurallarına uygun herhangi bir isim olabilir. Genellikle programcılar etiket isminin
	tamamını büyük harfle, birden fazla kelimeden oluşuyorsa da araya alttire karakterini koyarak isimlendirme yaparlar.
	Yukarıdaki program aşağıdaki gibi yazılabilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		EXIT_LOOP:
		for (int i = 0; i < 10; ++i) {
			for (int k = 25; k >= 0; --k) {
				System.out.printf("(%d, %d)%n", i, k);

				if ((i + k) % 6 == 0)
					break EXIT_LOOP;
			}
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Etiket isimleri bildirildiği döngü boyunca kullanılablir (scope).
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		EXIT_LOOP:
		for (int i = 0; i < 10; ++i) {
			for (int k = 25; k >= 0; --k) {
				System.out.printf("(%d, %d)%n", i, k);

				if ((i + k) % 6 == 0)
					break EXIT_LOOP;
			}
		}

		EXIT_LOOP:
		for (int i = 0; i < 10; ++i) {
			for (int k = 25; k >= 0; --k) {
				System.out.printf("(%d, %d)%n", i, k);

				if ((i + k) % 6 == 0)
					break EXIT_LOOP;
			}
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Etiketli break kullanımı. Örnek yine durumu göstermek için yazılmıştır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		EXIT_LOOP:
		for (int i = 0; i < 10; ++i) {
			EXIT_INNER_LOOP:
			for (int j = 0; j < 60; ++j) {
				for (int k = 25; k >= 0; --k) {
					System.out.printf("(%d, %d, %d)%n", i, j, k);

					if ((i + j + k) % 10 == 0)
						break;

					if ((i + j + k) % 6 == 0)
						break EXIT_INNER_LOOP;

					if ((i + j + k) % 11 == 0)
						break EXIT_LOOP;
				}
			}
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}
/*-----------------------------------------------------
Homework-002
Soru 1
Bir çözümü
-------------------------------------------------------*/

package csd;

import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        displayDiamondTest.run(new Scanner(System.in));
    }
}
class displayDiamondTest{
    public static void run(Scanner kb)
    {
        System.out.println("Enter n?");
        int n = Integer.parseInt(kb.nextLine());
        NumberUtil.displayDiamond(n);
    }
}


class NumberUtil{
    public static void displayDiamond(int n)
    {
        int x = 0;
        boolean flag = true;
        do{
            for(int i = 0;i < n - x - 1;++i)
                System.out.print(" ");
            for (int i = 0;i < 2 * x + 1;++i)
                System.out.print("*");
            if(flag && x == n - 1)
                flag = false;
            if(flag)
                ++x;
            else
                --x;
            System.out.println();
        }while(x >= 0);
    }
}
/*-----------------------------------------------------
Homework-002
Soru 4
Bir çözümü
-------------------------------------------------------*/

package csd;

import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        BallShapeTest.run(new Scanner(System.in));
    }
}

class BallShapeTest{
    public static void run(Scanner kb)
    {
        System.out.println("Enter Height?");
        int height = Integer.parseInt(kb.nextLine());
        System.out.println("Enter Width?");
        int width = Integer.parseInt(kb.nextLine());
        BallGame.BallShape(height,width);
    }
}

class BallGame{
    public static void BallShape(int height,int width)
    {
        int BallIndex = 0;
        boolean directionFlag = true;
        while(height-- != 0){
            System.out.print("|");
            for(int i = 0;i < BallIndex;++i)
                System.out.print(" ");
            System.out.print("*");
            for (int i = BallIndex;i < width - 1;++i)
                System.out.print(" ");
            System.out.println("|");
            if(directionFlag && BallIndex == width - 1)
                directionFlag = false;
            else if(!directionFlag && BallIndex == 0)
                directionFlag = true;
            if(directionFlag)
                ++BallIndex;
            else
                --BallIndex;
        }
    }
}
/*----------------------------------------------------------------------------------------------------------------------
	continue deyimi döngüyü değil döngünün bir adımını sonlandırmak için kullanılır. continue deyiminin de etiketli biçimi
	vardır. Ancak yapısal programlama ve nesne yönelimli programlama tekniği açısından kullanımı tavsiye edilmez. continue
	deyiminin etiketsiz biçimi break deyimi kadar sık kullanılmasa da bazı durumlarda okunabilirlik/algılanabilirlik
	açısında tercih edilebilir. continue deyimi yalnızca döngü deyimlerinde kullanılabilir

	Aşağıdaki örnekte sıfır ile klavyeden girilen bir sayı arasındaki çift sayılar constinue deyimi kullanılarak ekrana
	bastırılmıştır. Şüphesiz daha kolay yazılabbilir. Örnek continue deyiminin çalışmasını göstermek için bu şekilde
	yazılmıştır.
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		for (int i = 0; i < count; ++i) {
			if (i % 2 != 0)
				continue;

			System.out.printf("%d ", i);
		}


		System.out.println("\nTekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Basit bir menü uygulamasının iskeleti
	(İleride daha iyisi yazılacaktır)
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		MenuApp.run();
	}
}

class MenuApp {
	public static void printMenu()
	{
		System.out.println("1.Ekle");
		System.out.println("2.Sil");
		System.out.println("3.Güncelle");
		System.out.println("4.Listele");
		System.out.println("5.Çıkış");
		System.out.print("Seçenek:");
	}

	public static void doWorkForInsert()
	{
		System.out.println("---------------------");
		System.out.println("\"Ekle\" seçildi");
		System.out.println("---------------------");
	}

	public static void doWorkForDelete()
	{
		System.out.println("---------------------");
		System.out.println("\"Sil\" seçildi");
		System.out.println("---------------------");
	}

	public static void doWorkForUpdate()
	{
		System.out.println("---------------------");
		System.out.println("\"Güncelle\" seçildi");
		System.out.println("---------------------");
	}

	public static void doWorkForList()
	{
		System.out.println("---------------------");
		System.out.println("\"Listele\" seçildi");
		System.out.println("---------------------");
	}

	public static void doWorkForInvalidOption()
	{
		System.out.println("---------------------");
		System.out.println("Geçersiz seçenek");
		System.out.println("---------------------");
	}

	public static void doWork(int option)
	{
		if (option == 1)
			doWorkForInsert();
		else if (option == 2)
			doWorkForDelete();
		else if (option == 3)
			doWorkForUpdate();
		else if (option == 4)
			doWorkForList();
	}

	public static void doGoodbyeWork()
	{
		System.out.println("Teşekkürler");
		System.out.println("C ve Sistem Programcıları Derneği");
		System.out.println("Tekrar yapıyor musunuz?");
	}

	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for (;;) {
			printMenu();
			int option = Integer.parseInt(kb.nextLine());

			if (option < 1 || option > 5) {
				doWorkForInvalidOption();
				continue;
			}

			if (option == 5)
				break;

			doWork(option);
		}

		doGoodbyeWork();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Basit bir menü uygulamasının iskeleti
	(İleride daha iyisi yazılacaktır)
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		MenuApp.run();
	}
}

class MenuApp {
	public static void printMenu()
	{
		System.out.println("1.Ekle");
		System.out.println("2.Sil");
		System.out.println("3.Güncelle");
		System.out.println("4.Listele");
		System.out.println("5.Çıkış");
		System.out.print("Seçenek:");
	}

	public static void doWorkForInsert()
	{
		System.out.println("---------------------");
		System.out.println("\"Ekle\" seçildi");
		System.out.println("---------------------");
	}

	public static void doWorkForDelete()
	{
		System.out.println("---------------------");
		System.out.println("\"Sil\" seçildi");
		System.out.println("---------------------");
	}

	public static void doWorkForUpdate()
	{
		System.out.println("---------------------");
		System.out.println("\"Güncelle\" seçildi");
		System.out.println("---------------------");
	}

	public static void doWorkForList()
	{
		System.out.println("---------------------");
		System.out.println("\"Listele\" seçildi");
		System.out.println("---------------------");
	}

	public static void doWorkForInvalidOption()
	{
		System.out.println("---------------------");
		System.out.println("Geçersiz seçenek");
		System.out.println("---------------------");
	}

	public static void doWork(int option)
	{
		if (option == 1)
			doWorkForInsert();
		else if (option == 2)
			doWorkForDelete();
		else if (option == 3)
			doWorkForUpdate();
		else if (option == 4)
			doWorkForList();
	}

	public static void doGoodbyeWork()
	{
		System.out.println("Teşekkürler");
		System.out.println("C ve Sistem Programcıları Derneği");
		System.out.println("Tekrar yapıyor musunuz?");
	}

	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for (;;) {
			printMenu();
			int option = Integer.parseInt(kb.nextLine());

			if (1 <= option && option <= 5) {
				if (option == 5)
					break;

				doWork(option);
			}
			else
				doWorkForInvalidOption();
		}

		doGoodbyeWork();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	05.11.2022
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı n sayısı için n-inci Fibonacci sayısını döndüren getFibonacciNumber isimli
	metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz

	Açıklamalar:
		- Fibonacci sayıları
			0 1 1 2 3 5 8 13 21 ...
		- Metot pozitif olmayan n değerleri için kontrol yapmayacaktır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		GetFibonacciNumberTest.run();
	}
}

class GetFibonacciNumberTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int n = Integer.parseInt(kb.nextLine());

			if (n <= 0)
				break;

			System.out.printf("%d.Fibonacci sayısı:%d%n", n, NumberUtil.getFibonacciNumber(n));
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil {
	public static int getFibonacciNumber(int n)
	{
		if (n <= 2)
			return n - 1;

		int prev1 = 1, prev2 = 0, val = prev1 + prev2;

		for (int i = 3; i < n; ++i) {
			prev2 = prev1;
			prev1 = val;
			val = prev1 + prev2;
		}

		return val;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayıdan büyük ilk Fibonacci sayısına geri dönen getNextFibonacciNumber
	isimli metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		GetNextFibonacciNumberTest.run();
	}
}

class GetNextFibonacciNumberTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int val = Integer.parseInt(kb.nextLine());

			System.out.printf("%d den sonraki ilk Fibonacci sayısı:%d%n", val, NumberUtil.getNextFibonacciNumber(val));

			if (val == 0)
				break;
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil {
	public static int getNextFibonacciNumber(int val)
	{
		if (val < 0)
			return 0;

		int prev1 = 1, prev2 = 0, next;

		for (;;) {
			next = prev1 + prev2;

			if (next > val)
				return next;

			prev2 = prev1;
			prev1 = next;
		}
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	switch deyiminin genel biçimi:
	switch (<ifade>) {
		case <sabit ifadesi>:
			<deyim>
		case <sabit ifadesi>:
			<deyim>
			...
		[
		default:
			<deyim>
		]
	}

	Bu deyimde parantez içerisindeki ifadenin türü, temel türler için tamsayı türlerinden biri veya char türü olabilir.
	Temel türler dışında String veya enum class türlerinden de olabilir. Bu türler ileride ele alınacaktır. switch deyiminin
	default kısmı olmak zorunda değildir.

	Anahtar Notlar: switch deyimine Java12'den itibaren ifade (expression) olarak da kullanılabilecek şekilde eklentiler
	yapılmıştır. Bu tarz deyimlere programlamada "ifadesel deyim (expression statement)" de denir. Bu deyimin ifadesel
	olarak kullanımına ilişkin eklentiler ileride ele alınacaktır.
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
    public static void main(String [] args)
    {
        java.util.Scanner kb = new java.util.Scanner(System.in);
        System.out.println("Bir şehir giriniz");
        String str = kb.nextLine();

        switch (str){
            case "İstanbul":
            case "istanbul":
                System.out.println("İstanbul şehri");
                break;
            case "İzmir":
            case "izmir":
                System.out.println("izmir şehri");
                break;
            case "Ankara":
            case "ankara":
                System.out.println("Ankara şehri");
                break;
            default:
                System.out.println("Başka bir şehir");
        }
    }
}
//------------------------------------------------------------------
package csd;

class App {
    public static void main(String [] args)
    {
        java.util.Scanner kb = new java.util.Scanner(System.in);
        System.out.println("Bir sayı giriniz");
        int val = Integer.parseInt(kb.nextLine());

        switch (val){
            case 11:
                val = (int)Math.pow(val,2);
                System.out.printf("val : %d%n",val);
                break;
            case 21:
                val += 10;
                System.out.printf("val : %d%n",val);
                break;
            case 31:
                val +=4;
                System.out.printf("val : %d%n",val);
                break;
            default:
                val = (int)Math.sqrt(val);
                System.out.printf("val : %d%n",val);
        }

    }
}
//----------------------------------------------------------------------------------------------
package csd;

class App {
    public static void main(String [] args)
    {
        char ch = '|';

        switch (ch){
            case 'A':
            case 'a':
                System.out.println("A");
                break;
            case 'b':
            case 'B':
                System.out.println("B");
                break;
            default:
                System.out.println("Başka bir karakter");
        }

    }
}
//----------------------------------------------------------------
package csd;

class App {
    public static void main(String [] args)
    {
        java.util.Scanner kb = new java.util.Scanner(System.in);
        System.out.println("Bir sayı giriniz?");
        float fval = Float.parseFloat(kb.nextLine());
        System.out.println("Bir sayı giriniz?");
        double dval = Double.parseDouble(kb.nextLine());
        switch (fval){
            case 2.3:
                System.out.println("2.3");
        }
        switch (dval){
            case 20.5:
                System.out.println("20.5");
        }
    }
}
/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki switch deyiminin if deyimi karşılığı:

	if (postalCode == 67100)
		System.out.println("Zonguldak Bahçelievler Mahallesi");
	else if (postalCode == 34387)
		System.out.println("İstanbul Mecidiyeköy");
	else
		System.out.println("Geçersiz posta kodu");
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Posta kodunu giriniz:");
		int postalCode = kb.nextInt();

		switch (postalCode) {
		case 67100:
			System.out.println("Zonguldak Bahçelievler Mahallesi");
			break;
		case 34387:
			System.out.println("İstanbul Mecidiyeköy");
			break;
		default:
			System.out.println("Geçersiz posta kodu");
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	switch deyiminin default kısmı olmak zorunda değildir. Aşağıdaki switch deyiminin if deyimi karşılığı şu şekildedir:

	if (postalCode == 67100)
		System.out.println("Zonguldak Bahçelievler Mahallesi");
	else if (postalCode == 34387)
		System.out.println("İstanbul Mecidiyeköy");
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Posta kodunu giriniz:");
		int postalCode = kb.nextInt();

		switch (postalCode) {
		case 67100:
			System.out.println("Zonguldak Bahçelievler Mahallesi");
			break;
		case 34387:
			System.out.println("İstanbul Mecidiyeköy");
			break;
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	switch deyiminde default bölümün yerinin önemi yoktur. Şüphesiz sona koymak iyi bir tekniktir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Posta kodunu giriniz:");
		int postalCode = kb.nextInt();

		switch (postalCode) {
		default:
			System.out.println("Geçersiz posta kodu");
			break;
		case 67100:
			System.out.println("Zonguldak Bahçelievler Mahallesi");
			break;
		case 34387:
			System.out.println("İstanbul Mecidiyeköy");
			break;
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: switch deyiminin bölümleri içerisinde (case ve default) çok fazla işlem yapılması okunabilirlik/algılanabilirlik
	açısından iyi bir teknik değildir. Bu durumda metot yazıp ilgili bölümlerde çağırmak gerekir. Bunun için nest bir sınır
	olmasa da 3-4 satırı geçen kodların yazılamaması gerekir
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	switch deyiminde case bölümlerine ilişkin ifadeler sabit ifadesi (constant expression) olmalıdır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Posta kodunu giriniz:");
		int postalCode = kb.nextInt();

		int code = 67100;

		switch (postalCode) {
		case code:
			System.out.println("Zonguldak Bahçelievler Mahallesi");
			break;
		case 34387:
			System.out.println("İstanbul Mecidiyeköy");
			break;
		default:
			System.out.println("Geçersiz posta kodu");
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	switch deyiminde aynı değere sahip birden fazla case bölümü geçersizdir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Posta kodunu giriniz:");
		int postalCode = kb.nextInt();

		switch (postalCode) {
		case 67100:
			System.out.println("Zonguldak Bahçelievler Mahallesi");
			break;
		case 34387: //error
			System.out.println("İstanbul Mecidiyeköy");
			break;
		case 34388 - 1: //error
			System.out.println("İstanbul Mecidiyeköy");
			break;
		default:
			System.out.println("Geçersiz posta kodu");
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	switch deyiminde temel türler için tamsayı türleri veya char türü dışında başka bir tüt kullanılamaz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Posta kodunu giriniz:");
		double postalCode = kb.nextDouble();

		switch (postalCode) {
		case 67100:
			System.out.println("Zonguldak Bahçelievler Mahallesi");
			break;
		case 34387:
			System.out.println("İstanbul Mecidiyeköy");
			break;
		default:
			System.out.println("Geçersiz posta kodu");
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	switch deyiminde aşağı düşme (fall-through) özelliği vardır. Bir case bölümü veya default bölüm yakalandığında
	aşağıya doğru engelleyen herhangi bir deyim görülünceye kadar her deyim çalıştırılır. break deyimi switch deyimini
	sonlandırmak için kullanılır. Bu durumda break deyimi aşağı düşmeyi engeller. Başka engelleyici deyimler de olabilir.
	Aşağıdaki kodu inceleyiniz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Posta kodunu giriniz:");
		int postalCode = kb.nextInt();

		switch (postalCode) {
		case 67100:
			System.out.println("Zonguldak Bahçelievler Mahallesi");
		case 34387:
			System.out.println("İstanbul Mecidiyeköy");
			//break;
		default:
			System.out.println("Geçersiz posta kodu");
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	switch deyiminde aşağı düşme (fall-through) özelliği vardır. Bir case bölümü veya default bölüm yakalandığında
	aşağıya doğru engelleyen herhangi bir deyim görülünceye kadar her deyim çalıştırılır. break deyimi switch deyimini
	sonlandırmak için kullanılır. Bu durumda break deyimi aşağı düşmeyi engeller. Başka engelleyici deyimler de olabilir.
	Aşağıdaki kodu inceleyiniz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Posta kodunu giriniz:");
		int postalCode = kb.nextInt();

		switch (postalCode) {
		default:
			System.out.println("Geçersiz posta kodu");
		case 67100:
			System.out.println("Zonguldak Bahçelievler Mahallesi");
		case 34387:
			System.out.println("İstanbul Mecidiyeköy");
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	switch deyiminde aşağı düşme (fall-through) özelliği vardır. Bir case bölümü veya default bölüm yakalandığında
	aşağıya doğru engelleyen herhangi bir deyim görülünceye kadar her deyim çalıştırılır. break deyimi switch deyimini
	sonlandırmak için kullanılır. Bu durumda break deyimi aşağı düşmeyi engeller. Başka engelleyici deyimler de olabilir.
	Aşağıdaki kodu inceleyiniz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Posta kodunu giriniz:");
		int postalCode = kb.nextInt();

		switch (postalCode) {
		default:
			System.out.println("Geçersiz posta kodu");
		case 67100:
			System.out.println("Zonguldak Bahçelievler Mahallesi");
		case 34387:
			System.out.println("İstanbul Mecidiyeköy");
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte switch deyiminin aşağı düşme özelliğinden yararlanılmıştır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Telefon kodunu giriniz:");
		int code = kb.nextInt();

		switch (code) {
		case 212:
			System.out.print("Avrupa ");
		case 216:
			System.out.println("İstanbul");
			break;
		case 372:
			System.out.println("Zonguldak");
			break;
		case 312:
			System.out.println("Ankara");
			break;
		default:
			System.out.println("Geçersiz şehir");
		}
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte switch deyiminin aşağı düşme özelliğinden yararlanılmıştır. Aşağıdaki örnekteki 212 ve 216 kodları
	için yapılan işlemin daha kısa yapılışı yoktur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Telefon kodunu giriniz:");
		int code = kb.nextInt();

		switch (code) {
		case 212:
		case 216:
			System.out.println("İstanbul");
			break;
		case 372:
			System.out.println("Zonguldak");
			break;
		case 312:
			System.out.println("Ankara");
			break;
		default:
			System.out.println("Geçersiz şehir");
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Basit bir menü uygulamasının iskeleti
	(İleride daha iyisi yazılacaktır)
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		MenuApp.run();
	}
}

class MenuApp {
	public static void printMenu()
	{
		System.out.println("1.Ekle");
		System.out.println("2.Sil");
		System.out.println("3.Güncelle");
		System.out.println("4.Listele");
		System.out.println("5.Çıkış");
		System.out.print("Seçenek:");
	}

	public static void doWorkForInsert()
	{
		System.out.println("---------------------");
		System.out.println("\"Ekle\" seçildi");
		System.out.println("---------------------");
	}

	public static void doWorkForDelete()
	{
		System.out.println("---------------------");
		System.out.println("\"Sil\" seçildi");
		System.out.println("---------------------");
	}

	public static void doWorkForUpdate()
	{
		System.out.println("---------------------");
		System.out.println("\"Güncelle\" seçildi");
		System.out.println("---------------------");
	}

	public static void doWorkForList()
	{
		System.out.println("---------------------");
		System.out.println("\"Listele\" seçildi");
		System.out.println("---------------------");
	}

	public static void doWorkForInvalidOption()
	{
		System.out.println("---------------------");
		System.out.println("Geçersiz seçenek");
		System.out.println("---------------------");
	}

	public static void doWork(int option)
	{
		switch (option) {
		case 1:
			doWorkForInsert();
			break;
		case 2:
			doWorkForDelete();
			break;
		case 3:
			doWorkForUpdate();
			break;
		case 4:
			doWorkForList();
			break;
		default:
			doWorkForInvalidOption();
		}
	}

	public static void doGoodbyeWork()
	{
		System.out.println("Teşekkürler");
		System.out.println("C ve Sistem Programcıları Derneği");
		System.out.println("Tekrar yapıyor musunuz?");
	}

	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for (;;) {
			printMenu();
			int option = Integer.parseInt(kb.nextLine());

			if (option == 5)
				break;

			doWork(option);
		}

		doGoodbyeWork();
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Hangi metot içerisinde olursak olalım programı sonlandırmak için System.exit isimli metodu çağırabiliriz. Bu metot
	parametre olarak int türden "çıkış kodu (exit code)" denilen ve program sonlandığında JVM'e oradan da işletim sistemine
	iletilen bir değer alır. Bu değerin çoğu zaman önemi olmaz. Bazı durumlarda okunabilirlik açısından mantıksal başarı veya
	başarısızlığa göre belirlenen değerler argüman olarak verilebilir. main normal sonlandığında JVM'e oradan da işletim
	sistemine sıfır çıkış kodu iletilir. Çıkış kodunun nerelerde kullanıldığı burada ele alınmayacaktır.

	Aşağıdaki örnekte geçersiz giriş durumunda program sonlandırılmıştır. Örnek exit metodunu göstermek amaçlı aşağıdaki
	gibi yazılmıştır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		LogApp.run();
	}
}

class LogApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		double val = kb.nextDouble();

		if (val <= 0) {
			System.out.println("Geçersiz giriş");
			System.exit(1);
		}

		//...
		System.out.printf("log(%f) = %f%n", val, Math.log(val));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Basit bir menü uygulamasının iskeleti
	(İleride daha iyisi yazılacaktır)
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		MenuApp.run();
	}
}

class MenuApp {
	public static void printMenu()
	{
		System.out.println("1.Ekle");
		System.out.println("2.Sil");
		System.out.println("3.Güncelle");
		System.out.println("4.Listele");
		System.out.println("5.Çıkış");
		System.out.print("Seçenek:");
	}

	public static void doWorkForInsert()
	{
		System.out.println("---------------------");
		System.out.println("\"Ekle\" seçildi");
		System.out.println("---------------------");
	}

	public static void doWorkForDelete()
	{
		System.out.println("---------------------");
		System.out.println("\"Sil\" seçildi");
		System.out.println("---------------------");
	}

	public static void doWorkForUpdate()
	{
		System.out.println("---------------------");
		System.out.println("\"Güncelle\" seçildi");
		System.out.println("---------------------");
	}

	public static void doWorkForList()
	{
		System.out.println("---------------------");
		System.out.println("\"Listele\" seçildi");
		System.out.println("---------------------");
	}

	public static void doWorkForInvalidOption()
	{
		System.out.println("---------------------");
		System.out.println("Geçersiz seçenek");
		System.out.println("---------------------");
	}

	public static void doWork(int option)
	{
		switch (option) {
		case 1:
			doWorkForInsert();
			break;
		case 2:
			doWorkForDelete();
			break;
		case 3:
			doWorkForUpdate();
			break;
		case 4:
			doWorkForList();
			break;
		case 5:
			doGoodbyeWork();
		default:
			doWorkForInvalidOption();
		}
	}

	public static void doGoodbyeWork()
	{
		System.out.println("Teşekkürler");
		System.out.println("C ve Sistem Programcıları Derneği");
		System.out.println("Tekrar yapıyor musunuz?");
		System.exit(0);
	}

	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for (;;) {
			printMenu();
			doWork(Integer.parseInt(kb.nextLine()));
		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden yıl değerinin artık yıl olup olmadığını test eden isLeapYear
	isimli metodu yazınız ve aşağıdaki kod ile test ediniz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		IsLeapYearTest.run();
	}
}

class IsLeapYearTest {
	public static void run()
	{
		for (int year = 1994; year <= 2104; ++year)
			if (DateUtil.isLeapYear(year))
				System.out.println(year);
	}
}

class DateUtil {
	public static boolean isLeapYear(int year)
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	06.11.2022
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden gün, ay ve yıl bilgilerine ilişkin tarihin geçerli olup olmadığını
	test eden isValidDate isimli metodu yazını ve aşağıdaki kod ile test ediniz
	(İleride daha iyisi yazılacaktır)
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		IsValidDateTest.run();
	}
}

class IsValidDateTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for (;;) {
			System.out.print("Gün ay ve yıl bilgilerini giriniz:");
			int day = kb.nextInt();
			int month = kb.nextInt();
			int year = kb.nextInt();

			if (day == 0)
				break;

			if (DateUtil.isValidDate(day, month, year))
				System.out.printf("%02d/%02d/%04d tarihi geçerlidir%n", day, month, year);
			else
				System.out.println("Geçersiz tarih");
		}

		System.out.println("Tekrar yapıyor munuz?");
	}
}

class DateUtil {
	public static boolean isValidDate(int day, int month, int year)
	{
		return 1 <= day && day <= 31 && 1 <= month && month <= 12 && day <= getDays(month, year);
	}

	public static int getDays(int month, int year)
	{
		int days = 31;

		switch (month) {
		case 4:
		case 6:
		case 9:
		case 11:
			days = 30;
			break;
		case 2:
			days = 28;
			if (isLeapYear(year))
				++days;
		}

		return days;
	}

	public static boolean isLeapYear(int year)
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden gün, ay ve yıl bilgilerine ilişkin tarihin aşağıdaki açıklamalara
	göre haftanın hangi gününe geldiğini döndüren getDayOfWeek metodunu yazınız ve aşağıdaki kod ile test ediniz.,
	Açıklamalar:
		- Metot geçersiz bir tarih için -1 değerine geri dönecektir
		- 01.01.1900 öncesindeki tarihler geçersiz kabul edilecektir
		- Haftanın günü 01.01.1900 ile verilen tarih arasındaki (verilen tarih dahil) gün sayısının 7(yedi) ile
		bölümünden elde edilen kalan alınarak belirlenebilir. Buna göre değer sıfır ise "pazar", 1 ise "pazartesi", ...,
		6 ise "cumartesi" günlerine karşılık gelir
		- Bu metot ile birlikte verilen tarihin hafta sonu olup olmadığını test eden isWeekend ve hafta içi olup olmadığını
		test eden isWeekday metotlarını da yazınız. Bu metotlar tarih geçerlilik kontrolü yapmayacaktır
		- İleride daha iyisi yazılacaktır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		GetDayOfWeekTest.run();
	}
}

class GetDayOfWeekTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for (;;) {
			System.out.print("Gün ay ve yıl bilgilerini giriniz:");
			int day = kb.nextInt();
			int month = kb.nextInt();
			int year = kb.nextInt();

			if (day == 0)
				break;

			DateUtil.printDateTR(day, month, year);
		}

		System.out.println("Tekrar yapıyor munuz?");
	}
}

class DateUtil {
	public static void printDateTR(int day, int month, int year)
	{
		int dayOfWeek = getDayOfWeek(day, month, year);

		if (dayOfWeek == -1) {
			System.out.println("Geçersiz tarih");
			return;
		}

		printDateByDayOfWeekTR(day, month, year, dayOfWeek);

		if (isWeekend(day, month, year))
			System.out.println("Bugün kurs var. Tekrar yaptınız mı?");
		else
			System.out.println("Kurs günü yaklaşıyor. Tekrar yapmayı unutmayınız!...");
	}

	public static void printDateByDayOfWeekTR(int day, int month, int year, int dayOfWeek)
	{
		switch (dayOfWeek) {
		case 0:
			System.out.printf("%02d/%02d/%04d Pazar%n", day, month, year);
			break;
		case 1:
			System.out.printf("%02d/%02d/%04d Pazartesi%n", day, month, year);
			break;
		case 2:
			System.out.printf("%02d/%02d/%04d Salı%n", day, month, year);
			break;
		case 3:
			System.out.printf("%02d/%02d/%04d Çarşamba%n", day, month, year);
			break;
		case 4:
			System.out.printf("%02d/%02d/%04d Perşembe%n", day, month, year);
			break;
		case 5:
			System.out.printf("%02d/%02d/%04d Cuma%n", day, month, year);
			break;
		case 6:
			System.out.printf("%02d/%02d/%04d Cumartesi%n", day, month, year);
		}
	}

	public static int getDayOfWeek(int day, int month, int year)
	{
		int totalDays;

		if (year < 1900 || (totalDays = getDayOfYear(day, month, year)) == -1)
			return -1;

		return getTotalDays(year, totalDays) % 7;
	}

	public static int getTotalDays(int year, int totalDays)
	{
		for (int y = 1900; y < year; ++y) {
			totalDays += 365;
			if (isLeapYear(y))
				++totalDays;
		}

		return totalDays;
	}

	public static boolean isWeekend(int day, int month, int year)
	{
		int dayOfWeek = getDayOfWeek(day, month, year);

		return dayOfWeek == 0 || dayOfWeek == 6;
	}

	public static boolean isWeekday(int day, int month, int year)
	{
		return !isWeekend(day, month, year);
	}

	public static int getDayOfYear(int day, int month, int year)
	{
		if (!isValidDate(day, month, year))
			return -1;

		int total = day;

		switch (month - 1) {
		case 11:
			total += 30;
		case 10:
			total += 31;
		case 9:
			total += 30;
		case 8:
			total += 31;
		case 7:
			total += 31;
		case 6:
			total += 30;
		case 5:
			total += 31;
		case 4:
			total += 30;
		case 3:
			total += 31;
		case 2:
			total += 28;
			if (isLeapYear(year))
				++total;
		case 1:
			total += 31;
		}

		return total;
	}

	public static boolean isValidDate(int day, int month, int year)
	{
		return 1 <= day && day <= 31 && 1 <= month && month <= 12 && day <= getDays(month, year);
	}

	public static int getDays(int month, int year)
	{
		int days = 31;

		switch (month) {
		case 4:
		case 6:
		case 9:
		case 11:
			days = 30;
			break;
		case 2:
			days = 28;
			if (isLeapYear(year))
				++days;
		}

		return days;
	}

	public static boolean isLeapYear(int year)
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	19.11.2022
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Java 12 ile birlikte "preview" olarak "switch expression" dile dahil edilmiştir. Bu durumda switch ifade biçiminde de
	kullanılabilecek şekilde sentaks ve semantik açıdan geliştirilmiştir. switch'in bu şekildeki kullanımı
	"switch expression statement" olarak da adlandırılabilir. Yani kabaca switch expression semantiği statement biçiminde de
	kullanılabilir.

	Anahtar Notlar: Java dünyasında Java 8, Java 11 ve Java 17 LTS (Long Term Support) olarak kullanıldığından switch
	expression yeni yeni yaygınlaşmaya başlamıştır. Çünkü halen en çok kullanılan sürümler Java 8 ve Java 11'dir. Java'nın
	LTS dışında kalan ara sürümlerinin desteği çabuk bittiğinden ticari uygulamalarda pek tercih edilmezler. Örneğin Android
	sistemlerinde Java 17 kullanımı şu an oldukça kısıtlıdır. Bu sistemlerde ağırlıklı olarak Java 8 ve Java 11 kullanılmaktadır
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte switch expression, statement biçiminde kullanılmıştır. switch statement karşılığı şu şekildedir:
	switch (code) {
		case 67100:
			System.out.println("Zonguldak Bahçelievler");
			break;
		case 34387:
			System.out.println("İstanbul Mecidiyeköy");
			break;
		default:
			System.out.println("Geçersiz post kodu");
	}

	switch expression'ın fall-through özelliği yoktur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);


		for (;;) {
			System.out.print("Posta kodunu giriniz:");
			int code = Integer.parseInt(kb.nextLine());

			if (code <= 0)
				break;

			switch (code) {
			case 67100 -> System.out.println("Zonguldak Bahçelievler");
			case 34387 -> System.out.println("İstanbul Mecidiyeköy");
			default -> System.out.println("Geçersiz post kodu");
			}
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte switch expression'ın değeri bri değişkene atanmıştır. Eşdeğeri şu şekildedir:
	switch (code) {
		case 212:
		case 216:
			plate = 34;
			break;
		case 372:
			plate = 67;
			break;
		case 312:
			plate = 6;
			break;
		default:
			plate = -1;
	}
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);


		for (;;) {
			System.out.print("Telefon kodunu giriniz:");
			int code = Integer.parseInt(kb.nextLine());

			if (code <= 0)
				break;

			int plate = switch (code) {
					case 212, 216 -> 34;
					case 372 -> 67;
					case 312 -> 6;
					default -> -1;
			};


			if (plate != -1)
				System.out.printf("Plaka No:%d%n", plate);
			else
				System.out.println("Geçersiz plaka no!...");
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte switch expression'ın değeri metoda argüman olarak geçilmiştir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);


		for (;;) {
			System.out.print("Telefon kodunu giriniz:");
			int code = Integer.parseInt(kb.nextLine());

			if (code <= 0)
				break;

			Util.printPlateStatus(switch(code) {
					case 212, 216 -> 34;
					case 372 -> 67;
					case 312 -> 6;
					default -> -1;
			});
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class Util {
	public static void printPlateStatus(int plate)
	{
		if (plate != -1)
			System.out.printf("Plaka No:%d%n", plate);
		else
			System.out.println("Geçersiz plaka no!...");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte switch expression'ın değeri kullanıldığından default kısmı olmak zorundadır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);


		for (;;) {
			System.out.print("Telefon kodunu giriniz:");
			int code = Integer.parseInt(kb.nextLine());

			if (code <= 0)
				break;

			Util.printPlateStatus(switch(code) { //error
					case 212, 216 -> 34;
					case 372 -> 67;
					case 312 -> 6;
			});
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class Util {
	public static void printPlateStatus(int plate)
	{
		if (plate != -1)
			System.out.printf("Plaka No:%d%n", plate);
		else
			System.out.println("Geçersiz plaka no!...");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte switch expression, statement olarak kullanıldığından default kısmı zorunlu değildir. Senaryoya göre
	olabilir ya da olmayabilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);


		for (;;) {
			System.out.print("Posta kodunu giriniz:");
			int code = Integer.parseInt(kb.nextLine());

			if (code <= 0)
				break;

			switch (code) {
			case 67100 -> System.out.println("Zonguldak Bahçelievler");
			case 34387 -> System.out.println("İstanbul Mecidiyeköy");
			}
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Klasik switch deyiminin yield anahtar sözcüğü ile değer üretmesi yani expression olarak kullanılması sağlanabilir. Bu  da
	Java 12 ile dile eklenmiştir. yield kullanıldığında aşağı düşme olmaz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);


		for (;;) {
			System.out.print("Telefon kodunu giriniz:");
			int code = Integer.parseInt(kb.nextLine());

			if (code <= 0)
				break;

			Util.printPlateStatus(switch(code) {
					case 212:
					case 216: yield 34;
					case 372: yield 67;
					case 312: yield 6;
					default: yield -1;
			});
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class Util {
	public static void printPlateStatus(int plate)
	{
		if (plate != -1)
			System.out.printf("Plaka No:%d%n", plate);
		else
			System.out.println("Geçersiz plaka no!...");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Klasik switch deyiminin yield anahtar sözcüğü ile değer üretmesi yani expression olarak kullanılması sağlanabilir. Bu  da
	Java 12 ile dile eklenmiştir. yield kullanıldığında aşağı düşme olmaz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);


		for (;;) {
			System.out.print("Telefon kodunu giriniz:");
			int code = Integer.parseInt(kb.nextLine());

			if (code <= 0)
				break;

			Util.printPlateStatus(switch(code) {
					case 212:
					case 216:
						System.out.println("İstanbul");
						yield 34;
					case 372: yield 67;
					case 312: yield 6;
					default: yield -1;
			});
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class Util {
	public static void printPlateStatus(int plate)
	{
		if (plate != -1)
			System.out.printf("Plaka No:%d%n", plate);
		else
			System.out.println("Geçersiz plaka no!...");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	switch expression'da case bölümünde bileşik deyim olduğunda bir değer üretebilmesi için yield anahtar sözcüğü
	kullanılmalıdır. Şüphesiz değer üretmeyen bir switch expression için yield kullanılması gerekmez
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);


		for (;;) {
			System.out.print("Telefon kodunu giriniz:");
			int code = Integer.parseInt(kb.nextLine());

			if (code <= 0)
				break;

			Util.printPlateStatus(switch(code) {
					case 212, 216 -> {
						System.out.println("İstanbul");
						yield 34;
					}
					case 372 -> 67;
					case 312 -> 6;
					default -> -1;
			});
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class Util {
	public static void printPlateStatus(int plate)
	{
		if (plate != -1)
			System.out.printf("Plaka No:%d%n", plate);
		else
			System.out.println("Geçersiz plaka no!...");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte switch expression'ın ürettiği değer metoda geri dönüş değeri olarak verilmiştir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);


		for (;;) {
			System.out.print("Telefon kodunu giriniz:");
			int code = Integer.parseInt(kb.nextLine());

			if (code <= 0)
				break;

			Util.printPlateStatus(Util.getPlateByCode(code));
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class Util {
	public static int getPlateByCode(int code)
	{
		return switch(code) {
			case 212, 216 -> 34;
			case 372 -> 67;
			case 312 -> 6;
			default -> -1;
		};
	}

	public static void printPlateStatus(int plate)
	{
		if (plate != -1)
			System.out.printf("Plaka No:%d%n", plate);
		else
			System.out.println("Geçersiz plaka no!...");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden gün, ay ve yıl bilgilerine ilişkin tarihin aşağıdaki açıklamalara
	göre haftanın hangi gününe geldiğini döndüren getDayOfWeek metodunu yazınız ve aşağıdaki kod ile test ediniz.,
	Açıklamalar:
		- Metot geçersiz bir tarih için -1 değerine geri dönecektir
		- 01.01.1900 öncesindeki tarihler geçersiz kabul edilecektir
		- Haftanın günü 01.01.1900 ile verilen tarih arasındaki (verilen tarih dahil) gün sayısının 7(yedi) ile
		bölümünden elde edilen kalan alınarak belirlenebilir. Buna göre değer sıfır ise "pazar", 1 ise "pazartesi", ...,
		6 ise "cumartesi" günlerine karşılık gelir
		- Bu metot ile birlikte verilen tarihin hafta sonu olup olmadığını test eden isWeekend ve hafta içi olup olmadığını
		test eden isWeekday metotlarını da yazınız. Bu metotlar tarih geçerlilik kontrolü yapmayacaktır
		- İleride daha iyisi yazılacaktır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		GetDayOfWeekTest.run();
	}
}

class GetDayOfWeekTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for (;;) {
			System.out.print("Gün ay ve yıl bilgilerini giriniz:");
			int day = kb.nextInt();
			int month = kb.nextInt();
			int year = kb.nextInt();

			if (day == 0)
				break;

			DateUtil.printDateTR(day, month, year);
		}

		System.out.println("Tekrar yapıyor munuz?");
	}
}

class DateUtil {
	public static void printDateTR(int day, int month, int year)
	{
		int dayOfWeek = getDayOfWeek(day, month, year);

		if (dayOfWeek == -1) {
			System.out.println("Geçersiz tarih");
			return;
		}

		printDateByDayOfWeekTR(day, month, year, dayOfWeek);

		if (isWeekend(day, month, year))
			System.out.println("Bugün kurs var. Tekrar yaptınız mı?");
		else
			System.out.println("Kurs günü yaklaşıyor. Tekrar yapmayı unutmayınız!...");
	}

	public static void printDateByDayOfWeekTR(int day, int month, int year, int dayOfWeek)
	{
		switch (dayOfWeek) {
		case 0 -> System.out.printf("%02d/%02d/%04d Pazar%n", day, month, year);
		case 1 -> System.out.printf("%02d/%02d/%04d Pazartesi%n", day, month, year);
		case 2 -> System.out.printf("%02d/%02d/%04d Salı%n", day, month, year);
		case 3 -> System.out.printf("%02d/%02d/%04d Çarşamba%n", day, month, year);
		case 4 -> System.out.printf("%02d/%02d/%04d Perşembe%n", day, month, year);
		case 5 -> System.out.printf("%02d/%02d/%04d Cuma%n", day, month, year);
		case 6 -> System.out.printf("%02d/%02d/%04d Cumartesi%n", day, month, year);
		}
	}

	public static int getDayOfWeek(int day, int month, int year)
	{
		int totalDays;

		if (year < 1900 || (totalDays = getDayOfYear(day, month, year)) == -1)
			return -1;

		return getTotalDays(year, totalDays) % 7;
	}

	public static int getTotalDays(int year, int totalDays)
	{
		for (int y = 1900; y < year; ++y) {
			totalDays += 365;
			if (isLeapYear(y))
				++totalDays;
		}

		return totalDays;
	}

	public static boolean isWeekend(int day, int month, int year)
	{
		int dayOfWeek = getDayOfWeek(day, month, year);

		return dayOfWeek == 0 || dayOfWeek == 6;
	}

	public static boolean isWeekday(int day, int month, int year)
	{
		return !isWeekend(day, month, year);
	}

	public static int getDayOfYear(int day, int month, int year)
	{
		if (!isValidDate(day, month, year))
			return -1;

		int total = day;

		switch (month - 1) {
		case 11:
			total += 30;
		case 10:
			total += 31;
		case 9:
			total += 30;
		case 8:
			total += 31;
		case 7:
			total += 31;
		case 6:
			total += 30;
		case 5:
			total += 31;
		case 4:
			total += 30;
		case 3:
			total += 31;
		case 2:
			total += 28;
			if (isLeapYear(year))
				++total;
		case 1:
			total += 31;
		}

		return total;
	}

	public static boolean isValidDate(int day, int month, int year)
	{
		return 1 <= day && day <= 31 && 1 <= month && month <= 12 && day <= getDays(month, year);
	}

	public static int getDays(int month, int year)
	{
		return switch (month) {
		case 4, 6, 9, 11 -> 30;
		case 2 -> {
			if (isLeapYear(year))
				yield 29;

			yield 28;
		}
		default -> 31;
		};
	}

	public static boolean isLeapYear(int year)
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Basit bir menü uygulamasının iskeleti
	(İleride daha iyisi yazılacaktır)
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		MenuApp.run();
	}
}

class MenuApp {
	public static void printMenu()
	{
		System.out.println("1.Ekle");
		System.out.println("2.Sil");
		System.out.println("3.Güncelle");
		System.out.println("4.Listele");
		System.out.println("5.Çıkış");
		System.out.print("Seçenek:");
	}

	public static void doWorkForInsert()
	{
		System.out.println("---------------------");
		System.out.println("\"Ekle\" seçildi");
		System.out.println("---------------------");
	}

	public static void doWorkForDelete()
	{
		System.out.println("---------------------");
		System.out.println("\"Sil\" seçildi");
		System.out.println("---------------------");
	}

	public static void doWorkForUpdate()
	{
		System.out.println("---------------------");
		System.out.println("\"Güncelle\" seçildi");
		System.out.println("---------------------");
	}

	public static void doWorkForList()
	{
		System.out.println("---------------------");
		System.out.println("\"Listele\" seçildi");
		System.out.println("---------------------");
	}

	public static void doWorkForInvalidOption()
	{
		System.out.println("---------------------");
		System.out.println("Geçersiz seçenek");
		System.out.println("---------------------");
	}

	public static void doWork(int option)
	{
		switch (option) {
		case 1 -> doWorkForInsert();
		case 2 -> doWorkForDelete();
		case 3 -> doWorkForUpdate();
		case 4 -> doWorkForList();
		case 5 -> doGoodbyeWork();
		default -> doWorkForInvalidOption();
		}
	}

	public static void doGoodbyeWork()
	{
		System.out.println("Teşekkürler");
		System.out.println("C ve Sistem Programcıları Derneği");
		System.out.println("Tekrar yapıyor musunuz?");
		System.exit(0);
	}

	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for (;;) {
			printMenu();
			doWork(Integer.parseInt(kb.nextLine()));
		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Programcı new zaman switch expression, ne zaman switch statement kullanmalıdır? Şüphesiz programcı Java 12
	öncesinde çalışıyorsa zaten switch expression kullanamaz. Bu durumda programcı zorunlu olmadıkça ve okunabilirlik açısından da
	bir sorun yoksa switch expression tercih etmelidir. Yani aslında programcı Java 12 ve üstünde çalışıyorsa genel olarak
	switch statement kullanıp kullanmayacağına karar verir
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	20.11.2022
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Farklı Türlerin Birbirine Atanması (Tür Dönüşümleri - Type Conversions)
	T1 ve T2 birer tür ismi olmak üzere T1 türünden, T2 türüne yapılam doğrudan atama işlemine T1 türünden T2 türüne
	"doğrudan dönüşüm (implicit conversion)" denir. Atama işlemi aynı zamanda bir dönüşümdür. Örneğin bu işlem

		T1 a;
		T2 b;

		b = a;

	şeklinde belirtilebilir. Konu içerisinde anlatılacak olan istisna bazı durumlar dışında, kurallar tüm atama durumları
	için geçerlidir. İstisna durumlar ayrıca ele alınacaktır.

	Yukarıdaki atama işleminde T1 türüne "kaynak tür (source type)", T2 türüne de "hedef tür (target type)" denir. Java'da
	kaynak türden hedef türe doğrudan atama (dönüşüm) yapılıp yapılamayacağı derleme zamanında belirlenir. Kaynak türe
	ilişkin değere çalışma zamanında bakılarak karar verilmez. Zaten çoğu zaman da bu değer derleme zamanında anlaşılamaz.
	Yani hangi türlerin hangi türlere atanıp atanamayacağı belirlidir.

	Java'da genel olarak bilgi kaybına yol açmayacak doğrudan dönüşümler (implicit conversion) geçerlidir.

	Anahtar Notlar: Java Language Specification'da temel türler arasında, uzunluk (size) olarak büyük olan bir türden,
	uzunluk olarak küçük olan bir türe yapılan dönüşüme "daraltma dönüşümü (narrowing conversion)", uzunluk olarak
	küçük olan bir türden, uzunluk olarak büyük olan bir türe yapılan dönüşüme "genişletme dönüşümü (widening conversion)"
	terimleri kullanılmaktadır.

	Doğrudan dönüşüme ilişkin ayrıntılar aşağıda ele alınmıştır
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte long türüne ilişkin değer çalışma zamanında belirlenir. Dolayısıyla derleyici istese de bu değeri
	bilemez. Derleyici açısından kural "long türünden int türüne doğrudan dönüşüm geçersizdir" biçimindedir. Dolayısıyla
	error oluşur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		long a = kb.nextLong();
		int b;

		b = a; //error

	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte long türüne ilişkin değer çalışma zamanında belirlenir. Dolayısıyla derleyici istese de bu değeri
	bilemez. Derleyici açısından kural "long türünden int türüne doğrudan dönüşüm geçersizdir" biçimindedir. Dolayısıyla
	error oluşur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		long a = 1000;
		int b;

		b = a; //error

	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Küçük tamsayı türünden büyük tamsayı türüne doğrudan atama geçerlidir. Küçük tamsayı türüne ilişkin değer pozitif veya
	sıfır ise yüksek anlamlı yeni bit değerleri sıfır ile beslenir. Eğer sayı negatif ise sayının işaretinin korunması için
	yüksek anlamlı bit değerleri 1(bir) ile beslenir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		short a = kb.nextShort();
		int b;

		b = a;

		System.out.printf("a = %d%n", a);
		System.out.printf("a = 0x%04X%n", a);
		System.out.printf("b = %d%n", b);
		System.out.printf("b = 0x%08X%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Hiçbir türden char türüne doğrudan dönüşüm yapılamaz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 67;
		char c;

		c = a; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Hiçbir türden char türüne doğrudan dönüşüm yapılamaz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		byte a = 67;
		char c;

		c = a; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Yukarıdaki kurala istisna olarak "char türü sınırları içerisinde kalan VE int türden olan bir sabit char türüne
	 doğrudan atanabilir"
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		char c;

		c = 67;

		System.out.printf("c = %c%n", c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Yukarıdaki kurala istisna olarak "char türü sınırları içerisinde kalan VE int türden olan bir sabit char türüne
	 doğrudan atanabilir"
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 67;
		char c1, c2, c3;

		c1 = -67; //error
		c2 = 67L; //error
		c3 = a; //error

	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 short türünden char türüne doğrudan dönüşüm geçersizdir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		short a;
		char c;

		a = 10;

		c = a; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 char türünden short türüne doğrudan dönüşüm geçersizdir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		char a;
		short c;

		a = 10;

		c = a; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Anımsanacağı gibi Java'da byte ve short türden sabit yoktur. Ancak "sınırlar içerisinde olması koşuluyla int türden
	 bir sabit byte/short türüne doğrudan atanabilir"
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		short a;
		byte b;
		byte c;

		a = 10;
		b = 78;
		c = -129; //error
		c = 89L; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıda anlatılan byte, short ve char türlerine ilişkin istisna kurallar geri dönüş değerinin geçici değişkene
	yapılan atama işlemi için de geçerlidir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public static short foo()
	{
		//...
		return 10;
	}

	public static byte bar()
	{
		//...
		return 10;
	}

	public static char tar()
	{
		//...
		return 10;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıda anlatılan byte, short ve char türlerine ilişkin istisna kurallar metot çağrılarında argüman parametrelere
	yapılan atama işleminde geçersizdir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample.foo(10); //error
		Sample.bar(10); //error
		Sample.tar(10);	//error
	}
}

class Sample {
	public static void foo(short a)
	{
		//...
	}

	public static void bar(byte b)
	{
		//...
	}

	public static void tar(char c)
	{
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	char türünden kendisinden uzunluk olarak büyük tüm türlere doğrudan atama geçerlidir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		char c = 'C';
		double a;
		int b;

		a = c;
		b = c;

		System.out.printf("a = %f%n", a);
		System.out.printf("b = %d%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bütün tamsayı türlerinden gerçek sayı türlerine doğrudan atama geçerlidir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		long a = 4_000_000_000L;
		float b;

		b = a;

		System.out.printf("b = %f%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Gerçek sayı türlerinden tam sayı türlerine doğrudan atama geçersizdir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		float a = 12;
		long b;

		b = a; //error
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	float türünden double türüne doğrudan atama geçerlidir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		float a = 12;
		double b;

		b = a;

		//...
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	double türünden float türüne doğrudan atama geçersizdir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		double a = 12;
		float b;

		b = a; //error

		//..
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte sabitin sonuna F konmazsa sabit double türden olduğundan atama geçersiz olur. Aşağıdaki örneği
	çalıştırarak yuvarlama hatasını gözlemleyiniz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		float a;

		a = 3.4F;

		System.out.printf("a = %.12f%n", a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	boolean türünden harhangi bir türe doğrudan dönüşüm geçersizdir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		boolean a = false;
		int b;

		b = a; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Herhangi bir türden boolean türüne doğrudan dönüşüm geçersizdir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 1;
		boolean b;

		b = a; //error
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Temel türler için doğrudan dönüşüm (implicit conversion) listesi:

	byte	-> short, int, long, float, double
	short	-> int, long, float, double
	int		-> long, float, double
	long	-> float, double
	float	-> double
	char	-> int, long, float, double
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	İşlem öncesi Otomatik Tür Dönüşümü:
	İki operandlı bir operatör için derleyici önce operandların türüne bakar. Operandlar farklı türdense ve işlem geçerliyse,
	ortak bir türe dönüştürme yapan kodu üretir. Hatta bazı durumlarda iki tür aynı olsa bile ikisini de farklı türe
	dönüştüren kodu üretir. Bu dönüştürmeye "işlem öncesi otomatik tür dönüşümü" denir.

	Bu kuralın özeti "genel olarak küçük türe ilişkin değer büyük türe dönüştürülür. Sonuç büyük türden elde edilir" biçimindedir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a;
		long b;
		long c;

		a = 10;
		b = 20;

		c = a + b;

		System.out.printf("c = %d%n", c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Her iki operand da byte, short veya char türlerindense ikisi birden işlem öncesinde int türüne dönüştürülür ve sonuç
	int türden çıkar. Buna "integral/integer promotion" denir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		short a = 10;
		short b = 20;
		short c;

		c = a + b; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Her iki operand da byte, short veya char türlerindense ikisi birden işlem öncesinde int türüne dönüştürülür ve sonuç
	int türden çıkar. Buna "integral/integer promotion" denir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		short a = 10;
		byte b = 20;
		short c;

		c = a + b; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bölme işleminde her iki operand da tamsayı türlerindense sonuç tamsayı türünden çıkar. Bölme işlemi yapılır, elde
	edilen değerin noktadan sonraki kısmı atılır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		int b = 3;
		double c;

		c = a / b;

		System.out.printf("c = %f%n", c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir gerçek sayı türü ile tamsayı türü işleme sokulduğunda dönüşüm gerçek sayı türüne doğrudur. Yani tamsayı türüne
	ilişkin değer gerçek sayı türüne dönüştürülür. Sonuç o gerçek sayı türünden çıkar
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		float a = 3.4F;
		long b = 100;
		float c;

		c = a + b;

		System.out.printf("c = %f%n", c);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Küçük tamsayı türünden büyük tamsayı türü işleme sokulduğunda dönüşüm büyük tamsayı türüne doğrudaur. Sonuç büyük
	tamsayı türünden çıkar.
	Dikkat: Integral promotion bu kuralın dışındadır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 3;
		long b = 100;
		long c;

		c = a + b;

		System.out.printf("c = %f%n", c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	boolean türü hiç bir tür ile işleme sokulamaz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		boolean a = true;
		int b = 30;
		int c;

		c = a + b; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	char türü herhangi bir tür ile işleme sokulabişir. Bu durumda char türüne ilişkin değer diğer türe dönüştürülür..
	Dikkat: Integral promotion bu durumundan dışındadır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 32;
		char c = 'D';
		int result;

		result = c + a;

		System.out.println(result);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	float türü ile double türü işleme sokulduğunda float türünde ilişkin değer double türüne dönüştürülür. İşlem double
	türden çıkar
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		float a = 3.4F;
		double b = 5.6;
		double c;

		c = a + b;

		System.out.printf("c = %.20f%n", c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	İşlem öncesi otomatik tür dönüşümü geçici değişken yaratılarak yapılır. Yani derleyici geçici değişken yaratan kodu
	üretir. Örnekte derleyici ** ile belirtilen işlem için yaklaşık olarak şu şekilde klod üretir:
		long temp = a;

		c = temp + b;
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		long b = 200;
		long c;

		c = a + b; //**

		System.out.printf("c = %.20f%n", c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	İşlem öncesi otomatik tür dönüşümü geçici değişken yaratılarak yapılır. Yani derleyici geçici değişken yaratan kodu
	üretir. Örnekte derleyici ** ile belirtilen işlem için yaklaşık olarak şu şekilde kod üretir:
		int temp1 = a;
		int temp2 = b;

		c = temp1 + temp2;
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		short a = 10;
		byte b = 100;
		int c;

		c = a + b; //**

		System.out.printf("c = %.20f%n", c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Tür dönüştürme (type cast) operatörü:
	Tür dönüştürme operatörü özel amaçlı, tek operandlı (unary) ve önek (prefix) durumunda bir operatördür. Tür dönüştürme
	operatörünün genel biçimi:

		(<hedef tür>)<ifade>

	Bu operatör, operandına ilişkin ifadenin hedef türe dönüştürüldükten sonra elde edilen değerini üretir. Bu operatörün
	yan etkisi yoktur. Bu operatör ile yapılan dönüşüme "casting ya da explicit conversion" denir. Genele olarak, implicit
	yapılamayan dönüşümler tür dönüştürme operatörü ile yapılabilir. Şüphesi bu durumda bilgi kaybı oluşabilir. Bu bilgi
	kayıplarının nasıl oluşacağı belirlidir ve konu içerisinde ele alınacaktır.

	implicit olarak geçerli olan tüm dönüşümler explicit olarak da yani tür dönüştürme operatörü ile de yapılabilir.

	Anahtar Notlar: Tür dönüştürme operatörünün sentaks ve semantik olarak zorunlu olması durumu genel olarak
	"işlem doğrudan yapılırsa problem olabilir. Bu sebeple derleyici bunu doğrudan yapmamızı istemiyor. Biz yapmak istersek
	tür dönüştürme operatörü kullanarak derleyiciye, durumun farkındayım bana izin ver" anlaşılmalıdır
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte tür dönüştürme operatörü kullanılarak işlemin double olarak yapılması sağlanmış ve noktadan sonraki
	kısım da elde edilebilmiştir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İki tamsayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		double c;

		c = (double)a / b;

		System.out.printf("c = %f%n", c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Tür dönüştürme operatörü
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir tamsayı giriniz:");
		long a = kb.nextLong();
		int b;

		b = (int)a;

		System.out.printf("b = %d%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	26.11.2022
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	implicit olarak geçerli olan dönüşümler için de explicit dönüşüm yapılabilir. Yani tür dönüştürme operatörü
	kullanılabilir. Aşağıdaki örnekte tür dönüştürme operatörü kullanılmış olsa da kullanılmamasıyla aynı anlamdadır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir tamsayı giriniz:");
		int a = kb.nextInt();
		long b;

		b = (long)a;

		System.out.printf("b = %d%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Explicit conversion (type cast) işlemine ilişkin aşağıdaki maddlere genel olarak implicit yapılamayan dönüşümlere
	ilişkindir
-----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Büyük tamsayı türünden küçük tamsayı türüne yapılan explicit dönüşümde kaynak türe ilişkin değerin yüksek anlamlı byte değerleri
	atılır. Bu durumda elde edilen değer hedef türe atanır. Bu durumda kaynak türe ilişkin değer hedef türün sınırları
	içerisindeyse bilgi kaybı oluşmaz, değilse bilgi kaybı oluşur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);


		for (;;) {
			System.out.print("Bir tamsayı giriniz:");
			long a = Long.parseLong(kb.nextLine());

			if (a == 0)
				break;

			int b;

			b = (int)a;

			System.out.printf("a = %d%n", a);
			System.out.printf("a = %016X%n", a);
			System.out.printf("b = %d%n", b);
			System.out.printf("b = %08X%n", b);
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	short türünden char türüne yapılan explicit dönüşümde sayının bit kalıbı değişmez. Sayının yorumlanışı değişir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);


		for (;;) {
			System.out.print("Bir sayı giriniz:");
			short a = Short.parseShort(kb.nextLine());

			if (a == 0)
				break;

			char b;

			b = (char)a;

			System.out.printf("a = %d%n", a);
			System.out.printf("a = %04X%n", a);
			System.out.printf("b = %c%n", b);
			System.out.printf("(int)b = %04X%n", (int)b);
			System.out.printf("(int)b = %d%n", (int)b);
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}



/*----------------------------------------------------------------------------------------------------------------------
	char türünden short türüne yapılan explicit dönüşümde sayının bit kalıbı değişmez. Sayının yorumlanışı değişir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		char c = '\uFFBD';
		short b;

		b = (short)c;

		System.out.printf("c = %c%n", c);
		System.out.printf("c = %04X%n", (int)c);
		System.out.printf("c = %d%n", (int)c);
		System.out.printf("b = %04X%n", b);
		System.out.printf("b = %d%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	boolean türünden hiç bir türe explicit dönüşüm yapılamaz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		boolean a = true;
		int b;

		b = (int)a; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Herhangi bir türden boolean türüne explicit dönüşüm yapılamaz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 1;
		boolean b;

		b = (boolean)a; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	byte türünden char türüne yapılan explicit dönüşüm iki aşamada gerçekleşir. Birinci aşamada değer int türüne yükseltilir.
	İkinci aşamada yüksek anlamlı 2 byte atılarak char türüne dönüştürülür. Bu işlem Java Language Specification'da
	"widening and narrowing conversion" olarak belirtilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		byte a = 99;
		char c;

		c = (char)a;

		System.out.printf("a = %d%n", a);
		System.out.printf("a = %02X%n", a);
		System.out.printf("(int)a = %08X%n", (int)a);
		System.out.printf("(short)c = %04X%n", (short)c);
		System.out.printf("c = %c%n", c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	byte türünden char türüne yapılan explicit dönüşüm iki aşamada gerçekleşir. Birinci aşamada değer int türüne yükseltilir.
	İkinci aşamada yüksek anlamlı 2 byte atılarak char türüne dönüştürülür. Bu işlem Java Language Specification'da
	"widening and narrowing conversion" olarak belirtilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		byte a = -99;
		char c;

		c = (char)a;

		System.out.printf("a = %d%n", a);
		System.out.printf("a = %02X%n", a);
		System.out.printf("(int)a = %08X%n", (int)a);
		System.out.printf("(short)c = %04X%n", (short)c);
		System.out.printf("c = %c%n", c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	double türünden float türüner nexplicit dönüşümde bilgi kaybı olabilir. Bu durumda IEEE 754 standardına göre
	yuvarlama hataları oluşabilir ve değer float türü ile temsil edilebilecek bir değer olarak elde edilir. Ayrıca float
	sınırları dışında ise de aynı yöntem geçerlidir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		double a = 3.4;
		float b;

		b = (float)a;

		System.out.printf("a = %.20f%n", a);
		System.out.printf("b = %.20f%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Gerçek sayı türünden tam sayı türüne (veya char türüne) yapılan explicit dönüşüm şu şekilde gerçekleşir:
	- Sayının noktadan sonraki kısmı atılır
	 	- Elde edilen değer hedef türün sınırları içerisindeyse hedef türe atanır
	 	- Elde edilen değer hedef türün sınırları içerisinde değilse
	 		- Hedef tür byte, short, int veya char türlerinden biriyse
	 			- Elde edilen değer int türü sınırları içerisindeyse int türüne dönüştürülür. Buradan elde edilen değer,
	 			tamsayılar arasındaki dönüşüm kurallarına göre atanır
	 			- Elde edilen değer int türü sınırları içerisinde değilse değerin pozitif ya da negatif olmasına göre
	 			int türünün en büyük veya en küçük değeri alınır ve hedef türe dönüştürülür
	 		- Hedef tür long ise
	 			- Elde edilen değer long türü sınırları içerisindeyse doğrudan atanır
	 			- Elde edilen değer long türü sınırları içerisinde değilse sayının pozitif veya negatif olması durumuna
	 			göre long türünün en büyük veya en küçük değeri alınır ve atanır
-----------------------------------------------------------------------------------------------------------------------*/

package csd;

class App {
	public static void main(String [] args)
	{
		double a = 3.4;
		short b;

		b = (short)a;

		System.out.printf("b = %d%n", b);
	}
}

package csd;

class App {
	public static void main(String [] args)
	{
		double a = 1234.5;
		byte b;

		b = (byte)a;

		System.out.printf("1234 = %08X%n", 1234);
		System.out.printf("b = %02X%n", b);
		System.out.printf("b = %d%n", b);
	}
}

package csd;

class App {
	public static void main(String [] args)
	{
		double a = -1234.5;
		byte b;

		b = (byte)a;

		System.out.printf("-1234 = %08X%n", -1234);
		System.out.printf("b = %02X%n", b);
		System.out.printf("b = %d%n", b);
	}
}

package csd;

class App {
	public static void main(String [] args)
	{
		double a = 5_000_000_000.5;
		byte b;

		b = (byte)a;

		System.out.printf("5_000_000_000 = %08X%n", (int)5_000_000_000L);
		System.out.printf("2147483647 = %08X%n", 2147483647);
		System.out.printf("b = %02X%n", b);
		System.out.printf("b = %d%n", b);
	}
}


package csd;

class App {
	public static void main(String [] args)
	{
		double a = -5_000_000_124.5;
		byte b;

		b = (byte)a;

		System.out.printf("-5_000_000_124 = %08X%n", (int)-5_000_000_124L);
		System.out.printf("-2147483648 = %08X%n", -2147483648);
		System.out.printf("b = %02X%n", b);
		System.out.printf("b = %d%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Klavyeden sıfır girilene kadar alınan int türden sayıların ortalamasını bulan programı yazınız.
	Açıklamalar: Toplam değeri ve girilen değerlerin sayısı int olarak tutulacaktır

	Aşağıdaki örnekte tür dönüştürme operatörü kullanılmazsa bilgi kaybı oluşabilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		FindAverageApp.run();
	}
}


class FindAverageApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.println("Sayıları girmeye başlayınız:");
		int sum = 0, count = 0;
		int val;

		while ((val = kb.nextInt()) != 0) {
			sum += val;
			++count;
		}

		double average;

		average = (double)sum / count;

		System.out.printf("Ortalama: %f%n", average);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte tür dönüştürme operatörü kullanılmazsa bilgi kaybı oluşabilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		long c;

		c = (long)a + b;

		System.out.printf("%d + %d = %d%n", a, b, c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte double türden sabit kullanıldığından işlem double olarak yapılır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int sum = 0;

		System.out.println("5 tane sayı giriniz:");

		for (int i = 0; i < 5; ++i)
			sum += kb.nextInt();

		double average;

		average = sum / 5.;

		System.out.printf("Ortalama:%f%n", average);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte double türden sabit kullanıldığından işlem double olarak yapılır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int sum = 0;

		System.out.println("5 tane sayı giriniz:");

		for (int i = 0; i < 5; ++i)
			sum += kb.nextInt();

		double average;

		average = sum / 5D;

		System.out.printf("Ortalama:%f%n", average);
	}
}

/*-----------------------------------------------------------------------------------------------------------------------
	27.11.2022
-----------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------
	İşlemli atama operatrlerinin genel biçimi aşağıdaki gibidir.

	T1 a;
	T2 b;

	a op= b => a = (T1)(a op b)

	Dikkat edilirse bu operatörler daha önce de söylendiği gibi ifadeleri basitleştirirler
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		int b = 20;

		a += Math.sqrt(b); //a = (int)(a + Math.sqrt(b));

		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir sayının basamak sayısının log10 ile bulunması
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());

		int count = 1;

		if (val != 0)
			count = (int)Math.log10(Math.abs(val)) + 1;

		System.out.printf("%d sayısının basamak sayısı:%d%n", val, count);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının Armstrong sayısı olup olmadığını test eden isArmstrong
	metodunu NumberUtil sınıfı içerisinde yazınız
	Açıklamalar:
		- Bir sayının her basamağının "basamak sayı"-ncı kuvvetleri toplanmı sayının kendisine eşitse bu sayıya Armstrong
		sayısı denit. Örneğin:
			153 -> 1 ^ 3 + 5 ^ 3 + 3 ^ 3 = 153

		- Negatif sayılar Armstrong sayısı olarak kabul edilmeyecektir

		- Metodu, 1 basamaklı, 2 basamaklı, 3 basamaklı, 4 basamaklı, 5 basamaklı ve 6 basamaklı Armstrong sayılarını
		ekrana yazdırarak test ediniz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		IsArmstrongTest.run();
	}
}

class IsArmstrongTest {
	public static void run()
	{
		for (int n = -10; n <= 999999; ++n)
			if (NumberUtil.isArmstrong(n))
				System.out.println(n);

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil {
	public static boolean isArmstrong(int val)
	{
		return val >= 0 && getDigitsPowSum(val) == val;
	}

	public static int getDigitsPowSum(int val)
	{
		int n = countDigits(val);
		int total = 0;

		while (val != 0) {
			total += Math.pow(val % 10, n);
			val /= 10;
		}

		return total;
	}

	public static int countDigits(int val)
	{
		if (val == 0)
			return 1;

		return (int)Math.log10(Math.abs(val)) + 1;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	03.12.2022
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Koşul Operatörü (Conditional Operator): Koşul operatörğ özel amaçlı, üç operandlı (ternary) ve araek durumunda bir
	operatördür. Operatörün genel biçimi:
		<operand1> ? <operand2> : <operand3>
	operand1: boolean türden bir ifade olmalıdır. Aşağıdaki koşul operatörüne ilişkin ifadenin if deyimi ile yapılışı:
		if (a < b)
			min = a;
		else
		 	min = b;
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();

		int min;

		min = a < b ? a : b;

		System.out.printf("min(%d, %d) = %d%n", a, b, min);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte b - 100 ifadesi koşul operatörünün üçüncü operandıdır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();

		int result;

		result = a < b ? a : b - 100;

		System.out.printf("result = %d%n", result);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte koşul operatörünün ürettiği değerden 100 çıkartılacaktır. Parantez ile bu sağlanmıştır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();

		int result;

		result = (a < b ? a : b) - 100;

		System.out.printf("result = %d%n", result);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte koşul operatörünün birinci operandı = ile ? arasıdır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();

		int result;

		result = a > 0 && a >= b ? a : b;

		System.out.printf("result = %d%n", result);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte koşul operatörünün birinci operandı = ile ? arasıdır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();

		int result;

		result = a + a >= b ? a : b;

		System.out.printf("result = %d%n", result);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();

		int result;

		result = a + (a >= b ? a : b);

		System.out.printf("result = %d%n", result);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Koşul operatörünün ürettiği değerin bir değişkene atanması durumunda kullanımı if deyimine göre daha okunabilirdir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();

		int min;

		min = a < b ? a : b;

		System.out.printf("min(%d, %d) = %d%n", a, b, min);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Koşul operatörünün ürettiği değerin return deyiminde kullanımı okunabilirliği artırır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();

		System.out.printf("min(%d, %d) = %d%n", a, b, Util.min(a, b));
	}
}

class Util {
	public static int min(int a, int b)
	{
		return a < b ? a : b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Koşul operatörünün ürettiği değerin metot çağrısında argüman olarak metoda verilmesi okunabilirliği artırır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();

		System.out.printf("min(%d, %d) = %d%n", a, b, a < b ? a : b);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Koşul operatörünün ikinci ve üçüncü operandı void bir ifade olamaz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();

		a < b ? Sample.foo() : Sample.bar(); //error
	}
}

class Sample {
	public static void foo()
	{
		System.out.println("foo");
	}

	public static void bar()
	{
		System.out.println("bar");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Koşul operatörünün bir kullanımı. Örnekte parantez kullanımına sentaks açısından gerek yoktur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Üç sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int c = kb.nextInt();

		int min;

		min = a < b ? a < c ? a : c : b < c ? b : c;
		System.out.printf("min(%d, %d, %d) = %d%n", a, b, c, min);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örnekte koşul operatörünün operandlarını parantez içerisine almak okunabilirliği artırır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Üç sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int c = kb.nextInt();

		int min;

		min = (a < b) ? (a < c ? a : c) : (b < c ? b : c);
		System.out.printf("min(%d, %d, %d) = %d%n", a, b, c, min);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden gün, ay ve yıl bilgilerine ilişkin tarihin aşağıdaki açıklamalara
	göre haftanın hangi gününe geldiğini döndüren getDayOfWeek metodunu yazınız ve aşağıdaki kod ile test ediniz.,
	Açıklamalar:
		- Metot geçersiz bir tarih için -1 değerine geri dönecektir
		- 01.01.1900 öncesindeki tarihler geçersiz kabul edilecektir
		- Haftanın günü 01.01.1900 ile verilen tarih arasındaki (verilen tarih dahil) gün sayısının 7(yedi) ile
		bölümünden elde edilen kalan alınarak belirlenebilir. Buna göre değer sıfır ise "pazar", 1 ise "pazartesi", ...,
		6 ise "cumartesi" günlerine karşılık gelir
		- Bu metot ile birlikte verilen tarihin hafta sonu olup olmadığını test eden isWeekend ve hafta içi olup olmadığını
		test eden isWeekday metotlarını da yazınız. Bu metotlar tarih geçerlilik kontrolü yapmayacaktır
		- İleride daha iyisi yazılacaktır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		GetDayOfWeekTest.run();
	}
}

class GetDayOfWeekTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for (;;) {
			System.out.print("Gün ay ve yıl bilgilerini giriniz:");
			int day = kb.nextInt();
			int month = kb.nextInt();
			int year = kb.nextInt();

			if (day == 0)
				break;

			DateUtil.printDateTR(day, month, year);
		}

		System.out.println("Tekrar yapıyor munuz?");
	}
}

class DateUtil {
	public static void printDateTR(int day, int month, int year)
	{
		int dayOfWeek = getDayOfWeek(day, month, year);

		if (dayOfWeek == -1) {
			System.out.println("Geçersiz tarih");
			return;
		}

		printDateByDayOfWeekTR(day, month, year, dayOfWeek);

		System.out.println(isWeekend(day, month, year) ? "Bugün kurs var. Tekrar yaptınız mı?" : "Kurs günü yaklaşıyor. Tekrar yapmayı unutmayınız!...");
	}

	public static void printDateByDayOfWeekTR(int day, int month, int year, int dayOfWeek)
	{
		switch (dayOfWeek) {
		case 0 -> System.out.printf("%02d/%02d/%04d Pazar%n", day, month, year);
		case 1 -> System.out.printf("%02d/%02d/%04d Pazartesi%n", day, month, year);
		case 2 -> System.out.printf("%02d/%02d/%04d Salı%n", day, month, year);
		case 3 -> System.out.printf("%02d/%02d/%04d Çarşamba%n", day, month, year);
		case 4 -> System.out.printf("%02d/%02d/%04d Perşembe%n", day, month, year);
		case 5 -> System.out.printf("%02d/%02d/%04d Cuma%n", day, month, year);
		case 6 -> System.out.printf("%02d/%02d/%04d Cumartesi%n", day, month, year);
		}
	}

	public static int getDayOfWeek(int day, int month, int year)
	{
		int totalDays;

		return (year < 1900 || (totalDays = getDayOfYear(day, month, year)) == -1) ? -1 : (getTotalDays(year, totalDays) % 7);
	}

	public static int getTotalDays(int year, int totalDays)
	{
		for (int y = 1900; y < year; ++y)
			totalDays += isLeapYear(y) ? 366 : 365;

		return totalDays;
	}

	public static boolean isWeekend(int day, int month, int year)
	{
		int dayOfWeek = getDayOfWeek(day, month, year);

		return dayOfWeek == 0 || dayOfWeek == 6;
	}

	public static boolean isWeekday(int day, int month, int year)
	{
		return !isWeekend(day, month, year);
	}

	public static int getDayOfYear(int day, int month, int year)
	{
		if (!isValidDate(day, month, year))
			return -1;

		int total = day;

		switch (month - 1) {
		case 11:
			total += 30;
		case 10:
			total += 31;
		case 9:
			total += 30;
		case 8:
			total += 31;
		case 7:
			total += 31;
		case 6:
			total += 30;
		case 5:
			total += 31;
		case 4:
			total += 30;
		case 3:
			total += 31;
		case 2:
			total += isLeapYear(year) ? 29 : 28;
		case 1:
			total += 31;
		}

		return total;
	}

	public static boolean isValidDate(int day, int month, int year)
	{
		return 1 <= day && day <= 31 && 1 <= month && month <= 12 && day <= getDays(month, year);
	}

	public static int getDays(int month, int year)
	{
		return switch (month) {
		case 4, 6, 9, 11 -> 30;
		case 2 -> isLeapYear(year) ? 29 : 28;
		default -> 31;
		};
	}

	public static boolean isLeapYear(int year)
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının Armstrong sayısı olup olmadığını test eden isArmstrong
	metodunu NumberUtil sınıfı içerisinde yazınız
	Açıklamalar:
		- Bir sayının her basamağının "basamak sayı"-ncı kuvvetleri toplanmı sayının kendisine eşitse bu sayıya Armstrong
		sayısı denit. Örneğin:
			153 -> 1 ^ 3 + 5 ^ 3 + 3 ^ 3 = 153

		- Negatif sayılar Armstrong sayısı olarak kabul edilmeyecektir

		- Metodu, 1 basamaklı, 2 basamaklı, 3 basamaklı, 4 basamaklı, 5 basamaklı ve 6 basamaklı Armstrong sayılarını
		ekrana yazdırarak test ediniz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		IsArmstrongTest.run();
	}
}

class IsArmstrongTest {
	public static void run()
	{
		for (int n = -10; n <= 999999; ++n)
			if (NumberUtil.isArmstrong(n))
				System.out.println(n);

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil {
	public static boolean isArmstrong(int val)
	{
		return val >= 0 && getDigitsPowSum(val) == val;
	}

	public static int getDigitsPowSum(int val)
	{
		int n = countDigits(val);
		int total = 0;

		while (val != 0) {
			total += Math.pow(val % 10, n);
			val /= 10;
		}

		return total;
	}

	public static int countDigits(int val)
	{
		return (val != 0) ? ((int)Math.log10(Math.abs(val)) + 1) : 1;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Method Overloading: Bir sınıf içerisinde aynı isimde metotlar yazılması durumuna "method overloading" denir. Bu kavram
	farklı sınıflar içerisinde aynı isimde metotlar olması durumu değildir
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki durum "method overloading" değildir. Çünkü aynı isimde olan metotlar farklı sınıflardadır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample.foo();
		Mample.foo();
	}
}

class Sample {
	public static void foo()
	{
		System.out.println("Sample.foo");
	}
}

class Mample {
	public static void foo()
	{
		System.out.println("Mample.foo");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Bir sınıf içerisinde "aynı" metottan birden fazla olamaz. Bu durumda bir metodun "overload" edilebilmesi
	için kendisiyle aynı isimde olanlardan "farklı" olması gerekir. Aşağıdaki maddelerde metodun "aynı" ya da "farklı" olmasına
	ilişkin detaylar anlatılmaktadır
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun erişim belirleyicisinin "overload" işlemine etkisi yoktur. Yani metodun erişim belirleyicilerin farklı
	olması metodu farklı yapmaz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public static void foo() //error
	{
		//...
	}

	private static void foo() //error
	{
		//...
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun static olup olmamasının overload işlemine etkisi yoktur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public void foo() //error
	{
		//...
	}

	public static void foo() //error
	{
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun geri dönüş değeri bilgisinin de overload işlemine etkisi yoktur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public static int foo() //error
	{
		//...

		return 0;
	}

	public static void foo() //error
	{
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun parametre değişken isimlerinin de overload işlemine etkisi yoktur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public static void foo(int a) //error
	{
		//...

	}

	public static void foo(int x) //error
	{
		//...
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun "overload" edilebilmesi için metodun parametre tür bilgisi ve parametrelerin dizilimlerinin farklı olması
	gerekir. Buna genel olarak "parametrik yapı" diyebiliriz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public static void foo()
	{
		//...
	}

	public static void foo(int a)
	{
		//...
	}

	public static void foo(double a)
	{
		//...
	}

	public static void foo(double a, int b)
	{
		//...
	}

	public static void foo(int a, double b)
	{
		//...
	}
	//...
}


/*----------------------------------------------------------------------------------------------------------------------
	Bir sınıf içerisinde metodun ismi ve parametrik yapısının ikisine birden metodun "imzası (signature)" diyelim.
	Kural: Bir sınıf içerisinde aynı imzaya sahip 1'den fazla metot bildirimi geçersizdir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public static void foo() //imza: foo
	{
		//...
	}

	public static void foo(int a)  //imza: foo, int
	{
		//...
	}

	public static void foo(double a)  //imza: foo, double
	{
		//...
	}

	public static void foo(double a, int b)  //imza: foo, double, int
	{
		//...
	}

	public static void foo(int b, double a)  //imza: foo, int, double
	{
		//...
	}

	public static void bar(int a, double b)  //imza: bar, int, double
	{
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir metot çağrısında derleyicinin hangi metodun çağrılacağına karar vermesi sürecine "method overload resolution" ya da
	kısaca "oveload resolution" denir
-----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Metot çağrısında argümalar ile karşılık geldikleri parametrelerin türlerinin aynı olduğu o isimde bir metot sınıf
	içerisinde varsa o seçilir (best match)
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		double b = 3.4;

		Sample.foo(a, b);
	}
}

class Sample {
	public static void foo()
	{
		System.out.println("foo");
	}

	public static void foo(int a)
	{
		System.out.println("foo, int");
	}

	public static void foo(double a)
	{
		System.out.println("foo, double");
	}

	public static void foo(double a, int b)
	{
		System.out.println("foo, double, int");
	}

	public static void foo(int b, double a)
	{
		System.out.println("foo, int, double");
	}

	public static void bar(int a, double b)
	{
		System.out.println("bar, int, double");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Tam uyum (best match) yoksa overload resolution işlemi aşağıdaki gibi yapılır:
	1. Aday metotlar (candidate methods) belirlenir: Çağrılan metot ile aynı isimli tüm metotlardır

	2. Uygun metotlar (applicable methods) belirlenir: Aday metotlar içerisindeki, parametre sayısı çağrıdaki argüman
	sayısı ile aynı olan ve argümanlardan parametrelere "implicit" dönüşümün geçerli olduğu metotlardır

	3. En uygun metot (the most applicable method) belirlenir: Uygun metotlar içerisinde daha kaliteli, ya da daha kalitesiz
	olmayan dönüşümü sunan metottur. Ya da başka bir deyişle "en uygun metot öyle bir metottur ki, argümanlardan parametrelere
	yapılan dönüşümler kalite olarak yarışa sokulduğunda daha iyi ya da daha kötü olmayan dönüşümü sunar"

	Dönüşümün kalitesi aşağıdaki kurallara belirlenir:
	T1 argümanın türü, T2 ve T3 yarıştırılan uygun metotların T1'e karşılık gelen parametre türleri olsun:

	1. T1 -> T2 ve T1 -> T3 otomatik dönüşümlerinde T2 veya T3'den biri T1 ile aynı ise aynı olan dönüşüm daha kalitelidir
	Örneğin:
	int -> int *
	int -> long

	2. T1 -> T2 ve T1 -> T3 otomatik dönüşümlerinde T2'den T3'e otomatik (implicit) dönüşüm var, T3'den T2'ye otomatik dönüşüm
	yoksa T2 kalitelidir
	Örneğin:
	int -> long *
	int -> float
	ya da örneğin:

	short -> int *
	short -> long

	Burada aday metotlar bulunamazsa VEYA aday metotlar var ancak uygun metotlar bulunamazsa VEYA uygun metotlar var ancak
	en uygun metot bulunamazsa error oluşur

	Yukarıdaki anlatım "overload resolution" kavramının basitleştirilmiş bir biçimidir
-----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	1. Aday metotlar: 1, 2, 3, 4, 5, 6, 7
	2. Uygun metotlar: 3, 5, 6
	3. En uygun metotlar: 3
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		short b = 20;

		Sample.foo(a, b); //#3
	}
}

class Sample {
	public static void foo() //#1
	{
		System.out.println("foo");
	}

	public static void foo(int a) //#2
	{
		System.out.println("foo, int");
	}

	public static void foo(int a, int b) //#3
	{
		System.out.println("foo, int, int");
	}

	public static void foo(double a) //#4
	{
		System.out.println("foo, double");
	}

	public static void foo(double a, int b) //#5
	{
		System.out.println("foo, double, int");
	}

	public static void foo(int b, long a) //#6
	{
		System.out.println("foo, int, long");
	}

	public static void foo(short b, long a) //#7
	{
		System.out.println("foo, short, long");
	}

	public static void bar(int a, double b) //#8
	{
		System.out.println("bar, int, double");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	1. Aday metotlar: 1, 2, 3, 4, 5, 6, 7
	2. Uygun metotlar: yok
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		short a = 10;
		double b = 20;

		Sample.foo(a, b); //error
	}
}

class Sample {
	public static void foo() //#1
	{
		System.out.println("foo");
	}

	public static void foo(int a) //#2
	{
		System.out.println("foo, int");
	}

	public static void foo(int a, int b) //#3
	{
		System.out.println("foo, int, int");
	}

	public static void foo(double a) //#4
	{
		System.out.println("foo, double");
	}

	public static void foo(double a, int b) //#5
	{
		System.out.println("foo, double, int");
	}

	public static void foo(int b, long a) //#6
	{
		System.out.println("foo, int, long");
	}

	public static void foo(short b, long a) //#7
	{
		System.out.println("foo, short, long");
	}

	public static void bar(int a, double b) //#8
	{
		System.out.println("bar, int, double");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	1. Aday metotlar: Yok
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		short a = 10;
		double b = 20;

		Sample.fo(a, b); //error
	}
}

class Sample {
	public static void foo() //#1
	{
		System.out.println("foo");
	}

	public static void foo(int a) //#2
	{
		System.out.println("foo, int");
	}

	public static void foo(int a, int b) //#3
	{
		System.out.println("foo, int, int");
	}

	public static void foo(double a) //#4
	{
		System.out.println("foo, double");
	}

	public static void foo(double a, int b) //#5
	{
		System.out.println("foo, double, int");
	}

	public static void foo(int b, long a) //#6
	{
		System.out.println("foo, int, long");
	}

	public static void foo(short b, long a) //#7
	{
		System.out.println("foo, short, long");
	}

	public static void bar(int a, double b) //#8
	{
		System.out.println("bar, int, double");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	1. Aday metotlar: 1, 2, 3, 4, 5, 6
	2. Uygun metotlar: 4, 5
	3. En uygun metot: Yok
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		short b = 20;

		Sample.foo(a, b); //error: ambiguity
	}
}

class Sample {
	public static void foo() //#1
	{
		System.out.println("foo");
	}

	public static void foo(int a) //#2
	{
		System.out.println("foo, int");
	}

	public static void foo(double a) //#3
	{
		System.out.println("foo, double");
	}

	public static void foo(double a, int b) //#4
	{
		System.out.println("foo, double, int");
	}

	public static void foo(int b, long a) //#5
	{
		System.out.println("foo, int, long");
	}

	public static void foo(short b, long a) //#6
	{
		System.out.println("foo, short, long");
	}

	public static void bar(int a, double b) //#7
	{
		System.out.println("bar, int, double");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte tam uyum vardır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		short b = 20;

		Sample.foo(a, (long)b);
	}
}

class Sample {
	public static void foo() //#1
	{
		System.out.println("foo");
	}

	public static void foo(int a) //#2
	{
		System.out.println("foo, int");
	}

	public static void foo(double a) //#3
	{
		System.out.println("foo, double");
	}

	public static void foo(double a, int b) //#4
	{
		System.out.println("foo, double, int");
	}

	public static void foo(int b, long a) //#5
	{
		System.out.println("foo, int, long");
	}

	public static void foo(short b, long a) //#6
	{
		System.out.println("foo, short, long");
	}

	public static void bar(int a, double b) //#7
	{
		System.out.println("bar, int, double");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	04.12.2022
-----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Nesne Yönelimli Programlama Tekniği (Object Oriented Programming): Nesne yönelimli programlama tekniğini (NYPT) tek bir
	cümle ile anlatmak pek mümkün değildir. Ancak bu tekniği bilen bir programcıya "sınıflar kullanarak program yazma tekniğidir"
	denebilir.  NYPT aslında anahtar kavramların birleşiminden oluşur. Bu anahtar kavramlar birbirlerinden tamamen ayrık değildir.
	Bu kavramlar iç içe geçmiş daireler olarak düşünülebilir. Tüm anahtar kavramların temelinde kodun okunabilir/algılanabilir
	olması ve iyi yönetilmesi vardır. Örneğin benzer işi yapan metotlara aynı ismi vermek iyi bir tekniktir. Bu durumda
	bu metotları kullanan programcılar "çok şey var" duygusundan uzaklaşıp "az şey var" gibi bir algı oluştururlar. Bu da
	hatırlamayı kolaylaştırır.

	NYPT insanın doğayı algılama biçimini model almıştır. İnsanlar herşeyi nesne biçiminde ele alıp kullanırlar. Örneğin
	elimizdeki cep telefonları farklı olsa bile konuşurken bizim için hepsi cep telefonudur. Gerekirse onların başka
	özellikleri de ayrıca söylenebilir.

	NYPT'de artık ağırlıklı olarak fonksiyonlarla değil (Java'da metot), sınıflarla konuşulur. Böylece yine "çok şey var"
	algısından uzaklaştırılıp "az şey var" algısı oluşturulur. Bu anlamda kullanan programcı açısından detaylar, metotların
	detayları gizlemesinden daha da fazla gizlenebilir. Böylelikle kullanım kolaylaşır. Bunların detayları ileride daha iyi
	anlaşılacaktır
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Değişkenlerin Ömürleri (storage duration): Bir değişkenin bellekte kapladığı zaman aralığına denir. Yani bir değişkenin
	ömrü o değişkenin bellekte yaratılmasıyla (yer ayrılmasıyla) yok edilmesi arasında geçen zaman aralığıdır. Ömür
	çalışma zamanına ilişkin bir kavramdır
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Bir Java programı için çalışma zamanında "stack" ve "heap" denilen iki ayrı bellek alanı yaratılır. Her uygulama için
	bu alanlar ayrı ayrı yaratılırlar. Aşağı seviyede başka alanlar da vardır. Stack ve heap RAM'de organize edilir. Stack
	ve heap'in yeri yani hangi adresten başladığı ve uzunluğu sistemden sisteme değişebilir. Program çalıştırılurken bu
	alanların uzunlukları belirlenebilir. Belirlenmezse default değerler kullanılır. Default değerler sistemden sisteme
	değişebilmektedir.

	Stack'te yaratma ve yoketme işlemi birer makine komutuyla çok hızlı bir biçimde yapılır. Stack alanında değişken yaratılması
	ve yok edilmesi stack veri yapısı ile gerçekleştirilir.


	Anahtar Notlar: Aralarında mantıksal ya da fiziksel ilişki olan bir grup nesnenin tutulduğu yapıya "veri yapısı (data structure)"
	denir. Stack veri yapısı "LIFO (Last In First Out)" kuyruk sistemine göre çalışan veri yapısıdır. LIFO'da ekleme (push)
	sona yapılır. Eleman elde etme (veya silme) sondan yapılır (peek/pop). Yani her zaman son eleman elde ede edilir. Örneğin
	bir editörün "undo-redo" işlemleri iki ayrı stack kullanılarak gerçekleştirebilir. Bu durumda "undo" işlemi undo stack'inden
	"pop" yapıp, "redo" stack'ine "push "yapmaktır. Benzer şekilde "redo" işlemi de "redo" stack'inden "pop" yapıp, "undo" stack'ine
	"push" yapmaktır.
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Yerel değişkenler ve parametre değişkenleri stack alanında yaratılır. Yerel bir değişken, akış bakımında bildirim
	noktasına gelindiğinde yaratılır, bildirildiği bloğun sonuna gelindiğinde yok edilir. Zaten yerel değişkenlere
	faaliyet alanı bakımından bildirildikleri bloğun sonunda erişilememesinin nedeni budur. Parametre değişkenleri
	metot çağrıldığında yaratılır, metot çağrısı bittiğinde yok edilir.

	Anahtar Notlar: Her ne kadar faaliyet alanı(scope) ve ömür (storage duration) farklı zamanlara ilişkin kavramlar
	olsa da aralarında mantıksal bir bağ söz konusudur. Yani aralarında dolaylı da olsa bir ilişki vardır.
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		//...
		{
			int a; //Akış buraya geldiğinde a stack'te yaratılır
			double b = 5.6; //Akış buraya geldiğinde b stack'te yaratılır

			a = 3;

			//...

		} //a ve b yok edilir

		Sample.foo(10, 6.7); //Metodun parametre değişkenleri stack'te yaratılır ve argümların değerleri ilgili parametrelere aktarılır
		//Metot çağrısı bittiğinde parametre değişkenleri yok edilir

		//...

		Sample.foo(1, 6.5); //Metodun parametre değişkenleri stack'te yaratılır ve argümların değerleri ilgili parametrelere aktarılır
		//Metot çağrısı bittiğinde parametre değişkenleri yok edilir
	}
}

class Sample {
	public static void foo(int a, double b)
	{
		int val; //Akış buraya geldiğinde val stack'te yaratılır

		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	boolean türü hiç bir tür ile işleme sokulamaz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		boolean a = true;
		int b = 30;
		int c;

		c = a + b; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	char türü herhangi bir tür ile işleme sokulabişir. Bu durumda char türüne ilişkin değer diğer türe dönüştürülür..
	Dikkat: Integral promotion bu durumundan dışındadır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 32;
		char c = 'D';
		int result;

		result = c + a;

		System.out.println(result);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	float türü ile double türü işleme sokulduğunda float türünde ilişkin değer double türüne dönüştürülür. İşlem double
	türden çıkar
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		float a = 3.4F;
		double b = 5.6;
		double c;

		c = a + b;

		System.out.printf("c = %.20f%n", c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	İşlem öncesi otomatik tür dönüşümü geçici değişken yaratılarak yapılır. Yani derleyici geçici değişken yaratan kodu
	üretir. Örnekte derleyici ** ile belirtilen işlem için yaklaşık olarak şu şekilde klod üretir:
		long temp = a;

		c = temp + b;
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		long b = 200;
		long c;

		c = a + b; //**

		System.out.printf("c = %.20f%n", c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	İşlem öncesi otomatik tür dönüşümü geçici değişken yaratılarak yapılır. Yani derleyici geçici değişken yaratan kodu
	üretir. Örnekte derleyici ** ile belirtilen işlem için yaklaşık olarak şu şekilde kod üretir:
		int temp1 = a;
		int temp2 = b;

		c = temp1 + temp2;
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		short a = 10;
		byte b = 100;
		int c;

		c = a + b; //**

		System.out.printf("c = %.20f%n", c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Tür dönüştürme (type cast) operatörü:
	Tür dönüştürme operatörü özel amaçlı, tek operandlı (unary) ve önek (prefix) durumunda bir operatördür. Tür dönüştürme
	operatörünün genel biçimi:

		(<hedef tür>)<ifade>

	Bu operatör, operandına ilişkin ifadenin hedef türe dönüştürüldükten sonra elde edilen değerini üretir. Bu operatörün
	yan etkisi yoktur. Bu operatör ile yapılan dönüşüme "casting ya da explicit conversion" denir. Genele olarak, implicit
	yapılamayan dönüşümler tür dönüştürme operatörü ile yapılabilir. Şüphesi bu durumda bilgi kaybı oluşabilir. Bu bilgi
	kayıplarının nasıl oluşacağı belirlidir ve konu içerisinde ele alınacaktır.

	implicit olarak geçerli olan tüm dönüşümler explicit olarak da yani tür dönüştürme operatörü ile de yapılabilir.

	Anahtar Notlar: Tür dönüştürme operatörünün sentaks ve semantik olarak zorunlu olması durumu genel olarak
	"işlem doğrudan yapılırsa problem olabilir. Bu sebeple derleyici bunu doğrudan yapmamızı istemiyor. Biz yapmak istersek
	tür dönüştürme operatörü kullanarak derleyiciye, durumun farkındayım bana izin ver" anlaşılmalıdır
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte tür dönüştürme operatörü kullanılarak işlemin double olarak yapılması sağlanmış ve noktadan sonraki
	kısım da elde edilebilmiştir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İki tamsayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		double c;

		c = (double)a / b;

		System.out.printf("c = %f%n", c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Tür dönüştürme operatörü
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir tamsayı giriniz:");
		long a = kb.nextLong();
		int b;

		b = (int)a;

		System.out.printf("b = %d%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	26.11.2022
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	implicit olarak geçerli olan dönüşümler için de explicit dönüşüm yapılabilir. Yani tür dönüştürme operatörü
	kullanılabilir. Aşağıdaki örnekte tür dönüştürme operatörü kullanılmış olsa da kullanılmamasıyla aynı anlamdadır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir tamsayı giriniz:");
		int a = kb.nextInt();
		long b;

		b = (long)a;

		System.out.printf("b = %d%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Explicit conversion (type cast) işlemine ilişkin aşağıdaki maddlere genel olarak implicit yapılamayan dönüşümlere
	ilişkindir
-----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Büyük tamsayı türünden küçük tamsayı türüne yapılan explicit dönüşümde kaynak türe ilişkin değerin yüksek anlamlı byte değerleri
	atılır. Bu durumda elde edilen değer hedef türe atanır. Bu durumda kaynak türe ilişkin değer hedef türün sınırları
	içerisindeyse bilgi kaybı oluşmaz, değilse bilgi kaybı oluşur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);


		for (;;) {
			System.out.print("Bir tamsayı giriniz:");
			long a = Long.parseLong(kb.nextLine());

			if (a == 0)
				break;

			int b;

			b = (int)a;

			System.out.printf("a = %d%n", a);
			System.out.printf("a = %016X%n", a);
			System.out.printf("b = %d%n", b);
			System.out.printf("b = %08X%n", b);
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	short türünden char türüne yapılan explicit dönüşümde sayının bit kalıbı değişmez. Sayının yorumlanışı değişir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);


		for (;;) {
			System.out.print("Bir sayı giriniz:");
			short a = Short.parseShort(kb.nextLine());

			if (a == 0)
				break;

			char b;

			b = (char)a;

			System.out.printf("a = %d%n", a);
			System.out.printf("a = %04X%n", a);
			System.out.printf("b = %c%n", b);
			System.out.printf("(int)b = %04X%n", (int)b);
			System.out.printf("(int)b = %d%n", (int)b);
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}



/*----------------------------------------------------------------------------------------------------------------------
	char türünden short türüne yapılan explicit dönüşümde sayının bit kalıbı değişmez. Sayının yorumlanışı değişir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		char c = '\uFFBD';
		short b;

		b = (short)c;

		System.out.printf("c = %c%n", c);
		System.out.printf("c = %04X%n", (int)c);
		System.out.printf("c = %d%n", (int)c);
		System.out.printf("b = %04X%n", b);
		System.out.printf("b = %d%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	boolean türünden hiç bir türe explicit dönüşüm yapılamaz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		boolean a = true;
		int b;

		b = (int)a; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Herhangi bir türden boolean türüne explicit dönüşüm yapılamaz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 1;
		boolean b;

		b = (boolean)a; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	byte türünden char türüne yapılan explicit dönüşüm iki aşamada gerçekleşir. Birinci aşamada değer int türüne yükseltilir.
	İkinci aşamada yüksek anlamlı 2 byte atılarak char türüne dönüştürülür. Bu işlem Java Language Specification'da
	"widening and narrowing conversion" olarak belirtilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		byte a = 99;
		char c;

		c = (char)a;

		System.out.printf("a = %d%n", a);
		System.out.printf("a = %02X%n", a);
		System.out.printf("(int)a = %08X%n", (int)a);
		System.out.printf("(short)c = %04X%n", (short)c);
		System.out.printf("c = %c%n", c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	byte türünden char türüne yapılan explicit dönüşüm iki aşamada gerçekleşir. Birinci aşamada değer int türüne yükseltilir.
	İkinci aşamada yüksek anlamlı 2 byte atılarak char türüne dönüştürülür. Bu işlem Java Language Specification'da
	"widening and narrowing conversion" olarak belirtilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		byte a = -99;
		char c;

		c = (char)a;

		System.out.printf("a = %d%n", a);
		System.out.printf("a = %02X%n", a);
		System.out.printf("(int)a = %08X%n", (int)a);
		System.out.printf("(short)c = %04X%n", (short)c);
		System.out.printf("c = %c%n", c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	double türünden float türüner nexplicit dönüşümde bilgi kaybı olabilir. Bu durumda IEEE 754 standardına göre
	yuvarlama hataları oluşabilir ve değer float türü ile temsil edilebilecek bir değer olarak elde edilir. Ayrıca float
	sınırları dışında ise de aynı yöntem geçerlidir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		double a = 3.4;
		float b;

		b = (float)a;

		System.out.printf("a = %.20f%n", a);
		System.out.printf("b = %.20f%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Gerçek sayı türünden tam sayı türüne (veya char türüne) yapılan explicit dönüşüm şu şekilde gerçekleşir:
	- Sayının noktadan sonraki kısmı atılır
	 	- Elde edilen değer hedef türün sınırları içerisindeyse hedef türe atanır
	 	- Elde edilen değer hedef türün sınırları içerisinde değilse
	 		- Hedef tür byte, short, int veya char türlerinden biriyse
	 			- Elde edilen değer int türü sınırları içerisindeyse int türüne dönüştürülür. Buradan elde edilen değer,
	 			tamsayılar arasındaki dönüşüm kurallarına göre atanır
	 			- Elde edilen değer int türü sınırları içerisinde değilse değerin pozitif ya da negatif olmasına göre
	 			int türünün en büyük veya en küçük değeri alınır ve hedef türe dönüştürülür
	 		- Hedef tür long ise
	 			- Elde edilen değer long türü sınırları içerisindeyse doğrudan atanır
	 			- Elde edilen değer long türü sınırları içerisinde değilse sayının pozitif veya negatif olması durumuna
	 			göre long türünün en büyük veya en küçük değeri alınır ve atanır
-----------------------------------------------------------------------------------------------------------------------*/

package csd;

class App {
	public static void main(String [] args)
	{
		double a = 3.4;
		short b;

		b = (short)a;

		System.out.printf("b = %d%n", b);
	}
}

package csd;

class App {
	public static void main(String [] args)
	{
		double a = 1234.5;
		byte b;

		b = (byte)a;

		System.out.printf("1234 = %08X%n", 1234);
		System.out.printf("b = %02X%n", b);
		System.out.printf("b = %d%n", b);
	}
}

package csd;

class App {
	public static void main(String [] args)
	{
		double a = -1234.5;
		byte b;

		b = (byte)a;

		System.out.printf("-1234 = %08X%n", -1234);
		System.out.printf("b = %02X%n", b);
		System.out.printf("b = %d%n", b);
	}
}

package csd;

class App {
	public static void main(String [] args)
	{
		double a = 5_000_000_000.5;
		byte b;

		b = (byte)a;

		System.out.printf("5_000_000_000 = %08X%n", (int)5_000_000_000L);
		System.out.printf("2147483647 = %08X%n", 2147483647);
		System.out.printf("b = %02X%n", b);
		System.out.printf("b = %d%n", b);
	}
}


package csd;

class App {
	public static void main(String [] args)
	{
		double a = -5_000_000_124.5;
		byte b;

		b = (byte)a;

		System.out.printf("-5_000_000_124 = %08X%n", (int)-5_000_000_124L);
		System.out.printf("-2147483648 = %08X%n", -2147483648);
		System.out.printf("b = %02X%n", b);
		System.out.printf("b = %d%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Klavyeden sıfır girilene kadar alınan int türden sayıların ortalamasını bulan programı yazınız.
	Açıklamalar: Toplam değeri ve girilen değerlerin sayısı int olarak tutulacaktır

	Aşağıdaki örnekte tür dönüştürme operatörü kullanılmazsa bilgi kaybı oluşabilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		FindAverageApp.run();
	}
}


class FindAverageApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.println("Sayıları girmeye başlayınız:");
		int sum = 0, count = 0;
		int val;

		while ((val = kb.nextInt()) != 0) {
			sum += val;
			++count;
		}

		double average;

		average = (double)sum / count;

		System.out.printf("Ortalama: %f%n", average);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte tür dönüştürme operatörü kullanılmazsa bilgi kaybı oluşabilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		long c;

		c = (long)a + b;

		System.out.printf("%d + %d = %d%n", a, b, c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte double türden sabit kullanıldığından işlem double olarak yapılır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int sum = 0;

		System.out.println("5 tane sayı giriniz:");

		for (int i = 0; i < 5; ++i)
			sum += kb.nextInt();

		double average;

		average = sum / 5.;

		System.out.printf("Ortalama:%f%n", average);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte double türden sabit kullanıldığından işlem double olarak yapılır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int sum = 0;

		System.out.println("5 tane sayı giriniz:");

		for (int i = 0; i < 5; ++i)
			sum += kb.nextInt();

		double average;

		average = sum / 5D;

		System.out.printf("Ortalama:%f%n", average);
	}
}

/*-----------------------------------------------------------------------------------------------------------------------
	27.11.2022
-----------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------
	İşlemli atama operatrlerinin genel biçimi aşağıdaki gibidir.

	T1 a;
	T2 b;

	a op= b => a = (T1)(a op b)

	Dikkat edilirse bu operatörler daha önce de söylendiği gibi ifadeleri basitleştirirler
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		int b = 20;

		a += Math.sqrt(b); //a = (int)(a + Math.sqrt(b));

		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir sayının basamak sayısının log10 ile bulunması
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());

		int count = 1;

		if (val != 0)
			count = (int)Math.log10(Math.abs(val)) + 1;

		System.out.printf("%d sayısının basamak sayısı:%d%n", val, count);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının Armstrong sayısı olup olmadığını test eden isArmstrong
	metodunu NumberUtil sınıfı içerisinde yazınız
	Açıklamalar:
		- Bir sayının her basamağının "basamak sayı"-ncı kuvvetleri toplanmı sayının kendisine eşitse bu sayıya Armstrong
		sayısı denit. Örneğin:
			153 -> 1 ^ 3 + 5 ^ 3 + 3 ^ 3 = 153

		- Negatif sayılar Armstrong sayısı olarak kabul edilmeyecektir

		- Metodu, 1 basamaklı, 2 basamaklı, 3 basamaklı, 4 basamaklı, 5 basamaklı ve 6 basamaklı Armstrong sayılarını
		ekrana yazdırarak test ediniz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		IsArmstrongTest.run();
	}
}

class IsArmstrongTest {
	public static void run()
	{
		for (int n = -10; n <= 999999; ++n)
			if (NumberUtil.isArmstrong(n))
				System.out.println(n);

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil {
	public static boolean isArmstrong(int val)
	{
		return val >= 0 && getDigitsPowSum(val) == val;
	}

	public static int getDigitsPowSum(int val)
	{
		int n = countDigits(val);
		int total = 0;

		while (val != 0) {
			total += Math.pow(val % 10, n);
			val /= 10;
		}

		return total;
	}

	public static int countDigits(int val)
	{
		if (val == 0)
			return 1;

		return (int)Math.log10(Math.abs(val)) + 1;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	03.12.2022
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Koşul Operatörü (Conditional Operator): Koşul operatörğ özel amaçlı, üç operandlı (ternary) ve araek durumunda bir
	operatördür. Operatörün genel biçimi:
		<operand1> ? <operand2> : <operand3>
	operand1: boolean türden bir ifade olmalıdır. Aşağıdaki koşul operatörüne ilişkin ifadenin if deyimi ile yapılışı:
		if (a < b)
			min = a;
		else
		 	min = b;
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();

		int min;

		min = a < b ? a : b;

		System.out.printf("min(%d, %d) = %d%n", a, b, min);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte b - 100 ifadesi koşul operatörünün üçüncü operandıdır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();

		int result;

		result = a < b ? a : b - 100;

		System.out.printf("result = %d%n", result);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte koşul operatörünün ürettiği değerden 100 çıkartılacaktır. Parantez ile bu sağlanmıştır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();

		int result;

		result = (a < b ? a : b) - 100;

		System.out.printf("result = %d%n", result);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte koşul operatörünün birinci operandı = ile ? arasıdır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();

		int result;

		result = a > 0 && a >= b ? a : b;

		System.out.printf("result = %d%n", result);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte koşul operatörünün birinci operandı = ile ? arasıdır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();

		int result;

		result = a + a >= b ? a : b;

		System.out.printf("result = %d%n", result);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();

		int result;

		result = a + (a >= b ? a : b);

		System.out.printf("result = %d%n", result);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Koşul operatörünün ürettiği değerin bir değişkene atanması durumunda kullanımı if deyimine göre daha okunabilirdir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();

		int min;

		min = a < b ? a : b;

		System.out.printf("min(%d, %d) = %d%n", a, b, min);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Koşul operatörünün ürettiği değerin return deyiminde kullanımı okunabilirliği artırır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();

		System.out.printf("min(%d, %d) = %d%n", a, b, Util.min(a, b));
	}
}

class Util {
	public static int min(int a, int b)
	{
		return a < b ? a : b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Koşul operatörünün ürettiği değerin metot çağrısında argüman olarak metoda verilmesi okunabilirliği artırır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();

		System.out.printf("min(%d, %d) = %d%n", a, b, a < b ? a : b);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Koşul operatörünün ikinci ve üçüncü operandı void bir ifade olamaz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();

		a < b ? Sample.foo() : Sample.bar(); //error
	}
}

class Sample {
	public static void foo()
	{
		System.out.println("foo");
	}

	public static void bar()
	{
		System.out.println("bar");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Koşul operatörünün bir kullanımı. Örnekte parantez kullanımına sentaks açısından gerek yoktur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Üç sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int c = kb.nextInt();

		int min;

		min = a < b ? a < c ? a : c : b < c ? b : c;
		System.out.printf("min(%d, %d, %d) = %d%n", a, b, c, min);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örnekte koşul operatörünün operandlarını parantez içerisine almak okunabilirliği artırır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Üç sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int c = kb.nextInt();

		int min;

		min = (a < b) ? (a < c ? a : c) : (b < c ? b : c);
		System.out.printf("min(%d, %d, %d) = %d%n", a, b, c, min);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden gün, ay ve yıl bilgilerine ilişkin tarihin aşağıdaki açıklamalara
	göre haftanın hangi gününe geldiğini döndüren getDayOfWeek metodunu yazınız ve aşağıdaki kod ile test ediniz.,
	Açıklamalar:
		- Metot geçersiz bir tarih için -1 değerine geri dönecektir
		- 01.01.1900 öncesindeki tarihler geçersiz kabul edilecektir
		- Haftanın günü 01.01.1900 ile verilen tarih arasındaki (verilen tarih dahil) gün sayısının 7(yedi) ile
		bölümünden elde edilen kalan alınarak belirlenebilir. Buna göre değer sıfır ise "pazar", 1 ise "pazartesi", ...,
		6 ise "cumartesi" günlerine karşılık gelir
		- Bu metot ile birlikte verilen tarihin hafta sonu olup olmadığını test eden isWeekend ve hafta içi olup olmadığını
		test eden isWeekday metotlarını da yazınız. Bu metotlar tarih geçerlilik kontrolü yapmayacaktır
		- İleride daha iyisi yazılacaktır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		GetDayOfWeekTest.run();
	}
}

class GetDayOfWeekTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for (;;) {
			System.out.print("Gün ay ve yıl bilgilerini giriniz:");
			int day = kb.nextInt();
			int month = kb.nextInt();
			int year = kb.nextInt();

			if (day == 0)
				break;

			DateUtil.printDateTR(day, month, year);
		}

		System.out.println("Tekrar yapıyor munuz?");
	}
}

class DateUtil {
	public static void printDateTR(int day, int month, int year)
	{
		int dayOfWeek = getDayOfWeek(day, month, year);

		if (dayOfWeek == -1) {
			System.out.println("Geçersiz tarih");
			return;
		}

		printDateByDayOfWeekTR(day, month, year, dayOfWeek);

		System.out.println(isWeekend(day, month, year) ? "Bugün kurs var. Tekrar yaptınız mı?" : "Kurs günü yaklaşıyor. Tekrar yapmayı unutmayınız!...");
	}

	public static void printDateByDayOfWeekTR(int day, int month, int year, int dayOfWeek)
	{
		switch (dayOfWeek) {
		case 0 -> System.out.printf("%02d/%02d/%04d Pazar%n", day, month, year);
		case 1 -> System.out.printf("%02d/%02d/%04d Pazartesi%n", day, month, year);
		case 2 -> System.out.printf("%02d/%02d/%04d Salı%n", day, month, year);
		case 3 -> System.out.printf("%02d/%02d/%04d Çarşamba%n", day, month, year);
		case 4 -> System.out.printf("%02d/%02d/%04d Perşembe%n", day, month, year);
		case 5 -> System.out.printf("%02d/%02d/%04d Cuma%n", day, month, year);
		case 6 -> System.out.printf("%02d/%02d/%04d Cumartesi%n", day, month, year);
		}
	}

	public static int getDayOfWeek(int day, int month, int year)
	{
		int totalDays;

		return (year < 1900 || (totalDays = getDayOfYear(day, month, year)) == -1) ? -1 : (getTotalDays(year, totalDays) % 7);
	}

	public static int getTotalDays(int year, int totalDays)
	{
		for (int y = 1900; y < year; ++y)
			totalDays += isLeapYear(y) ? 366 : 365;

		return totalDays;
	}

	public static boolean isWeekend(int day, int month, int year)
	{
		int dayOfWeek = getDayOfWeek(day, month, year);

		return dayOfWeek == 0 || dayOfWeek == 6;
	}

	public static boolean isWeekday(int day, int month, int year)
	{
		return !isWeekend(day, month, year);
	}

	public static int getDayOfYear(int day, int month, int year)
	{
		if (!isValidDate(day, month, year))
			return -1;

		int total = day;

		switch (month - 1) {
		case 11:
			total += 30;
		case 10:
			total += 31;
		case 9:
			total += 30;
		case 8:
			total += 31;
		case 7:
			total += 31;
		case 6:
			total += 30;
		case 5:
			total += 31;
		case 4:
			total += 30;
		case 3:
			total += 31;
		case 2:
			total += isLeapYear(year) ? 29 : 28;
		case 1:
			total += 31;
		}

		return total;
	}

	public static boolean isValidDate(int day, int month, int year)
	{
		return 1 <= day && day <= 31 && 1 <= month && month <= 12 && day <= getDays(month, year);
	}

	public static int getDays(int month, int year)
	{
		return switch (month) {
		case 4, 6, 9, 11 -> 30;
		case 2 -> isLeapYear(year) ? 29 : 28;
		default -> 31;
		};
	}

	public static boolean isLeapYear(int year)
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının Armstrong sayısı olup olmadığını test eden isArmstrong
	metodunu NumberUtil sınıfı içerisinde yazınız
	Açıklamalar:
		- Bir sayının her basamağının "basamak sayı"-ncı kuvvetleri toplanmı sayının kendisine eşitse bu sayıya Armstrong
		sayısı denit. Örneğin:
			153 -> 1 ^ 3 + 5 ^ 3 + 3 ^ 3 = 153

		- Negatif sayılar Armstrong sayısı olarak kabul edilmeyecektir

		- Metodu, 1 basamaklı, 2 basamaklı, 3 basamaklı, 4 basamaklı, 5 basamaklı ve 6 basamaklı Armstrong sayılarını
		ekrana yazdırarak test ediniz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		IsArmstrongTest.run();
	}
}

class IsArmstrongTest {
	public static void run()
	{
		for (int n = -10; n <= 999999; ++n)
			if (NumberUtil.isArmstrong(n))
				System.out.println(n);

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil {
	public static boolean isArmstrong(int val)
	{
		return val >= 0 && getDigitsPowSum(val) == val;
	}

	public static int getDigitsPowSum(int val)
	{
		int n = countDigits(val);
		int total = 0;

		while (val != 0) {
			total += Math.pow(val % 10, n);
			val /= 10;
		}

		return total;
	}

	public static int countDigits(int val)
	{
		return (val != 0) ? ((int)Math.log10(Math.abs(val)) + 1) : 1;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Nesne Yönelimli programlamada iki tip polimorfizm vardır Bunlar:
	1-)Compile time Polimorfzim(Method Overloading)
	2-)Runtime Polimorfzim(Method Override)

	Method Overloading: Bir sınıf içerisinde aynı isimde metotlar yazılması durumuna "method overloading" denir. Bu kavram
	farklı sınıflar içerisinde aynı isimde metotlar olması durumu değildir.

-----------------------------------------------------------------------------------------------------------------------*/
Aşağıdaki örnekte bir method overriding örneği verilmiştir.
//-----------------------------------------------------------------------------------------------------------------------
package csd;

class App {
    public static void main(String [] args)
    {
        java.util.Scanner kb = new java.util.Scanner(System.in);
        Car c = new Car();
        c.run();
        Mercedes m = new Mercedes();
        m.run();
    }
}

class Car{
    public static void run()
    {
        System.out.println("Car is running");
    }
}

class Mercedes extends Car{
    public static void run()
    {
        System.out.println("Mercedes is running");
    }
}
/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki durum "method overloading" değildir. Çünkü aynı isimde olan metotlar farklı sınıflardadır.
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample.foo();
		Mample.foo();
	}
}

class Sample {
	public static void foo()
	{
		System.out.println("Sample.foo");
	}
}

class Mample {
	public static void foo()
	{
		System.out.println("Mample.foo");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Bir sınıf içerisinde "aynı" metottan birden fazla olamaz. Bu durumda bir metodun "overload" edilebilmesi
	için kendisiyle aynı isimde olanlardan "farklı" olması gerekir. Aşağıdaki maddelerde metodun "aynı" ya da "farklı" olmasına
	ilişkin detaylar anlatılmaktadır
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun erişim belirleyicisinin "overload" işlemine etkisi yoktur. Yani metodun erişim belirleyicilerin farklı
	olması metodu farklı yapmaz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public static void foo() //error
	{
		//...
	}

	private static void foo() //error
	{
		//...
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun static olup olmamasının overload işlemine etkisi yoktur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public void foo() //error
	{
		//...
	}

	public static void foo() //error
	{
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun geri dönüş değeri bilgisinin de overload işlemine etkisi yoktur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public static int foo() //error
	{
		//...

		return 0;
	}

	public static void foo() //error
	{
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun parametre değişken isimlerinin de overload işlemine etkisi yoktur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public static void foo(int a) //error
	{
		//...

	}

	public static void foo(int x) //error
	{
		//...
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun "overload" edilebilmesi için metodun parametre tür bilgisi ve parametrelerin dizilimlerinin farklı olması
	gerekir. Buna genel olarak "parametrik yapı" diyebiliriz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public static void foo()
	{
		//...
	}

	public static void foo(int a)
	{
		//...
	}

	public static void foo(double a)
	{
		//...
	}

	public static void foo(double a, int b)
	{
		//...
	}

	public static void foo(int a, double b)
	{
		//...
	}
	//...
}
/*---------------------------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
----------------------------------------------------------------------------*/
package csd;

class App {
    public static void main(String [] args)
    {
        B.foo();
        B.foo(12);
        B.foo(23.5);
        B.foo(23.5F);
        B.foo('A');
        B.foo(12,67.89);
        B.foo(34.5F,15);
    }
}


class B{
    public static void foo()
    {
        System.out.println("B.foo()");
    }

    public static void foo(int a)
    {
        System.out.println("B.foo(int)");
    }

    public static void foo(double a)
    {
        System.out.println("B.foo(double)");
    }

    public static void foo(double a, int b)
    {
        System.out.println("B.foo(double,int)");
    }

    public static void foo(int a, double b)
    {
        System.out.println("B.foo(int,double)");
    }
}
/*----------------------------------------------------------------------------------------------------------------------
	Bir sınıf içerisinde metodun ismi ve parametrik yapısının ikisine birden metodun "imzası (signature)" diyelim.
	Kural: Bir sınıf içerisinde aynı imzaya sahip 1'den fazla metot bildirimi geçersizdir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public static void foo() //imza: foo
	{
		//...
	}

	public static void foo(int a)  //imza: foo, int
	{
		//...
	}

	public static void foo(double a)  //imza: foo, double
	{
		//...
	}

	public static void foo(double a, int b)  //imza: foo, double, int
	{
		//...
	}

	public static void foo(int b, double a)  //imza: foo, int, double
	{
		//...
	}

	public static void bar(int a, double b)  //imza: bar, int, double
	{
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir metot çağrısında derleyicinin hangi metodun çağrılacağına karar vermesi sürecine "method overload resolution" ya da
	kısaca "overload resolution" denir.
-----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Metot çağrısında argümanlar ile karşılık geldikleri parametrelerin türlerinin aynı olduğu o isimde bir metot sınıf
	içerisinde varsa o seçilir (best match(en iyi uyum) / exact match(tam uyum))
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		double b = 3.4;

		Sample.foo(a, b);
	}
}

class Sample {
	public static void foo()
	{
		System.out.println("foo");
	}

	public static void foo(int a)
	{
		System.out.println("foo, int");
	}

	public static void foo(double a)
	{
		System.out.println("foo, double");
	}

	public static void foo(double a, int b)
	{
		System.out.println("foo, double, int");
	}

	public static void foo(int b, double a)
	{
		System.out.println("foo, int, double");
	}

	public static void bar(int a, double b)
	{
		System.out.println("bar, int, double");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Tam uyum (best match) yoksa overload resolution işlemi aşağıdaki gibi yapılır:
	1. Aday metotlar (candidate methods) belirlenir: Çağrılan metot ile aynı isimli tüm metotlardır

	2. Uygun metotlar (applicable methods) belirlenir: Aday metotlar içerisindeki, parametre sayısı çağrıdaki argüman
	sayısı ile aynı olan ve argümanlardan parametrelere "implicit" dönüşümün geçerli olduğu metotlardır

	3. En uygun metot (the most applicable method) belirlenir: Uygun metotlar içerisinde daha kaliteli, ya da daha kalitesiz
	olmayan dönüşümü sunan metottur. Ya da başka bir deyişle "en uygun metot öyle bir metottur ki, argümanlardan parametrelere
	yapılan dönüşümler kalite olarak yarışa sokulduğunda daha iyi ya da daha kötü olmayan dönüşümü sunar"

	Dönüşümün kalitesi aşağıdaki kurallara belirlenir:
	T1 argümanın türü, T2 ve T3 yarıştırılan uygun metotların T1'e karşılık gelen parametre türleri olsun:

	1. T1 -> T2 ve T1 -> T3 otomatik dönüşümlerinde(standard/implicit conversion) T2 veya T3'den biri T1 ile aynı ise aynı olan dönüşüm daha kalitelidir
	Örneğin:
	int -> int *
	int -> long

	2. T1 -> T2 ve T1 -> T3 otomatik dönüşümlerinde T2'den T3'e otomatik (implicit) dönüşüm var, T3'den T2'ye otomatik dönüşüm
	yoksa T2 kalitelidir
	Örneğin:
	int -> long *
	int -> float
	ya da örneğin:

	short -> int *
	short -> long

	Burada aday metotlar bulunamazsa VEYA aday metotlar var, ancak uygun metotlar bulunamazsa VEYA uygun metotlar var, ancak
	en uygun metot bulunamazsa error oluşur.

	Yukarıdaki anlatım "overload resolution" kavramının basitleştirilmiş bir biçimidir
-----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	1. Aday metotlar: 1, 2, 3, 4, 5, 6, 7(isim uyumu)
	2. Uygun metotlar: 3, 5, 6(parametre sayısı uyumu)
	3. En uygun metotlar: 3
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		short b = 20;

		Sample.foo(a, b); //#3
	}
}

class Sample {
	public static void foo() //#1
	{
		System.out.println("foo");
	}

	public static void foo(int a) //#2
	{
		System.out.println("foo, int");
	}

	public static void foo(int a, int b) //#3
	{
		System.out.println("foo, int, int");
	}

	public static void foo(double a) //#4
	{
		System.out.println("foo, double");
	}

	public static void foo(double a, int b) //#5
	{
		System.out.println("foo, double, int");
	}

	public static void foo(int b, long a) //#6
	{
		System.out.println("foo, int, long");
	}

	public static void foo(short b, long a) //#7
	{
		System.out.println("foo, short, long");
	}

	public static void bar(int a, double b) //#8
	{
		System.out.println("bar, int, double");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	1. Aday metotlar: 1, 2, 3, 4, 5, 6, 7
    2. Uygun metotlar: yok(Uygun metot bulunamadı)
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		short a = 10;
		double b = 20;

		Sample.foo(a, b); //error
	}
}

class Sample {
	public static void foo() //#1
	{
		System.out.println("foo");
	}

	public static void foo(int a) //#2
	{
		System.out.println("foo, int");
	}

	public static void foo(int a, int b) //#3
	{
		System.out.println("foo, int, int");
	}

	public static void foo(double a) //#4
	{
		System.out.println("foo, double");
	}

	public static void foo(double a, int b) //#5
	{
		System.out.println("foo, double, int");
	}

	public static void foo(int b, long a) //#6
	{
		System.out.println("foo, int, long");
	}

	public static void foo(short b, long a) //#7
	{
		System.out.println("foo, short, long");
	}

	public static void bar(int a, double b) //#8
	{
		System.out.println("bar, int, double");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	1. Aday metotlar: Yok
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		short a = 10;
		double b = 20;

		Sample.fo(a, b); //error
	}
}

class Sample {
	public static void foo() //#1
	{
		System.out.println("foo");
	}

	public static void foo(int a) //#2
	{
		System.out.println("foo, int");
	}

	public static void foo(int a, int b) //#3
	{
		System.out.println("foo, int, int");
	}

	public static void foo(double a) //#4
	{
		System.out.println("foo, double");
	}

	public static void foo(double a, int b) //#5
	{
		System.out.println("foo, double, int");
	}

	public static void foo(int b, long a) //#6
	{
		System.out.println("foo, int, long");
	}

	public static void foo(short b, long a) //#7
	{
		System.out.println("foo, short, long");
	}

	public static void bar(int a, double b) //#8
	{
		System.out.println("bar, int, double");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	1. Aday metotlar: 1, 2, 3, 4, 5, 6
	2. Uygun metotlar: 4, 5
	3. En uygun metot: Yok
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		short b = 20;

		Sample.foo(a, b); //error: ambiguity
	}
}

class Sample {
	public static void foo() //#1
	{
		System.out.println("foo");
	}

	public static void foo(int a) //#2
	{
		System.out.println("foo, int");
	}

	public static void foo(double a) //#3
	{
		System.out.println("foo, double");
	}

	public static void foo(double a, int b) //#4
	{
		System.out.println("foo, double, int");
	}

	public static void foo(int b, long a) //#5
	{
		System.out.println("foo, int, long");
	}

	public static void foo(short b, long a) //#6
	{
		System.out.println("foo, short, long");
	}

	public static void bar(int a, double b) //#7
	{
		System.out.println("bar, int, double");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte tam uyum vardır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		short b = 20;

		Sample.foo(a, (long)b);
	}
}

class Sample {
	public static void foo() //#1
	{
		System.out.println("foo");
	}

	public static void foo(int a) //#2
	{
		System.out.println("foo, int");
	}

	public static void foo(double a) //#3
	{
		System.out.println("foo, double");
	}

	public static void foo(double a, int b) //#4
	{
		System.out.println("foo, double, int");
	}

	public static void foo(int b, long a) //#5
	{
		System.out.println("foo, int, long");
	}

	public static void foo(short b, long a) //#6
	{
		System.out.println("foo, short, long");
	}

	public static void bar(int a, double b) //#7
	{
		System.out.println("bar, int, double");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	04.12.2022
-----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Nesne Yönelimli Programlama Tekniği (Object Oriented Programming): Nesne yönelimli programlama tekniğini (NYPT) tek bir
	cümle ile anlatmak pek mümkün değildir. Ancak bu tekniği bilen bir programcıya "sınıflar kullanarak program yazma tekniğidir"
	denebilir.  NYPT(OOP) aslında anahtar kavramların birleşiminden oluşur. Bu anahtar kavramlar birbirlerinden tamamen ayrık değildir.
	Bu kavramlar iç içe geçmiş daireler olarak düşünülebilir. Tüm anahtar kavramların temelinde kodun okunabilir/algılanabilir
	olması ve iyi yönetilmesi vardır. Örneğin benzer işi yapan metotlara aynı ismi vermek iyi bir tekniktir. Bu durumda
	bu metotları kullanan programcılar "çok şey var" duygusundan uzaklaşıp "az şey var" gibi bir algı oluştururlar. Bu da
	hatırlamayı kolaylaştırır.

	NYPT insanın doğayı algılama biçimini model almıştır. İnsanlar herşeyi nesne biçiminde ele alıp kullanırlar. Örneğin
	elimizdeki cep telefonları farklı olsa bile konuşurken bizim için hepsi cep telefonudur. Gerekirse onların başka
	özellikleri de ayrıca söylenebilir.

	NYPT'de artık ağırlıklı olarak fonksiyonlarla değil (Java'da metot), sınıflarla konuşulur. Böylece yine "çok şey var"
	algısından uzaklaştırılıp "az şey var" algısı oluşturulur. Bu anlamda kullanan programcı açısından detaylar, metotların
	detayları gizlemesinden daha da fazla gizlenebilir. Böylelikle kullanım kolaylaşır. Bunların detayları ileride daha iyi
	anlaşılacaktır.
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Değişkenlerin Ömürleri (storage duration): Bir değişkenin bellekte kapladığı zaman aralığına denir. Yani bir değişkenin
	ömrü o değişkenin bellekte yaratılmasıyla (yer ayrılmasıyla) yok edilmesi arasında geçen zaman aralığıdır. Ömür
	çalışma zamanına ilişkin bir kavramdır.
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Bir Java programı için çalışma zamanında "stack" ve "heap" denilen iki ayrı bellek alanı yaratılır. Her uygulama için
	bu alanlar ayrı ayrı yaratılırlar. Aşağı seviyede başka alanlar da vardır. Stack ve heap RAM'de organize edilir. Stack
	ve heap'in yeri yani hangi adresten başladığı ve uzunluğu sistemden sisteme değişebilir. Program çalıştırılırken bu
	alanların uzunlukları belirlenebilir. Belirlenmezse default değerler kullanılır. Default değerler sistemden sisteme
	değişebilmektedir.

	Stack'te yaratma ve yoketme işlemi birer makine komutuyla çok hızlı bir biçimde yapılır. Stack alanında değişken yaratılması
	ve yok edilmesi stack veri yapısı ile gerçekleştirilir.

	Anahtar Notlar: Aralarında mantıksal ya da fiziksel ilişki olan bir grup nesnenin tutulduğu yapıya "veri yapısı (data structure)"
	denir. Stack veri yapısı "LIFO (Last In First Out)" kuyruk sistemine göre çalışan veri yapısıdır. LIFO'da ekleme (push)
	sona yapılır. Eleman elde etme (veya silme) sondan yapılır (peek/pop). Yani her zaman son eleman elde ede edilir. Örneğin
	bir editörün "undo-redo" işlemleri iki ayrı stack kullanılarak gerçekleştirebilir. Bu durumda "undo" işlemi undo stack'inden
	"pop" yapıp, "redo" stack'ine "push "yapmaktır. Benzer şekilde "redo" işlemi de "redo" stack'inden "pop" yapıp, "undo" stack'ine
	"push" yapmaktır.
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Yerel değişkenler ve parametre değişkenleri stack alanında yaratılır. Yerel bir değişken, akış bakımında bildirim
	noktasına gelindiğinde yaratılır, bildirildiği bloğun sonuna gelindiğinde yok edilir. Zaten yerel değişkenlere
	faaliyet alanı bakımından bildirildikleri bloğun sonunda erişilememesinin nedeni budur. Parametre değişkenleri
	metot çağrıldığında yaratılır, metot çağrısı bittiğinde yok edilir.

	Anahtar Notlar: Her ne kadar faaliyet alanı(scope) ve ömür (storage duration) farklı zamanlara ilişkin kavramlar
	olsa da aralarında mantıksal bir bağ söz konusudur. Yani aralarında dolaylı da olsa bir ilişki vardır.
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		//...
		{
			int a; //Akış buraya geldiğinde a stack'te yaratılır
			double b = 5.6; //Akış buraya geldiğinde b stack'te yaratılır

			a = 3;

			//...

		} //a ve b yok edilir

		Sample.foo(10, 6.7); //Metodun parametre değişkenleri stack'te yaratılır ve argümanların değerleri ilgili parametrelere aktarılır
		//Metot çağrısı bittiğinde parametre değişkenleri yok edilir

		//...

		Sample.foo(1, 6.5); //Metodun parametre değişkenleri stack'te yaratılır ve argümanların değerleri ilgili parametrelere aktarılır
		//Metot çağrısı bittiğinde parametre değişkenleri yok edilir
	}
}

class Sample {
	public static void foo(int a, double b)
	{
		int val; //Akış buraya geldiğinde val stack'te yaratılır

		//...
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Point sınıfı ve test kodu
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Point p1 = new Point();
		Point p2 = new Point();

		p1.x = 100;
		p1.y = 98;
		p2.x = 97;
		p2.y = 102;
		int x = 97;
		int y = 102;

		System.out.printf("Distance:%f%n", p1.distance(p2));
		System.out.printf("Distance:%f%n", p1.distance(x, y));
		System.out.printf("Distance:%f%n", p1.distance());
		p1.offset(10);
        p2.offset(5,3);
        System.out.printf("Distance:%f%n", p1.distance(p2));
        System.out.printf("Distance:%f%n", p1.distance(x, y));
        System.out.printf("Distance:%f%n", p1.distance());
	}
}

class Point {
	public double x;
	public double y;

	//...

	public double distance()
	{
		return distance(0, 0);
	}

	public double distance(Point other)
	{
		return distance(other.x, other.y);
	}

	public double distance(double a, double b)
	{
		return Math.sqrt(Math.pow(x - a, 2) + Math.pow(y - b, 2));
	}

	public void offset(double dxy)
	{
		offset(dxy, dxy);
	}

	public void offset(double dx, double dy)
	{
		x += dx;
		y += dy;
	}

	public void print()
	{
		System.out.printf("(%f, %f)%n", x, y);
	}
}
//----------------------------------------------------------------------------------------------------------------------
package csd;

class App {
    public static void main(String [] args)
    {
        Point p1 = new Point();
        Point p2 = new Point();

        p1.x = 100;
        p1.y = 98;
        p1.z = 34;
        p2.x = 97;
        p2.y = 102;
        p2.z = 56;
        int x = 97;
        int y = 102;
        int z = 78;
        int dx = 9;
        int dy = 12;
        int dz = 4;

        System.out.printf("Distance:%f%n", p1.distance(p2));
        System.out.printf("Distance:%f%n", p1.distance(x, y, z));
        System.out.printf("Distance:%f%n", p1.distance());
        p1.offset(dx,dy,dz);
        System.out.printf("Distance:%f%n", p1.distance(p2));
        System.out.printf("Distance:%f%n", p1.distance(x, y, z));
        System.out.printf("Distance:%f%n", p1.distance());
        p2.offset(-12);
        System.out.printf("Distance:%f%n", p1.distance(p2));
        System.out.printf("Distance:%f%n", p1.distance(x, y, z));
        System.out.printf("Distance:%f%n", p1.distance());
        p2.offset(-dx,-dy,-dz);
    }
}

class Point {
    public double x;
    public double y;
    public double z;
    //...

    public double distance()
    {
        return distance(0, 0,0);
    }

    public double distance(Point other)
    {
        return distance(other.x, other.y,other.z);
    }

    public double distance(double a, double b,double c)
    {
        return Math.sqrt(Math.pow(x - a, 2) + Math.pow(y - b, 2)+ Math.pow(z - c, 2));
    }

    public void offset(double dxy)
    {
        offset(dxy, dxy,dxy);
    }

    public void offset(double dx, double dy,double dz)
    {
        x += dx;
        y += dy;
        z += dz;
    }

    public void print()
    {
        System.out.printf("(%f, %f, %f)%n", x, y, z);
    }
}
/*----------------------------------------------------------------------------------------------------------------------
	Point sınıfı ve test kodu
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
    public static void main(String [] args)
    {
        Point p1 = new Point();
        Point p2 = new Point();

        p1.x = 100;
        p1.y = 98;
        p1.z = 34;
        p2.x = 97;
        p2.y = 102;
        p2.z = 56;
        int x = 97;
        int y = 102;
        int z = 78;

        System.out.printf("Distance:%f%n", p1.distance(p2));
        System.out.printf("Distance:%f%n", p1.distance(x, y, z));
        System.out.printf("Distance:%f%n", p1.distance());
    }
}

class Point {
    public double x;
    public double y;
    public double z;
    //...

    public double distance()
    {
        return distance(0, 0,0);
    }

    public double distance(Point other)
    {
        return distance(other.x, other.y,other.z);
    }

    public double distance(double a, double b,double c)
    {
        return Math.sqrt(Math.pow(x - a, 2) + Math.pow(y - b, 2)+ Math.pow(z - c, 2));
    }

    public void offset(double dxy)
    {
        offset(dxy, dxy,dxy);
    }

    public void offset(double dx, double dy,double dz)
    {
        x += dx;
        y += dy;
        z += dz;
    }

    public void print()
    {
        System.out.printf("(%f, %f, %f)%n", x, y, z);
    }
}
//-----------------------------------------------------------------------------------------------------------------------
package csd;

class App {
    public static void main(String [] args)
    {
        Complex c1 = new Complex();
        Complex c2 = new Complex();
        c1.imaginary = 12;
        c1.reel = 11;
        c2.imaginary = 4;
        c2.reel = 4;
        System.out.printf("|%f|%n",c1.length(c1.reel,c1.imaginary));
        System.out.printf("|%f|%n",c2.length(c2.reel,c2.imaginary));
    }
}

class Complex{
    public int reel;
    public int imaginary;


    public double length(double reel,double imaginary)
    {
        return Math.sqrt(Math.pow(reel,2) + Math.pow(imaginary,2));
    }
}
/*----------------------------------------------------------------------------------------------------------------------
	Random sınıfının parametresiz nextInt metodu int türü sınırları içerisinde rasgele üretilmiş bir sayıya geri döner
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();

		for (int i = 0; i < 10; ++i)
			System.out.println(r.nextInt());
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Random sınıfının parametreli nextInt metodu [0, bound) aralığında rasgele üretilmiş int türden bir sayıya geri döner
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

 class App {
 	public static void main(String [] args)
 	{
 		java.util.Random r = new java.util.Random();

 		for (int i = 0; i < 10; ++i)
 			System.out.printf("%d ", r.nextInt(100));

 		System.out.println();
 	}
 }

/*----------------------------------------------------------------------------------------------------------------------
	24.12.2022
-----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Random sınıfına Java 17 ile birlikte iki tane int türden parametreli bir nextInt metodu da dolaylı olarak eklenmiştir
	Anahtar Notlar: Java 17 ile birlikte RandomGenerator isimli bir "arayüz (interface)" eklenmiştir. Random sınıfı da
	bu arayüzü desteklemektedir (implements). Bu arayüzle birlikte bir çok yeni metot da Random sınıfına ait olmuştur.
	Arayüz kavramı ve diğer anlatılanlar ileride detaylı olarak ele alınacaktır. Şu an için bu metotların Random sınıfına
	ait olduğunun bilinmesi yeterlidir.
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("İki sayı giriniz:");
		int min = kb.nextInt();
		int bound = kb.nextInt();
		int count = kb.nextInt();

		for (int i = 0; i < count; ++i)
			System.out.printf("%d ", r.nextInt(min, bound));//[min, bound)

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Java 17 öncesinde [min, bound) aralığında int türden rasgele sayı üretimi
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Üç sayı giriniz:");
		int min = kb.nextInt();
		int bound = kb.nextInt();
		int count = kb.nextInt();

		for (int i = 0; i < count; ++i)
			System.out.printf("%d ", r.nextInt(bound - min) + min);//[min, bound)

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Random sınıfının parametresiz nextLong metodu
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		for (int i = 0; i < count; ++i)
			System.out.printf("%d%n", r.nextLong());
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Random sınıfına Java 17 ile birlikte dolaylı olarak tek parametreli nextLong metodu eklenmiştir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("İki sayı giriniz:");
		int count = kb.nextInt();
		long bound = kb.nextLong();

		for (int i = 0; i < count; ++i)
			System.out.printf("%d%n", r.nextLong(bound));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Random sınıfına Java 17 ile birlikte dolaylı olarak iki parametreli nextLong metodu eklenmiştir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Üç sayı giriniz:");
		int count = kb.nextInt();
		long min = kb.nextLong();
		long bound = kb.nextLong();

		for (int i = 0; i < count; ++i)
			System.out.printf("%d%n", r.nextLong(min, bound));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Random sınıfının nextDouble metodu [0, 1) aralığında rasgele üretilmiş double türden bir sayıya geri döner
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		for (int i = 0; i < count; ++i)
			System.out.printf("%f%n", r.nextDouble());
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Random sınıfına Java 17 ile birlikte dolaylı olarak tek parametreli nextDouble metodu eklenmiştir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();
		double bound = kb.nextDouble();

		for (int i = 0; i < count; ++i)
			System.out.printf("%f%n", r.nextDouble(bound));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Random sınıfına Java 17 ile birlikte dolaylı olarak iki parametreli nextDouble metodu eklenmiştir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Üç sayı giriniz:");
		int count = kb.nextInt();
		double min = kb.nextDouble();
		double bound = kb.nextDouble();

		for (int i = 0; i < count; ++i)
			System.out.printf("%f%n", r.nextDouble(min, bound));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Java 17 öncesinde [min, bound) aralığında rasgele double türden sayı üretimi
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Üç sayı giriniz:");
		int count = kb.nextInt();
		double min = kb.nextDouble();
		double bound = kb.nextDouble();

		for (int i = 0; i < count; ++i)
			System.out.printf("%f%n", r.nextDouble() * (bound - min) + min);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Random sınıfının nextBoolean metodu
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		for (int i = 0; i < count; ++i)
			System.out.printf("%b%n", r.nextBoolean());
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Hilesiz bir paranın yazı gelme olasılığının yaklaşık olarak 0.5 olduğunu bulan basit bir simülasyon
	programını yazınız
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		CoinSimulationApp.run();
	}
}

class CoinSimulationApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		CoinSimulation cs = new CoinSimulation();

		for (;;) {
			System.out.print("Parayı kaç kez atmak istersiniz?");
			int n = Integer.parseInt(kb.nextLine());

			if (n <= 0)
				break;

			cs.run(n);
			System.out.printf("Yazı gelme olasılığı:%f%n", cs.p);
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class CoinSimulation {
	public double p;

	public static int getTailCount(int n)
	{
		java.util.Random r = new java.util.Random();
		int count = 0;

		for (int i = 0; i < n; ++i)
			count += r.nextInt(2);

		return count;
	}

	public void run(int n)
	{
		p = getTailCount(n) / (double)n;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Hilesiz bir paranın yazı gelme olasılığının yaklaşık olarak 0.5 olduğunu bulan basit bir simülasyon
	programını yazınız
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		CoinSimulationApp.run();
	}
}

class CoinSimulationApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		CoinSimulation cs = new CoinSimulation();

		for (;;) {
			System.out.print("Parayı kaç kez atmak istersiniz?");
			int n = Integer.parseInt(kb.nextLine());

			if (n <= 0)
				break;

			cs.run(n);
			System.out.printf("Yazı gelme olasılığı:%f%n", cs.p);
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class CoinSimulation {
	public double p;

	public static int getTailCount(int n)
	{
		java.util.Random r = new java.util.Random();
		int count = 0;

		for (int i = 0; i < n; ++i)
			if (r.nextBoolean())
				++count;

		return count;
	}

	public void run(int n)
	{
		p = getTailCount(n) / (double)n;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: İki zar atıldığında zarların çift gelmesi (ikisinin de aynı) olasılığını yaklaşık olarak hesaplayan
	simülasyon programını yazınız
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		DiceSimulationApp.run();
	}
}

class DiceSimulationApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		DiceSimulation ds = new DiceSimulation();

		for (;;) {
			System.out.print("Kaç kez zar atmak istersiniz?");
			int n = Integer.parseInt(kb.nextLine());

			if (n <= 0)
				break;

			ds.run(n);
			System.out.printf("Çift gelme olasılığı:%f%n", ds.p);
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class DiceSimulation {
	public double p;

	public static boolean areSame(java.util.Random r)
	{
		return r.nextInt(1, 7) == r.nextInt(1, 7); //Since Java 17
	}

	public static int getSameCount(int n)
	{
		java.util.Random r = new java.util.Random();
		int count = 0;

		for (int i = 0; i < n; ++i)
			if (areSame(r))
				++count;

		return count;
	}

	public void run(int n)
	{
		p = getSameCount(n) / (double)n;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: İki zar atıldığında zarların çift gelmesi (ikisinin de aynı) olasılığını yaklaşık olarak hesaplayan
	simülasyon programını yazınız
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		DiceSimulationApp.run();
	}
}

class DiceSimulationApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		DiceSimulation ds = new DiceSimulation();

		for (;;) {
			System.out.print("Kaç kez zar atmak istersiniz?");
			int n = Integer.parseInt(kb.nextLine());

			if (n <= 0)
				break;

			ds.run(n);
			System.out.printf("Çift gelme olasılığı:%f%n", ds.p);
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class DiceSimulation {
	public double p;

	public static boolean areSame(java.util.Random r)
	{
		return r.nextInt(6) + 1 == r.nextInt(6) + 1; //Before Java 17
	}

	public static int getSameCount(int n)
	{
		java.util.Random r = new java.util.Random();
		int count = 0;

		for (int i = 0; i < n; ++i)
			if (areSame(r))
				++count;

		return count;
	}

	public void run(int n)
	{
		p = getSameCount(n) / (double)n;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Tohum değeri setSeed metodu ile değiştirilebilir. Aşağıdaki örnekte her çalıştırmada aynı dizilim elde edilecektir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();

		r.setSeed(100);

		for (int i = 0; i < 10; ++i)
			System.out.printf("%d ", r.nextInt(100));

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte resgele üretilen ilk 10 sayının dizilimi her çalıştırmada farklı olur. İlk 10 sayının diziliminin
	aynı gelme olasılığı düşüktür. İkinci üretilen 10 sayı klavyeden alınan tohum değerine göre üretilir. Bu durumda
	örneğin her çalıştırmada tohum değeri 200 olarak girilirse ikinci üretilen 10 saynın dizilimi hep aynı olacaktır.
	Programı çalıştırıp sonuçları gözlemleyiniz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.println("Bir sayı giriniz:");
		long seed = kb.nextLong();

		for (int i = 0; i < 10; ++i)
			System.out.printf("%d ", r.nextInt(100));

		System.out.println();

		r.setSeed(seed);

		for (int i = 0; i < 10; ++i)
			System.out.printf("%d ", r.nextInt(100));

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	25.12.2022
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte rasgele nokta üretilmiştir. Program her çalıştırıldığında üretilecek noktaların dizilimi farklı
	olacaktır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		RandomPointGeneratorApp.run();
	}
}

class RandomPointGeneratorApp {
	public static void run()
	{
		java.util.Random r = new java.util.Random();
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for (;;) {
			System.out.print("Kaç tane nokta üretilsin:");
			int count = Integer.parseInt(kb.nextLine());

			if (count <= 0)
				break;

			System.out.print("Minimum değeri giriniz:");
			int min = Integer.parseInt(kb.nextLine());

			System.out.print("Maksimum değeri giriniz:");
			int max = Integer.parseInt(kb.nextLine());

			System.out.println("--------------------------------------------------------");
			for (int i = 0; i < count; ++i) {
				IntPoint p = RandomPointGenerator.randomIntPoint(r, min, max);

				p.print();
			}

			System.out.println("--------------------------------------------------------");
		}

		System.out.println("Tekrar yapıyor musunuz?");

	}
}

class RandomPointGenerator {
	//...

	public static IntPoint randomIntPoint(java.util.Random r, int min, int max)
	{
		IntPoint p = new IntPoint();

		p.x = r.nextInt(min, max + 1);
		p.y = r.nextInt(min, max + 1);

		return p;
	}
}

class IntPoint {
	public int x;
	public int y;

	//...

	public double distance()
	{
		return distance(0, 0);
	}

	public double distance(IntPoint other)
	{
		return distance(other.x, other.y);
	}

	public double distance(double a, double b)
	{
		return Math.sqrt(Math.pow(x - a, 2) + Math.pow(y - b, 2));
	}

	public void offset(int dxy)
	{
		offset(dxy, dxy);
	}

	public void offset(int dx, int dy)
	{
		x += dx;
		y += dy;
	}

	public void print()
	{
		System.out.printf("(%d, %d)%n", x, y);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte rasgele nokta üretilmiştir. Program her çalıştırıldığında tohum değerini de kullanıcıdan istemektedir.
	Bu durumda aynı tohum değeri girilen farklı çalıştırmalarda aynı girdiler için aynı noktalar üretilecektir. Programı
	çalıştırıp sonucuçları gözlemleyiniz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		RandomPointGeneratorApp.run();
	}
}

class RandomPointGeneratorApp {
	public static void run()
	{
		java.util.Random r = new java.util.Random();
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Tohum değerini giriniz:");
		long seed = Long.parseLong(kb.nextLine());

		r.setSeed(seed);

		for (;;) {
			System.out.print("Kaç tane nokta üretilsin:");
			int count = Integer.parseInt(kb.nextLine());

			if (count <= 0)
				break;

			System.out.print("Minimum değeri giriniz:");
			int min = Integer.parseInt(kb.nextLine());

			System.out.print("Maksimum değeri giriniz:");
			int max = Integer.parseInt(kb.nextLine());

			System.out.println("--------------------------------------------------------");
			for (int i = 0; i < count; ++i) {
				IntPoint p = RandomPointGenerator.randomIntPoint(r, min, max);

				p.print();
			}

			System.out.println("--------------------------------------------------------");
		}

		System.out.println("Tekrar yapıyor musunuz?");

	}
}

class RandomPointGenerator {
	//...

	public static IntPoint randomIntPoint(java.util.Random r, int min, int max)
	{
		IntPoint p = new IntPoint();

		p.x = r.nextInt(min, max + 1);
		p.y = r.nextInt(min, max + 1);

		return p;
	}
}

class IntPoint {
	public int x;
	public int y;

	//...

	public double distance()
	{
		return distance(0, 0);
	}

	public double distance(IntPoint other)
	{
		return distance(other.x, other.y);
	}

	public double distance(double a, double b)
	{
		return Math.sqrt(Math.pow(x - a, 2) + Math.pow(y - b, 2));
	}

	public void offset(int dxy)
	{
		offset(dxy, dxy);
	}

	public void offset(int dx, int dy)
	{
		x += dx;
		y += dy;
	}

	public void print()
	{
		System.out.printf("(%d, %d)%n", x, y);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Math sınıfının random metodu [0, 1) aralığında rasgele üretilmiş double türden bir değere geri döner. Bu metot
	içsel olarak her çağırmada aynı Random nesnesini kullanır.Bu met ilk kez çağrıldığında kullandığı Random
	nesnesi yaratılır ve her çağrıda bu nesne kullanılır. Aşağıdaki örneğin yaklaşık eşdeğeri şu şekildedir:

	java.util.Random r = new java.util.Random();

	for (int i = 0; i < 10; ++i)
		System.out.println(r.nextDouble());
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		for (int i = 0; i < 10; ++i)
			System.out.println(Math.random());
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    1-)local/yerel değişkenler
    2-)dinamik
	Nesne yaratılması aşamaları:
	1. Bellekte yer ayrılır.
	2. non-static olan ancak final olmayan veri elemanlarına default değerler atanır.
	3. Constructor (ctor) çağrılır.

	Bu 3 adımın sonunda new operatörünün ürettiği değer yani nesnenin adresi (referans) elde edilmiş olur. Yani
	mantıksal olarak bir nesnenin yaratılmış olması bu üç adımın tamamlanmış olması demektir. Ya da başka bir deyişle
	bu 3 adım tamamlanmadan nesne yaratılmış olmaz.
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	ctor aşağıdaki özelliklere sahip bir metottur:
	- Sınıfı yazan programcı sınıfa hiç bir ctor yazmazsa parametresiz ctor (default ctor) derleyici tarafından içi boş
	ve public olarak yazılır.

	- Sınıfı yazan programcı en az bir tane ctor yazarsa default ctor derleyici tarafından yazılmaz. Artık default
	ctor'un yazılıp yazılmayacağına sınıfı yazan programcı karar verecektir

	- ctor overload edilebilir (constructor overloading)

	- Sınıfın ctor'u sınıf ismi ile aynı olan ve geri dönüş değeri kavramı olmayan bir metottur. Geri dönüş değeri
	bilgisi yazılmaz. void da yazılmaz. Sınıf ismi ile aynı isimde bir metot yazılıp geri dönüş değeri bilgisi yazılırsa
	artık bu metot ctor olmaz. Şüphesiz bu şekilde bir metot yazılmamalıdır.

	- ctor non-static bir metottur.

	- ctor new operatörü ile nesne yaratılması sırasında çağrılır. Hangi ctor'un çağrılacağı derleme zamanında
	new operatörü ile kullanımda geçilen argümanlara göre "method overload resolution" kurallarıyla belirlenir.

	- Programcı ctor'u çağıramaz. Programcı new operatörü ile ilgli ctor'un ÇAĞRILACAĞI kodun derleyici tarafından
	üretilmesini sağlar.

	- ctor'dan önce non-static ve final olmayan veri elemanlarına default değerler atanmış olur

	- ctor içerisinde return tek başına ctor'u sonlandırmak için istenirse kullanılabilir.
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
    public static void main(String [] args)
    {
        Complex c1 = new Complex();
        Complex c2 = new Complex(10);
        Complex c3 = new Complex(10,5);
    }
}

class Complex{
    public Complex()
    {
        System.out.println("Complex default ctor.");
    }
    public Complex(int reel)
    {
        System.out.println("Complex int ctor");
    }
    public Complex(int reel,int imaginary)
    {
        System.out.println("Complex int,int ctor");
    }

}
/*----------------------------------------------------------------------------------------------------------------------
	Hangi ctor'un çağrılacağının tespit edilmesi
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample s1, s2, s3, s4;

		s1 = new Sample();
		System.out.println("---------------------------------------------------------");
		s2 = new Sample(10);
		System.out.println("---------------------------------------------------------");
		s3 = new Sample(10, 3.4);
		System.out.println("---------------------------------------------------------");
		s4 = new Sample(10, 10);
		System.out.println("---------------------------------------------------------");
	}
}

class Sample {
	public Sample()
	{
		System.out.println("I am a default ctor");
	}

	public Sample(int a)
	{
		System.out.println("I am a ctor with parameter type int");
	}

	public Sample(int a, double b)
	{
		System.out.println("I am a ctor with parameter type int and double");
	}
}
//----------------------------------------------------------------------------------------------------------------------
/*----------------------------------------------------------------------------------------------------------------------
	Hangi ctor'un çağrılacağının tespit edilmesi
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
    public static void main(String [] args)
    {
        MySample s1, s2, s3, s4;

        s1 = new MySample();
        System.out.println("---------------------------------------------------------");
        s2 = new MySample(10);
        System.out.println("---------------------------------------------------------");
        s3 = new MySample(10, 3.4);
        System.out.println("---------------------------------------------------------");
        s4 = new MySample(10, 10);
        System.out.println("---------------------------------------------------------");
    }
}

class MySample {
    public MySample()
    {
        System.out.println("I am a default ctor");
    }

    public MySample(int a)
    {
        System.out.println("I am a ctor with parameter type int");
    }

    public MySample(int a, double b)
    {
        System.out.println("I am a ctor with parameter type int and double");
    }
    public MySample(int a,int b)
    {
        System.out.println("I am a ctor with parameter type int and int");
    }
}
/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte Sample sınıfnı yazan programcı int parametreli bir ctor yazdığı için derleyici artık default ctor'u
	yazmaz. Default ctor'un olup olmaması artık yazan programcının karar vermesi gereken bir durumdur. Şüphesiz bu da
	sınıfa bağlıdır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample s;

		s = new Sample(); //error
	}
}

class Sample {
	public Sample(int a)
	{
		System.out.println("I am a ctor with parameter type int");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	ctor'dan önce non-static olan ve final olmayan veri elemanlarına default değerler atanmış olur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample s1, s2, s3, s4;

		s1 = new Sample();
		System.out.println("---------------------------------------------------------");
		s2 = new Sample(10);
		System.out.println("---------------------------------------------------------");
		s3 = new Sample(10, 3.4);
		System.out.println("---------------------------------------------------------");
		s4 = new Sample(10, 10);
		System.out.println("---------------------------------------------------------");
	}
}

class Sample {
	public int x;
	public boolean y;

	public Sample()
	{
		System.out.println("I am a default ctor");
		System.out.printf("x = %d, y = %b%n", x, y);
	}

	public Sample(int a)
	{
		System.out.println("I am a ctor with parameter type int");
		System.out.printf("x = %d, y = %b%n", x, y);
	}

	public Sample(int a, double b)
	{
		System.out.println("I am a ctor with parameter type int and double");
		System.out.printf("x = %d, y = %b%n", x, y);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	ctor içerisinde birçok işlem yapılabilir. ctor'un temel işlevi nesne yaratıldığı noktada bir takım ilk işlemlerin o
	nesne için yapılmasını sağlamaktır. Yani sınıfı yazan programcı sınıfın tasarımına göre bu ilk işlemleri ilgili
	ctor içerisinde yapar. Bu ilk işlemlerden en çok karşılaşılanı ctor içerisinde non-static veri elemanlarına değer
	verilmesidir. Bu durumda nesne yaratıldığı zaman non-static veri elemanları istenilen değerde olur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample s1, s2, s3;

		s1 = new Sample();
		s2 = new Sample(10);
		s3 = new Sample(11, true);


		System.out.printf("s1.x = %d, s1.y = %b%n", s1.x, s1.y);
		System.out.printf("s2.x = %d, s2.y = %b%n", s2.x, s2.y);
		System.out.printf("s3.x = %d, s3.y = %b%n", s3.x, s3.y);
	}
}

class Sample {
	public int x;
	public boolean y;

	public Sample()
	{

	}

	public Sample(int a)
	{
		x = a;
	}

	public Sample(int a, boolean b)
	{
		x = a;
		y = b;
	}

	//...

}

/*----------------------------------------------------------------------------------------------------------------------
	ctor içerisinde istenirse return tek başına sonlandırmak için kullanılabilir. Örnekte konuyu anlatmak için kod böyle
	yazılmıştır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample s1, s2;

		s1 = new Sample(6);
		s2 = new Sample(-6);
		System.out.printf("s1.x = %d%n", s1.x);
		System.out.printf("s2.x = %d%n", s2.x);
	}
}

class Sample {
	public int x;

	public Sample(int a)
	{
		if (a >= 0)
			return;

		x = a;
		//...
	}

	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Point sınıfı
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Point p1 = new Point(100, 98);
		Point p2 = new Point(97, 102);

		int x = 97;
		int y = 102;

		System.out.printf("Distance:%f%n", p1.distance(p2));
		System.out.printf("Distance:%f%n", p1.distance(x, y));
		System.out.printf("Distance:%f%n", p1.distance());
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Point sınıfı
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Point p = new Point();

		p.print();

	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Point sınıfı
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
    public static void main(String [] args)
    {
        Point p1 = new Point(34.0);
        Point p2 = new Point();
        Point p3 = new Point(12.5,24.7);

        p1.print();
        p2.print();
        p3.print();

    }
}

class Point {
    public double x;
    public double y;

    public Point()
    {
    }

    public Point(double a)
    {
        x = a;
    }

    public Point(double a, double b)
    {
        x = a;
        y = b;
    }

    public double distance()
    {
        return distance(0, 0);
    }

    public double distance(Point other)
    {
        return distance(other.x, other.y);
    }

    public double distance(double a, double b)
    {
        return Math.sqrt(Math.pow(x - a, 2) + Math.pow(y - b, 2));
    }

    public void offset(double dxy)
    {
        offset(dxy, dxy);
    }

    public void offset(double dx, double dy)
    {
        x += dx;
        y += dy;
    }

    public void print()
    {
        System.out.printf("(%f, %f)%n", x, y);
    }
}
/*----------------------------------------------------------------------------------------------------------------------
	Random sınıfının tohum değeri parametreli ctor'u
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		RandomPointGeneratorApp.run();
	}
}

class RandomPointGeneratorApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Tohum değerini giriniz:");
		long seed = Long.parseLong(kb.nextLine());

		java.util.Random r = new java.util.Random(seed);

		for (;;) {
			System.out.print("Kaç tane nokta üretilsin:");
			int count = Integer.parseInt(kb.nextLine());

			if (count <= 0)
				break;

			System.out.print("Minimum değeri giriniz:");
			int min = Integer.parseInt(kb.nextLine());

			System.out.print("Maksimum değeri giriniz:");
			int max = Integer.parseInt(kb.nextLine());

			System.out.println("--------------------------------------------------------");
			for (int i = 0; i < count; ++i) {
				IntPoint p = RandomPointGenerator.randomIntPoint(r, min, max);

				p.print();
			}

			System.out.println("--------------------------------------------------------");
		}

		System.out.println("Tekrar yapıyor musunuz?");

	}
}

class RandomPointGenerator {
	//...

	public static IntPoint randomIntPoint(java.util.Random r, int min, int max)
	{
		return new IntPoint(r.nextInt(min, max + 1), r.nextInt(min, max + 1));
	}
}

class IntPoint {
	public int x;
	public int y;

	public IntPoint()
	{
	}

	public IntPoint(int a)
	{
		x = a;
	}

	public IntPoint(int a, int b)
	{
		x = a;
		y = b;
	}

	public double distance()
	{
		return distance(0, 0);
	}

	public double distance(IntPoint other)
	{
		return distance(other.x, other.y);
	}

	public double distance(double a, double b)
	{
		return Math.sqrt(Math.pow(x - a, 2) + Math.pow(y - b, 2));
	}

	public void offset(int dxy)
	{
		offset(dxy, dxy);
	}

	public void offset(int dx, int dy)
	{
		x += dx;
		y += dy;
	}

	public void print()
	{
		System.out.printf("(%d, %d)%n", x, y);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Complex sınıf
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Complex z1 = new Complex(3, 4);
		Complex z2 = new Complex();
		Complex z3 = new Complex(3.4);

		z1.print();
		z2.print();
		z3.print();

	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Complex sınıfı
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Complex z1 = new Complex(3, 4);
		Complex z2 = new Complex(-9, 6);
		Complex z;

		z = z1.add(z2);
		z.print();
		System.out.println("---------------------------------------------");

		z = z1.add(4.5);
		z.print();
		System.out.println("---------------------------------------------");

		z = Complex.add(4.5, z);
		z.print();
		System.out.println("---------------------------------------------");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Complex sınıfı
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Complex z1 = new Complex(3, 4);
		Complex z2 = new Complex(-9, 6);
		Complex z;

		z = z1.subtract(z2);
		z.print();
		System.out.println("---------------------------------------------");

		z = z1.subtract(4.5);
		z.print();
		System.out.println("---------------------------------------------");

		z = Complex.subtract(4.5, z);
		z.print();
		System.out.println("---------------------------------------------");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Complex sınıfı
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Complex z1 = new Complex(3, 4);
		Complex z2 = new Complex(-9, 6);
		Complex z;

		z = z1.subtract(z2);
		z.print();
		System.out.println("---------------------------------------------");

		z = z1.subtract(4.5);
		z.print();
		System.out.println("---------------------------------------------");

		z = Complex.subtract(4.5, z);
		z.print();
		System.out.println("---------------------------------------------");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	07.01.2023
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Complex sınıfı
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Complex z1 = new Complex(3, 4);
		Complex z2 = new Complex(-9, 6);
		Complex z;

		z = z1.multiply(z2);
		z.print();
		System.out.println("---------------------------------------------");

		z = z1.multiply(4.5);
		z.print();
		System.out.println("---------------------------------------------");

		z = Complex.multiply(4.5, z);
		z.print();
		System.out.println("---------------------------------------------");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Complex sınıfı
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Complex z1 = new Complex(3, 4);
		Complex z2 = new Complex(-9, 6);
		Complex z;

		z = z1.divide(z2);
		z.print();
		System.out.println("---------------------------------------------");

		z = z1.divide(4.5);
		z.print();
		System.out.println("---------------------------------------------");

		z = Complex.divide(4.5, z);
		z.print();
		System.out.println("---------------------------------------------");
	}
}

class Complex {
	public double real;
	public double imag;

	public static Complex add(double re1, double im1, double re2, double im2)
	{
		return new Complex(re1 + re2, im1 + im2);
	}

	public static Complex subtract(double re1, double im1, double re2, double im2)
	{
		return add(re1, im1, -re2, -im2);
	}

	public static Complex multiply(double re1, double im1, double re2, double im2)
	{
		return new Complex(re1 * re2 - im1 * im2, re1 * im2 + re2 * im1);
	}

	public static Complex divide(double re1, double im1, double re2, double im2)
	{
		Complex z = multiply(re1, im1, re2, -im2);
		double divider = re1 * re1 + im1 * im2;

		z.real /= divider;
		z.imag /= divider;

		return z;
	}

	public Complex()
	{
	}

	public Complex(double re)
	{
		real = re;
	}

	public Complex(double re, double im)
	{
		real = re;
		imag = im;
	}

	public double getLength()
	{
		return Math.sqrt(real * real + imag * imag);
	}

	public double getNorm()
	{
		return getLength();
	}

	public static Complex add(double val, Complex z)
	{
		return add(val, 0, z.real, z.imag);
	}

	public Complex add(Complex other)
	{
		return add(real, imag, other.real, other.imag);
	}

	public Complex add(double val)
	{
		return add(real, imag, val, 0);
	}

	public static Complex subtract(double val, Complex z)
	{
		return subtract(val, 0, z.real, z.imag);
	}

	public Complex subtract(Complex other)
	{
		return subtract(real, imag, other.real, other.imag);
	}

	public Complex subtract(double val)
	{
		return subtract(real, imag, val, 0);
	}

	public static Complex multiply(double val, Complex z)
	{
		return multiply(val, 0, z.real, z.imag);
	}

	public Complex multiply(Complex other)
	{
		return multiply(real, imag, other.real, other.imag);
	}

	public Complex multiply(double val)
	{
		return multiply(real, imag, val, 0);
	}

	public static Complex divide(double val, Complex z)
	{
		return divide(val, 0, z.real, z.imag);
	}

	public Complex divide(Complex other)
	{
		return divide(real, imag, other.real, other.imag);
	}

	public Complex divide(double val)
	{
		return divide(real, imag, val, 0);
	}

	public Complex getConjugate()
	{
		return new Complex(real, -imag);
	}

	public void print()
	{
		System.out.printf("|%.2f + %.2fi| = %f%n", real, imag, getLength());
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	String sınıfı:
	Programlamada yazılarla işlem her uygulamada yapılır. Java'da yazılarla işlem yapmakta kullanılan en temel sınıf
	String sınıfıdır. Yazılarla işlem yapan başka sınıflar da vardır. Bunların hemen hemen hepsi aslında String sınıfına
	yardımcı sınıflardır. String sınıfı java.lang paketi içerisinde bulunduğu için ismine doğrudan erişilebilir. String
	"primitive" bir tür değildir. JavaSE'de bulunan bir sınıftır.
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Derleyici bir String literal gördüğünde ve bu String literal'ın özdeşini daha önce görmemişse şöyle bir kod üretir:
	"Çalışma zamanında String türden bir nesne yarat, karakterlerini bu nesneye aktar ve o nesnenin referansını (adresini)
	ver"

	print ve println metotlarının String parametreli overload'ları argüman olarak aldıkları String referansına ilişkin yazıyı
	ekrana basarlar.
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		String s;

		s = "Arda Ezgin";

		System.out.println(s);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	printf metodunda s format karakteri ile String referansına ilişkin yazı formatlanıp ekrana basılabilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		String s;

		s = "Arda Ezgin";

		System.out.printf("Yazı:%s%n", s);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Scanner sınıfının nextLine metodu ile klavyeden enter girilen kadar alınan karakterlere ilişkin bir String referansı
	elde edilebilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		String s;

		System.out.print("Bir yazı giriniz:");
		s = kb.nextLine();

		System.out.printf("Yazı:%s%n", s);
	}
}
//----------------------------------------------------------------------------------------------------------------------
package csd;

class App {
    public static void main(String [] args)
    {
        java.util.Scanner kb = new java.util.Scanner(System.in);
        String s;
        System.out.println("Bir yazı giriniz?");
        s = kb.nextLine();
        for(int i = 0;i < s.length(); ++i){
            System.out.println(s.charAt(i));
        }

    }
}
/*----------------------------------------------------------------------------------------------------------------------
	Immutable class: Bir nesnenin non-static veri elemanlarının değerleri, sınıfı kullanan programcılar tarafından
	değiştirilemiyorsa bu tarz sınıflara "immutable class" denir. Immutable sınıfların nasıl yazılabileceği ileride ele
	alınacaktır. immutable sınıfların avantajlı ve dezvantajlı olduğu durumlar vardır. Bunlar zamanla anlaşılacaktır.

	String sınıfı immutable bir sınıftır.
-----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: String nesnesine ilişkin yazı ayrı bölgede tutulur. Bu anlamda bölgeye "içsel bölge" diyebiliriz.
	Zaten Java'da aynı türden nesnelerin uzunlukları aynı olduğundan, yazılar doğrudan nesnenin içerisinde bulunamazlar
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Bir yazının uzunluğu (kaç karakterden oluştuğu bilgisi) length metodu ile elde edilebilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		String s;

		System.out.print("Bir yazı giriniz:");
		s = kb.nextLine();

		System.out.printf("Yazının uzunluğu:%d%n", s.length());
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir yazının herhangi konumdaki karakteri charAt metodu ile elde edilebilir. Bu metot karakterin konum bilgisi olan
	indeks değerini alır. Indeks değeri sıfırdan başlar
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		String s;

		System.out.print("Bir yazı giriniz:");
		s = kb.nextLine();

		int len = s.length();

		for (int i = 0; i < len; ++i)
			System.out.println(s.charAt(i));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	charAt metoduna pozitif ya da negatif bakımdan sınırlar dışında indeks değeri verildiğinde exception oluşur
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		String s;

		System.out.print("Bir yazı giriniz:");
		s = kb.nextLine();

		System.out.println(s.charAt(4));
	}
}

/*----------------------------------------------------------------------------
Aşağıdaki örnekte string nesneleri değil. adresler karşılaştırılmaktadır.
----------------------------------------------------------------------------*/
package csd;
class App {
    public static void main(String[] args)
    {
        java.util.Scanner kb = new java.util.Scanner(System.in);
        System.out.println("Birinci yazıyı giriniz");
        String text1 = kb.nextLine();
        System.out.println("İkinci yazıyı giriniz");
        String text2 = kb.nextLine();
        if(text1 == text2)
            System.out.println("Yazılar aynı");
        else
            System.out.println("Yazılar farklı");
        kb.close();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	İki aynı türden referans == ve != operatörleri ile karşılaştırılabilir. Bu karşılaştırma adres karşılaştırmasıdır.
	Bu durumda == operatörü iki referans aynı nesneyi gösteriyorsa true, göstermiyorsa false değerini üretir. Benzer
	şekilde != operatörü iki referans aynı nesneyi göstermiyorsa true, gösteriyorsa false değerini üretir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Complex z1 = new Complex(3, 4);
		Complex z2 = z1; //new Complex(3, 4);

		System.out.println(z1 == z2 ? "Aynı nesne" : "Farklı nesneler");
		System.out.println(z1 != z2 ? "Farklı nesneler" : "Aynı nesne");
	}
}


class Complex {
	public double real;
	public double imag;

	public static Complex add(double re1, double im1, double re2, double im2)
	{
		return new Complex(re1 + re2, im1 + im2);
	}

	public static Complex subtract(double re1, double im1, double re2, double im2)
	{
		return add(re1, im1, -re2, -im2);
	}

	public static Complex multiply(double re1, double im1, double re2, double im2)
	{
		return new Complex(re1 * re2 - im1 * im2, re1 * im2 + re2 * im1);
	}

	public static Complex divide(double re1, double im1, double re2, double im2)
	{
		Complex z = multiply(re1, im1, re2, -im2);
		double divider = re1 * re1 + im1 * im2;

		z.real /= divider;
		z.imag /= divider;

		return z;
	}

	public Complex()
	{
	}

	public Complex(double re)
	{
		real = re;
	}

	public Complex(double re, double im)
	{
		real = re;
		imag = im;
	}

	public double getLength()
	{
		return Math.sqrt(real * real + imag * imag);
	}

	public double getNorm()
	{
		return getLength();
	}

	public Complex getConjugate()
	{
		return new Complex(real, -imag);
	}

	public static Complex add(double val, Complex z)
	{
		return add(val, 0, z.real, z.imag);
	}

	public Complex add(Complex other)
	{
		return add(real, imag, other.real, other.imag);
	}

	public Complex add(double val)
	{
		return add(real, imag, val, 0);
	}

	public static Complex subtract(double val, Complex z)
	{
		return subtract(val, 0, z.real, z.imag);
	}

	public Complex subtract(Complex other)
	{
		return subtract(real, imag, other.real, other.imag);
	}

	public Complex subtract(double val)
	{
		return subtract(real, imag, val, 0);
	}

	public static Complex multiply(double val, Complex z)
	{
		return multiply(val, 0, z.real, z.imag);
	}

	public Complex multiply(Complex other)
	{
		return multiply(real, imag, other.real, other.imag);
	}

	public Complex multiply(double val)
	{
		return multiply(real, imag, val, 0);
	}

	public static Complex divide(double val, Complex z)
	{
		return divide(val, 0, z.real, z.imag);
	}

	public Complex divide(Complex other)
	{
		return divide(real, imag, other.real, other.imag);
	}

	public Complex divide(double val)
	{
		return divide(real, imag, val, 0);
	}

	public void print()
	{
		System.out.printf("|%.2f + %.2fi| = %f%n", real, imag, getLength());
	}
}
/*----------------------------------------------------------------------------
Standart kütüphanenin compareTo metodu ve test kodu
----------------------------------------------------------------------------*/
package csd;
class App {
    public static void main(String[] args)
    {
        java.util.Scanner kb = new java.util.Scanner(System.in);
        System.out.println("Birinci yazıyı giriniz");
        String text1 = kb.nextLine();
        System.out.println("İkinci yazıyı giriniz");
        String text2 = kb.nextLine();
        int cmp = text1.compareTo(text2);
        if(cmp > 0)
            System.out.printf("%s stringi %s stringinden büyüktür",text1,text2);
        else if(cmp == 0)
            System.out.printf("%s stringi %s stringine eşittir",text1,text2);
        else
            System.out.printf("%s stringi %s stringinden büyüktür",text2,text1);
        kb.close();
    }
}
/*----------------------------------------------
Tam Polindromları bulan program ve test kodu
-----------------------------------------------*/
package csd;
class App {
    public static void main(String[] args)
    {
        isPalindromeTest.run(new java.util.Scanner(System.in));
    }
}


class isPalindromeTest{
    public static void run(java.util.Scanner kb)
    {
        System.out.println("Bir yazı giriniz");
        String text = kb.nextLine();
        if(StringUtil.isPalindrome(text))
            System.out.println("yazı Palindrom");
        else
            System.out.println("yazı Palindrom değil");
    }
}

class StringUtil{
    public static String reverseString(String text)
    {
        String rev = "";
        for(int i = text.length() - 1;0 <= i ;--i){
            rev += text.charAt(i);
        }
        return rev;
    }
    public static boolean isPalindrome(String text)
    {
        return reverseString(text).equals(text);
    }

}
/*----------------------------------------------
Hızlı versiyon
-----------------------------------------------*/
package csd;
class App {
    public static void main(String[] args)
    {
        isPalindromeTest.run(new java.util.Scanner(System.in));
    }
}


class isPalindromeTest{
    public static void run(java.util.Scanner kb)
    {
        System.out.println("Bir yazı giriniz");
        String text = kb.nextLine();
        if(StringUtil.isPalindrome(text))
            System.out.println("yazı Palindrom");
        else
            System.out.println("yazı Palindrom değil");
    }
}

class StringUtil{

    public static boolean isPalindrome(String text)
    {
        int len = text.length();
        for(int i = 0;i < len / 2;++i)
            if(text.charAt(i) != text.charAt(len - 1 - i))
                return false;
        return true;
    }

}
/*--------------------------------------------------------------------------------
Tüm Polindromlar için true değer döndürür.
------------------------------------------------------------------------------*/
package csd;

class App {
    public static void main(String[] args)
    {
        isPalindromeTest.run(new java.util.Scanner(System.in));
    }
}


class isPalindromeTest{
    public static void run(java.util.Scanner kb)
    {
        System.out.println("Bir yazı giriniz");
        String text = kb.nextLine();
        if(StringUtil.isPalindrome(text))
            System.out.println("yazı Palindrom");
        else
            System.out.println("yazı Palindrom değil");
    }
}

class StringUtil{

    public static boolean isPalindrome(String text)
    {
        String result = clearWS(text);
        int len = result.length();
        for(int i = 0;i < len / 2;++i)
            if(result.charAt(i) != result.charAt(len - 1 - i))
                return false;
        return true;
    }
    public static String clearWS(String text)
    {
        String result = "";
        for(int i = 0;i < text.length();++i){
            if (!Character.isWhitespace(text.charAt(i)))
                result += text.charAt(i);
        }
        return result;
    }

}
/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı bir yazının Türkçe pangram olup olmadığını test eden isPangramTR ve
	İngilizce pangram olup olmadığını test eden isPangramEN metotlarını StringUtil sınıfı içerisinde yazınız ve aşağıdaki
	kod ile test ediniz
	Pangram: İçerisinde özel isim olmayan ve ilgili dilin alfabesindeki tüm karakterleri içeren anlamlı cümlelere denir.

	Programda özel isim ve anlam dikkate alınmayacaktır

	İnglizce: The quick brown fox jumps over the lazy dog
	Türkçe: Pijamalı hasta yağız şoföre çabucak güvendi
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		IsPangramTest.run();
	}
}

class IsPangramTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		IsPangramTestTR.run(kb);
		IsPangramTestEN.run(kb);
	}
}


class IsPangramTestTR {
	public static void run(java.util.Scanner kb)
	{
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();

			if ("elma".equals(s))
				break;

			System.out.println(StringUtil.isPangramTR(s) ? "Pangram" : "Pangram değil");
		}
	}
}

class IsPangramTestEN {
	public static void run(java.util.Scanner kb)
	{
		for (;;) {
			System.out.print("Input a text:");
			String s = kb.nextLine();

			if ("quit".equals(s))
				break;

			System.out.println(StringUtil.isPangramEN(s) ? "Pangram" : "Not a Pangram");
		}
	}
}

class StringUtil {
	public static boolean isPangramTR(String s)
	{
		return isPangram(s.toLowerCase(), "abcçdefgğhıijklmnoöprsştuüvyz");
	}

	public static boolean isPangramEN(String s)
	{
		return isPangram(s.toLowerCase(), "abcdefghijklmnopqrstuwxvyz");
	}

	public static boolean isPangram(String s, String alphabet)
	{
		int len = alphabet.length();

		for (int i = 0; i < len; ++i)
			if (s.indexOf(alphabet.charAt(i)) == -1)
				return false;

		return true;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örnek için İnglizce alfabedeki karakterler karakter tablosunda sıralı olduğunhdan isPangramEN metodu
	aşağıdaki gibi yazılabilir. Şüphesiz yukarıdaki yaklaşım daha geneldir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		IsPangramTestEN.run();
	}
}

class IsPangramTestEN {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for (;;) {
			System.out.print("Input a text:");
			String s = kb.nextLine();

			if ("quit".equals(s))
				break;

			System.out.println(StringUtil.isPangramEN(s) ? "Pangram" : "Not a Pangram");
		}
	}
}

class StringUtil {
	public static boolean isPangramEN(String s)
	{
		s = s.toLowerCase();

		for (char c = 'a'; c <= 'z'; ++c)
			if (!s.contains(c + ""))
				return false;

		return true;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		IsPangramTestEN.run();
	}
}

class IsPangramTestEN {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for (;;) {
			System.out.print("Input a text:");
			String s = kb.nextLine();

			if ("quit".equals(s))
				break;

			System.out.println(StringUtil.isPangramEN(s) ? "Pangram" : "Not a Pangram");
		}
	}
}

class StringUtil {
	public static boolean isPangramEN(String s)
	{
		s = s.toLowerCase();

		for (int i = 0; i < 26; ++i) {
			char c = (char)('a' + i);

			if (!s.contains(c + ""))
				return false;
		}

		return true;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir n değeri için n tane rasgele üretilmiş Türkçe alfabedeki
	karakterlerden oluşan bir yazı döndüren getRandomTextTR ile n tane rasgele üretilmiş İnglizce alfabedeki
	karakterlerden oluşan bir yazı döndüren getRandomTextEN metotlarını StringUtil sınıf içerisinde yazını ve aşağıdaki
	kod ile test ediniz
	(Not: İleride daha iyisi yazılacaktır)
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		GetRandomTextsTest.run();
	}
}

class GetRandomTextsTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		java.util.Random r = new java.util.Random();

		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int n = Integer.parseInt(kb.nextLine());

			if (n < 1)
				break;

			System.out.printf("Şifre:%s%n", StringUtil.getRandomTextTR(r, n));
			System.out.printf("Password:%s%n", StringUtil.getRandomTextEN(r, n));
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class StringUtil {
	public static String getRandomTextTR(int n)
	{
		return getRandomTextTR(new java.util.Random(), n);
	}

	public static String getRandomTextTR(java.util.Random r, int n)
	{
		return getRandomText(r, n, "abcçdefgğhıijklmnoöprsştuüvyzABCÇDEFGĞHIİJKLMNOÖPRSŞTUÜVYZ");
	}

	public static String getRandomTextEN(int n)
	{
		return getRandomTextEN(new java.util.Random(), n);
	}

	public static String getRandomTextEN(java.util.Random r, int n)
	{
		return getRandomText(r, n, "abcdefghijklmnopqrstuwxvyzABCDEFGHIJKLMNOPQRSTUWVXYZ");
	}

	public static String getRandomText(java.util.Random r, int n, String sourceText)
	{
		String str = "";

		int len = sourceText.length();

		for (int i = 0; i < n; ++i)
			str += sourceText.charAt(r.nextInt(len));

		return str;
	}
}
//---------------------------------------------------------------------------------------------------------------------
package csd;

class App {
    public static void main(String [] args)
    {
        java.util.Scanner kb = new java.util.Scanner(System.in);
        System.out.println("Bir yazı giriniz");
        String s = kb.nextLine();
        System.out.println(StringUtil.Reverse(s));

    }
}
class StringUtil{
    public static String Reverse(String s)
    {
        String rev = "";
        int len = s.length();
        for(int i = 0;i < len;++i){
            rev += s.charAt(len - i - 1);
        }
        return rev.toLowerCase();
    }
}
/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı bir yazının içerisindeki en kısa İngilizce pangram'ı bulan getShortestPangram
	metodunu yazınız ve test ediniz.
	Açıklamalar:
		- Yazının içerisinde alfabetik karakter dışında başka bir karakter kullanılmıyor varsayınız
		- Yazının içerisinde yalnızca İnglizce alfabedeki karakterlerin olduğunu varsayınız

	Örnek yazılar:
	xyzabcthequickbrownfoxjumpsoverthelazydogabcdefghijklmnopqrstuwxvyzthequickbrownfoxjumpsovrthlazydogabcdefghijklmnopqrstuwxvyz
	xyzabcthequickbrownfoxjumpsoverthelazydogabcdefghijklnopqrstuwxvyzthequickbrownfoxjumpsovrthlazydogabcdefghijklnopqrstuwxvyz
	(Not: İleride daha iyisi yazılacaktır)
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		GetShortestPangramTest.run();
	}
}

class GetShortestPangramTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for (;;) {
			System.out.print("Input a text:");
			String s = kb.nextLine();

			if ("quit".equals(s))
				break;

			System.out.printf("Shortest Pangram:%s%n", Solution.getShortestPangram(s));
		}
	}
}


class Solution {
	public static String getShortestPangram(String s)
	{
		String result = s;

		int end = s.length();

		while (end != 0) {
			int begin = 0;

			while (begin != end) {
				String str = s.substring(begin++, end);

				if (str.length() >= 26 && isPangramEN(str) && str.length() < result.length())
					result = str;
			}

			--end;
		}

		return result;
	}

	public static boolean isPangramEN(String s)
	{
		s = s.toLowerCase();

		for (int i = 0; i < 26; ++i) {
			char c = (char)('a' + i);

			if (!s.contains(c + ""))
				return false;
		}

		return true;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz.
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		GetShortestPangramTest.run();
	}
}

class GetShortestPangramTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		GetShortestPangramTRTest.run(kb);
		GetShortestPangramENTest.run(kb);
	}

}

class GetShortestPangramTRTest {
	public static void run(java.util.Scanner kb)
	{
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();

			if ("elma".equals(s))
				break;

			System.out.printf("En kısa pangram:%s%n", StringUtil.getShortestPangramTR(s));
		}
	}
}


class GetShortestPangramENTest {
	public static void run(java.util.Scanner kb)
	{
		for (;;) {
			System.out.print("Input a text:");
			String s = kb.nextLine();

			if ("quit".equals(s))
				break;

			System.out.printf("Shortest pangram:%s%n", StringUtil.getShortestPangramEN(s));
		}
	}
}


class StringUtil {
	public static String getShortestPangramTR(String s)
	{
		String result = s;

		int end = s.length();

		while (end != 0) {
			int begin = 0;

			while (begin != end) {
				String str = s.substring(begin++, end);

				if (str.length() >= 29 && isPangramTR(str) && str.length() < result.length())
					result = str;
			}

			--end;
		}

		return result;
	}

	public static String getShortestPangramEN(String s)
	{
		String result = s;

		int end = s.length();

		while (end != 0) {
			int begin = 0;

			while (begin != end) {
				String str = s.substring(begin++, end);

				if (str.length() >= 26 && isPangramEN(str) && str.length() < result.length())
					result = str;
			}

			--end;
		}

		return result;
	}

	public static boolean isPangramTR(String s)
	{
		return isPangram(s.toLowerCase(), "abcçdefgğhıijklmnoöprsştuüvyz");
	}

	public static boolean isPangramEN(String s)
	{
		return isPangram(s.toLowerCase(), "abcdefghijklmnopqrstuwxvyz");
	}

	public static boolean isPangram(String s, String alphabet)
	{
		int len = alphabet.length();

		for (int i = 0; i < len; ++i)
			if (s.indexOf(alphabet.charAt(i)) == -1)
				return false;

		return true;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı bir yazının palindrom olup olmadığını test eden isPalindrome isimli metodu
	yazınız ve aşağıdaki kod ile test ediniz.

	Palindrom: Yalnızca alfabetik karakterleri tersten okunduğunda aynı olan yazılara denir. Detaylar gözardı edilerek
	bu tanım yapılabilir

	Örnekler:
	Ey Edip Adana'da pide ye	-> eyedipadanadapideye
	Anastas mum satsana 		-> anastasmumsatsana
	Ali Papila 					-> alipapila

	Not: İleride daha iyisi yazılacaktır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		IsPalindromeTest.run();
	}
}

class IsPalindromeTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();

			if ("elma".equals(s))
				break;

			System.out.println(StringUtil.isPalindrome(s) ? "Palindrom" : "Palindrom değil");
		}
	}
}

class StringUtil {
	public static boolean isPalindrome(String s)
	{
		int left = 0;
		int right = s.length() - 1;

		while (left < right) {
			char cLeft = Character.toLowerCase(s.charAt(left));

			if (!Character.isLetter(cLeft)) {
				++left;
				continue;
			}

			char cRight = Character.toLowerCase(s.charAt(right));

			if (!Character.isLetter(cRight)) {
				--right;
				continue;
			}


			if (cLeft != cRight)
				return false;

			++left;
			--right;
		}

		return true;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı bir yazının palindrom olup olmadığını test eden isPalindrome isimli metodu
	yazınız ve aşağıdaki kod ile test ediniz.

	Palindrom: Yalnızca alfabetik karakterleri tersten okunduğunda aynı olan yazılara denir. Detaylar gözardı edilerek
	bu tanım yapılabilir

	Örnekler:
	Ey Edip Adana'da pide ye	-> eyedipadanadapideye
	Anastas mum satsana 		-> anastasmumsatsana
	Ali Papila 					-> alipapila

	Not: İleride daha iyisi yazılacaktır
	Not: Örnek yukarıdaki yazıma göre biraz daha etkinleştirilmiştir. Ancak kullanılan standart metotlar dolayısıyla
	derleyicinin de yapabileceği optimizasyonlar düşünülerek çok fazla fark oluşmaz
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		IsPalindromeTest.run();
	}
}

class IsPalindromeTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();

			if ("elma".equals(s))
				break;

			System.out.println(StringUtil.isPalindrome(s) ? "Palindrom" : "Palindrom değil");
		}
	}
}

class StringUtil {
	public static boolean isPalindrome(String s)
	{
		int left = 0;
		int right = s.length() - 1;
		boolean cLeftSelected = false, cRightSelected = false;
		char cLeft = '\0', cRight;

		while (left < right) {
			if (!cLeftSelected) {
				cLeft = Character.toLowerCase(s.charAt(left));

				if (!Character.isLetter(cLeft)) {
					++left;
					continue;
				}
				cLeftSelected = true;
			}

			if (!cRightSelected) {
				cRight = Character.toLowerCase(s.charAt(right));

				if (!Character.isLetter(cRight)) {
					--right;
					continue;
				}

				if (cLeft != cRight)
					return false;

				cRightSelected = true;
			}

			++left;
			--right;

			cLeftSelected = cRightSelected = false;
		}

		return true;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Java'da her temel türe karşılık gelen bir sınıf vardır. Bu sınıflara "sarmalayan nsınıflar (wrapper classes)"
	denir. Sarmalayan sınıfların gerekliliği ve detayları ileride ele alınacaktır. Buna göre temel türlere ilişkin
	sarmalayan sınıflar şunlardır:

	Tür					Sarmalayan Sınıf
	short					Short
	int						Integer
	long					Long
	byte					Byte
	float					Float
	double					Double
	boolean					Boolean
	char					Character
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Character sınıf dışında tüm msarmalayan sınıfların parseXXX static metotları ile yazılar ilgili türden değerler
	çevrilebilir. Bu metotlar Boolean sınıfının parseBoolean metodu hariç çeviremedikleri durumda exception fırlatırlar
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		String str = kb.nextLine();
		int val = Integer.parseInt(str);

		System.out.printf("%d * %d = %d%n", val, val, val * val);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Integer sınıfının sayı sistemi (radix) parametreli parseInt metodu
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		String str = kb.nextLine();
		int val = Integer.parseInt(str, 16);

		System.out.printf("%d * %d = %d%n", val, val, val * val);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	String sınıfının format metodu ile formatlanmış bir yazı elde edilebilir. Bu metodun kulanımı printf ile aynıdır.
	Yalnızca printf gibi ekrana basmak yerine formatlanmış yazıya ilişkin String referansına geri döner
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int a = Integer.parseInt(kb.nextLine());

		System.out.print("Bir gerçek sayı giriniz:");
		double b = Double.parseDouble(kb.nextLine());

		String message = String.format("a = %d, b = %.2f%n", a, b);

		System.out.println(message);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Complex sınıfının toString metodu
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Complex z1 = new Complex(3, 4);
		Complex z2 = new Complex(3);
		Complex z3 = new Complex();

		System.out.println(z1.toString());
		System.out.println(z2.toString());
		System.out.println(z3.toString());
	}
}

class Complex {
	public double real;
	public double imag;

	public static Complex add(double re1, double im1, double re2, double im2)
	{
		return new Complex(re1 + re2, im1 + im2);
	}

	public static Complex subtract(double re1, double im1, double re2, double im2)
	{
		return add(re1, im1, -re2, -im2);
	}

	public static Complex multiply(double re1, double im1, double re2, double im2)
	{
		return new Complex(re1 * re2 - im1 * im2, re1 * im2 + re2 * im1);
	}

	public static Complex divide(double re1, double im1, double re2, double im2)
	{
		Complex z = multiply(re1, im1, re2, -im2);
		double divider = re1 * re1 + im1 * im2;

		z.real /= divider;
		z.imag /= divider;

		return z;
	}

	public Complex()
	{
	}

	public Complex(double re)
	{
		real = re;
	}

	public Complex(double re, double im)
	{
		real = re;
		imag = im;
	}

	public double getLength()
	{
		return Math.sqrt(real * real + imag * imag);
	}

	public double getNorm()
	{
		return getLength();
	}

	public Complex getConjugate()
	{
		return new Complex(real, -imag);
	}

	public static Complex add(double val, Complex z)
	{
		return add(val, 0, z.real, z.imag);
	}

	public Complex add(Complex other)
	{
		return add(real, imag, other.real, other.imag);
	}

	public Complex add(double val)
	{
		return add(real, imag, val, 0);
	}

	public static Complex subtract(double val, Complex z)
	{
		return subtract(val, 0, z.real, z.imag);
	}

	public Complex subtract(Complex other)
	{
		return subtract(real, imag, other.real, other.imag);
	}

	public Complex subtract(double val)
	{
		return subtract(real, imag, val, 0);
	}

	public static Complex multiply(double val, Complex z)
	{
		return multiply(val, 0, z.real, z.imag);
	}

	public Complex multiply(Complex other)
	{
		return multiply(real, imag, other.real, other.imag);
	}

	public Complex multiply(double val)
	{
		return multiply(real, imag, val, 0);
	}

	public static Complex divide(double val, Complex z)
	{
		return divide(val, 0, z.real, z.imag);
	}

	public Complex divide(Complex other)
	{
		return divide(real, imag, other.real, other.imag);
	}

	public Complex divide(double val)
	{
		return divide(real, imag, val, 0);
	}

	public String toString()
	{
		return String.format("(%f, %f)", real, imag);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Point sınıfının toString metodu
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Point p = new Point(34.0);

		System.out.println(p.toString());

	}
}

class Point {
	public double x;
	public double y;

	public Point()
	{
	}

	public Point(double a)
	{
		x = a;
	}

	public Point(double a, double b)
	{
		x = a;
		y = b;
	}

	public double distance()
	{
		return distance(0, 0);
	}

	public double distance(Point other)
	{
		return distance(other.x, other.y);
	}

	public double distance(double a, double b)
	{
		return Math.sqrt(Math.pow(x - a, 2) + Math.pow(y - b, 2));
	}

	public void offset(double dxy)
	{
		offset(dxy, dxy);
	}

	public void offset(double dx, double dy)
	{
		x += dx;
		y += dy;
	}

	public String toString()
	{
		return String.format("(%f, %f)", x, y);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	String sınıfının valueOf metotları ile temel türlere ilişkin değerlerin yazı kaşılıkları elde edilebilir. Bu durumda
	bir temel türden değerin yazı karşılığı aşağıdaki yöntemlerle elde edilebilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		String s1 = a + "";
		String s2 = String.valueOf(a);
		String s3 = String.format("%d", a);

		System.out.println(s1);
		System.out.println(s2);
		System.out.println(s3);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	String sınıfının replace metodu
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		String str = "Bugün hava çok güzel. Bu güzel havada Java dersi olur mu? Evet";

		str = str.replace("güzel", "kötü");

		System.out.println(str);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	String sınıfının replace metodu
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		String str = "Java";

		str = str.replace('a', 'b');

		System.out.println(str);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Aşağıda açıklanan metotları StringUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz.

	public static String padLeading(String s, int len, char ch);
	public static String padLeading(String s, int len);
	public static String padTrailing(String s, int len, char ch);
	public static String padTrailing(String s, int len);

	Açıklamalar:
	- padLeading metodunun 3 parametreli overload'u ikinci parametresi ile aldığı len, birinci paramtresi ile aldığı
	yazının uzunluğundan büyükse yazıyı soldan (baştan) üçüncü parametresi ile aldığı karakter ile dolduracaktır.
	Örneğin:
		padLeading("csd", 5, 'x');
	çağrısı
		xxcsd
	yazısını döndürecektir

	- len uzunluğu yazının uzunluğundan küçük veya eşitse aynı referansa geri dönecektir

	- padLeading metodunun 2 parametreli overload'u yazıyı soldan (baştan) space karakteri ile dolduracaktır

	- padTrailing metotları benzer şekilde sağdan (sondan) dolduracak şekilde yazılacaktır

	- Örneği Java 11 öncesi için yazınız

	Örnekte repeat metodu döngü kullanmadan yazılmıştır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		PadLeadingTrailingTest.run();
	}
}

class PadLeadingTrailingTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();

			if ("elma".equals(s))
				break;

			System.out.print("Bir sayı giriniz:");
			int count = Integer.parseInt(kb.nextLine());

			System.out.printf("(%s)%n", StringUtil.padLeading(s, count, 'x'));
			System.out.printf("(%s)%n", StringUtil.padLeading(s, count));
			System.out.printf("(%s)%n", StringUtil.padTrailing(s, count, 'x'));
			System.out.printf("(%s)%n", StringUtil.padTrailing(s, count));
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class StringUtil {
	public static String padLeading(String s, int len, char ch)
	{
		int length  = s.length();

		return len <= length ? s : repeat(len - length, ch) + s;
	}

	public static String padLeading(String s, int len)
	{
		return padLeading(s, len, ' ');
	}

	public static String padTrailing(String s, int len, char ch)
	{
		int length  = s.length();

		return len <= length ? s : s + repeat(len - length, ch);
	}

	public static String padTrailing(String s, int len)
	{
		return padTrailing(s, len, ' ');
	}

	public static String repeat(int count, char ch)
	{
		return String.format("%0" + count + "d", 0).replace('0', ch);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Aşağıda açıklanan metotları StringUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz.

	public static String padLeading(String s, int len, char ch);
	public static String padLeading(String s, int len);
	public static String padTrailing(String s, int len, char ch);
	public static String padTrailing(String s, int len);

	Açıklamalar:
	- padLeading metodunun 3 parametreli overload'u ikinci parametresi ile aldığı len, birinci paramtresi ile aldığı
	yazının uzunluğundan büyükse yazıyı soldan (baştan) üçüncü parametresi ile aldığı karakter ile dolduracaktır.
	Örneğin:
		padLeading("csd", 5, 'x');
	çağrısı
		xxcsd
	yazısını döndürecektir

	- len uzunluğu yazının uzunluğundan küçük veya eşitse aynı referansa geri dönecektir

	- padLeading metodunun 2 parametreli overload'u yazıyı soldan (baştan) space karakteri ile dolduracaktır

	- padTrailing metotları benzer şekilde sağdan (sondan) dolduracak şekilde yazılacaktır

	- Örneği Java 11 öncesi için yazınız

	Örnekte repeat metodu döngü kullanmadan yazılmıştır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		PadLeadingTrailingTest.run();
	}
}

class PadLeadingTrailingTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();

			if ("elma".equals(s))
				break;

			System.out.print("Bir sayı giriniz:");
			int count = Integer.parseInt(kb.nextLine());

			System.out.printf("(%s)%n", StringUtil.padLeading(s, count, 'x'));
			System.out.printf("(%s)%n", StringUtil.padLeading(s, count));
			System.out.printf("(%s)%n", StringUtil.padTrailing(s, count, 'x'));
			System.out.printf("(%s)%n", StringUtil.padTrailing(s, count));
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class StringUtil {
	public static String padLeading(String s, int len, char ch)
	{
		int length  = s.length();

		return len <= length ? s : repeat(len - length, ch) + s;
	}

	public static String padLeading(String s, int len)
	{
		return padLeading(s, len, ' ');
	}

	public static String padTrailing(String s, int len, char ch)
	{
		int length  = s.length();

		return len <= length ? s : s + repeat(len - length, ch);
	}

	public static String padTrailing(String s, int len)
	{
		return padTrailing(s, len, ' ');
	}

	public static String repeat(int count, char ch)
	{
		return String.format("%" + count + "c", ' ').replace(' ', ch);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Java 7 ile birlikte switch deyiminde String de kullanılabilmektedir. Bu durumda case bölümlerinin "String literal"
	ifadeleri olması gerekir. String sınıfı switch deyimi ile kullanıldığında karşılaştırma işlemi equals metodu ile
	yapılır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Şehir ismini giriniz:");
		String city = kb.nextLine();

		switch (city.toLowerCase()) {
		case "edirne":
		case "istanbul":
		case "balıkesir":
			System.out.println("Marmara bölgesi");
			break;
		case "zonguldak":
		case "sinop":
		case "bolu":
			System.out.println("Batı karadeniz bölgesi");
			break;
		default:
			System.out.println("Geçersiz şehir ismi");
		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	String switch expression ile de kullanılabilir
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Şehir ismini giriniz:");
		String city = kb.nextLine();

		switch (city.toLowerCase()) {
		case "edirne", "istanbul", "balıkesir" -> System.out.println("Marmara bölgesi");
		case "zonguldak", "sinop", "bolu" -> System.out.println("Batı karadeniz bölgesi");
		default -> System.out.println("Geçersiz şehir ismi");
		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	22.01.2023
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Paketler (Packages) ve İsim Arama (Name Lookup):
	Aşağıdaki maddelerde "user defined type (UDT)" olarak belirtilen kavram için şu ana kadar ki bilgilerimizle sınıf
	düşünülebilir. Ancak ileride göreceğimiz başka UDT'ler de vardır (enum class, interface vb.).

	Java kodlarını içeren ve genellikle ".java" uzantılı olan bir dosyaya (derlenen dosya)  "derleme birimi (compilation/translation unit)"
	denir. Eğer Java dosyasında birden fazla UDT söz konusu ise herbir UDT bir derleme birimi olarak düşünülebilir.

	Paketlere ilişkin detaylar:
	- javac her UDT için ayrı bir ".class" uzantılı dosya (byte code) üretir. Bu işlem UDT'ler aynı java dosyasında
	olsa bile bu şekilde yapılır.

	- Bir UDT herhangi bir pakette olabilir. Bir proje içerisinde kullanılan UDT'lerin aynı pakette olma zorunluluğu
	yoktur

	- Bir ".class" uzantılı dosyanın dosyaya ilişkin UDT'nin ait olduğu paketle aynı isimde bir dizinde (directory)
	olması gerekir. Aslında java dosyaları için böyle bir zorunluluk yoktur. Ancak birçok IDE kendi içerisinde bunu da
	zorunlu tutar

	- Bir UDT bulunduğu paket dışında (başka bir poaketin içerisinde), paket ismi ve nokta operatörü ile kullanılabilir.

	- Bir paket içerisinde bildirilen bir UDT'nin farklı bir paketten kullanılabilmesi için public olarak bildirilmesi
	gerekir. public olarak bildirilmeyen bir UDT ancak aynı paketteki diğer UDT'ler tarafından kullanılabilir. public
	olmayan UDT'ler için "friendly" ya da daha nadir olarak "internal" terimi kullanılır.

	- Farklı paketteki UDT'ler için byte kodların da uygun yerde olması gerekir. Uygulamanın başlatıldığı dizin tüm paketlere
	ilişkin dizinlerin olması gereken dizindir. Ancak bu durumun da ayrıntıları ve istisnaları vardır

	- Uygulamada kullanılan sınıflar içerisinde bir tane main metodu olmak zorunda değildir. Ancak şüphesiz "java"
	programına verilen byte koda ilişkin sınıfta (bu kesinlikle sınıf olmalıdır) uygun main metodunun olması gerekir.
	main metodunun aşağıdaki yapıda olması zorunludur:
		public static void main(String [] args)
	java programına verilen main metoduna "giriş noktası (entry point)" denir

	- public olarak bildirilen bir UDT'nin kendi ismiyle aynı isimde bir java dosyası içerisinde bulunması gerekir. Bu
	durumda bir java dosyası içerisinde yalnızca o dosya ismiyle aynı isimde bir UDT public olarak bildirilebilir

	- Bir java dosyasında public bir UDT olmak zorunda değildir. public bir UDT olacaksa dosya ismi ile aynı isimde bir
	UDT olabilir

	- Bir java dosyası içerisinde dosya ismi ile aynı isimde bir UDT olmak zorunda değildir

	- Bir java dosyası içerisinde public olmayan istenildiği kadar UDT bildirilebilir. Bu UDT'lerin hepsi aynı pakette
	bildirilmiş olur

	- Aynı paket içerisinde aynı isimde birden fazla UDT bildirimi yapılamaz

	- Farklı paketler içerisinde aynı isimde UDT bildirimleri yapılabilir

	- Bir java dosyasında birden fazla paket bildirimi yapılamaz

	- Hiç bir paket bildirimi olmayan java dosyalarında bildirilen UDT'ler "isimsiz paket (unnamed package)" denilen bir
	paket içerisinde bildirilmiş kabul edilirler. Ancak projelerde isimsiz paket içerisinde UDT bildirimi yapılmamalıdır

	- Bir paket içerisinde alt paketler (sub packages) olabilir. Alt paket bildiriminin genel biçimi şu şekildedir:
		package <paket ismi>.<alt paket ismi>.<alt paket ismi> ...
	Alt paketlerde bulunan UDT'lerin .class dosyaları paket hiyerarşisi ile uygun alt dizinlerde bulunmalıdır. Benzer
	şekilde IDE'ler java dosyaları için de bunu uygularlar

	- Paketler içiçe bile olsa bunlar farklı paketlerdir. Yani örneğin org.csystem.util.numeric paketi içerisinde
	bulunan NumberUtil isimli sınıf org.csystem.util içerisinde de bulunabilir. Bu isimler çakışmaz

	- Paket isimleri genelde firmaya özgü tekil (unique) bilgi olan domain isimlerinden üretilir. Örneğin CSD'nin paketleri,
	ve UDT'leri domain ismi "csystem.org" olduğundan "org.csystem" paketi altında yazılabilir. Bu convention'a uyulmalıdır

	- Java'nın standart tüm paketleri java isimli bir paket altında toplanmıştır. java paket altındaki paketler içerisinde
	başka paketler ve başka UDT'ler bildirilmiştir

	- java.lang paketi altında bulunan tüm UDT'ler her yerde görülebilirdir (visible). Yani buradaki tür ismlerini
	paket ismi ile kombine etmeye gerek yoktur. İleride ele alacağımız "import bildirimi" yapılmasına da gerek yoktur
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------
	FILE		: Complex.java
	AUTHOR		: Java-Aug-2022 Group
	LAST UPDATE	: 22.01.2023

	Complex class that represents complex number

	Copyleft (c) 1993 C and System Programmers Association
	All Rights Free
----------------------------------------------------------------*/
package org.csystem.util.math;

public class Complex {
	public double real;
	public double imag;

	public static Complex add(double re1, double im1, double re2, double im2)
	{
		return new Complex(re1 + re2, im1 + im2);
	}

	public static Complex subtract(double re1, double im1, double re2, double im2)
	{
		return add(re1, im1, -re2, -im2);
	}

	public static Complex multiply(double re1, double im1, double re2, double im2)
	{
		return new Complex(re1 * re2 - im1 * im2, re1 * im2 + re2 * im1);
	}

	public static Complex divide(double re1, double im1, double re2, double im2)
	{
		Complex z = multiply(re1, im1, re2, -im2);
		double divider = re1 * re1 + im1 * im2;

		z.real /= divider;
		z.imag /= divider;

		return z;
	}

	public Complex()
	{
	}

	public Complex(double re)
	{
		real = re;
	}

	public Complex(double re, double im)
	{
		real = re;
		imag = im;
	}

	public double getLength()
	{
		return Math.sqrt(real * real + imag * imag);
	}

	public double getNorm()
	{
		return getLength();
	}

	public Complex getConjugate()
	{
		return new Complex(real, -imag);
	}

	public static Complex add(double val, Complex z)
	{
		return add(val, 0, z.real, z.imag);
	}

	public Complex add(Complex other)
	{
		return add(real, imag, other.real, other.imag);
	}

	public Complex add(double val)
	{
		return add(real, imag, val, 0);
	}

	public static Complex subtract(double val, Complex z)
	{
		return subtract(val, 0, z.real, z.imag);
	}

	public Complex subtract(Complex other)
	{
		return subtract(real, imag, other.real, other.imag);
	}

	public Complex subtract(double val)
	{
		return subtract(real, imag, val, 0);
	}

	public static Complex multiply(double val, Complex z)
	{
		return multiply(val, 0, z.real, z.imag);
	}

	public Complex multiply(Complex other)
	{
		return multiply(real, imag, other.real, other.imag);
	}

	public Complex multiply(double val)
	{
		return multiply(real, imag, val, 0);
	}

	public static Complex divide(double val, Complex z)
	{
		return divide(val, 0, z.real, z.imag);
	}

	public Complex divide(Complex other)
	{
		return divide(real, imag, other.real, other.imag);
	}

	public Complex divide(double val)
	{
		return divide(real, imag, val, 0);
	}

	public String toString()
	{
		return String.format("(%f, %f)", real, imag);
	}
}

/*----------------------------------------------------------------
	FILE		: Point.java
	AUTHOR		: Java-Aug-2022 Group
	LAST UPDATE	: 22.01.2023

	Point class that represents 2 dimensional point in
	Cartesian plane

	Copyleft (c) 1993 C and System Programmers Association
	All Rights Free
----------------------------------------------------------------*/
package org.csystem.util.math.geometry;

public class Point {
	public double x;
	public double y;

	public Point()
	{
	}

	public Point(double a)
	{
		x = a;
	}

	public Point(double a, double b)
	{
		x = a;
		y = b;
	}

	public double distance()
	{
		return distance(0, 0);
	}

	public double distance(Point other)
	{
		return distance(other.x, other.y);
	}

	public double distance(double a, double b)
	{
		return Math.sqrt(Math.pow(x - a, 2) + Math.pow(y - b, 2));
	}

	public void offset(double dxy)
	{
		offset(dxy, dxy);
	}

	public void offset(double dx, double dy)
	{
		x += dx;
		y += dy;
	}

	public String toString()
	{
		return String.format("(%f, %f)", x, y);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	BallFall uygulaması
-----------------------------------------------------------------------------------------------------------------------*/

package org.csystem.app.ballfall;

public class BallFallApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		BallFall bf = new BallFall();

		for (;;) {
			System.out.print("Input width and height:");
			int width = kb.nextInt();
			int height = kb.nextInt();

			if (width == 0)
				break;

			bf.play(width, height);
			System.out.println(bf.shape);
		}
	}

}

package org.csystem.app.ballfall;

public class BallFall {
	public String shape;

	public void fillSpace(int begin, int end)
	{
		for (int i = begin; i < end; ++i)
			shape += ' ';
	}

	public void fillBall(int ballIndex, int end)
	{
		fillSpace(0, ballIndex);
		shape += '*';
		fillSpace(ballIndex + 1, end);
	}

	public static boolean updateRightFlag(boolean isRight, int ballIndex, int width)
	{
		if (ballIndex == 0)
			isRight = true;
		else if (ballIndex == width - 1)
			isRight = false;

		return isRight;
	}

	public static int updateBallIndex(boolean isRight, int ballIndex)
	{
		if (isRight)
			return ballIndex + 1;

		return ballIndex - 1;
	}

	public BallFall()
	{
		shape = "";
	}

	public void play(int width, int height)
	{
		shape = "";

		if (width != 1) {
			int ballIndex = 0;
			boolean isRight = false;

			for (int i = 1; i <= height; ++i) {
				shape += '|';
				fillBall(ballIndex, width);
				isRight = updateRightFlag(isRight, ballIndex, width);
				ballIndex = updateBallIndex(isRight, ballIndex);
				shape += "|\r\n";
			}
		}
		else
			for (int i = 1; i <= height; ++i)
				shape += "|*|\r\n";
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	04.02.2023
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------
	FILE		: NumberUtil.java
	AUTHOR		: Java-Aug-2022 Group
	LAST UPDATE	: 04.02.2023

	Utility class for numeric operations

	Copyleft (c) 1993 C and System Programmers Association
	All Rights Free
----------------------------------------------------------------*/
package org.csystem.util.numeric;

public class NumberUtil {
	public static int getDigitsPowSum(int val)
	{
		int n = countDigits(val);
		int total = 0;

		while (val != 0) {
			total += Math.pow(val % 10, n);
			val /= 10;
		}

		return total;
	}

	public static int countDigits(int val)
	{
		return (val != 0) ? ((int)Math.log10(Math.abs(val)) + 1) : 1;
	}

	public static long factorial(int n)
	{
		long result = 1;

		for (int i = 2; i <= n; ++i)
			result *= i;

		return result;
	}

	public static int getFibonacciNumber(int n)
	{
		if (n <= 2)
			return n - 1;

		int prev1 = 1, prev2 = 0, val = prev1 + prev2;

		for (int i = 3; i < n; ++i) {
			prev2 = prev1;
			prev1 = val;
			val = prev1 + prev2;
		}

		return val;
	}

	public static int getNextFibonacciNumber(int val)
	{
		if (val < 0)
			return 0;

		int prev1 = 1, prev2 = 0, next;

		for (;;) {
			next = prev1 + prev2;

			if (next > val)
				return next;

			prev2 = prev1;
			prev1 = next;
		}
	}

	public static long getPrime(int n)
	{
		long val = 2;
		int count = 0;

		for (;;) {
			if (isPrime(val))
				++count;

			if (count == n)
				return val;

			++val;
		}
	}

	public static boolean isArmstrong(int val)
	{
		return val >= 0 && getDigitsPowSum(val) == val;
	}

	public static boolean isEven(int val)
	{
		return val % 2 == 0;
	}

	public static boolean isOdd(int val)
	{
		return !isEven(val);
	}

	public static boolean isPrime(long val)
	{
		if (val <= 1)
			return false;

		if (val % 2 == 0)
			return val == 2;

		if (val % 3 == 0)
			return val == 3;

		if (val % 5 == 0)
			return val == 5;

		if (val % 7 == 0)
			return val == 7;

		for (long i = 11; i * i <= val; i += 2)
			if (val % i == 0)
				return false;

		return true;
	}

	public static double max(double a, double b, double c)
	{
		return Math.max(Math.max(a, b), c);
	}

	public static int mid(int a, int b, int c)
	{
		if (a <= b && b <= c || c <= b && b <= a)
			return b;

		if (b <= a && a <= c || c <= a && a <= b)
			return a;

		return c;
	}

	public static double min(double a, double b, double c)
	{
		return Math.min(Math.min(a, b), c);
	}

	public static int reverse(int val)
	{
		int result = 0;

		while (val != 0) {
			result = result * 10 + val % 10;
			val /= 10;
		}

		return result;
	}

	public static int sumDigits(int val)
	{
		int sum = 0;

		while (val != 0) {
			sum += val % 10;
			val /= 10;
		}

		return Math.abs(sum);
	}
}


/*----------------------------------------------------------------
	FILE		: StringUtil.java
	AUTHOR		: Java-Aug-2022 Group
	LAST UPDATE	: 04.02.2023

	Utility class for string operations

	Copyleft (c) 1993 C and System Programmers Association
	All Rights Free
----------------------------------------------------------------*/
package org.csystem.util.string;

public class StringUtil {

	public static String capitalize(String s)
	{
		return s.isEmpty() ? "" : Character.toUpperCase(s.charAt(0)) + s.substring(1).toLowerCase();
	}

	public static int countString(String s1, String s2)
	{
		int count = 0;

		for (int i = -1; (i = s1.indexOf(s2, i + 1)) != -1; ++count)
			;

		return count;
	}

	public static int countStringIgnoreCase(String s1, String s2)
	{
		return countString(s1.toLowerCase(), s2.toLowerCase());
	}

	public static String getRandomText(java.util.Random r, int n, String sourceText)
	{
		String str = "";

		int len = sourceText.length();

		for (int i = 0; i < n; ++i)
			str += sourceText.charAt(r.nextInt(len));

		return str;
	}

	public static String getRandomTextEN(int n)
	{
		return getRandomTextEN(new java.util.Random(), n);
	}

	public static String getRandomTextEN(java.util.Random r, int n)
	{
		return getRandomText(r, n, "abcdefghijklmnopqrstuwxvyzABCDEFGHIJKLMNOPQRSTUWVXYZ");
	}

	public static String getRandomTextTR(int n)
	{
		return getRandomTextTR(new java.util.Random(), n);
	}

	public static String getRandomTextTR(java.util.Random r, int n)
	{
		return getRandomText(r, n, "abcçdefgğhıijklmnoöprsştuüvyzABCÇDEFGĞHIİJKLMNOÖPRSŞTUÜVYZ");
	}

	public static String getShortestPangramEN(String s)
	{
		String result = s;

		int end = s.length();

		while (end != 0) {
			int begin = 0;

			while (begin != end) {
				String str = s.substring(begin++, end);

				if (str.length() >= 26 && isPangramEN(str) && str.length() < result.length())
					result = str;
			}

			--end;
		}

		return result;
	}

	public static String getShortestPangramTR(String s)
	{
		String result = s;

		int end = s.length();

		while (end != 0) {
			int begin = 0;

			while (begin != end) {
				String str = s.substring(begin++, end);

				if (str.length() >= 29 && isPangramTR(str) && str.length() < result.length())
					result = str;
			}

			--end;
		}

		return result;
	}

	public static boolean isPalindrome(String s)
	{
		int left = 0;
		int right = s.length() - 1;
		boolean cLeftSelected = false, cRightSelected = false;
		char cLeft = '\0', cRight;

		while (left < right) {
			if (!cLeftSelected) {
				cLeft = Character.toLowerCase(s.charAt(left));

				if (!Character.isLetter(cLeft)) {
					++left;
					continue;
				}
				cLeftSelected = true;
			}

			if (!cRightSelected) {
				cRight = Character.toLowerCase(s.charAt(right));

				if (!Character.isLetter(cRight)) {
					--right;
					continue;
				}

				if (cLeft != cRight)
					return false;

				cRightSelected = true;
			}

			++left;
			--right;

			cLeftSelected = cRightSelected = false;
		}

		return true;
	}

	public static boolean isPangram(String s, String alphabet)
	{
		int len = alphabet.length();

		for (int i = 0; i < len; ++i)
			if (s.indexOf(alphabet.charAt(i)) == -1)
				return false;

		return true;
	}

	public static boolean isPangramEN(String s)
	{
		return isPangram(s.toLowerCase(), "abcdefghijklmnopqrstuwxvyz");
	}

	public static boolean isPangramTR(String s)
	{
		return isPangram(s.toLowerCase(), "abcçdefgğhıijklmnoöprsştuüvyz");
	}

	public static String padLeading(String s, int len, char ch)
	{
		int length  = s.length();

		return len <= length ? s : repeat(len - length, ch) + s;
	}

	public static String padLeading(String s, int len)
	{
		return padLeading(s, len, ' ');
	}

	public static String padTrailing(String s, int len, char ch)
	{
		int length  = s.length();

		return len <= length ? s : s + repeat(len - length, ch);
	}

	public static String padTrailing(String s, int len)
	{
		return padTrailing(s, len, ' ');
	}

	public static String repeat(int count, char ch)
	{
		return String.format("%0" + count + "d", 0).replace('0', ch);
	}

	public static String reverse(String s)
	{
		String str = "";

		for (int i = s.length() - 1; i >= 0; --i)
			str += s.charAt(i);

		return str;
	}

	public static String trimLeading(String s)
	{
		int i;
		int len = s.length();

		for (i = 0; i < len && Character.isWhitespace(s.charAt(i)); ++i)
			;

		return s.substring(i);
	}

	public static String trimTrailing(String s)
	{
		int i;


		for (i = s.length() - 1; i >= 0 && Character.isWhitespace(s.charAt(i)); --i)
			;

		return s.substring(0, i + 1);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	İsim Arama (Name Lookup): Derleyici kullanılan bir ismi önce arar, eğer bulursa erşim kontrolünü yapar yani ismin
	doğru bir biçimde kullanılıp kullanılmadığına bakar. Derleyici isim aramayı belirli kurallara göre yapar. İsim arama
	için genel kurallar olduğu gibi özel durumlar için genel kuralların uygulanmaz. Yani kabacak genel ve özel kurallar
	olarak ayırabiliriz. Özel durumlara ilişkin detaylar da isim aramanın bir parçasıdır. Burada önce genel kurallar
	sonra özel durumlar için uygulanan kurallar anlatılacaktır
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Derleyici bildirimi yapılan isimleri bildirim noktasında aramaz. Kullanıldığı noktada aranır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		Sample.foo(); //Sample aranır, foo aranır
		//...
	}
}


class Sample { //Sample aranmaz
	public static void foo() //foo aranmaz
	{
		//...
		int a = 30; //a aranmaz

		a = 20; // a aranır
	}

}

/*----------------------------------------------------------------------------------------------------------------------
	Bir isim kod içerisinde iki şekilde kullanılabilir: nitelikli (qualified), niteliksiz (unqualified)
	Bir isim nokta operatörünün sağında kalıyorsa nitelikli, kalmıyorsa niteliksiz kullanılmış olur.

	Niteliksiz kullanılan isimler "niteliksiz isim arama (unqualified name lookup)" kurallarına göre, nitelikli
	kullanılan bir isimler de "nitelikli isim arama (qualified name lookup)" kurallarına göre aranır.

	Anahtar Notlar: Yukarıdaki tanımlarda nitelikli (qualified) ve niteliksiz (unqualified) olmak olumlu ya da olumsuz bir
	etki anlamında düşünülmemelidir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		Sample s; //Sample niteliksiz aranır, s aranmaz

		Sample.foo(); //Sample niteliksiz aranır, foo nitelikli aranır

		s = new Sample(); //s niteliksiz aranır, Sample niteliksiz aranır

		s.bar(); //s niteliksiz aranır, bar nitelikli aranır
		System.out.printf("s.a = %d%n", s.a); //System niteliksiz aranır, out nitelikli aranır, printf nitelikli aranır, s niteliksiz aranır, a nitelikli aranır
	}
}


class Sample { //Sample aranmaz
	public int a;

	public static void foo() //foo aranmaz
	{
		//...
		int a = 30; //a aranmaz

		a = 20; // a aranır
	}

	public void bar() //bar aranmaz
	{
		//...
	}

}

/*----------------------------------------------------------------------------------------------------------------------
	Derleyici bir ismi bulduktan sonra erişim kontrolünü yapar. Aşağıdaki örnekteki hata mesajlarını inceleyiniz
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		double a = 10;
		int b;

		b = a; //error
		b = 4.5; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz isim arama genel kuralları (else if biçiminde değerlendiriniz):
	1.Bir isim metot içerisinde kullanılmışsa, kullanıldığı yerden yukarıya doğru metot içerisinde aranır. Burada
	kullanılan isimden önce bildirilen yerel değişkenler ile metodun parametre değişken isimlerine bakılır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		int a;


		a = 10;
	}
}


class Sample {
	public void foo(int x)
	{
		int a;

		a = x;

		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz isim arama genel kuralları (else if biçiminde değerlendiriniz):
	2.İsim metodun ait olduğu sınıfın tamamında ancak tüm metotların dışında aranır. Burada isim bulunamazsa sırasıyla
	"doğrudan taban sınıfa (direct super class)" ve "dolaylı taban sınıflara (indirect super class)" da bakılır. Taban
	sınıf kavranı ileride detaylı bir biçimde ele alınacaktır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		Sample s;

		s = new Sample();

		s.foo(67);

		System.out.printf("s.a = %d%n", s.a);
	}
}


class Sample {
	public void foo(int x)
	{
		a = x;
	}

	public int a;

	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki iki kurala göre bir sınıfın veri elemanı ile aynı isimde metot parametre değişkeni veya yerel değişken
	bildirimi geçerlidir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		Sample s;

		s = new Sample();

		s.foo(67);

		System.out.printf("s.a = %d%n", s.a);
	}
}


class Sample {
	public int b;

	public void foo(int a)
	{
		int b; //shadowing, masking, hiding

		b = 10;

		++a;

		System.out.printf("foo:a = %d%n", a);
	}

	public int a;

	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz isim arama genel kuralları (else if biçiminde değerlendiriniz):
	3. İsim sınıfın ait olduğu paket içerisinde aranır. Burada alt paketlere ya da üst paketlere bakılmaz. Sadece ait
	olduğu pakete bakılır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		Sample s;

		s = new Sample();

		s.foo(67);

		System.out.printf("s.a = %d%n", s.a);
	}
}


class Sample {
	public int a;

	public void foo(int x)
	{
		a = x;
	}

	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz isim arama genel kuralları (else if biçiminde değerlendiriniz):
	3.İsim sınıfın ait olduğu paket içerisinde aranır. Burada alt paketlere ya da üst paketlere bakılmaz. Sadece ait
	olduğu pakete bakılır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		Sample s;

		s = new Sample();

		s.foo(67);

		System.out.printf("s.a = %d%n", s.a);
	}
}

package org.csystem.app;

public class Sample {
	public int a;

	public void foo(int x)
	{
		a = x;
	}

	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz isim arama genel kuralları (else if biçiminde değerlendiriniz):
	3.İsim sınıfın ait olduğu paket içerisinde aranır. Burada alt paketlere ya da üst paketlere bakılmaz. Sadece ait
	olduğu pakete bakılır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		Sample s = new Sample(); //error

	}
}

package org.csystem;

public class Sample {
	public int a;

	public void foo(int x)
	{
		a = x;
	}

	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz isim arama genel kuralları (else if biçiminde değerlendiriniz):
	3.İsim sınıfın ait olduğu paket içerisinde aranır. Burada alt paketlere ya da üst paketlere bakılmaz. Sadece ait
	olduğu pakete bakılır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		Sample s = new Sample(); //error

	}
}

package org.csystem.app.test;

public class Sample {
	public int a;

	public void foo(int x)
	{
		a = x;
	}

	//...
}


/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz isim arama genel kuralları (else if biçiminde değerlendiriniz):
	4."import on demand declaration" varsa o paketlere de bakılır. Bu konu ileride ele alınacaktır
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz kullanılan bir isim, niteliksiz isim arama genel kurallarına göre aranmış ve bulunamamışsa error oluşur
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki kurallara göre isimsiz paket altında bulunan bir UDT'ye başka bir paket içerisinden erişilemez. Nitelikli
	olarak da erişilemez. Yalnızca bu sebepten bile bir projede isimsiz paket altında UDT bildirilmemelidir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		Sample s = new Sample(); //error

	}
}


public class Sample {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Nitelikli isim arama genel kuralları (else if biçiminde değerlendiriniz):
	1.Aranacak ismin solunda sınıf ismi varsa, isim ilgili sınıf içerisinde aranır. Bulunamazsa taban sınıflara da bakılır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;


class App {
	public static void main(String [] args)
	{
		Sample.a = 10;
		Sample.foo(20);

		System.out.printf("Sample.a = %d%n", Sample.a);
	}
}

class Sample {
	public static int a;

	public static void foo(int x)
	{
		a = x;
	}

	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Nitelikli isim arama genel kuralları (else if biçiminde değerlendiriniz):
	2.Aranacak ismin solunda referans ismi varsa, isim referansa ilişkin UDT içerisinde aranır. Bulunamazsa taban sınıflara da
	bakılır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;


class App {
	public static void main(String [] args)
	{
		Sample s;

		s = new Sample();

		s.foo(34);

		System.out.printf("Sample.a = %d%n", s.a);
	}
}

class Sample {
	public int a;

	public void foo(int x)
	{
		a = x;
	}

	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Nitelikli isim arama genel kuralları (else if biçiminde değerlendiriniz):
	3.Aranacak ismin solunda paket ismi varsa, isim o paket içerisinde aranır. Alt ya da üst paketlere bakılmaz
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		test.Sample s;
	}
}


public class Sample {
	//...
}

package test;

public class Sample {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Nitelikli isim arama genel kuralları (else if biçiminde değerlendiriniz):
	3.Aranacak ismin solunda paket ismi varsa, isim o paket içerisinde aranır. Alt ya da üst paketlere bakılmaz
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		test.mest.Sample s; //error
	}
}

package test;

public class Sample {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Nitelikli isim arama genel kuralları (else if biçiminde değerlendiriniz):
	3.Aranacak ismin solunda paket ismi varsa, isim o paket içerisinde aranır. Alt ya da üst paketlere bakılmaz
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		test.Sample s; //error
	}
}

package test.mest;

public class Sample {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Alt paket isimleri niteliksiz isim aramaya dahil değildir. Yani aşağıdaki örnekte test ismi aranırken org.csystem.app
	içerisindeki test paket ismi dikkate alınmaz. Niteliksiz kullanılan bir ismin paket ismi olarak bulunabilmesi için
	"source folder" (eclipse'de default olarak src dizini) içerisinde bir paket olarak bulunması gerekir. Ya da başka
	bir deyişle üst paketinin olmaması gerekir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		test.Sample s; //error
	}
}

package org.csystem.app.test;

public class Sample {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	import bildirimi genel olarak niteliklendirmeyi azaltmak, dolayısıyla daha yalın ve açık (clean) kod yazımı için
	kullanılır.

	Anahtar Notlar: import bildirimi bir kütüphaneyi "projeye dahil etmek (import etmek)" anlamına GELMEZ

	import bildirimleri iki şekilde kullanılabilir:
	1. Yıldızlı import bildirimi (import on demand declaration)
	2. Yıldızsız import bildirimi (import single type declaration)

	import bildirimleri ".java" dosyasında (compilation unit) paket bildiriminden sonra, tüm diğer bildirimlerden
	önce yazılmalıdır. import bildirimleri bir derleme biriminden birden fazla olabilir. Yazılış sırasının önemi
	yoktur. import bildirimi bildirildiği derleme biriminde geçerlidir. Diğer derleme birimleri etkilenmez. import
	bildirimleri niteliksiz isim arama kurallarına ilişkindir. Nitelikli isim arama kurallarında import bildiriminin
	önemi yoktur.

	Anahtar Notlar: "Yıldızlı ve yıldızsız import bildirimi" cümleleri kolay anlatmak için Oğuz Karan tarafından
	uydurulmuştur. Şüphesiz teknik terimlerinin tercümleri bunlar değildir.
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Yıldızlı import bildiriminin (import on demand declaration) genel biçimi:
		import <paket ismi>[.alt paketler].*;

	Bu bildirim niteliksiz isim arama genel kurallarına göre, aranan isim paket içerisinde de bıulunamazsa aramak için
	bakılacak paketleri belirtir. Yani adeta bir paketin başka bir paket içerisine isim arama anlamında enjekte edilmesidir.

	Daha açık olarak bu bildirimler derleyiciye "eğer niteliksiz kullanılan bir ismi pakette bulamazsan yıldızlı import
	bildirimlerine ilişkin paketlerde de ara" demektir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.*;
import org.csystem.util.math.geometry.*;
import org.csystem.util.math.*;
import org.csystem.util.numeric.*;

class App {
	public static void main(String [] args)
	{
		Random r = new Random();
		Scanner kb = new Scanner(System.in);

		Point p = new Point(12.3, 6.6);
		System.out.println(NumberUtil.isPrime(r.nextInt(100)) ? "Asal" : "Asal değil");
		Complex z = new Complex();

		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yıldızlı import bildirimlerine ilişkin paketlerin hepsine bakılır. Birden fzla paket içerisinde aranan isim bulunursa
	error oluşur (ambiguity error).
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import test.*;
import mest.*;

class App {
	public static void main(String [] args)
	{
		Test t;
		Mample m;
		Sample s; //error: ambiguity
	}
}

package test;

public class Sample {
	//...
}

package mest;

public class Sample {
	//...
}

package test;

public class Mample {
	//...
}

package mest;

public class Test {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	05.02.2023
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Yıldızlı import bildiriminin bir kullanımı. Örnekte isimler için niteliklendirmenin azaltıldığına dikkat ediniz
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.*;
import org.csystem.util.math.*;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();

		for (int i = 0; i < n; ++i) {
			Complex z = new Complex(r.nextDouble(-10, 10), r.nextDouble(-10, 10));

			System.out.println(z.toString());
		}
	}
}

/*----------------------------------------------------------------
	FILE		: StringUtil.java
	AUTHOR		: Java-Aug-2022 Group
	LAST UPDATE	: 05.02.2023

	Utility class for string operations

	Copyleft (c) 1993 C and System Programmers Association
	All Rights Free
----------------------------------------------------------------*/
package org.csystem.util.string;

import java.util.*;

public class StringUtil {

	public static String capitalize(String s)
	{
		return s.isEmpty() ? "" : Character.toUpperCase(s.charAt(0)) + s.substring(1).toLowerCase();
	}

	public static int countString(String s1, String s2)
	{
		int count = 0;

		for (int i = -1; (i = s1.indexOf(s2, i + 1)) != -1; ++count)
			;

		return count;
	}

	public static int countStringIgnoreCase(String s1, String s2)
	{
		return countString(s1.toLowerCase(), s2.toLowerCase());
	}

	public static String getRandomText(Random r, int n, String sourceText)
	{
		String str = "";

		int len = sourceText.length();

		for (int i = 0; i < n; ++i)
			str += sourceText.charAt(r.nextInt(len));

		return str;
	}

	public static String getRandomTextEN(int n)
	{
		return getRandomTextEN(new Random(), n);
	}

	public static String getRandomTextEN(Random r, int n)
	{
		return getRandomText(r, n, "abcdefghijklmnopqrstuwxvyzABCDEFGHIJKLMNOPQRSTUWVXYZ");
	}

	public static String getRandomTextTR(int n)
	{
		return getRandomTextTR(new Random(), n);
	}

	public static String getRandomTextTR(Random r, int n)
	{
		return getRandomText(r, n, "abcçdefgğhıijklmnoöprsştuüvyzABCÇDEFGĞHIİJKLMNOÖPRSŞTUÜVYZ");
	}

	public static String getShortestPangramEN(String s)
	{
		String result = s;

		int end = s.length();

		while (end != 0) {
			int begin = 0;

			while (begin != end) {
				String str = s.substring(begin++, end);

				if (str.length() >= 26 && isPangramEN(str) && str.length() < result.length())
					result = str;
			}

			--end;
		}

		return result;
	}

	public static String getShortestPangramTR(String s)
	{
		String result = s;

		int end = s.length();

		while (end != 0) {
			int begin = 0;

			while (begin != end) {
				String str = s.substring(begin++, end);

				if (str.length() >= 29 && isPangramTR(str) && str.length() < result.length())
					result = str;
			}

			--end;
		}

		return result;
	}

	public static boolean isPalindrome(String s)
	{
		int left = 0;
		int right = s.length() - 1;
		boolean cLeftSelected = false, cRightSelected = false;
		char cLeft = '\0', cRight;

		while (left < right) {
			if (!cLeftSelected) {
				cLeft = Character.toLowerCase(s.charAt(left));

				if (!Character.isLetter(cLeft)) {
					++left;
					continue;
				}
				cLeftSelected = true;
			}

			if (!cRightSelected) {
				cRight = Character.toLowerCase(s.charAt(right));

				if (!Character.isLetter(cRight)) {
					--right;
					continue;
				}

				if (cLeft != cRight)
					return false;

				cRightSelected = true;
			}

			++left;
			--right;

			cLeftSelected = cRightSelected = false;
		}

		return true;
	}

	public static boolean isPangram(String s, String alphabet)
	{
		int len = alphabet.length();

		for (int i = 0; i < len; ++i)
			if (s.indexOf(alphabet.charAt(i)) == -1)
				return false;

		return true;
	}

	public static boolean isPangramEN(String s)
	{
		return isPangram(s.toLowerCase(), "abcdefghijklmnopqrstuwxvyz");
	}

	public static boolean isPangramTR(String s)
	{
		return isPangram(s.toLowerCase(), "abcçdefgğhıijklmnoöprsştuüvyz");
	}

	public static String padLeading(String s, int len, char ch)
	{
		int length  = s.length();

		return len <= length ? s : repeat(len - length, ch) + s;
	}

	public static String padLeading(String s, int len)
	{
		return padLeading(s, len, ' ');
	}

	public static String padTrailing(String s, int len, char ch)
	{
		int length  = s.length();

		return len <= length ? s : s + repeat(len - length, ch);
	}

	public static String padTrailing(String s, int len)
	{
		return padTrailing(s, len, ' ');
	}

	public static String repeat(int count, char ch)
	{
		return String.format("%0" + count + "d", 0).replace('0', ch);
	}

	public static String reverse(String s)
	{
		String str = "";

		for (int i = s.length() - 1; i >= 0; --i)
			str += s.charAt(i);

		return str;
	}

	public static String trimLeading(String s)
	{
		int i;
		int len = s.length();

		for (i = 0; i < len && Character.isWhitespace(s.charAt(i)); ++i)
			;

		return s.substring(i);
	}

	public static String trimTrailing(String s)
	{
		int i;


		for (i = s.length() - 1; i >= 0 && Character.isWhitespace(s.charAt(i)); --i)
			;

		return s.substring(0, i + 1);
	}
}

/*----------------------------------------------------------------
	FILE		: Point.java
	AUTHOR		: Java-Aug-2022 Group
	LAST UPDATE	: 22.01.2023

	Point class that represents 2 dimensional point in
	Cartesian plane

	Copyleft (c) 1993 C and System Programmers Association
	All Rights Free
----------------------------------------------------------------*/
package org.csystem.util.math.geometry;

public class Point {
	public double x;
	public double y;

	public Point()
	{
	}

	public Point(double a)
	{
		x = a;
	}

	public Point(double a, double b)
	{
		x = a;
		y = b;
	}

	public double distance()
	{
		return distance(0, 0);
	}

	public double distance(Point other)
	{
		return distance(other.x, other.y);
	}

	public double distance(double a, double b)
	{
		return Math.sqrt(Math.pow(x - a, 2) + Math.pow(y - b, 2));
	}

	public void offset(double dxy)
	{
		offset(dxy, dxy);
	}

	public void offset(double dx, double dy)
	{
		x += dx;
		y += dy;
	}

	public String toString()
	{
		return String.format("(%f, %f)", x, y);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	BallFall uygulaması
-----------------------------------------------------------------------------------------------------------------------*/

package org.csystem.app.ballfall;

public class BallFallApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		BallFall bf = new BallFall();

		for (;;) {
			System.out.print("Input width and height:");
			int width = kb.nextInt();
			int height = kb.nextInt();

			if (width == 0)
				break;

			bf.play(width, height);
			System.out.println(bf.shape);
		}
	}

}

package org.csystem.app.ballfall;

public class BallFall {
	public String shape;

	public void fillSpace(int begin, int end)
	{
		for (int i = begin; i < end; ++i)
			shape += ' ';
	}

	public void fillBall(int ballIndex, int end)
	{
		fillSpace(0, ballIndex);
		shape += '*';
		fillSpace(ballIndex + 1, end);
	}

	public static boolean updateRightFlag(boolean isRight, int ballIndex, int width)
	{
		if (ballIndex == 0)
			isRight = true;
		else if (ballIndex == width - 1)
			isRight = false;

		return isRight;
	}

	public static int updateBallIndex(boolean isRight, int ballIndex)
	{
		if (isRight)
			return ballIndex + 1;

		return ballIndex - 1;
	}

	public BallFall()
	{
		shape = "";
	}

	public void play(int width, int height)
	{
		shape = "";

		if (width != 1) {
			int ballIndex = 0;
			boolean isRight = false;

			for (int i = 1; i <= height; ++i) {
				shape += '|';
				fillBall(ballIndex, width);
				isRight = updateRightFlag(isRight, ballIndex, width);
				ballIndex = updateBallIndex(isRight, ballIndex);
				shape += "|\r\n";
			}
		}
		else
			for (int i = 1; i <= height; ++i)
				shape += "|*|\r\n";
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	04.02.2023
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------
	FILE		: NumberUtil.java
	AUTHOR		: Java-Aug-2022 Group
	LAST UPDATE	: 04.02.2023

	Utility class for numeric operations

	Copyleft (c) 1993 C and System Programmers Association
	All Rights Free
----------------------------------------------------------------*/
package org.csystem.util.numeric;

public class NumberUtil {
	public static int getDigitsPowSum(int val)
	{
		int n = countDigits(val);
		int total = 0;

		while (val != 0) {
			total += Math.pow(val % 10, n);
			val /= 10;
		}

		return total;
	}

	public static int countDigits(int val)
	{
		return (val != 0) ? ((int)Math.log10(Math.abs(val)) + 1) : 1;
	}

	public static long factorial(int n)
	{
		long result = 1;

		for (int i = 2; i <= n; ++i)
			result *= i;

		return result;
	}

	public static int getFibonacciNumber(int n)
	{
		if (n <= 2)
			return n - 1;

		int prev1 = 1, prev2 = 0, val = prev1 + prev2;

		for (int i = 3; i < n; ++i) {
			prev2 = prev1;
			prev1 = val;
			val = prev1 + prev2;
		}

		return val;
	}

	public static int getNextFibonacciNumber(int val)
	{
		if (val < 0)
			return 0;

		int prev1 = 1, prev2 = 0, next;

		for (;;) {
			next = prev1 + prev2;

			if (next > val)
				return next;

			prev2 = prev1;
			prev1 = next;
		}
	}

	public static long getPrime(int n)
	{
		long val = 2;
		int count = 0;

		for (;;) {
			if (isPrime(val))
				++count;

			if (count == n)
				return val;

			++val;
		}
	}

	public static boolean isArmstrong(int val)
	{
		return val >= 0 && getDigitsPowSum(val) == val;
	}

	public static boolean isEven(int val)
	{
		return val % 2 == 0;
	}

	public static boolean isOdd(int val)
	{
		return !isEven(val);
	}

	public static boolean isPrime(long val)
	{
		if (val <= 1)
			return false;

		if (val % 2 == 0)
			return val == 2;

		if (val % 3 == 0)
			return val == 3;

		if (val % 5 == 0)
			return val == 5;

		if (val % 7 == 0)
			return val == 7;

		for (long i = 11; i * i <= val; i += 2)
			if (val % i == 0)
				return false;

		return true;
	}

	public static double max(double a, double b, double c)
	{
		return Math.max(Math.max(a, b), c);
	}

	public static int mid(int a, int b, int c)
	{
		if (a <= b && b <= c || c <= b && b <= a)
			return b;

		if (b <= a && a <= c || c <= a && a <= b)
			return a;

		return c;
	}

	public static double min(double a, double b, double c)
	{
		return Math.min(Math.min(a, b), c);
	}

	public static int reverse(int val)
	{
		int result = 0;

		while (val != 0) {
			result = result * 10 + val % 10;
			val /= 10;
		}

		return result;
	}

	public static int sumDigits(int val)
	{
		int sum = 0;

		while (val != 0) {
			sum += val % 10;
			val /= 10;
		}

		return Math.abs(sum);
	}
}


/*----------------------------------------------------------------
	FILE		: StringUtil.java
	AUTHOR		: Java-Aug-2022 Group
	LAST UPDATE	: 04.02.2023

	Utility class for string operations

	Copyleft (c) 1993 C and System Programmers Association
	All Rights Free
----------------------------------------------------------------*/
package org.csystem.util.string;

public class StringUtil {

	public static String capitalize(String s)
	{
		return s.isEmpty() ? "" : Character.toUpperCase(s.charAt(0)) + s.substring(1).toLowerCase();
	}

	public static int countString(String s1, String s2)
	{
		int count = 0;

		for (int i = -1; (i = s1.indexOf(s2, i + 1)) != -1; ++count)
			;

		return count;
	}

	public static int countStringIgnoreCase(String s1, String s2)
	{
		return countString(s1.toLowerCase(), s2.toLowerCase());
	}

	public static String getRandomText(java.util.Random r, int n, String sourceText)
	{
		String str = "";

		int len = sourceText.length();

		for (int i = 0; i < n; ++i)
			str += sourceText.charAt(r.nextInt(len));

		return str;
	}

	public static String getRandomTextEN(int n)
	{
		return getRandomTextEN(new java.util.Random(), n);
	}

	public static String getRandomTextEN(java.util.Random r, int n)
	{
		return getRandomText(r, n, "abcdefghijklmnopqrstuwxvyzABCDEFGHIJKLMNOPQRSTUWVXYZ");
	}

	public static String getRandomTextTR(int n)
	{
		return getRandomTextTR(new java.util.Random(), n);
	}

	public static String getRandomTextTR(java.util.Random r, int n)
	{
		return getRandomText(r, n, "abcçdefgğhıijklmnoöprsştuüvyzABCÇDEFGĞHIİJKLMNOÖPRSŞTUÜVYZ");
	}

	public static String getShortestPangramEN(String s)
	{
		String result = s;

		int end = s.length();

		while (end != 0) {
			int begin = 0;

			while (begin != end) {
				String str = s.substring(begin++, end);

				if (str.length() >= 26 && isPangramEN(str) && str.length() < result.length())
					result = str;
			}

			--end;
		}

		return result;
	}

	public static String getShortestPangramTR(String s)
	{
		String result = s;

		int end = s.length();

		while (end != 0) {
			int begin = 0;

			while (begin != end) {
				String str = s.substring(begin++, end);

				if (str.length() >= 29 && isPangramTR(str) && str.length() < result.length())
					result = str;
			}

			--end;
		}

		return result;
	}

	public static boolean isPalindrome(String s)
	{
		int left = 0;
		int right = s.length() - 1;
		boolean cLeftSelected = false, cRightSelected = false;
		char cLeft = '\0', cRight;

		while (left < right) {
			if (!cLeftSelected) {
				cLeft = Character.toLowerCase(s.charAt(left));

				if (!Character.isLetter(cLeft)) {
					++left;
					continue;
				}
				cLeftSelected = true;
			}

			if (!cRightSelected) {
				cRight = Character.toLowerCase(s.charAt(right));

				if (!Character.isLetter(cRight)) {
					--right;
					continue;
				}

				if (cLeft != cRight)
					return false;

				cRightSelected = true;
			}

			++left;
			--right;

			cLeftSelected = cRightSelected = false;
		}

		return true;
	}

	public static boolean isPangram(String s, String alphabet)
	{
		int len = alphabet.length();

		for (int i = 0; i < len; ++i)
			if (s.indexOf(alphabet.charAt(i)) == -1)
				return false;

		return true;
	}

	public static boolean isPangramEN(String s)
	{
		return isPangram(s.toLowerCase(), "abcdefghijklmnopqrstuwxvyz");
	}

	public static boolean isPangramTR(String s)
	{
		return isPangram(s.toLowerCase(), "abcçdefgğhıijklmnoöprsştuüvyz");
	}

	public static String padLeading(String s, int len, char ch)
	{
		int length  = s.length();

		return len <= length ? s : repeat(len - length, ch) + s;
	}

	public static String padLeading(String s, int len)
	{
		return padLeading(s, len, ' ');
	}

	public static String padTrailing(String s, int len, char ch)
	{
		int length  = s.length();

		return len <= length ? s : s + repeat(len - length, ch);
	}

	public static String padTrailing(String s, int len)
	{
		return padTrailing(s, len, ' ');
	}

	public static String repeat(int count, char ch)
	{
		return String.format("%0" + count + "d", 0).replace('0', ch);
	}

	public static String reverse(String s)
	{
		String str = "";

		for (int i = s.length() - 1; i >= 0; --i)
			str += s.charAt(i);

		return str;
	}

	public static String trimLeading(String s)
	{
		int i;
		int len = s.length();

		for (i = 0; i < len && Character.isWhitespace(s.charAt(i)); ++i)
			;

		return s.substring(i);
	}

	public static String trimTrailing(String s)
	{
		int i;


		for (i = s.length() - 1; i >= 0 && Character.isWhitespace(s.charAt(i)); --i)
			;

		return s.substring(0, i + 1);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	İsim Arama (Name Lookup): Derleyici kullanılan bir ismi önce arar, eğer bulursa erşim kontrolünü yapar yani ismin
	doğru bir biçimde kullanılıp kullanılmadığına bakar. Derleyici isim aramayı belirli kurallara göre yapar. İsim arama
	için genel kurallar olduğu gibi özel durumlar için genel kuralların uygulanmaz. Yani kabacak genel ve özel kurallar
	olarak ayırabiliriz. Özel durumlara ilişkin detaylar da isim aramanın bir parçasıdır. Burada önce genel kurallar
	sonra özel durumlar için uygulanan kurallar anlatılacaktır
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Derleyici bildirimi yapılan isimleri bildirim noktasında aramaz. Kullanıldığı noktada aranır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		Sample.foo(); //Sample aranır, foo aranır
		//...
	}
}


class Sample { //Sample aranmaz
	public static void foo() //foo aranmaz
	{
		//...
		int a = 30; //a aranmaz

		a = 20; // a aranır
	}

}

/*----------------------------------------------------------------------------------------------------------------------
	Bir isim kod içerisinde iki şekilde kullanılabilir: nitelikli (qualified), niteliksiz (unqualified)
	Bir isim nokta operatörünün sağında kalıyorsa nitelikli, kalmıyorsa niteliksiz kullanılmış olur.

	Niteliksiz kullanılan isimler "niteliksiz isim arama (unqualified name lookup)" kurallarına göre, nitelikli
	kullanılan bir isimler de "nitelikli isim arama (qualified name lookup)" kurallarına göre aranır.

	Anahtar Notlar: Yukarıdaki tanımlarda nitelikli (qualified) ve niteliksiz (unqualified) olmak olumlu ya da olumsuz bir
	etki anlamında düşünülmemelidir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		Sample s; //Sample niteliksiz aranır, s aranmaz

		Sample.foo(); //Sample niteliksiz aranır, foo nitelikli aranır

		s = new Sample(); //s niteliksiz aranır, Sample niteliksiz aranır

		s.bar(); //s niteliksiz aranır, bar nitelikli aranır
		System.out.printf("s.a = %d%n", s.a); //System niteliksiz aranır, out nitelikli aranır, printf nitelikli aranır, s niteliksiz aranır, a nitelikli aranır
	}
}


class Sample { //Sample aranmaz
	public int a;

	public static void foo() //foo aranmaz
	{
		//...
		int a = 30; //a aranmaz

		a = 20; // a aranır
	}

	public void bar() //bar aranmaz
	{
		//...
	}

}

/*----------------------------------------------------------------------------------------------------------------------
	Derleyici bir ismi bulduktan sonra erişim kontrolünü yapar. Aşağıdaki örnekteki hata mesajlarını inceleyiniz
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		double a = 10;
		int b;

		b = a; //error
		b = 4.5; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz isim arama genel kuralları (else if biçiminde değerlendiriniz):
	1.Bir isim metot içerisinde kullanılmışsa, kullanıldığı yerden yukarıya doğru metot içerisinde aranır. Burada
	kullanılan isimden önce bildirilen yerel değişkenler ile metodun parametre değişken isimlerine bakılır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		int a;


		a = 10;
	}
}


class Sample {
	public void foo(int x)
	{
		int a;

		a = x;

		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz isim arama genel kuralları (else if biçiminde değerlendiriniz):
	2.İsim metodun ait olduğu sınıfın tamamında ancak tüm metotların dışında aranır. Burada isim bulunamazsa sırasıyla
	"doğrudan taban sınıfa (direct super class)" ve "dolaylı taban sınıflara (indirect super class)" da bakılır. Taban
	sınıf kavranı ileride detaylı bir biçimde ele alınacaktır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		Sample s;

		s = new Sample();

		s.foo(67);

		System.out.printf("s.a = %d%n", s.a);
	}
}


class Sample {
	public void foo(int x)
	{
		a = x;
	}

	public int a;

	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki iki kurala göre bir sınıfın veri elemanı ile aynı isimde metot parametre değişkeni veya yerel değişken
	bildirimi geçerlidir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		Sample s;

		s = new Sample();

		s.foo(67);

		System.out.printf("s.a = %d%n", s.a);
	}
}


class Sample {
	public int b;

	public void foo(int a)
	{
		int b; //shadowing, masking, hiding

		b = 10;

		++a;

		System.out.printf("foo:a = %d%n", a);
	}

	public int a;

	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz isim arama genel kuralları (else if biçiminde değerlendiriniz):
	3. İsim sınıfın ait olduğu paket içerisinde aranır. Burada alt paketlere ya da üst paketlere bakılmaz. Sadece ait
	olduğu pakete bakılır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		Sample s;

		s = new Sample();

		s.foo(67);

		System.out.printf("s.a = %d%n", s.a);
	}
}


class Sample {
	public int a;

	public void foo(int x)
	{
		a = x;
	}

	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz isim arama genel kuralları (else if biçiminde değerlendiriniz):
	3.İsim sınıfın ait olduğu paket içerisinde aranır. Burada alt paketlere ya da üst paketlere bakılmaz. Sadece ait
	olduğu pakete bakılır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		Sample s;

		s = new Sample();

		s.foo(67);

		System.out.printf("s.a = %d%n", s.a);
	}
}

package org.csystem.app;

public class Sample {
	public int a;

	public void foo(int x)
	{
		a = x;
	}

	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz isim arama genel kuralları (else if biçiminde değerlendiriniz):
	3.İsim sınıfın ait olduğu paket içerisinde aranır. Burada alt paketlere ya da üst paketlere bakılmaz. Sadece ait
	olduğu pakete bakılır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		Sample s = new Sample(); //error

	}
}

package org.csystem;

public class Sample {
	public int a;

	public void foo(int x)
	{
		a = x;
	}

	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz isim arama genel kuralları (else if biçiminde değerlendiriniz):
	3.İsim sınıfın ait olduğu paket içerisinde aranır. Burada alt paketlere ya da üst paketlere bakılmaz. Sadece ait
	olduğu pakete bakılır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		Sample s = new Sample(); //error

	}
}

package org.csystem.app.test;

public class Sample {
	public int a;

	public void foo(int x)
	{
		a = x;
	}

	//...
}


/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz isim arama genel kuralları (else if biçiminde değerlendiriniz):
	4."import on demand declaration" varsa o paketlere de bakılır. Bu konu ileride ele alınacaktır
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz kullanılan bir isim, niteliksiz isim arama genel kurallarına göre aranmış ve bulunamamışsa error oluşur
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki kurallara göre isimsiz paket altında bulunan bir UDT'ye başka bir paket içerisinden erişilemez. Nitelikli
	olarak da erişilemez. Yalnızca bu sebepten bile bir projede isimsiz paket altında UDT bildirilmemelidir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		Sample s = new Sample(); //error

	}
}


public class Sample {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Nitelikli isim arama genel kuralları (else if biçiminde değerlendiriniz):
	1.Aranacak ismin solunda sınıf ismi varsa, isim ilgili sınıf içerisinde aranır. Bulunamazsa taban sınıflara da bakılır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;


class App {
	public static void main(String [] args)
	{
		Sample.a = 10;
		Sample.foo(20);

		System.out.printf("Sample.a = %d%n", Sample.a);
	}
}

class Sample {
	public static int a;

	public static void foo(int x)
	{
		a = x;
	}

	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Nitelikli isim arama genel kuralları (else if biçiminde değerlendiriniz):
	2.Aranacak ismin solunda referans ismi varsa, isim referansa ilişkin UDT içerisinde aranır. Bulunamazsa taban sınıflara da
	bakılır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;


class App {
	public static void main(String [] args)
	{
		Sample s;

		s = new Sample();

		s.foo(34);

		System.out.printf("Sample.a = %d%n", s.a);
	}
}

class Sample {
	public int a;

	public void foo(int x)
	{
		a = x;
	}

	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Nitelikli isim arama genel kuralları (else if biçiminde değerlendiriniz):
	3.Aranacak ismin solunda paket ismi varsa, isim o paket içerisinde aranır. Alt ya da üst paketlere bakılmaz
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		test.Sample s;
	}
}


public class Sample {
	//...
}

package test;

public class Sample {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Nitelikli isim arama genel kuralları (else if biçiminde değerlendiriniz):
	3.Aranacak ismin solunda paket ismi varsa, isim o paket içerisinde aranır. Alt ya da üst paketlere bakılmaz
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		test.mest.Sample s; //error
	}
}

package test;

public class Sample {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Nitelikli isim arama genel kuralları (else if biçiminde değerlendiriniz):
	3.Aranacak ismin solunda paket ismi varsa, isim o paket içerisinde aranır. Alt ya da üst paketlere bakılmaz
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		test.Sample s; //error
	}
}

package test.mest;

public class Sample {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Alt paket isimleri niteliksiz isim aramaya dahil değildir. Yani aşağıdaki örnekte test ismi aranırken org.csystem.app
	içerisindeki test paket ismi dikkate alınmaz. Niteliksiz kullanılan bir ismin paket ismi olarak bulunabilmesi için
	"source folder" (eclipse'de default olarak src dizini) içerisinde bir paket olarak bulunması gerekir. Ya da başka
	bir deyişle üst paketinin olmaması gerekir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		test.Sample s; //error
	}
}

package org.csystem.app.test;

public class Sample {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	import bildirimi genel olarak niteliklendirmeyi azaltmak, dolayısıyla daha yalın ve açık (clean) kod yazımı için
	kullanılır.

	Anahtar Notlar: import bildirimi bir kütüphaneyi "projeye dahil etmek (import etmek)" anlamına GELMEZ

	import bildirimleri iki şekilde kullanılabilir:
	1. Yıldızlı import bildirimi (import on demand declaration)
	2. Yıldızsız import bildirimi (import single type declaration)

	import bildirimleri ".java" dosyasında (compilation unit) paket bildiriminden sonra, tüm diğer bildirimlerden
	önce yazılmalıdır. import bildirimleri bir derleme biriminden birden fazla olabilir. Yazılış sırasının önemi
	yoktur. import bildirimi bildirildiği derleme biriminde geçerlidir. Diğer derleme birimleri etkilenmez. import
	bildirimleri niteliksiz isim arama kurallarına ilişkindir. Nitelikli isim arama kurallarında import bildiriminin
	önemi yoktur.

	Anahtar Notlar: "Yıldızlı ve yıldızsız import bildirimi" cümleleri kolay anlatmak için Oğuz Karan tarafından
	uydurulmuştur. Şüphesiz teknik terimlerinin tercümleri bunlar değildir.
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Yıldızlı import bildiriminin (import on demand declaration) genel biçimi:
		import <paket ismi>[.alt paketler].*;

	Bu bildirim niteliksiz isim arama genel kurallarına göre, aranan isim paket içerisinde de bıulunamazsa aramak için
	bakılacak paketleri belirtir. Yani adeta bir paketin başka bir paket içerisine isim arama anlamında enjekte edilmesidir.

	Daha açık olarak bu bildirimler derleyiciye "eğer niteliksiz kullanılan bir ismi pakette bulamazsan yıldızlı import
	bildirimlerine ilişkin paketlerde de ara" demektir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.*;
import org.csystem.util.math.geometry.*;
import org.csystem.util.math.*;
import org.csystem.util.numeric.*;

class App {
	public static void main(String [] args)
	{
		Random r = new Random();
		Scanner kb = new Scanner(System.in);

		Point p = new Point(12.3, 6.6);
		System.out.println(NumberUtil.isPrime(r.nextInt(100)) ? "Asal" : "Asal değil");
		Complex z = new Complex();

		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yıldızlı import bildirimlerine ilişkin paketlerin hepsine bakılır. Birden fzla paket içerisinde aranan isim bulunursa
	error oluşur (ambiguity error).
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import test.*;
import mest.*;

class App {
	public static void main(String [] args)
	{
		Test t;
		Mample m;
		Sample s; //error: ambiguity
	}
}

package test;

public class Sample {
	//...
}

package mest;

public class Sample {
	//...
}

package test;

public class Mample {
	//...
}

package mest;

public class Test {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	05.02.2023
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Yıldızlı import bildiriminin bir kullanımı. Örnekte isimler için niteliklendirmenin azaltıldığına dikkat ediniz
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.*;
import org.csystem.util.math.*;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();

		for (int i = 0; i < n; ++i) {
			Complex z = new Complex(r.nextDouble(-10, 10), r.nextDouble(-10, 10));

			System.out.println(z.toString());
		}
	}
}

/*----------------------------------------------------------------
	FILE		: StringUtil.java
	AUTHOR		: Java-Aug-2022 Group
	LAST UPDATE	: 05.02.2023

	Utility class for string operations

	Copyleft (c) 1993 C and System Programmers Association
	All Rights Free
----------------------------------------------------------------*/
package org.csystem.util.string;

import java.util.*;

public class StringUtil {

	public static String capitalize(String s)
	{
		return s.isEmpty() ? "" : Character.toUpperCase(s.charAt(0)) + s.substring(1).toLowerCase();
	}

	public static int countString(String s1, String s2)
	{
		int count = 0;

		for (int i = -1; (i = s1.indexOf(s2, i + 1)) != -1; ++count)
			;

		return count;
	}

	public static int countStringIgnoreCase(String s1, String s2)
	{
		return countString(s1.toLowerCase(), s2.toLowerCase());
	}

	public static String getRandomText(Random r, int n, String sourceText)
	{
		String str = "";

		int len = sourceText.length();

		for (int i = 0; i < n; ++i)
			str += sourceText.charAt(r.nextInt(len));

		return str;
	}

	public static String getRandomTextEN(int n)
	{
		return getRandomTextEN(new Random(), n);
	}

	public static String getRandomTextEN(Random r, int n)
	{
		return getRandomText(r, n, "abcdefghijklmnopqrstuwxvyzABCDEFGHIJKLMNOPQRSTUWVXYZ");
	}

	public static String getRandomTextTR(int n)
	{
		return getRandomTextTR(new Random(), n);
	}

	public static String getRandomTextTR(Random r, int n)
	{
		return getRandomText(r, n, "abcçdefgğhıijklmnoöprsştuüvyzABCÇDEFGĞHIİJKLMNOÖPRSŞTUÜVYZ");
	}

	public static String getShortestPangramEN(String s)
	{
		String result = s;

		int end = s.length();

		while (end != 0) {
			int begin = 0;

			while (begin != end) {
				String str = s.substring(begin++, end);

				if (str.length() >= 26 && isPangramEN(str) && str.length() < result.length())
					result = str;
			}

			--end;
		}

		return result;
	}

	public static String getShortestPangramTR(String s)
	{
		String result = s;

		int end = s.length();

		while (end != 0) {
			int begin = 0;

			while (begin != end) {
				String str = s.substring(begin++, end);

				if (str.length() >= 29 && isPangramTR(str) && str.length() < result.length())
					result = str;
			}

			--end;
		}

		return result;
	}

	public static boolean isPalindrome(String s)
	{
		int left = 0;
		int right = s.length() - 1;
		boolean cLeftSelected = false, cRightSelected = false;
		char cLeft = '\0', cRight;

		while (left < right) {
			if (!cLeftSelected) {
				cLeft = Character.toLowerCase(s.charAt(left));

				if (!Character.isLetter(cLeft)) {
					++left;
					continue;
				}
				cLeftSelected = true;
			}

			if (!cRightSelected) {
				cRight = Character.toLowerCase(s.charAt(right));

				if (!Character.isLetter(cRight)) {
					--right;
					continue;
				}

				if (cLeft != cRight)
					return false;

				cRightSelected = true;
			}

			++left;
			--right;

			cLeftSelected = cRightSelected = false;
		}

		return true;
	}

	public static boolean isPangram(String s, String alphabet)
	{
		int len = alphabet.length();

		for (int i = 0; i < len; ++i)
			if (s.indexOf(alphabet.charAt(i)) == -1)
				return false;

		return true;
	}

	public static boolean isPangramEN(String s)
	{
		return isPangram(s.toLowerCase(), "abcdefghijklmnopqrstuwxvyz");
	}

	public static boolean isPangramTR(String s)
	{
		return isPangram(s.toLowerCase(), "abcçdefgğhıijklmnoöprsştuüvyz");
	}

	public static String padLeading(String s, int len, char ch)
	{
		int length  = s.length();

		return len <= length ? s : repeat(len - length, ch) + s;
	}

	public static String padLeading(String s, int len)
	{
		return padLeading(s, len, ' ');
	}

	public static String padTrailing(String s, int len, char ch)
	{
		int length  = s.length();

		return len <= length ? s : s + repeat(len - length, ch);
	}

	public static String padTrailing(String s, int len)
	{
		return padTrailing(s, len, ' ');
	}

	public static String repeat(int count, char ch)
	{
		return String.format("%0" + count + "d", 0).replace('0', ch);
	}

	public static String reverse(String s)
	{
		String str = "";

		for (int i = s.length() - 1; i >= 0; --i)
			str += s.charAt(i);

		return str;
	}

	public static String trimLeading(String s)
	{
		int i;
		int len = s.length();

		for (i = 0; i < len && Character.isWhitespace(s.charAt(i)); ++i)
			;

		return s.substring(i);
	}

	public static String trimTrailing(String s)
	{
		int i;


		for (i = s.length() - 1; i >= 0 && Character.isWhitespace(s.charAt(i)); --i)
			;

		return s.substring(0, i + 1);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Yıldızsız import bildiriminin (import single type declatration) genel biçimi:
		import <paket ismi>[.alt paketler].<udt ismi>;

	Bu bildirim udt isminin doğrudan kullanılabileceğini belirtir. Bu bildirimin yazılabildiği durumda bu udt ismi için
	niteliksiz isim arama genel kuralları uygulanmaz. Programcı mümkün olduğunca bu import bildirimini tercih etmelidir.
	Zaten bir çok IDE program da programcıyı genel olarak bu bildirime yönlendirir
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte
		import java.util.Scanner
	bildirimi "bu derleme biriminde Scanner ismi doğrudan kullanılabilir ve bu isim java.util.Scanner sınıfıdır" anlamına
	gelir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;
import org.csystem.util.math.Complex;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();

		for (int i = 0; i < n; ++i) {
			Complex z = new Complex(r.nextDouble(-10, 10), r.nextDouble(-10, 10));

			System.out.println(z.toString());
		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte Sample sınıfının niteliksiz kullanımına ilişkin birden fazla yıldızsız import bildirimi yapılmaya
	çalışıldığından error oluşur. Örnekte Sample ismi kullanılmazsa bile import bildiriminde error oluşur
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import mest.Sample;
import test.Sample; //error

class App {
	public static void main(String [] args)
	{
		Sample s;

	}
}

package test;

public class Sample {
	//...
}

package mest;

public class Sample {
	//...
}
/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte Sample ismi niteliksiz ism arama genel kuralları dolayısıyla org.csystem.app paketinde bulunan
	Sample sınıfının foo metodu çağrılır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import test.*;

class App {
	public static void main(String [] args)
	{
		Sample.foo();
	}
}

package org.csystem.app;

public class Sample {
	public static void foo()
	{
		System.out.println("org.csystem.app.Sample.foo");
	}
}

package test;

public class Sample {
	public static void foo()
	{
		System.out.println("test.Sample.foo");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte yıldızsız import bildirimi ile test paketindeki Sample ismi niteliksiz kullanır duruma gelmiştir.
	Yani örnekte niteliksiz isim arama genel kuralları Sample ismi için uygulanmaz
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import test.Sample;

class App {
	public static void main(String [] args)
	{
		Sample.foo();
	}
}

package org.csystem.app;

public class Sample {
	public static void foo()
	{
		System.out.println("org.csystem.app.Sample.foo");
	}
}

package test;

public class Sample {
	public static void foo()
	{
		System.out.println("test.Sample.foo");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte import bildiriminin yapıldığı java dosyasında Sample isminde bir sınıf bildirimi olduğundan
	yıldızsız import bildirimi geçersizdir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import test.Sample; //error

class App {
	public static void main(String [] args)
	{
		Sample.foo();
	}
}

class Sample {
	public static void foo()
	{
		System.out.println("org.csystem.app.Sample.foo");
	}
}

package test;

public class Sample {
	public static void foo()
	{
		System.out.println("test.Sample.foo");
	}
}

/*----------------------------------------------------------------
	FILE		: StringUtil.java
	AUTHOR		: Java-Aug-2022 Group
	LAST UPDATE	: 05.02.2023

	Utility class for string operations

	Copyleft (c) 1993 C and System Programmers Association
	All Rights Free
----------------------------------------------------------------*/
package org.csystem.util.string;

import java.util.Random;

public class StringUtil {

	public static String capitalize(String s)
	{
		return s.isEmpty() ? "" : Character.toUpperCase(s.charAt(0)) + s.substring(1).toLowerCase();
	}

	public static int countString(String s1, String s2)
	{
		int count = 0;

		for (int i = -1; (i = s1.indexOf(s2, i + 1)) != -1; ++count)
			;

		return count;
	}

	public static int countStringIgnoreCase(String s1, String s2)
	{
		return countString(s1.toLowerCase(), s2.toLowerCase());
	}

	public static String getRandomText(Random r, int n, String sourceText)
	{
		String str = "";

		int len = sourceText.length();

		for (int i = 0; i < n; ++i)
			str += sourceText.charAt(r.nextInt(len));

		return str;
	}

	public static String getRandomTextEN(int n)
	{
		return getRandomTextEN(new Random(), n);
	}

	public static String getRandomTextEN(Random r, int n)
	{
		return getRandomText(r, n, "abcdefghijklmnopqrstuwxvyz");
	}

	public static String getRandomTextTR(int n)
	{
		return getRandomTextTR(new Random(), n);
	}

	public static String getRandomTextTR(Random r, int n)
	{
		return getRandomText(r, n, "abcçdefgğhıijklmnoöprsştuüvyz");
	}

	public static String getShortestPangramEN(String s)
	{
		String result = s;

		int end = s.length();

		while (end != 0) {
			int begin = 0;

			while (begin != end) {
				String str = s.substring(begin++, end);

				if (str.length() >= 26 && isPangramEN(str) && str.length() < result.length())
					result = str;
			}

			--end;
		}

		return result;
	}

	public static String getShortestPangramTR(String s)
	{
		String result = s;

		int end = s.length();

		while (end != 0) {
			int begin = 0;

			while (begin != end) {
				String str = s.substring(begin++, end);

				if (str.length() >= 29 && isPangramTR(str) && str.length() < result.length())
					result = str;
			}

			--end;
		}

		return result;
	}

	public static boolean isPalindrome(String s)
	{
		int left = 0;
		int right = s.length() - 1;
		boolean cLeftSelected = false, cRightSelected = false;
		char cLeft = '\0', cRight;

		while (left < right) {
			if (!cLeftSelected) {
				cLeft = Character.toLowerCase(s.charAt(left));

				if (!Character.isLetter(cLeft)) {
					++left;
					continue;
				}
				cLeftSelected = true;
			}

			if (!cRightSelected) {
				cRight = Character.toLowerCase(s.charAt(right));

				if (!Character.isLetter(cRight)) {
					--right;
					continue;
				}

				if (cLeft != cRight)
					return false;

				cRightSelected = true;
			}

			++left;
			--right;

			cLeftSelected = cRightSelected = false;
		}

		return true;
	}

	public static boolean isPangram(String s, String alphabet)
	{
		int len = alphabet.length();

		for (int i = 0; i < len; ++i)
			if (s.indexOf(alphabet.charAt(i)) == -1)
				return false;

		return true;
	}

	public static boolean isPangramEN(String s)
	{
		return isPangram(s.toLowerCase(), "abcdefghijklmnopqrstuwxvyz");
	}

	public static boolean isPangramTR(String s)
	{
		return isPangram(s.toLowerCase(), "abcçdefgğhıijklmnoöprsştuüvyz");
	}

	public static String padLeading(String s, int len, char ch)
	{
		int length  = s.length();

		return len <= length ? s : repeat(len - length, ch) + s;
	}

	public static String padLeading(String s, int len)
	{
		return padLeading(s, len, ' ');
	}

	public static String padTrailing(String s, int len, char ch)
	{
		int length  = s.length();

		return len <= length ? s : s + repeat(len - length, ch);
	}

	public static String padTrailing(String s, int len)
	{
		return padTrailing(s, len, ' ');
	}

	public static String repeat(int count, char ch)
	{
		return String.format("%0" + count + "d", 0).replace('0', ch);
	}

	public static String reverse(String s)
	{
		String str = "";

		for (int i = s.length() - 1; i >= 0; --i)
			str += s.charAt(i);

		return str;
	}

	public static String trimLeading(String s)
	{
		int i;
		int len = s.length();

		for (i = 0; i < len && Character.isWhitespace(s.charAt(i)); ++i)
			;

		return s.substring(i);
	}

	public static String trimTrailing(String s)
	{
		int i;


		for (i = s.length() - 1; i >= 0 && Character.isWhitespace(s.charAt(i)); --i)
			;

		return s.substring(0, i + 1);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Java 5 ile birlikte import static bildirimleri dile dahil edilmiştir. import static bildirimlerinin de iki biçimi
	vardır:
	1. Yıldızlı import static bildirimi (import static on demand declaration)
	2. Yıldızsız import static bildirimi (import static single type declaration)

	import static bildirimleri okunabilirliği/algılanabilirliği etkilemedikten sonra kodu yalınlaştırır. Bu durumda
	programcının kullanırken okunabilirliği etkilemesi durumuna dikkat etmesi gerekir. import static bildirimleri de
	diğer import bildirimleri ile aynı yere yazılır ve yine sıranın önemi yoktur
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Yıldızlı import static bildiriminin (import static on demand declaration) genel biçimi:
		import static <paket ismi>[.alt paketler].<udt ismi>.*;

	Bu bildirim ile bildirimin yapıldığı derleme biriminde, bildirimi yapılan türün tüm static elemanları doğrudan
	kullanılabilir duruma gelir. Yine niteliksiz isim arama genel kurallarına göre eğer pakette bulunamazsa bu bildirime
	ilişkin tür içerisinde de aranır. Buradaki isim aramada bazı istisna kurallar vardır. Örneğin aşağıda sqrt isiminde
	bir sınıf bildirimi olsaydı bile yine sqrt ismi Math sınıfının metot ismi olarak bulunurdu
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import static java.lang.Math.*;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		double a = kb.nextDouble();

		System.out.printf("sqrt(%f) = %f%n", a, sqrt(a));
		System.out.printf("log10(%f) = %f%n", a, log10(a));
		System.out.printf("PI = %f%n", PI);
	}
}

/*----------------------------------------------------------------
	FILE		: Point.java
	AUTHOR		: Java-Aug-2022 Group
	LAST UPDATE	: 05.02.2023

	Point class that represents 2 dimensional point in
	Cartesian plane

	Copyleft (c) 1993 C and System Programmers Association
	All Rights Free
----------------------------------------------------------------*/
package org.csystem.util.math.geometry;

import static java.lang.Math.*;

public class Point {
	public double x;
	public double y;

	public Point()
	{
	}

	public Point(double a)
	{
		x = a;
	}

	public Point(double a, double b)
	{
		x = a;
		y = b;
	}

	public double distance()
	{
		return distance(0, 0);
	}

	public double distance(Point other)
	{
		return distance(other.x, other.y);
	}

	public double distance(double a, double b)
	{
		return sqrt(pow(x - a, 2) + pow(y - b, 2));
	}

	public void offset(double dxy)
	{
		offset(dxy, dxy);
	}

	public void offset(double dx, double dy)
	{
		x += dx;
		y += dy;
	}

	public String toString()
	{
		return String.format("(%f, %f)", x, y);
	}
}


/*----------------------------------------------------------------
	FILE		: Complex.java
	AUTHOR		: Java-Aug-2022 Group
	LAST UPDATE	: 05.02.2023

	Complex class that represents complex number

	Copyleft (c) 1993 C and System Programmers Association
	All Rights Free
----------------------------------------------------------------*/
package org.csystem.util.math;


import static java.lang.Math.*;


public class Complex {
	public double real;
	public double imag;

	public static Complex add(double re1, double im1, double re2, double im2)
	{
		return new Complex(re1 + re2, im1 + im2);
	}

	public static Complex subtract(double re1, double im1, double re2, double im2)
	{
		return add(re1, im1, -re2, -im2);
	}

	public static Complex multiply(double re1, double im1, double re2, double im2)
	{
		return new Complex(re1 * re2 - im1 * im2, re1 * im2 + re2 * im1);
	}

	public static Complex divide(double re1, double im1, double re2, double im2)
	{
		Complex z = multiply(re1, im1, re2, -im2);
		double divider = re1 * re1 + im1 * im2;

		z.real /= divider;
		z.imag /= divider;

		return z;
	}

	public Complex()
	{
	}

	public Complex(double re)
	{
		real = re;
	}

	public Complex(double re, double im)
	{
		real = re;
		imag = im;
	}

	public double getLength()
	{
		return sqrt(real * real + imag * imag);
	}

	public double getNorm()
	{
		return getLength();
	}

	public Complex getConjugate()
	{
		return new Complex(real, -imag);
	}

	public static Complex add(double val, Complex z)
	{
		return add(val, 0, z.real, z.imag);
	}

	public Complex add(Complex other)
	{
		return add(real, imag, other.real, other.imag);
	}

	public Complex add(double val)
	{
		return add(real, imag, val, 0);
	}

	public static Complex subtract(double val, Complex z)
	{
		return subtract(val, 0, z.real, z.imag);
	}

	public Complex subtract(Complex other)
	{
		return subtract(real, imag, other.real, other.imag);
	}

	public Complex subtract(double val)
	{
		return subtract(real, imag, val, 0);
	}

	public static Complex multiply(double val, Complex z)
	{
		return multiply(val, 0, z.real, z.imag);
	}

	public Complex multiply(Complex other)
	{
		return multiply(real, imag, other.real, other.imag);
	}

	public Complex multiply(double val)
	{
		return multiply(real, imag, val, 0);
	}

	public static Complex divide(double val, Complex z)
	{
		return divide(val, 0, z.real, z.imag);
	}

	public Complex divide(Complex other)
	{
		return divide(real, imag, other.real, other.imag);
	}

	public Complex divide(double val)
	{
		return divide(real, imag, val, 0);
	}

	public String toString()
	{
		return String.format("(%f, %f)", real, imag);
	}
}

/*----------------------------------------------------------------
	FILE		: NumberUtil.java
	AUTHOR		: Java-Aug-2022 Group
	LAST UPDATE	: 05.02.2023

	Utility class for numeric operations

	Copyleft (c) 1993 C and System Programmers Association
	All Rights Free
----------------------------------------------------------------*/
package org.csystem.util.numeric;

import static java.lang.Math.*;

public class NumberUtil {
	public static int getDigitsPowSum(int val)
	{
		int n = countDigits(val);
		int total = 0;

		while (val != 0) {
			total += pow(val % 10, n);
			val /= 10;
		}

		return total;
	}

	public static int countDigits(int val)
	{
		return (val != 0) ? ((int)log10(abs(val)) + 1) : 1;
	}

	public static long factorial(int n)
	{
		long result = 1;

		for (int i = 2; i <= n; ++i)
			result *= i;

		return result;
	}

	public static int getFibonacciNumber(int n)
	{
		if (n <= 2)
			return n - 1;

		int prev1 = 1, prev2 = 0, val = prev1 + prev2;

		for (int i = 3; i < n; ++i) {
			prev2 = prev1;
			prev1 = val;
			val = prev1 + prev2;
		}

		return val;
	}

	public static int getNextFibonacciNumber(int val)
	{
		if (val < 0)
			return 0;

		int prev1 = 1, prev2 = 0, next;

		for (;;) {
			next = prev1 + prev2;

			if (next > val)
				return next;

			prev2 = prev1;
			prev1 = next;
		}
	}

	public static long getPrime(int n)
	{
		long val = 2;
		int count = 0;

		for (;;) {
			if (isPrime(val))
				++count;

			if (count == n)
				return val;

			++val;
		}
	}

	public static boolean isArmstrong(int val)
	{
		return val >= 0 && getDigitsPowSum(val) == val;
	}

	public static boolean isEven(int val)
	{
		return val % 2 == 0;
	}

	public static boolean isOdd(int val)
	{
		return !isEven(val);
	}

	public static boolean isPrime(long val)
	{
		if (val <= 1)
			return false;

		if (val % 2 == 0)
			return val == 2;

		if (val % 3 == 0)
			return val == 3;

		if (val % 5 == 0)
			return val == 5;

		if (val % 7 == 0)
			return val == 7;

		for (long i = 11; i * i <= val; i += 2)
			if (val % i == 0)
				return false;

		return true;
	}

	public static double max(double a, double b, double c)
	{
		return Math.max(Math.max(a, b), c);
	}

	public static int mid(int a, int b, int c)
	{
		if (a <= b && b <= c || c <= b && b <= a)
			return b;

		if (b <= a && a <= c || c <= a && a <= b)
			return a;

		return c;
	}

	public static double min(double a, double b, double c)
	{
		return Math.min(Math.min(a, b), c);
	}

	public static int reverse(int val)
	{
		int result = 0;

		while (val != 0) {
			result = result * 10 + val % 10;
			val /= 10;
		}

		return result;
	}

	public static int sumDigits(int val)
	{
		int sum = 0;

		while (val != 0) {
			sum += val % 10;
			val /= 10;
		}

		return abs(sum);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yıldızsız import static bildiriminin (import static single type declaration) genel biçimi:
		import static <paket ismi>[.alt paketler].<udt ismi>.<static eleman ismi>;

	Bu bildirim ile belirtilen static eleman ilgili derleme biriminde doğrudan kullanılabilir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import static java.lang.Math.PI;
import static java.lang.Math.log10;
import static java.lang.Math.sqrt;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		double a = kb.nextDouble();

		System.out.printf("sqrt(%f) = %f%n", a, sqrt(a));
		System.out.printf("log10(%f) = %f%n", a, log10(a));
		System.out.printf("PI = %f%n", PI);
	}
}

/*----------------------------------------------------------------
	FILE		: Complex.java
	AUTHOR		: Java-Aug-2022 Group
	LAST UPDATE	: 05.02.2023

	Complex class that represents complex number

	Copyleft (c) 1993 C and System Programmers Association
	All Rights Free
----------------------------------------------------------------*/
package org.csystem.util.math;


import static java.lang.Math.sqrt;


public class Complex {
	public double real;
	public double imag;

	public static Complex add(double re1, double im1, double re2, double im2)
	{
		return new Complex(re1 + re2, im1 + im2);
	}

	public static Complex subtract(double re1, double im1, double re2, double im2)
	{
		return add(re1, im1, -re2, -im2);
	}

	public static Complex multiply(double re1, double im1, double re2, double im2)
	{
		return new Complex(re1 * re2 - im1 * im2, re1 * im2 + re2 * im1);
	}

	public static Complex divide(double re1, double im1, double re2, double im2)
	{
		Complex z = multiply(re1, im1, re2, -im2);
		double divider = re1 * re1 + im1 * im2;

		z.real /= divider;
		z.imag /= divider;

		return z;
	}

	public Complex()
	{
	}

	public Complex(double re)
	{
		real = re;
	}

	public Complex(double re, double im)
	{
		real = re;
		imag = im;
	}

	public double getLength()
	{
		return sqrt(real * real + imag * imag);
	}

	public double getNorm()
	{
		return getLength();
	}

	public Complex getConjugate()
	{
		return new Complex(real, -imag);
	}

	public static Complex add(double val, Complex z)
	{
		return add(val, 0, z.real, z.imag);
	}

	public Complex add(Complex other)
	{
		return add(real, imag, other.real, other.imag);
	}

	public Complex add(double val)
	{
		return add(real, imag, val, 0);
	}

	public static Complex subtract(double val, Complex z)
	{
		return subtract(val, 0, z.real, z.imag);
	}

	public Complex subtract(Complex other)
	{
		return subtract(real, imag, other.real, other.imag);
	}

	public Complex subtract(double val)
	{
		return subtract(real, imag, val, 0);
	}

	public static Complex multiply(double val, Complex z)
	{
		return multiply(val, 0, z.real, z.imag);
	}

	public Complex multiply(Complex other)
	{
		return multiply(real, imag, other.real, other.imag);
	}

	public Complex multiply(double val)
	{
		return multiply(real, imag, val, 0);
	}

	public static Complex divide(double val, Complex z)
	{
		return divide(val, 0, z.real, z.imag);
	}

	public Complex divide(Complex other)
	{
		return divide(real, imag, other.real, other.imag);
	}

	public Complex divide(double val)
	{
		return divide(real, imag, val, 0);
	}

	public String toString()
	{
		return String.format("(%f, %f)", real, imag);
	}
}


/*----------------------------------------------------------------
	FILE		: Point.java
	AUTHOR		: Java-Aug-2022 Group
	LAST UPDATE	: 05.02.2023

	Point class that represents 2 dimensional point in
	Cartesian plane

	Copyleft (c) 1993 C and System Programmers Association
	All Rights Free
----------------------------------------------------------------*/
package org.csystem.util.math.geometry;

import static java.lang.Math.pow;
import static java.lang.Math.sqrt;

public class Point {
	public double x;
	public double y;

	public Point()
	{
	}

	public Point(double a)
	{
		x = a;
	}

	public Point(double a, double b)
	{
		x = a;
		y = b;
	}

	public double distance()
	{
		return distance(0, 0);
	}

	public double distance(Point other)
	{
		return distance(other.x, other.y);
	}

	public double distance(double a, double b)
	{
		return sqrt(pow(x - a, 2) + pow(y - b, 2));
	}

	public void offset(double dxy)
	{
		offset(dxy, dxy);
	}

	public void offset(double dx, double dy)
	{
		x += dx;
		y += dy;
	}

	public String toString()
	{
		return String.format("(%f, %f)", x, y);
	}
}

/*----------------------------------------------------------------
	FILE		: NumberUtil.java
	AUTHOR		: Java-Aug-2022 Group
	LAST UPDATE	: 05.02.2023

	Utility class for numeric operations

	Copyleft (c) 1993 C and System Programmers Association
	All Rights Free
----------------------------------------------------------------*/
package org.csystem.util.numeric;

import static java.lang.Math.abs;
import static java.lang.Math.log10;
import static java.lang.Math.pow;

public class NumberUtil {
	public static int getDigitsPowSum(int val)
	{
		int n = countDigits(val);
		int total = 0;

		while (val != 0) {
			total += pow(val % 10, n);
			val /= 10;
		}

		return total;
	}

	public static int countDigits(int val)
	{
		return (val != 0) ? ((int)log10(abs(val)) + 1) : 1;
	}

	public static long factorial(int n)
	{
		long result = 1;

		for (int i = 2; i <= n; ++i)
			result *= i;

		return result;
	}

	public static int getFibonacciNumber(int n)
	{
		if (n <= 2)
			return n - 1;

		int prev1 = 1, prev2 = 0, val = prev1 + prev2;

		for (int i = 3; i < n; ++i) {
			prev2 = prev1;
			prev1 = val;
			val = prev1 + prev2;
		}

		return val;
	}

	public static int getNextFibonacciNumber(int val)
	{
		if (val < 0)
			return 0;

		int prev1 = 1, prev2 = 0, next;

		for (;;) {
			next = prev1 + prev2;

			if (next > val)
				return next;

			prev2 = prev1;
			prev1 = next;
		}
	}

	public static long getPrime(int n)
	{
		long val = 2;
		int count = 0;

		for (;;) {
			if (isPrime(val))
				++count;

			if (count == n)
				return val;

			++val;
		}
	}

	public static boolean isArmstrong(int val)
	{
		return val >= 0 && getDigitsPowSum(val) == val;
	}

	public static boolean isEven(int val)
	{
		return val % 2 == 0;
	}

	public static boolean isOdd(int val)
	{
		return !isEven(val);
	}

	public static boolean isPrime(long val)
	{
		if (val <= 1)
			return false;

		if (val % 2 == 0)
			return val == 2;

		if (val % 3 == 0)
			return val == 3;

		if (val % 5 == 0)
			return val == 5;

		if (val % 7 == 0)
			return val == 7;

		for (long i = 11; i * i <= val; i += 2)
			if (val % i == 0)
				return false;

		return true;
	}

	public static double max(double a, double b, double c)
	{
		return Math.max(Math.max(a, b), c);
	}

	public static int mid(int a, int b, int c)
	{
		if (a <= b && b <= c || c <= b && b <= a)
			return b;

		if (b <= a && a <= c || c <= a && a <= b)
			return a;

		return c;
	}

	public static double min(double a, double b, double c)
	{
		return Math.min(Math.min(a, b), c);
	}

	public static int reverse(int val)
	{
		int result = 0;

		while (val != 0) {
			result = result * 10 + val % 10;
			val /= 10;
		}

		return result;
	}

	public static int sumDigits(int val)
	{
		int sum = 0;

		while (val != 0) {
			sum += val % 10;
			val /= 10;
		}

		return abs(sum);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte  sqrt çağrısı için sınıfın int parametreli sqrt metodu bulunurç Bu durumda uygun metot bulunamayacağı
	için error oluşur. Anımsanacağı gibi isim bulunduktan sonra erişim kontrolü yapılır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import static java.lang.Math.PI;
import static java.lang.Math.log10;
import static java.lang.Math.sqrt;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		double a = kb.nextDouble();

		System.out.printf("sqrt(%f) = %f%n", a, sqrt(a)); //error
		System.out.printf("log10(%f) = %f%n", a, log10(a));
		System.out.printf("PI = %f%n", PI);
	}

	public static double sqrt(int val)
	{
		return Math.sqrt(val);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Diziler (Arrays): Elemanları aynı türden olan ve elemanların bellekte ardışıl olarak tutulduğu veri yapılarıdır.
	Java'da diziler sınıfsal olarak temsil edilir. Diziler bir referans türüdür. Öyleyse dizi türünden bir değişken bir
	referans değişkendir. Diziler heap'de yaratılır. Şüphesiz dizi referansları stack'te olabilir
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	T bir tür ismi olmak üzere T türden bir dizi referansı biğldirimi Java'da iki şekilde yapılabilir:
	1. T [] a;
	2. T a[];

"	Biz birinci biçimi tercih edeceğiz
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		int [] a; //Dizi referansı
		double b[]; //Dizi referansı
		boolean [] flags; //Dizi referansı
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	[]'in referans bildiriminde bulunduğu yere göre farkı
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		int [] a, b, c;
		int x[], y, z;

		a = 10; //error
		b = 20; //error
		c = 20; //error

		x = 34; //error
		y = 23;
		z = 67;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Dizi yaratmak için new operatörü kullanılır: Dizi yaratmanın genel biçimi:
	new <tür>[<negatif olmayan int türüne dönüşebilen türden eleman sayısı değeri>];
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		int [] a;

		a = new int[10];
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Dizinin eleman sayısının sabit ifadesi olması gibi bir zorunluluk yoktur. Dizinin eleman sayısı length isimli
	veri elemanı ile elde dilebilir. Dizilerin eleman sayıları değiştirilemez. Dolayısıyla length veri elemanı da
	değiştirilemez
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		int [] a = new int[count];
		System.out.printf("Dizinin eleman sayısı:%d%n", a.length);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Dizinin elemanlarına [] operatörü ile erişilir. Bu operatör özel amaçlı, iki operandlı ve araek durumunda bir
	operatördür. Operatörün birinci operandı dizi referansı olmalıdır. İkinci operandı int türden bir değer alır. Bu değer
	dizinin elemanına ilişkin indeks değeridir. Bu değer sıfırdan başlar. indeks değeri olarak pozitif ya da negatif
	bakımdan sınırlar dışında değer verildiğinde exception oluşur. Buna göre indeksin sınırları [0, length) aralığıdır.
	Bu aldığı indeks numarasında bulunan elemana ilişkin değişkeni üretir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		int [] a = new int[count];
		System.out.printf("Dizinin eleman sayısı:%d%n", a.length);

		for (int i = 0; i < a.length; ++i)
			a[i] = i * 10;

		for (int i = 0; i < a.length; ++i)
			System.out.printf("%d ", a[i]);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Dizi elemanlarına erişim
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		int [] a = new int[count];
		System.out.printf("Dizinin eleman sayısı:%d%n", a.length);

		for (int i = 0; i < a.length; ++i)
			a[i] = r.nextInt(100);

		for (int i = 0; i < a.length; ++i)
			System.out.printf("%02d ", a[i]);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir dizi yaratıldığında tüm elemanlarına default değerler atanır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		int [] a = new int[count];
		boolean [] b = new boolean[count];

		for (int i = 0; i < count; ++i)
			System.out.printf("%d ", a[i]);

		System.out.println();

		for (int i = 0; i < count; ++i)
			System.out.printf("%b ", b[i]);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    18.02.2023
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Dizilere ildeğer verilmesi (initialization) küme parantezi ile yapılır. Burada [] içerisinin boş bıraklılması zorunludur.
	Aşağıdaki örnekte diziye ilkdeğer verilmiştir ancak diziyi gösteren referansa ilkdeğer verilmemiştir. Atama yapılmıştır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		int [] a;

		a = new int[] {1, 2, 3, 4, 5, 6, 7};

		for (int i = 0; i < a.length; ++i)
			System.out.printf("%d ", a[i]);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Diziye ilkdeğer verme ifadesi, bir referansa da (şüphesiz aynı türden dizi referansı) ilk değer verme ifadesi olarak
	veriliyorsa bu durumda new operatörü yazılmayabilir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		int [] a = {1, 2, 3, 4, 5, 6, 7};

		for (int i = 0; i < a.length; ++i)
			System.out.printf("%d ", a[i]);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte referansa ilk değer verilmediği için error oluşur
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		int [] a;

		a = {1, 2, 3, 4, 5, 6, 7}; //error

		for (int i = 0; i < a.length; ++i)
			System.out.printf("%d ", a[i]);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Diziye ilkdeğer olarak verilen elemanlar sabit ifadesi olmak zorunda değildir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = kb.nextInt();
		int [] a = {val, val + 2, val + 4, val + 6};

		for (int i = 0; i < a.length; ++i)
			System.out.printf("%d ", a[i]);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun parametresi dizi referansı olabilir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import static org.csystem.util.array.ArrayUtil.print;

class App {
	public static void main(String [] args)
	{
		int [] a = {1, 2, 3, 4, 5};
		int [] b = {10, 20, 30, 40};

		print(2, a);
		print(b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun parametresi dizi referansı olabilir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import static org.csystem.util.array.ArrayUtil.print;
import static org.csystem.util.array.ArrayUtil.swap;

class App {
	public static void main(String [] args)
	{
		int [] a = {1, 2, 3, 4, 5};

		print(a);
		swap(a, 1, 4);
		print(a);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun paerametresi dizi referansı olabilir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.*;

class App {
	public static void main(String [] args)
	{
		Random random = new Random();
		Scanner kb = new Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int [] a = new int[kb.nextInt()];

		fillRandomArray(random, a, 0, 100);
		print(a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.*;

class App {
	public static void main(String [] args)
	{
		Random random = new Random();
		Scanner kb = new Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		double [] a = new double[kb.nextInt()];

		fillRandomArray(random, a, 2.345, 9.789);
		print(a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun geri dönüş değeri bir dizi referansı olabilir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.getRandomArray;
import static org.csystem.util.array.ArrayUtil.print;

class App {
	public static void main(String [] args)
	{
		Random random = new Random();
		Scanner kb = new Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int [] a = getRandomArray(random, kb.nextInt(), 0, 100);

		print(a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.getRandomArray;
import static org.csystem.util.array.ArrayUtil.print;

class App {
	public static void main(String [] args)
	{
		Random random = new Random();
		Scanner kb = new Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		double [] a = getRandomArray(random, kb.nextInt(), 2.345, 9.789);

		print(a);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir dizinin elemanlarının toplamına geri dönen sum isimli
	metodu ArrayUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.array.test;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.*;

public class SumTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();

        System.out.print("Sınır değerleri giriniz:");
        int min = kb.nextInt();
        int bound = kb.nextInt();

        for (;;) {
            System.out.print("Dizinin eleman sayısını giriniz:");
            int count = kb.nextInt();

            if (count <= 0)
                break;

            int [] a  = getRandomArray(r, count, min, bound);

            print(a);
            System.out.printf("Toplam:%d%n", sum(a));
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }

    public static void main(String [] args)
    {
        run();
    }
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir dizinin elemanlarını ters yüz eden reverse isimli metodu başka
	bir dizi kullanmadan ArrayUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.array.test;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.*;

public class ReverseTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();
        for (;;) {
            System.out.print("Dizinin eleman sayısını giriniz:");
            int count = Integer.parseInt(kb.nextLine());

            if (count <= 0)
                break;

            int [] a  = getRandomArray(r, count, 0, 99);

            print(2, a);
            reverse(a);
            print(2, a);
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }

    public static void main(String [] args)
    {
        run();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir dizinin elemanlarını ters yüz eden reverse isimli metodu başka
	bir dizi kullanmadan ArrayUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.*;

class App {
	public static void main(String [] args)
	{
		ReverseTest.run();
	}
}

class ReverseTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();
		for (;;) {
			System.out.print("Dizinin eleman sayısını giriniz:");
			int count = Integer.parseInt(kb.nextLine());

			if (count <= 0)
				break;

			int [] a  = getRandomArray(r, count, 0, 99);

			print(2, a);
			Util.reverse(a);
			print(2, a);
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}


class Util {
	public static void reverse(int [] a)
	{
		int left = 0;
		int right = a.length - 1;

		while (left < right)
			swap(a, left++, right--);
	}

	public static int sum(int [] a)
	{
		int total = 0;

		for (int i = 0; i < a.length; ++i)
			total += a[i];

		return total;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Java'da length bilgisi sıfır olan bir dizi yaratılabilir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		int [] a = new int[0];
		int [] b = {};
		int [] c;

		c = new int[]{};

		System.out.printf("Length:%d%n", a.length);
		System.out.printf("Length:%d%n", b.length);
		System.out.printf("Length:%d%n", c.length);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı long türden bir sayının basamaklarından oluşan diziyi döndüren getDigits
	isimli metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
-----------------------------------------------------------------------------------------------------------------------*/

package org.csystem.util.numeric.test;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.*;
import static org.csystem.util.numeric.NumberUtil.*;

public class GetDigitsTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();

        System.out.print("Bir sayı giriniz:");
        int n = kb.nextInt();

        while (n-- > 0) {
            long val = r.nextLong();
            System.out.printf("%d -> ", val);
            print(getDigits(val));
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }

    public static void main(String [] args)
    {
        run();
    }
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı iki tane int türden dizinin birleşiminden oluşan yeni bir dizi referansına
	geri dönen join isimli metodu ArrayUtil sınıfında yazınız ve aşağıdaki kod ile test ediniz
-----------------------------------------------------------------------------------------------------------------------*/

package org.csystem.util.array.test;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.*;

public class JoinArraysTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();
        for (;;) {
            System.out.print("Dizilerin eleman sayılarını giriniz:");
            int count1 = kb.nextInt();
            int count2 = kb.nextInt();

            if (count1 <= 0 && count2 <= 0)
                break;

            int [] a  = getRandomArray(r, count1, 0, 100);
            int [] b  = getRandomArray(r, count2, 0, 100);

            print(2, a);
            print(2, b);
            print(2, join(a, b));
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }

    public static void main(String [] args)
    {
        run();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Sınıf Çalışması: Parametresi ile aldığı int türden bir dizinin en büyük ve en küçük elemanlarının değerlerine geri dönen
    min ve max isimli metotları ArrayUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.array.test;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.*;

public class MinMaxTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();

        System.out.print("Sınır değerleri giriniz:");
        int min = kb.nextInt();
        int bound = kb.nextInt();

        for (;;) {
            System.out.print("Dizinin eleman sayısını giriniz:");
            int count = kb.nextInt();

            if (count <= 0)
                break;

            int [] a  = getRandomArray(r, count, min, bound);

            print(a);
            System.out.printf("En küçük değer:%d%n", min(a));
            System.out.printf("En büyük değer:%d%n", max(a));
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }

    public static void main(String [] args)
    {
        run();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    19.02.2023
-----------------------------------------------------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------------------------------------------------
	Dizilerin sıraya dizilmesi (sorting):
	Dizilerin sıraya dizilmesine yönelik pek çok algoritma bulunmaktadır.  Sıralama işleminin küçükten büyüğe yani artan
	sırada (ascending order) yapılmasına doğal sıralama (natural sort order) denir. Biz burada "kabarcık sıralama (bubble sort)" ve
	"seçerek sıralama (selection sort) algoritmalarını kodlayacağız. Algoritmalar doğal sıralama şeklinde anlatılacaktır.
	Ancak her iki sıralama da (ascending ve descending) kodlanacaktır

	Anahtar Notlar: Algoritmaların karşılaştırılmasına yönelik iki ölçüt vardır: hız (speed), kaynak kullanımı (resource usage).
	Burada baskın ölçüt hızdır. Burada kabarcık sıralama ve seçerek sıralama algoritmaları karşılaştırılmayacaktır.
	"Algoritma Analizi" isimli konuda bu iki algoritmanın karşılaştırılması yapılacaktır
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Kabarcık sıralama algoritmasında dizinin yanyana iki elemanı karşılaştırılır ve duruma göre yer değiştirilir. Her
	yinelemede en büyük eleman saraltılmnış dizinin sonuna gider. Böylece her yinelemede eskisinden bir geriye kadar
	gitmek yeterli olur
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.array.test;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.*;

public class BubbleSortTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();

        for (;;) {
            System.out.print("Dizinin eleman sayısını giriniz:");
            int count = Integer.parseInt(kb.nextLine());

            if (count <= 0)
                break;

            int [] a  = getRandomArray(r, count, 0, 100);

            print(2, a);

            boolean desc = r.nextBoolean();

            bubbleSort(a, desc);

            System.out.printf("%s sıralanmış dizi:%n", desc ? "Büyükten küçüğe" : "Küçükten büyüğe");

            print(2, a);
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }

    public static void main(String [] args)
    {
        run();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Seçerek sıralama algoritmasında en küçük eleman bulunur, ilk eleman ile yer değiştirilir. Dizi bir daraltılır, aynı şey
	daraltılmış dizi için yapılır. Böylece ilerlenir
-----------------------------------------------------------------------------------------------------------------------*/

package org.csystem.util.array.test;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.*;

public class SelectionSortTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();

        for (;;) {
            System.out.print("Dizinin eleman sayısını giriniz:");
            int count = Integer.parseInt(kb.nextLine());

            if (count <= 0)
                break;

            int [] a  = getRandomArray(r, count, 0, 100);

            print(2, a);

            boolean desc = r.nextBoolean();

            selectionSort(a, desc);

            System.out.printf("%s sıralanmış dizi:%n", desc ? "Büyükten küçüğe" : "Küçükten büyüğe");

            print(2, a);
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }

    public static void main(String [] args)
    {
        run();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Sayısal loto kuponu üreten programı yazınız
	(İleride daha iyisi yazılacaktır)
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.lottery.NumericLotteryApp;

class App {
	public static void main(String [] args)
	{
		NumericLotteryApp.run();
	}
}

package org.csystem.app.lottery;

import org.csystem.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

public class NumericLotteryApp {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();
        NumericLottery numericLottery = new NumericLottery(r);

        for (;;) {
            System.out.print("Kaç tane kupon oynamak istersiniz?");
            int count = Integer.parseInt(kb.nextLine());

            if (count <= 0)
                break;

            while (count-- > 0)
                ArrayUtil.print(2, numericLottery.getNumbers());
        }
    }
}
package org.csystem.app.lottery;

import org.csystem.util.array.ArrayUtil;

import java.util.Random;

public class NumericLottery {
    public Random random;

    public NumericLottery()
    {
        random = new Random();
    }

    public NumericLottery(Random r)
    {
        random = r;
    }
    public int [] getNumbers()
    {
        int [] numbers = new int[6];

        for (int i = 0; i < 6; ++i) {
            boolean repeat;

            do {
                repeat = false;
                numbers[i] = random.nextInt(1, 50);

                for (int k = 0; k < i; ++k)
                    if (numbers[i] == numbers[k]) {
                        repeat = true;
                        break;
                    }
            } while (repeat);
        }

        ArrayUtil.bubbleSort(numbers);

        return numbers;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Sayısal loto kuponu üreten programı yazınız
	(İleride daha iyisi yazılacaktır)
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.lottery.NumericLotteryApp;

class App {
	public static void main(String [] args)
	{
		NumericLotteryApp.run();
	}
}

package org.csystem.app.lottery;

import org.csystem.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

public class NumericLotteryApp {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();
        NumericLottery numericLottery = new NumericLottery(r);

        for (;;) {
            System.out.print("Kaç tane kupon oynamak istersiniz?");
            int count = Integer.parseInt(kb.nextLine());

            if (count <= 0)
                break;

            while (count-- > 0)
                ArrayUtil.print(2, numericLottery.getNumbers());
        }
    }
}

package org.csystem.app.lottery;

import java.util.Random;

public class NumericLottery {
    public Random random;

    public static int [] getNumbers(boolean [] flags)
    {
        int [] numbers = new int[6];

        int idx = 0;

        for (int i = 1; i < 50; ++i)
            if (flags[i])
                numbers[idx++] = i;

        return numbers;
    }

    public boolean [] getFlags()
    {
        boolean [] flags = new boolean[50];

        for (int i = 0; i < 6; ++i) {
            int val;

            for (;;) {
                val = random.nextInt(1, 50);

                if (!flags[val])
                    break;
            }
            flags[val] = true;
        }

        return flags;
    }

    public NumericLottery()
    {
        random = new Random();
    }

    public NumericLottery(Random r)
    {
        random = r;
    }
    public int [] getNumbers()
    {
        return getNumbers(getFlags());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	images dizininde bulunan firstNotRepeatingCharacter.jpeg dosyasındaki sorunun bir çözümü
	Not: İleride daha iyisi yazılacaktır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.lottery.NumericLotteryApp;
import org.csystem.util.string.StringUtil;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		FirstNonRepeatingCharacterTest.run();
	}
}


class FirstNonRepeatingCharacterTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);

		FirstNonRepeatingCharacterInputTest.run(kb);
		FirstNonRepeatingCharacterRandomTest.run(kb);
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class FirstNonRepeatingCharacterRandomTest {
	public static void run(Scanner kb)
	{
		Random r = new Random();
		System.out.print("Input a number:");
		int count = Integer.parseInt(kb.nextLine());

		while (count-- > 0) {
			System.out.println("-------------------------------------------");
			String s = StringUtil.getRandomTextEN(r, r.nextInt(2, 21)).toLowerCase();

			System.out.println(s);
			char ch = Util.firstNonRepeatingCharacter(s);

			System.out.printf("%s%n", ch == '_' ? "No \"non-repeating\" character" : "First non repeating character is:'" + ch + "'");
			System.out.println("-------------------------------------------");
		}
	}
}

class FirstNonRepeatingCharacterInputTest {
	public static void run(Scanner kb)
	{
		for (;;) {
			System.out.print("Input a text:");
			String s = kb.nextLine();

			char ch = Util.firstNonRepeatingCharacter(s);

			System.out.printf("%s%n", ch == '_' ? "No \"non-repeating\" character" : "First non repeating character is:'" + ch + "'");

			if ("quit".equals(s))
				break;
		}
	}
}

class Util {
	public static char firstNonRepeatingCharacter(String s)
	{
		int [] counts = new int[26];
		int len = s.length();

		for (int i = 0; i < len; ++i)
			++counts[s.charAt(i) - 'a'];

		for (int i = 0; i < len; ++i) {
			char ch = s.charAt(i);

			if (counts[ch - 'a'] == 1)
				return ch;
		}

		return '_';
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Partition algoritması: Bu algoritmada dizinin belirli bir koşula uyan elemanları dizinin mantıksal olarak solunda,
	uymayanlar ise dizinin mantıksal olarak bulunur. Buna göre dizi, ismine "partition point" ile ayrılmıştır. Aslında
	"partition point"'in solunda olanlar koşulan uyan elemanlar olur. Bu algoritmada önce ilk koşula ıuymayan eleman bulunur
	Bulunduktan sonra o elemandan sonra gelen elemandan başlanarak duruma göre yer değiştirme yapılır. Yer değiştirme
	yapıldıkça ilk koşula uymayan elemanı gösteren indekx yani "partition index" ilerletilir
-----------------------------------------------------------------------------------------------------------------------*/

package org.csystem.util.array.test;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.*;

public class PartitionTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();

        for (;;) {
            System.out.print("Dizinin eleman sayısını giriniz:");
            int count = Integer.parseInt(kb.nextLine());

            if (count <= 0)
                break;

            System.out.print("Eşik değerini giriniz:");
            int threshold = Integer.parseInt(kb.nextLine());

            int [] a  = getRandomArray(r, count, 0, 100);
            System.out.println("-----------------------------------------------------------");
            print(2, a);
            int partitionPoint = partition(a, threshold);
            System.out.printf("Bölümleme noktası:%d%n", partitionPoint);
            print(2, a);
            System.out.println("-----------------------------------------------------------");
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }

    public static void main(String [] args)
    {
        run();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Aşağıdaki açıklamalara göre getHistogramData isimli metodu ArrayUtil sınıfı içerisinde yazınız
	ve aşağıdaki kod ile test ediniz:
	Açıklamalar:
		- Metot int türden bir dizi ve int türden bir n sayısı alacaktır:
			int [] getHistogramData(int [] a, int n)

		- Metot a dizisi içerisinde [0, n] aralığındaki sayılardan jhangisinin kaç tane olduğunu içeren bir sayaç dizisine
		geri dönecektir

		- Sayaç dizisinin her bir indeks numarası [0, n] aralığındaki sayıyı temsil edecektir. Yani örneğinb sıfır numaralı
		indeksteki değer sıfır sdayısının kaç tane olduğu bilgisini içerecektir
-----------------------------------------------------------------------------------------------------------------------*/

package org.csystem.util.array.test;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.*;

public class GetHistogramTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();

        for (;;) {
            System.out.print("Dizinin eleman sayısını giriniz:");
            int count = Integer.parseInt(kb.nextLine());

            if (count <= 0)
                break;

            int [] a  = getRandomArray(r, count, 0, 11);
            System.out.println("-----------------------------------------------------------");
            print(a);
            print(getHistogramData(a, 10));
            System.out.println("-----------------------------------------------------------");
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }

    public static void main(String [] args)
    {
        run();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	ArrayUtil sınıfının drawHistogram metodu. Homework-011'de merkezi limit teoremi için önce bu metodu kullanınız. Daha
	sonra metodu çalışma sorusunda istendiği şekilde yazınız. Ya da önce drawHistogram metodunu çalışma sorusunda istendiği
	gibi yazıp aşağıdaki kod ile test ediniz ve daha sonra merkezi limit teoremi için olan kısmı yazınız
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.array.test;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.*;

public class DrawHistogramTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();

        for (;;) {
            System.out.print("Dizinin eleman sayısını giriniz:");
            int count = Integer.parseInt(kb.nextLine());

            if (count <= 0)
                break;

            int [] a  = getRandomArray(r, count, 0, 11);
            System.out.println("-----------------------------------------------------------");
            print(a);
            int [] data = getHistogramData(a, 10);
            print(data);
            System.out.println("Histogram:");
            drawHistogram(data, 10, 'X');
            System.out.println("-----------------------------------------------------------");
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }

    public static void main(String [] args)
    {
        run();
    }
}
/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte  sqrt çağrısı için sınıfın int parametreli sqrt metodu bulunurç Bu durumda uygun metot bulunamayacağı
	için error oluşur. Anımsanacağı gibi isim bulunduktan sonra erişim kontrolü yapılır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import static java.lang.Math.PI;
import static java.lang.Math.log10;
import static java.lang.Math.sqrt;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		double a = kb.nextDouble();

		System.out.printf("sqrt(%f) = %f%n", a, sqrt(a)); //error
		System.out.printf("log10(%f) = %f%n", a, log10(a));
		System.out.printf("PI = %f%n", PI);
	}

	public static double sqrt(int val)
	{
		return Math.sqrt(val);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Diziler (Arrays): Elemanları aynı türden olan ve elemanların bellekte ardışıl olarak tutulduğu veri yapılarıdır.
	Java'da diziler sınıfsal olarak temsil edilir. Diziler bir referans türüdür. Öyleyse dizi türünden bir değişken bir
	referans değişkendir. Diziler heap'de yaratılır. Şüphesiz dizi referansları stack'te olabilir
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	T bir tür ismi olmak üzere T türden bir dizi referansı biğldirimi Java'da iki şekilde yapılabilir:
	1. T [] a;
	2. T a[];

"	Biz birinci biçimi tercih edeceğiz
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		int [] a; //Dizi referansı
		double b[]; //Dizi referansı
		boolean [] flags; //Dizi referansı
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	[]'in referans bildiriminde bulunduğu yere göre farkı
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		int [] a, b, c;
		int x[], y, z;

		a = 10; //error
		b = 20; //error
		c = 20; //error

		x = 34; //error
		y = 23;
		z = 67;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Dizi yaratmak için new operatörü kullanılır: Dizi yaratmanın genel biçimi:
	new <tür>[<negatif olmayan int türüne dönüşebilen türden eleman sayısı değeri>];
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		int [] a;

		a = new int[10];
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Dizinin eleman sayısının sabit ifadesi olması gibi bir zorunluluk yoktur. Dizinin eleman sayısı length isimli
	veri elemanı ile elde dilebilir. Dizilerin eleman sayıları değiştirilemez. Dolayısıyla length veri elemanı da
	değiştirilemez
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		int [] a = new int[count];
		System.out.printf("Dizinin eleman sayısı:%d%n", a.length);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Dizinin elemanlarına [] operatörü ile erişilir. Bu operatör özel amaçlı, iki operandlı ve araek durumunda bir
	operatördür. Operatörün birinci operandı dizi referansı olmalıdır. İkinci operandı int türden bir değer alır. Bu değer
	dizinin elemanına ilişkin indeks değeridir. Bu değer sıfırdan başlar. indeks değeri olarak pozitif ya da negatif
	bakımdan sınırlar dışında değer verildiğinde exception oluşur. Buna göre indeksin sınırları [0, length) aralığıdır.
	Bu aldığı indeks numarasında bulunan elemana ilişkin değişkeni üretir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		int [] a = new int[count];
		System.out.printf("Dizinin eleman sayısı:%d%n", a.length);

		for (int i = 0; i < a.length; ++i)
			a[i] = i * 10;

		for (int i = 0; i < a.length; ++i)
			System.out.printf("%d ", a[i]);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Dizi elemanlarına erişim
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		int [] a = new int[count];
		System.out.printf("Dizinin eleman sayısı:%d%n", a.length);

		for (int i = 0; i < a.length; ++i)
			a[i] = r.nextInt(100);

		for (int i = 0; i < a.length; ++i)
			System.out.printf("%02d ", a[i]);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir dizi yaratıldığında tüm elemanlarına default değerler atanır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		int [] a = new int[count];
		boolean [] b = new boolean[count];

		for (int i = 0; i < count; ++i)
			System.out.printf("%d ", a[i]);

		System.out.println();

		for (int i = 0; i < count; ++i)
			System.out.printf("%b ", b[i]);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    18.02.2023
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Dizilere ildeğer verilmesi (initialization) küme parantezi ile yapılır. Burada [] içerisinin boş bıraklılması zorunludur.
	Aşağıdaki örnekte diziye ilkdeğer verilmiştir ancak diziyi gösteren referansa ilkdeğer verilmemiştir. Atama yapılmıştır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		int [] a;

		a = new int[] {1, 2, 3, 4, 5, 6, 7};

		for (int i = 0; i < a.length; ++i)
			System.out.printf("%d ", a[i]);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Diziye ilkdeğer verme ifadesi, bir referansa da (şüphesiz aynı türden dizi referansı) ilk değer verme ifadesi olarak
	veriliyorsa bu durumda new operatörü yazılmayabilir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		int [] a = {1, 2, 3, 4, 5, 6, 7};

		for (int i = 0; i < a.length; ++i)
			System.out.printf("%d ", a[i]);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte referansa ilk değer verilmediği için error oluşur
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		int [] a;

		a = {1, 2, 3, 4, 5, 6, 7}; //error

		for (int i = 0; i < a.length; ++i)
			System.out.printf("%d ", a[i]);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Diziye ilkdeğer olarak verilen elemanlar sabit ifadesi olmak zorunda değildir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = kb.nextInt();
		int [] a = {val, val + 2, val + 4, val + 6};

		for (int i = 0; i < a.length; ++i)
			System.out.printf("%d ", a[i]);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun parametresi dizi referansı olabilir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import static org.csystem.util.array.ArrayUtil.print;

class App {
	public static void main(String [] args)
	{
		int [] a = {1, 2, 3, 4, 5};
		int [] b = {10, 20, 30, 40};

		print(2, a);
		print(b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun parametresi dizi referansı olabilir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import static org.csystem.util.array.ArrayUtil.print;
import static org.csystem.util.array.ArrayUtil.swap;

class App {
	public static void main(String [] args)
	{
		int [] a = {1, 2, 3, 4, 5};

		print(a);
		swap(a, 1, 4);
		print(a);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun paerametresi dizi referansı olabilir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.*;

class App {
	public static void main(String [] args)
	{
		Random random = new Random();
		Scanner kb = new Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int [] a = new int[kb.nextInt()];

		fillRandomArray(random, a, 0, 100);
		print(a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.*;

class App {
	public static void main(String [] args)
	{
		Random random = new Random();
		Scanner kb = new Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		double [] a = new double[kb.nextInt()];

		fillRandomArray(random, a, 2.345, 9.789);
		print(a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun geri dönüş değeri bir dizi referansı olabilir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.getRandomArray;
import static org.csystem.util.array.ArrayUtil.print;

class App {
	public static void main(String [] args)
	{
		Random random = new Random();
		Scanner kb = new Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int [] a = getRandomArray(random, kb.nextInt(), 0, 100);

		print(a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.getRandomArray;
import static org.csystem.util.array.ArrayUtil.print;

class App {
	public static void main(String [] args)
	{
		Random random = new Random();
		Scanner kb = new Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		double [] a = getRandomArray(random, kb.nextInt(), 2.345, 9.789);

		print(a);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir dizinin elemanlarının toplamına geri dönen sum isimli
	metodu ArrayUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.array.test;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.*;

public class SumTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();

        System.out.print("Sınır değerleri giriniz:");
        int min = kb.nextInt();
        int bound = kb.nextInt();

        for (;;) {
            System.out.print("Dizinin eleman sayısını giriniz:");
            int count = kb.nextInt();

            if (count <= 0)
                break;

            int [] a  = getRandomArray(r, count, min, bound);

            print(a);
            System.out.printf("Toplam:%d%n", sum(a));
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }

    public static void main(String [] args)
    {
        run();
    }
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir dizinin elemanlarını ters yüz eden reverse isimli metodu başka
	bir dizi kullanmadan ArrayUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.array.test;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.*;

public class ReverseTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();
        for (;;) {
            System.out.print("Dizinin eleman sayısını giriniz:");
            int count = Integer.parseInt(kb.nextLine());

            if (count <= 0)
                break;

            int [] a  = getRandomArray(r, count, 0, 99);

            print(2, a);
            reverse(a);
            print(2, a);
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }

    public static void main(String [] args)
    {
        run();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir dizinin elemanlarını ters yüz eden reverse isimli metodu başka
	bir dizi kullanmadan ArrayUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.*;

class App {
	public static void main(String [] args)
	{
		ReverseTest.run();
	}
}

class ReverseTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();
		for (;;) {
			System.out.print("Dizinin eleman sayısını giriniz:");
			int count = Integer.parseInt(kb.nextLine());

			if (count <= 0)
				break;

			int [] a  = getRandomArray(r, count, 0, 99);

			print(2, a);
			Util.reverse(a);
			print(2, a);
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}


class Util {
	public static void reverse(int [] a)
	{
		int left = 0;
		int right = a.length - 1;

		while (left < right)
			swap(a, left++, right--);
	}

	public static int sum(int [] a)
	{
		int total = 0;

		for (int i = 0; i < a.length; ++i)
			total += a[i];

		return total;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Java'da length bilgisi sıfır olan bir dizi yaratılabilir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		int [] a = new int[0];
		int [] b = {};
		int [] c;

		c = new int[]{};

		System.out.printf("Length:%d%n", a.length);
		System.out.printf("Length:%d%n", b.length);
		System.out.printf("Length:%d%n", c.length);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı long türden bir sayının basamaklarından oluşan diziyi döndüren getDigits
	isimli metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
-----------------------------------------------------------------------------------------------------------------------*/

package org.csystem.util.numeric.test;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.*;
import static org.csystem.util.numeric.NumberUtil.*;

public class GetDigitsTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();

        System.out.print("Bir sayı giriniz:");
        int n = kb.nextInt();

        while (n-- > 0) {
            long val = r.nextLong();
            System.out.printf("%d -> ", val);
            print(getDigits(val));
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }

    public static void main(String [] args)
    {
        run();
    }
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı iki tane int türden dizinin birleşiminden oluşan yeni bir dizi referansına
	geri dönen join isimli metodu ArrayUtil sınıfında yazınız ve aşağıdaki kod ile test ediniz
-----------------------------------------------------------------------------------------------------------------------*/

package org.csystem.util.array.test;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.*;

public class JoinArraysTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();
        for (;;) {
            System.out.print("Dizilerin eleman sayılarını giriniz:");
            int count1 = kb.nextInt();
            int count2 = kb.nextInt();

            if (count1 <= 0 && count2 <= 0)
                break;

            int [] a  = getRandomArray(r, count1, 0, 100);
            int [] b  = getRandomArray(r, count2, 0, 100);

            print(2, a);
            print(2, b);
            print(2, join(a, b));
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }

    public static void main(String [] args)
    {
        run();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Sınıf Çalışması: Parametresi ile aldığı int türden bir dizinin en büyük ve en küçük elemanlarının değerlerine geri dönen
    min ve max isimli metotları ArrayUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.array.test;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.*;

public class MinMaxTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();

        System.out.print("Sınır değerleri giriniz:");
        int min = kb.nextInt();
        int bound = kb.nextInt();

        for (;;) {
            System.out.print("Dizinin eleman sayısını giriniz:");
            int count = kb.nextInt();

            if (count <= 0)
                break;

            int [] a  = getRandomArray(r, count, min, bound);

            print(a);
            System.out.printf("En küçük değer:%d%n", min(a));
            System.out.printf("En büyük değer:%d%n", max(a));
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }

    public static void main(String [] args)
    {
        run();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    19.02.2023
-----------------------------------------------------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------------------------------------------------
	Dizilerin sıraya dizilmesi (sorting):
	Dizilerin sıraya dizilmesine yönelik pek çok algoritma bulunmaktadır.  Sıralama işleminin küçükten büyüğe yani artan
	sırada (ascending order) yapılmasına doğal sıralama (natural sort order) denir. Biz burada "kabarcık sıralama (bubble sort)" ve
	"seçerek sıralama (selection sort) algoritmalarını kodlayacağız. Algoritmalar doğal sıralama şeklinde anlatılacaktır.
	Ancak her iki sıralama da (ascending ve descending) kodlanacaktır

	Anahtar Notlar: Algoritmaların karşılaştırılmasına yönelik iki ölçüt vardır: hız (speed), kaynak kullanımı (resource usage).
	Burada baskın ölçüt hızdır. Burada kabarcık sıralama ve seçerek sıralama algoritmaları karşılaştırılmayacaktır.
	"Algoritma Analizi" isimli konuda bu iki algoritmanın karşılaştırılması yapılacaktır
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Kabarcık sıralama algoritmasında dizinin yanyana iki elemanı karşılaştırılır ve duruma göre yer değiştirilir. Her
	yinelemede en büyük eleman saraltılmnış dizinin sonuna gider. Böylece her yinelemede eskisinden bir geriye kadar
	gitmek yeterli olur
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.array.test;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.*;

public class BubbleSortTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();

        for (;;) {
            System.out.print("Dizinin eleman sayısını giriniz:");
            int count = Integer.parseInt(kb.nextLine());

            if (count <= 0)
                break;

            int [] a  = getRandomArray(r, count, 0, 100);

            print(2, a);

            boolean desc = r.nextBoolean();

            bubbleSort(a, desc);

            System.out.printf("%s sıralanmış dizi:%n", desc ? "Büyükten küçüğe" : "Küçükten büyüğe");

            print(2, a);
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }

    public static void main(String [] args)
    {
        run();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Seçerek sıralama algoritmasında en küçük eleman bulunur, ilk eleman ile yer değiştirilir. Dizi bir daraltılır, aynı şey
	daraltılmış dizi için yapılır. Böylece ilerlenir
-----------------------------------------------------------------------------------------------------------------------*/

package org.csystem.util.array.test;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.*;

public class SelectionSortTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();

        for (;;) {
            System.out.print("Dizinin eleman sayısını giriniz:");
            int count = Integer.parseInt(kb.nextLine());

            if (count <= 0)
                break;

            int [] a  = getRandomArray(r, count, 0, 100);

            print(2, a);

            boolean desc = r.nextBoolean();

            selectionSort(a, desc);

            System.out.printf("%s sıralanmış dizi:%n", desc ? "Büyükten küçüğe" : "Küçükten büyüğe");

            print(2, a);
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }

    public static void main(String [] args)
    {
        run();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Sayısal loto kuponu üreten programı yazınız
	(İleride daha iyisi yazılacaktır)
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.lottery.NumericLotteryApp;

class App {
	public static void main(String [] args)
	{
		NumericLotteryApp.run();
	}
}

package org.csystem.app.lottery;

import org.csystem.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

public class NumericLotteryApp {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();
        NumericLottery numericLottery = new NumericLottery(r);

        for (;;) {
            System.out.print("Kaç tane kupon oynamak istersiniz?");
            int count = Integer.parseInt(kb.nextLine());

            if (count <= 0)
                break;

            while (count-- > 0)
                ArrayUtil.print(2, numericLottery.getNumbers());
        }
    }
}
package org.csystem.app.lottery;

import org.csystem.util.array.ArrayUtil;

import java.util.Random;

public class NumericLottery {
    public Random random;

    public NumericLottery()
    {
        random = new Random();
    }

    public NumericLottery(Random r)
    {
        random = r;
    }
    public int [] getNumbers()
    {
        int [] numbers = new int[6];

        for (int i = 0; i < 6; ++i) {
            boolean repeat;

            do {
                repeat = false;
                numbers[i] = random.nextInt(1, 50);

                for (int k = 0; k < i; ++k)
                    if (numbers[i] == numbers[k]) {
                        repeat = true;
                        break;
                    }
            } while (repeat);
        }

        ArrayUtil.bubbleSort(numbers);

        return numbers;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Sayısal loto kuponu üreten programı yazınız
	(İleride daha iyisi yazılacaktır)
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.lottery.NumericLotteryApp;

class App {
	public static void main(String [] args)
	{
		NumericLotteryApp.run();
	}
}

package org.csystem.app.lottery;

import org.csystem.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

public class NumericLotteryApp {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();
        NumericLottery numericLottery = new NumericLottery(r);

        for (;;) {
            System.out.print("Kaç tane kupon oynamak istersiniz?");
            int count = Integer.parseInt(kb.nextLine());

            if (count <= 0)
                break;

            while (count-- > 0)
                ArrayUtil.print(2, numericLottery.getNumbers());
        }
    }
}

package org.csystem.app.lottery;

import java.util.Random;

public class NumericLottery {
    public Random random;

    public static int [] getNumbers(boolean [] flags)
    {
        int [] numbers = new int[6];

        int idx = 0;

        for (int i = 1; i < 50; ++i)
            if (flags[i])
                numbers[idx++] = i;

        return numbers;
    }

    public boolean [] getFlags()
    {
        boolean [] flags = new boolean[50];

        for (int i = 0; i < 6; ++i) {
            int val;

            for (;;) {
                val = random.nextInt(1, 50);

                if (!flags[val])
                    break;
            }
            flags[val] = true;
        }

        return flags;
    }

    public NumericLottery()
    {
        random = new Random();
    }

    public NumericLottery(Random r)
    {
        random = r;
    }
    public int [] getNumbers()
    {
        return getNumbers(getFlags());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	images dizininde bulunan firstNotRepeatingCharacter.jpeg dosyasındaki sorunun bir çözümü
	Not: İleride daha iyisi yazılacaktır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.lottery.NumericLotteryApp;
import org.csystem.util.string.StringUtil;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		FirstNonRepeatingCharacterTest.run();
	}
}


class FirstNonRepeatingCharacterTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);

		FirstNonRepeatingCharacterInputTest.run(kb);
		FirstNonRepeatingCharacterRandomTest.run(kb);
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class FirstNonRepeatingCharacterRandomTest {
	public static void run(Scanner kb)
	{
		Random r = new Random();
		System.out.print("Input a number:");
		int count = Integer.parseInt(kb.nextLine());

		while (count-- > 0) {
			System.out.println("-------------------------------------------");
			String s = StringUtil.getRandomTextEN(r, r.nextInt(2, 21)).toLowerCase();

			System.out.println(s);
			char ch = Util.firstNonRepeatingCharacter(s);

			System.out.printf("%s%n", ch == '_' ? "No \"non-repeating\" character" : "First non repeating character is:'" + ch + "'");
			System.out.println("-------------------------------------------");
		}
	}
}

class FirstNonRepeatingCharacterInputTest {
	public static void run(Scanner kb)
	{
		for (;;) {
			System.out.print("Input a text:");
			String s = kb.nextLine();

			char ch = Util.firstNonRepeatingCharacter(s);

			System.out.printf("%s%n", ch == '_' ? "No \"non-repeating\" character" : "First non repeating character is:'" + ch + "'");

			if ("quit".equals(s))
				break;
		}
	}
}

class Util {
	public static char firstNonRepeatingCharacter(String s)
	{
		int [] counts = new int[26];
		int len = s.length();

		for (int i = 0; i < len; ++i)
			++counts[s.charAt(i) - 'a'];

		for (int i = 0; i < len; ++i) {
			char ch = s.charAt(i);

			if (counts[ch - 'a'] == 1)
				return ch;
		}

		return '_';
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Partition algoritması: Bu algoritmada dizinin belirli bir koşula uyan elemanları dizinin mantıksal olarak solunda,
	uymayanlar ise dizinin mantıksal olarak bulunur. Buna göre dizi, ismine "partition point" ile ayrılmıştır. Aslında
	"partition point"'in solunda olanlar koşulan uyan elemanlar olur. Bu algoritmada önce ilk koşula ıuymayan eleman bulunur
	Bulunduktan sonra o elemandan sonra gelen elemandan başlanarak duruma göre yer değiştirme yapılır. Yer değiştirme
	yapıldıkça ilk koşula uymayan elemanı gösteren indekx yani "partition index" ilerletilir
-----------------------------------------------------------------------------------------------------------------------*/

package org.csystem.util.array.test;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.*;

public class PartitionTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();

        for (;;) {
            System.out.print("Dizinin eleman sayısını giriniz:");
            int count = Integer.parseInt(kb.nextLine());

            if (count <= 0)
                break;

            System.out.print("Eşik değerini giriniz:");
            int threshold = Integer.parseInt(kb.nextLine());

            int [] a  = getRandomArray(r, count, 0, 100);
            System.out.println("-----------------------------------------------------------");
            print(2, a);
            int partitionPoint = partition(a, threshold);
            System.out.printf("Bölümleme noktası:%d%n", partitionPoint);
            print(2, a);
            System.out.println("-----------------------------------------------------------");
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }

    public static void main(String [] args)
    {
        run();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Aşağıdaki açıklamalara göre getHistogramData isimli metodu ArrayUtil sınıfı içerisinde yazınız
	ve aşağıdaki kod ile test ediniz:
	Açıklamalar:
		- Metot int türden bir dizi ve int türden bir n sayısı alacaktır:
			int [] getHistogramData(int [] a, int n)

		- Metot a dizisi içerisinde [0, n] aralığındaki sayılardan jhangisinin kaç tane olduğunu içeren bir sayaç dizisine
		geri dönecektir

		- Sayaç dizisinin her bir indeks numarası [0, n] aralığındaki sayıyı temsil edecektir. Yani örneğinb sıfır numaralı
		indeksteki değer sıfır sdayısının kaç tane olduğu bilgisini içerecektir
-----------------------------------------------------------------------------------------------------------------------*/

package org.csystem.util.array.test;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.*;

public class GetHistogramTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();

        for (;;) {
            System.out.print("Dizinin eleman sayısını giriniz:");
            int count = Integer.parseInt(kb.nextLine());

            if (count <= 0)
                break;

            int [] a  = getRandomArray(r, count, 0, 11);
            System.out.println("-----------------------------------------------------------");
            print(a);
            print(getHistogramData(a, 10));
            System.out.println("-----------------------------------------------------------");
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }

    public static void main(String [] args)
    {
        run();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	ArrayUtil sınıfının drawHistogram metodu. Homework-011'de merkezi limit teoremi için önce bu metodu kullanınız. Daha
	sonra metodu çalışma sorusunda istendiği şekilde yazınız. Ya da önce drawHistogram metodunu çalışma sorusunda istendiği
	gibi yazıp aşağıdaki kod ile test ediniz ve daha sonra merkezi limit teoremi için olan kısmı yazınız
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.array.test;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.*;

public class DrawHistogramTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();

        for (;;) {
            System.out.print("Dizinin eleman sayısını giriniz:");
            int count = Integer.parseInt(kb.nextLine());

            if (count <= 0)
                break;

            int [] a  = getRandomArray(r, count, 0, 11);
            System.out.println("-----------------------------------------------------------");
            print(a);
            int [] data = getHistogramData(a, 10);
            print(data);
            System.out.println("Histogram:");
            drawHistogram(data, 10, 'X');
            System.out.println("-----------------------------------------------------------");
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }

    public static void main(String [] args)
    {
        run();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden iki matrisin toplamından oluşan matrise geri dönen add ve yine
	parametresi ile aldığı iki matrisin farkına geri dönen subtract isimli metotları MatrixUtil sınıfı içerisinde yazınız
	ve aşağıdaki kodlar ile test ediniz.
	Açıklamalar: Metotlar matrislerle o işlemlerin yapılıp yapılamayacağı kontrolünü yapmayacaktır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.matrix.test;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.print;
import static org.csystem.util.matrix.MatrixUtil.*;

class AddTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		for (int i = 0; i < count; ++i) {
			int m = r.nextInt(4, 10);
			int n = r.nextInt(4, 10);
			int [][] a = getRandomMatrix(r, m, n, 0, 99);
			int [][] b = getRandomMatrix(r, m, n, 0, 99);

			System.out.println("---------------------------------------------------");
			print(2, a);
			System.out.println();
			print(2, b);
			System.out.println("Matrislerin toplamı:");
			print(3, add(a, b));
			System.out.println("---------------------------------------------------");
		}
	}

	public static void main(String [] args)
	{
		run();
	}
}

package org.csystem.util.matrix.test;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.print;
import static org.csystem.util.matrix.MatrixUtil.*;
import static org.csystem.util.matrix.MatrixUtil.getRandomSquareMatrix;

class SubtractTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		for (int i = 0; i < count; ++i) {
			int m = r.nextInt(4, 10);
			int n = r.nextInt(4, 10);
			int [][] a = getRandomMatrix(r, m, n, 0, 99);
			int [][] b = getRandomMatrix(r, m, n, 0, 99);

			System.out.println("---------------------------------------------------");
			print(2, a);
			System.out.println();
			print(2, b);
			System.out.println("Matrislerin farkı:");
			print(3, subtract(a, b));
			System.out.println("---------------------------------------------------");
		}
	}

	public static void main(String [] args)
	{
		run();
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir matrisin tüm elemanlarını ikinci parametresi ile aldığı int
	türden değer ile toplayan addBy, çıkartan subtractBy ve çarpan multiplyBy isimli metotları MatrixUtil isimli
	sınıf içerisinde yazınız ve aşağıdaki kodlar ile test ediniz
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.matrix.test;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.print;
import static org.csystem.util.matrix.MatrixUtil.addBy;
import static org.csystem.util.matrix.MatrixUtil.getRandomMatrix;

class AddByTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		for (int i = 0; i < count; ++i) {
			int [][] a = getRandomMatrix(r, r.nextInt(4, 10), r.nextInt(4, 10), 0, 99);
			int val = r.nextInt(2, 7);
			System.out.println("---------------------------------------------------");
			print(2, a);
			System.out.printf("Value:%d%n", val);
			System.out.println("Sonuç:");
			addBy(a, val);
			print(3, a);
			System.out.println("---------------------------------------------------");
		}
	}

	public static void main(String [] args)
	{
		run();
	}
}

package org.csystem.util.matrix.test;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.print;
import static org.csystem.util.matrix.MatrixUtil.getRandomMatrix;
import static org.csystem.util.matrix.MatrixUtil.subtractBy;

class SubtractByTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		for (int i = 0; i < count; ++i) {
			int [][] a = getRandomMatrix(r, r.nextInt(4, 10), r.nextInt(4, 10), 0, 99);
			int val = r.nextInt(2, 7);
			System.out.println("---------------------------------------------------");
			print(2, a);
			System.out.printf("Value:%d%n", val);
			System.out.println("Sonuç:");
			subtractBy(a, val);
			print(3, a);
			System.out.println("---------------------------------------------------");
		}
	}

	public static void main(String [] args)
	{
		run();
	}
}

package org.csystem.util.matrix.test;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.print;
import static org.csystem.util.matrix.MatrixUtil.getRandomMatrix;
import static org.csystem.util.matrix.MatrixUtil.multiplyBy;

class MultiplyByTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		for (int i = 0; i < count; ++i) {
			int [][] a = getRandomMatrix(r, r.nextInt(4, 10), r.nextInt(4, 10), 0, 99);
			int val = r.nextInt(2, 7);
			System.out.println("---------------------------------------------------");
			print(2, a);
			System.out.printf("Value:%d%n", val);
			System.out.println("Sonuç:");
			multiplyBy(a, val);
			print(3, a);
			System.out.println("---------------------------------------------------");
		}
	}

	public static void main(String [] args)
	{
		run();
	}
}

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden iki matrisin çarpımından oluşan matrise geri dönen multiply
	isimli metoddu MatrixUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz.

	Açıklamalar: Metotlar matrislerle o işlemlerin yapılıp yapılamayacağı kontrolünü yapmayacaktır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.matrix.test;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.print;
import static org.csystem.util.matrix.MatrixUtil.getRandomMatrix;
import static org.csystem.util.matrix.MatrixUtil.multiply;

class MultiplyTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		for (int i = 0; i < count; ++i) {
			int m = r.nextInt(4, 10);
			int n = r.nextInt(4, 10);
			int k = r.nextInt(4, 10);
			int [][] a = getRandomMatrix(r, m, n, 0, 99);
			int [][] b = getRandomMatrix(r, n, k, 0, 99);

			System.out.println("---------------------------------------------------");
			print(2, a);
			System.out.println();
			print(2, b);
			System.out.println("Matrislerin çarpımı:");
			print(3, multiply(a, b));
			System.out.println("---------------------------------------------------");
		}
	}

	public static void main(String [] args)
	{
		run();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Bir okulda Fizik sınavı ortak olarak yapılıyor olsun. Kaç şube olduğu ve herbir şubede kaç öğrenci
	olduğu bilgileri klavyeden alınsın. Öğrencilerin notları rasgele olarak belirlensin. Tüm bu işlemlerden sonra Fizik
	sınavı için herbir şubenin ayrı ayrı not ortalamaları ile okulun not ortalamasını bulan simülasyonu yazınız.
	Açıklamalar:
		- Notlar int türü ile tutulacaktır
		- Programı mümkün olduğuca nesne yönelimkli ve genel düşünerek yazınız
	Not: İleride daha iyisi yazılacaktır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.simulation.exam.ExamSimulationApp;

class App {
	public static void main(String [] args)
	{
		ExamSimulationApp.run();
	}
}

package org.csystem.app.simulation.exam;

public class ExamSimulationApp {
    public static void run()
    {
        ExamSimulation physicsSimulation = new ExamSimulation("Fizik");
        ExamSimulation mathSimulation = new ExamSimulation("Matematik");

        physicsSimulation.run();
        physicsSimulation.printReport();
        mathSimulation.run();
        mathSimulation.printReport();
    }
}

package org.csystem.app.simulation.exam;

import org.csystem.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

public class ExamSimulation {
    public String lectureName;
    public int [][] grades;
    public double [] averages;
    public double average;

    public void fillGrades()
    {
        Random r = new Random();
        Scanner kb = new Scanner(System.in);

        System.out.printf("%s sınavına giren şube sayısını giriniz:", lectureName);
        grades = new int[Integer.parseInt(kb.nextLine())][];
        averages = new double[grades.length];

        for (int i = 0; i < grades.length; ++i) {
            System.out.printf("%d.şubenin öğrenci sayısı?", i + 1);
            grades[i] = ArrayUtil.getRandomArray(r, Integer.parseInt(kb.nextLine()), 0, 101);
        }
    }

    public void calculateResults()
    {
        int totalNumberOfStudents = 0;
        int totalGrades = 0;

        for (int i = 0; i < grades.length; ++i) {
            int total = ArrayUtil.sum(grades[i]);

            averages[i] = (double)total / grades[i].length;
            totalGrades += total;
            totalNumberOfStudents += grades[i].length;
        }
        average = (double)totalGrades / totalNumberOfStudents;
    }

    public ExamSimulation(String name)
    {
        lectureName = name;
    }

    public void run()
    {
        fillGrades();
        calculateResults();
    }

    public void printAverages()
    {
        System.out.printf("%s dersi için not ortalamaları:%n", lectureName);
        System.out.println("----------------------------------------------------------------------------------------");
        for (int i = 0; i < averages.length; ++i)
            System.out.printf("%d.şube not ortalaması:%f%n", i + 1, averages[i]);

        System.out.printf("Okul ortalaması:%f%n", average);
        System.out.println("----------------------------------------------------------------------------------------");
    }

    public void printGrades()
    {
        System.out.println("----------------------------------------------------------------------------------------");
        System.out.printf("%s dersi sınav notları:%n", lectureName);
        for (int i = 0; i < grades.length; ++i) {
            System.out.printf("%d.şube sınav notları:", i + 1);
            ArrayUtil.print(2, grades[i]);
        }
        System.out.println("----------------------------------------------------------------------------------------");
    }

    public void printReport()
    {
        System.out.println("###########################################################################################");
        printGrades();
        printAverages();
        System.out.println("###########################################################################################");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Diziler ile ilgili karmaşık bildirimler
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		int [][][] a;
		int [][][][] b;

		a = new int[3][6][2];
		b = new int[3][7][6][9];
		//...
	}
}

/*----------------------------------------------------------------
	FILE		: ArrayUtil.java
	AUTHOR		: Java-Aug-2022 Group
	LAST UPDATE	: 04.03.2023

	Utility class for array operations

	Copyleft (c) 1993 C and System Programmers Association
	All Rights Free
----------------------------------------------------------------*/
package org.csystem.util.array;

import java.util.Random;

import static java.lang.Math.*;

public class ArrayUtil {
    public static void bubbleSortAscending(int [] a)
    {
        for (int i = 0; i < a.length - 1; ++i)
            for (int k = 0; k < a.length - 1 - i; ++k)
                if (a[k + 1] < a[k])
                    swap(a, k, k + 1);
    }

    public static void bubbleSortDescending(int [] a)
    {
        for (int i = 0; i < a.length - 1; ++i)
            for (int k = 0; k < a.length - 1 - i; ++k)
                if (a[k] < a[k + 1])
                    swap(a, k, k + 1);
    }

    public static void selectionSortAscending(int [] a)
    {
        int min, minIndex;

        for (int i = 0; i < a.length - 1; ++i) {
            min = a[i];
            minIndex = i;

            for (int k = i + 1; k < a.length; ++k)
                if (a[k] < min) {
                    min = a[k];
                    minIndex = k;
                }
            a[minIndex] = a[i];
            a[i] = min;
        }
    }

    public static void selectionSortDescending(int [] a)
    {
        int max, maxIndex;

        for (int i = 0; i < a.length - 1; ++i) {
            max = a[i];
            maxIndex = i;

            for (int k = i + 1; k < a.length; ++k)
                if (max < a[k]) {
                    max = a[k];
                    maxIndex = k;
                }
            a[maxIndex] = a[i];
            a[i] = max;
        }
    }

    public static void bubbleSort(int [] a)
    {
        bubbleSort(a, false);
    }

    public static void bubbleSort(int [] a, boolean descending)
    {
        if (descending)
            bubbleSortDescending(a);
        else
            bubbleSortAscending(a);
    }

    public static void drawHistogram(int [] data, int count, char ch)
    {
        int maxVal = max(data);

        for (int i = 0; i < data.length; ++i) {
            int charCount = (int)floor(data[i] * count / (double)maxVal);

            while (charCount-- > 0)
                System.out.print(ch);

            System.out.println();
        }
    }

    public static void fillRandomArray(Random random, int [] a, int min, int bound)
    {
        for (int i = 0; i < a.length; ++i)
            a[i] = random.nextInt(min, bound);
    }

    public static void fillRandomArray(Random random, double [] a, double min, double bound)
    {
        for (int i = 0; i < a.length; ++i)
            a[i] = random.nextDouble(min, bound);
    }

    public static int [] getHistogramData(int [] a, int n)
    {
        int [] counts = new int[n + 1];

        for (int i = 0; i < a.length; ++i)
            ++counts[a[i]];

        return counts;
    }

    public static int [] getRandomArray(Random random, int count, int min, int bound)
    {
        int [] a = new int[count];

        fillRandomArray(random, a, min, bound);

        return a;
    }

    public static double [] getRandomArray(Random random, int count, double min, double bound)
    {
        double [] a = new double[count];

        fillRandomArray(random, a, min, bound);

        return a;
    }



    public static int [] join(int [] a, int [] b)
    {
        int [] result = new int[a.length + b.length];
        int idx = 0;

        for (int i = 0; i < a.length; ++i)
            result[idx++] = a[i];

        for (int i = 0; i < b.length; ++i)
            result[idx++] = b[i];

        return result;
    }

    public static int min(int [] a)
    {
        int result = a[0];

        for (int i = 1; i < a.length; ++i)
            if (a[i] < result)
                result = a[i];

        return result;
    }

    public static int max(int [] a)
    {
        int result = a[0];

        for (int i = 1; i < a.length; ++i)
            if (result < a[i])
                result = a[i];

        return result;
    }



    public static int partition(int [] a, int threshold)
    {
        int partitionIndex = 0;

        while (partitionIndex != a.length && a[partitionIndex] < threshold)
            ++partitionIndex;

        if (partitionIndex == a.length)
            return partitionIndex;

        for (int i = partitionIndex + 1; i < a.length; ++i)
            if (a[i] < threshold)
                swap(a, i, partitionIndex++);

        return partitionIndex;
    }

    public static void print(double [] a)
    {
        for (int i = 0; i < a.length; ++i)
            System.out.printf("%f%n", a[i]);
    }

    public static void print(int [] a)
    {
        print(1, a);
    }

    public static void print(int n, int [] a)
    {
        String fmt = String.format("%%0%dd ", n);

        for (int i = 0; i < a.length; ++i)
            System.out.printf(fmt, a[i]);

        System.out.println();
    }


    public static void print(String [] s)
    {
        for (int i = 0; i < s.length; ++i)
            System.out.println(s[i]);
    }

    public static void print(int [][] a)
    {
        print(1, a);
    }

    public static void print(int n, int [][] a)
    {
        for (int i = 0; i < a.length; ++i)
            print(n, a[i]);
    }

    public static void reverse(int [] a)
    {
        for (int i = 0; i < a.length / 2; ++i)
            swap(a, i, a.length - 1 - i);
    }

    public static void reverse(double [] a)
    {
        for (int i = 0; i < a.length / 2; ++i)
            swap(a, i, a.length - 1 - i);
    }

    public static void reverse(char [] chars)
    {
        for (int i = 0; i < chars.length / 2; ++i)
            swap(chars, i, chars.length - 1 - i);
    }

    public static void selectionSort(int [] a)
    {
        selectionSort(a, false);
    }

    public static void selectionSort(int [] a, boolean descending)
    {
        if (descending)
            selectionSortDescending(a);
        else
            selectionSortAscending(a);
    }

    public static int sum(int [] a)
    {
        int total = 0;

        for (int i = 0; i < a.length; ++i)
            total += a[i];

        return total;
    }

    public static void swap(int [] a, int i, int k)
    {
        int temp = a[i];

        a[i] = a[k];
        a[k] = temp;
    }

    public static void swap(double [] a, int i, int k)
    {
        double temp = a[i];

        a[i] = a[k];
        a[k] = temp;
    }

    public static void swap(char [] a, int i, int k)
    {
        char temp = a[i];

        a[i] = a[k];
        a[k] = temp;
    }
}

/*----------------------------------------------------------------
	FILE		: MatrixUtil.java
	AUTHOR		: Java-Aug-2022 Group
	LAST UPDATE	: 05.03.2023

	Utility class for matrix operations

	Copyleft (c) 1993 C and System Programmers Association
	All Rights Free
----------------------------------------------------------------*/
package org.csystem.util.matrix;

import org.csystem.util.array.ArrayUtil;

import java.util.Random;

public class MatrixUtil {
    public static int [][] add(int [][] a, int [][] b)
    {
        int [][] result = new int[a.length][a[0].length];

        for (int i = 0; i < a.length; ++i)
            for (int j = 0; j < a[i].length; ++j)
                result[i][j] = a[i][j] + b[i][j];

        return result;
    }

    public static void addBy(int [][] a, int val)
    {
        for (int i = 0; i < a.length; ++i)
            for (int j = 0; j < a[i].length; ++j)
                a[i][j] += val;
    }

    public static int [][] getRandomMatrix(Random random, int m, int n, int min, int bound)
    {
        int [][] result = new int[m][];

        for (int i = 0; i < m; ++i)
            result[i] = ArrayUtil.getRandomArray(random, n, min, bound);

        return result;
    }

    public static int [][] getRandomSquareMatrix(Random random, int n, int min, int bound)
    {
        return getRandomMatrix(random, n, n, min, bound);
    }

    public static boolean isMatrix(int [][] a)
    {
        for (int i = 1; i < a.length; ++i)
            if (a[0].length != a[i].length)
                return false;

        return true;
    }

    public static boolean isSquareMatrix(int [][] a)
    {
        return isMatrix(a) && a.length == a[0].length;
    }

    public static int [][] multiply(int [][] a, int [][] b)
    {
        int [][] result = new int[a.length][b[0].length];

        //TODO:

        return result;
    }

    public static void multiplyBy(int [][] a, int val)
    {
        for (int i = 0; i < a.length; ++i)
            for (int j = 0; j < a[i].length; ++j)
                a[i][j] *= val;
    }

    public static int [][] subtract(int [][] a, int [][] b)
    {
        int [][] result = new int[a.length][a[0].length];

        for (int i = 0; i < a.length; ++i)
            for (int j = 0; j < a[i].length; ++j)
                result[i][j] = a[i][j] - b[i][j];

        return result;
    }

    public static void subtractBy(int [][] a, int val)
    {
        addBy(a, -val);
    }

    public static long sumDiagonal(int [][] a)
    {
        long total = 0;

        for (int i = 0; i < a.length; ++i)
            total += a[i][i];

        return total;
    }

    public static void swap(int [][] a, int i1, int j1, int i2, int j2)
    {
        int temp = a[i1][j1];

        a[i1][j1] = a[i2][j2];
        a[i2][j2] = temp;
    }

    public static int [][] transpose(int [][] a)
    {
        int [][] t = new int[a[0].length][a.length];

        for (int i = 0; i < a.length; ++i)
            for (int j = 0; j < a[i].length; ++j)
                t[j][i] = a[i][j];

        return t;
    }

    //...
}

/*----------------------------------------------------------------
	FILE		: NumberUtil.java
	AUTHOR		: Java-Aug-2022 Group
	LAST UPDATE	: 26.02.2023

	Utility class for numeric operations

	Copyleft (c) 1993 C and System Programmers Association
	All Rights Free
----------------------------------------------------------------*/
package org.csystem.util.numeric;

import static java.lang.Math.abs;
import static java.lang.Math.log10;
import static java.lang.Math.pow;

public class NumberUtil {
	public static String [] onesTR = {"", "bir", "iki", "üç", "dört", "beş", "altı", "yedi", "sekiz", "dokuz"};
	public static String [] tensTR = {"", "on", "yirmi", "otuz", "kırk", "elli", "altmış", "yetmiş", "seksen", "doksan"};

	public static int [] getDigits(long val, int n)
	{
		int [] values = new int[val == 0 ? 1 : (int)(log10((val = abs(val))) / n) + 1];
		int powOfTen = (int)pow(10, n);

		for (int i = values.length - 1; i >= 0; values[i] = (int)(val % powOfTen), val /= powOfTen, --i)
			;

		return values;
	}

	public static int getDigitsPowSum(int val)
	{
		int n = countDigits(val);
		int total = 0;

		while (val != 0) {
			total += pow(val % 10, n);
			val /= 10;
		}

		return total;
	}

	public static int countDigits(long val)
	{
		return (val != 0) ? ((int)log10(abs(val)) + 1) : 1;
	}

	public static long factorial(int n)
	{
		long result = 1;

		for (int i = 2; i <= n; ++i)
			result *= i;

		return result;
	}

	public static int [] getDigits(long val)
	{
		return getDigits(val, 1);
	}

	public static int [] getDigitsInTwos(long val)
	{
		return getDigits(val, 2);
	}

	public static int [] getDigitsInThrees(long val)
	{
		return getDigits(val, 3);
	}

	public static int getFibonacciNumber(int n)
	{
		if (n <= 2)
			return n - 1;

		int prev1 = 1, prev2 = 0, val = prev1 + prev2;

		for (int i = 3; i < n; ++i) {
			prev2 = prev1;
			prev1 = val;
			val = prev1 + prev2;
		}

		return val;
	}

	public static int getNextFibonacciNumber(int val)
	{
		if (val < 0)
			return 0;

		int prev1 = 1, prev2 = 0, next;

		for (;;) {
			next = prev1 + prev2;

			if (next > val)
				return next;

			prev2 = prev1;
			prev1 = next;
		}
	}

	public static long getPrime(int n)
	{
		long val = 2;
		int count = 0;

		for (;;) {
			if (isPrime(val))
				++count;

			if (count == n)
				return val;

			++val;
		}
	}

	public static boolean isArmstrong(int val)
	{
		return val >= 0 && getDigitsPowSum(val) == val;
	}

	public static boolean isEven(int val)
	{
		return val % 2 == 0;
	}

	public static boolean isOdd(int val)
	{
		return !isEven(val);
	}

	public static boolean isPrime(long val)
	{
		if (val <= 1)
			return false;

		if (val % 2 == 0)
			return val == 2;

		if (val % 3 == 0)
			return val == 3;

		if (val % 5 == 0)
			return val == 5;

		if (val % 7 == 0)
			return val == 7;

		for (long i = 11; i * i <= val; i += 2)
			if (val % i == 0)
				return false;

		return true;
	}

	public static double max(double a, double b, double c)
	{
		return Math.max(Math.max(a, b), c);
	}

	public static int mid(int a, int b, int c)
	{
		if (a <= b && b <= c || c <= b && b <= a)
			return b;

		if (b <= a && a <= c || c <= a && a <= b)
			return a;

		return c;
	}

	public static double min(double a, double b, double c)
	{
		return Math.min(Math.min(a, b), c);
	}

	public static String numToTextTR(long val)
	{
		if (val == 0)
			return "sıfır";

		String text = val < 0 ? "eksi" : "";

		val = abs(val);

		int a = (int)(val / 100);
		int b = (int)(val / 10 % 10);
		int c = (int)(val % 10);

		if (a != 0) {
			if (a != 1)
				text += onesTR[a];
			text += "yüz";
		}

		if (b != 0)
			text += tensTR[b];

		if (c != 0)
			text += onesTR[c];

		return text;
	}

	public static int reverse(int val)
	{
		int result = 0;

		while (val != 0) {
			result = result * 10 + val % 10;
			val /= 10;
		}

		return result;
	}

	public static int sumDigits(int val)
	{
		int sum = 0;

		while (val != 0) {
			sum += val % 10;
			val /= 10;
		}

		return abs(sum);
	}
}

/*----------------------------------------------------------------
	FILE		: StringUtil.java
	AUTHOR		: Java-Aug-2022 Group
	LAST UPDATE	: 04.03.2023

	Utility class for string operations

	Copyleft (c) 1993 C and System Programmers Association
	All Rights Free
----------------------------------------------------------------*/
package org.csystem.util.string;

import org.csystem.util.array.ArrayUtil;

import java.util.Random;

public class StringUtil {
	public static String alphabetTR = "abcçdefgğhıijklmnoöprsştuüvyz";
	public static String alphabetEN = "abcdefghijklmnopqrstuwvxyz";
	public static String alphabetCapitalTR = "ABCÇDEFGĞHIİJKLMNOÖPRSŞTUÜVYZ";
	public static String alphabetCapitalEN = "ABCDEFGHIJKLMNOPQRSTUWVXYZ";
	public static String alphabetAllTR = alphabetTR + alphabetCapitalTR;
	public static String alphabetAllEN = alphabetEN + alphabetCapitalEN;

	public static String capitalize(String s)
	{
		return s.isEmpty() ? "" : Character.toUpperCase(s.charAt(0)) + s.substring(1).toLowerCase();
	}

	public static String changeCase(String s)
	{
		char [] chars = new char[s.length()];

		for (int i = 0; i < chars.length; ++i) {
			char c = s.charAt(i);

			chars[i] = Character.isUpperCase(c) ? Character.toLowerCase(c) : Character.toUpperCase(c);
		}

		return String.valueOf(chars);
	}

	public static int countString(String s1, String s2)
	{
		int count = 0;

		for (int i = -1; (i = s1.indexOf(s2, i + 1)) != -1; ++count)
			;

		return count;
	}

	public static int countStringIgnoreCase(String s1, String s2)
	{
		return countString(s1.toLowerCase(), s2.toLowerCase());
	}


	public static void fillRandomTexts(Random r, String [] texts, int n, String sourceText)
	{
		for (int i = 0; i < texts.length; ++i)
			texts[i] = getRandomText(r, n, sourceText);
	}

	public static void fillRandomTexts(Random r, String [] texts, int min, int bound, String sourceText)
	{
		for (int i = 0; i < texts.length; ++i)
			texts[i] = getRandomText(r, r.nextInt(min, bound), sourceText);
	}

	public static void fillRandomTextsTR(Random r, String [] texts, int n)
	{
		fillRandomTexts(r, texts, n, alphabetAllTR);
	}

	public static void fillRandomTextsTR(Random r, String [] texts, int min, int bound)
	{
		fillRandomTexts(r, texts, min, bound, alphabetAllTR);
	}

	public static void fillRandomTextsEN(Random r, String [] texts, int n)
	{
		fillRandomTexts(r, texts, n, alphabetAllEN);
	}

	public static void fillRandomTextsEN(Random r, String [] texts, int min, int bound)
	{
		fillRandomTexts(r, texts, min, bound, alphabetAllEN);
	}

	public static String getRandomText(Random r, int n, String sourceText)
	{
		char [] c = new char[n];
		int len = sourceText.length();

		for (int i = 0; i < n; ++i)
			c[i] = sourceText.charAt(r.nextInt(len));

		return String.valueOf(c);
	}

	public static String [] getRandomTexts(Random r, int count, int min, int bound, String sourceText)
	{
		String [] texts = new String[count];

		fillRandomTexts(r, texts, min, bound, sourceText);

		return texts;
	}

	public static String [] getRandomTexts(Random r, int count, int n, String sourceText)
	{
		String [] texts = new String[count];

		fillRandomTexts(r, texts, n, sourceText);

		return texts;
	}

	public static String getRandomTextEN(int n)
	{
		return getRandomTextEN(new Random(), n);
	}

	public static String getRandomTextEN(Random r, int n)
	{
		return getRandomText(r, n, alphabetAllEN);
	}

	public static String getRandomTextTR(int n)
	{
		return getRandomTextTR(new Random(), n);
	}

	public static String getRandomTextTR(Random r, int n)
	{
		return getRandomText(r, n, alphabetAllTR);
	}

	public static String [] getRandomTextsTR(Random r, int count, int min, int bound)
	{
		return getRandomTexts(r, count, min, bound, alphabetAllTR);
	}

	public static String [] getRandomTextsTR(Random r, int count, int n)
	{
		return getRandomTexts(r, count, n, alphabetAllTR);
	}

	public static String [] getRandomTextsEN(Random r, int count, int min, int bound)
	{
		return getRandomTexts(r, count, min, bound, alphabetAllEN);
	}

	public static String [] getRandomTextsEN(Random r, int count, int n)
	{
		return getRandomTexts(r, count, n, alphabetAllEN);
	}

	public static String getShortestPangramEN(String s)
	{
		String result = s;

		int end = s.length();

		while (end != 0) {
			int begin = 0;

			while (begin != end) {
				String str = s.substring(begin++, end);

				if (str.length() >= 26 && isPangramEN(str) && str.length() < result.length())
					result = str;
			}

			--end;
		}

		return result;
	}

	public static String getShortestPangramTR(String s)
	{
		String result = s;

		int end = s.length();

		while (end != 0) {
			int begin = 0;

			while (begin != end) {
				String str = s.substring(begin++, end);

				if (str.length() >= 29 && isPangramTR(str) && str.length() < result.length())
					result = str;
			}

			--end;
		}

		return result;
	}

	public static boolean isIdentifier(String s)
	{
		if (s.isBlank() || s.equals("_"))
			return false;

		if (!Character.isJavaIdentifierStart(s.charAt(0)))
			return false;

		int len = s.length();

		for (int i = 1; i < len; ++i)
			if (!Character.isJavaIdentifierPart(s.charAt(i)))
				return false;

		return true;
	}

	public static boolean isPalindrome(String s)
	{
		int left = 0;
		int right = s.length() - 1;
		boolean cLeftSelected = false, cRightSelected = false;
		char cLeft = '\0', cRight;

		while (left < right) {
			if (!cLeftSelected) {
				cLeft = Character.toLowerCase(s.charAt(left));

				if (!Character.isLetter(cLeft)) {
					++left;
					continue;
				}
				cLeftSelected = true;
			}

			if (!cRightSelected) {
				cRight = Character.toLowerCase(s.charAt(right));

				if (!Character.isLetter(cRight)) {
					--right;
					continue;
				}

				if (cLeft != cRight)
					return false;

				cRightSelected = true;
			}

			++left;
			--right;

			cLeftSelected = cRightSelected = false;
		}

		return true;
	}

	public static boolean isPangram(String s, String alphabet)
	{
		int len = alphabet.length();

		for (int i = 0; i < len; ++i)
			if (s.indexOf(alphabet.charAt(i)) == -1)
				return false;

		return true;
	}

	public static boolean isPangramEN(String s)
	{
		return isPangram(s.toLowerCase(), "abcdefghijklmnopqrstuwxvyz");
	}

	public static boolean isPangramTR(String s)
	{
		return isPangram(s.toLowerCase(), "abcçdefgğhıijklmnoöprsştuüvyz");
	}

	public static String join(String [] s, char delimiter)
	{
		return join(s, delimiter + "");
	}

	public static String join(String [] s, String delimiter)
	{
		String result = "";

		for (int i = 0; i < s.length; ++i)
			result += s[i] + delimiter;

		return result.substring(0, result.length() - delimiter.length());
	}

	public static String padLeading(String s, int len, char ch)
	{
		int length  = s.length();

		return len <= length ? s : repeat(len - length, ch) + s;
	}

	public static String padLeading(String s, int len)
	{
		return padLeading(s, len, ' ');
	}

	public static String padTrailing(String s, int len, char ch)
	{
		int length  = s.length();

		return len <= length ? s : s + repeat(len - length, ch);
	}

	public static String padTrailing(String s, int len)
	{
		return padTrailing(s, len, ' ');
	}

	public static String repeat(int count, char ch)
	{
		return String.format("%0" + count + "d", 0).replace('0', ch);
	}

	public static String reverse(String s)
	{
		char [] c = s.toCharArray();

		ArrayUtil.reverse(c);
		return String.valueOf(c);
	}

	public static String [] split(String str, String delimiters)
	{
		return split(str, delimiters, false);
	}

	public static String [] split(String str, String delimiters, boolean removeEmptyEntries)
	{
		String pattern = "[";

		int len = delimiters.length();

		for (int i = 0; i < len; ++i) {
			char c = delimiters.charAt(i);
			pattern += (c == '[' || c == ']') ? ("\\" + c) : c;
		}

		pattern += "]" + (removeEmptyEntries ? "+" : "");

		return str.split(pattern);
	}

	public static String squeeze(String s1, String s2)
	{
		String str = "";
		int len = s1.length();

		for (int i = 0; i < len; ++i) {
			char c = s1.charAt(i);

			if (!s2.contains(c + ""))
				str += c;
		}

		return str;
	}

	public static String trimLeading(String s)
	{
		int i;
		int len = s.length();

		for (i = 0; i < len && Character.isWhitespace(s.charAt(i)); ++i)
			;

		return s.substring(i);
	}

	public static String trimTrailing(String s)
	{
		int i;

		for (i = s.length() - 1; i >= 0 && Character.isWhitespace(s.charAt(i)); --i)
			;

		return s.substring(0, i + 1);
	}

	public static String wrapWith(String s, char prefix, char suffix)
	{
		return wrapWith(s, prefix + "", suffix + "");
	}

	public static String wrapWith(String s, String prefix, String suffix)
	{
		return String.format("%s%s%s", prefix, s, suffix);
	}

	public static String wrapWithStrip(String s, char prefix, char suffix)
	{
		return wrapWithStrip(s, prefix + "", suffix + "");
	}

	public static String wrapWithStrip(String s, String prefix, String suffix)
	{
		return wrapWith(s.strip(), prefix, suffix);
	}

	public static String wrapWithBracesStrip(String s)
	{
		return wrapWithStrip(s, '(', ')');
	}

	public static String wrapWithBraces(String s)
	{
		return wrapWith(s, '(', ')');
	}

	public static String wrapWithCurlyBracesStrip(String s)
	{
		return wrapWithStrip(s, '{', '}');
	}

	public static String wrapWithCurlyBraces(String s)
	{
		return wrapWith(s, '{', '}');
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	for-each döngü deyiminin genel biçimi:
	for (<tür> <değişken> : <dolaşılabilir türe ilişkin referans>)
		<deyim>
	Dolaşılabilir (iterable) tür kavramının detayları "Java ile Uygulama Geliştirme 1 ve Android Programlama" kurslarında
	ele alınacaktır. Diziler de dolaşılabilir türler olduğundan for-each döngü deyimi ile kullanılabilirler

	for-each döngü deyimi ile kod daha yalın hale gelir. Bu durumda for-each döngü deyimi yalınlığı ve okunabilirliği
	bozmadığı sürece kesinlikle kullanılmalıdır. for-each döngü deyimi okunabililiği/algılanabilirliği artırır. Kodu okuyan
	kişi, örneğin bir dizi için klasik for döngü deyimi gördüğünde "for-each ile yazmamasının bir gerekçesi vardır. Aksi
	durumda for-each döngüsü ile yazardı" biçiminde anlar. Yani programcının for-each döngü deyimini kullanması, kullanmadığı
	durumların okunabilirliğini artırır. Bu durumda aslında programcının for-each döngü deyimini kullanmaması için bir
	gerekçesi olmalıdır. Ayrıca derleyici for-each döngü deyimi için çeşitli optimizasyonlar da yapabilmektedir
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	for-each döngü deyiminin dizi ile kullanımında döngü değişkenine her adımda o anki elemanın değeri atanır. Bu işlem
	dizinin başından sonuna kadar yinelenir. Örnekteki for-each döngü deyiminin yaklaşık karşılığı şu şekildedir

	{
		int val;

		for (int i = 0; i < a.length; ++i) {
			val = a[i];
			System.out.printf("%d ", val);
		}
	}
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		int [] a = {10, 20, 33, 48, 5};

		for (int val : a)
			System.out.printf("%d ", val);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	for-each döngü deyiminde döngü değişkenine atama doğrudan (implicit) yapılır. Aşağıdaki for-each döngü deyimi geçerlidir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		int [] a = {10, 20, 33, 48, 5};

		for (long val : a)
			System.out.printf("%d ", val);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	for-each döngü deyiminde döngü değişkenine atama doğrudan (implicit) yapılır. Aşağıdaki for-each döngü deyimi geçersizdir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		int [] a = {10, 20, 33, 48, 5};

		for (short val : a) //error
			System.out.printf("%d ", val);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	for-each döngü deyiminde döngü değişkeninin faaliyet alanı (scope) döngü deyimi boyuncadır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		int [] a = {10, 20, 33, 48, 5};

		for (int val : a)
			System.out.printf("%d ", val);

		System.out.println();
		System.out.printf("val = %d%n", val); //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	for-each döngü deyiminde döngü değişkenin değeri değiştirilebilir. Şüphesiz döngü değişkeninin değerini değiştirmek
	dizi elemanlarını değiştirmez. Bu durumun pratikte çok anlamı yoktur
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		int [] a = {10, 20, 33, 48, 5};

		for (int val : a) {
			++val;
			System.out.printf("%d ", val);
		}

		System.out.println();

		for (int val : a)
			System.out.printf("%d ", val);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte dizinin elemanları değiştirilirken for-each kullanılmış olsa da kod okunabilir olmaz.  Bu durumda
	programcının klasik for döngü deyimini kullanması daha uygundur
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		int [] a = {10, 20, 33, 48, 5};

		int idx = 0;

		for (int val : a)
			++a[idx++];

		for (int val : a)
			System.out.printf("%d ", val);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örneğin aşağıdaki biçimde yazılması daha okunabilirdir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		int [] a = {10, 20, 33, 48, 5};

		for (int i = 0; i < a.length; ++i)
			++a[i];

		for (int val : a)
			System.out.printf("%d ", val);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden iki matrisin toplamından oluşan matrise geri dönen add ve yine
	parametresi ile aldığı iki matrisin farkına geri dönen subtract isimli metotları MatrixUtil sınıfı içerisinde yazınız
	ve aşağıdaki kodlar ile test ediniz.
	Açıklamalar: Metotlar matrislerle o işlemlerin yapılıp yapılamayacağı kontrolünü yapmayacaktır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.matrix.test;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.print;
import static org.csystem.util.matrix.MatrixUtil.*;

class AddTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		for (int i = 0; i < count; ++i) {
			int m = r.nextInt(4, 10);
			int n = r.nextInt(4, 10);
			int [][] a = getRandomMatrix(r, m, n, 0, 99);
			int [][] b = getRandomMatrix(r, m, n, 0, 99);

			System.out.println("---------------------------------------------------");
			print(2, a);
			System.out.println();
			print(2, b);
			System.out.println("Matrislerin toplamı:");
			print(3, add(a, b));
			System.out.println("---------------------------------------------------");
		}
	}

	public static void main(String [] args)
	{
		run();
	}
}

package org.csystem.util.matrix.test;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.print;
import static org.csystem.util.matrix.MatrixUtil.*;
import static org.csystem.util.matrix.MatrixUtil.getRandomSquareMatrix;

class SubtractTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		for (int i = 0; i < count; ++i) {
			int m = r.nextInt(4, 10);
			int n = r.nextInt(4, 10);
			int [][] a = getRandomMatrix(r, m, n, 0, 99);
			int [][] b = getRandomMatrix(r, m, n, 0, 99);

			System.out.println("---------------------------------------------------");
			print(2, a);
			System.out.println();
			print(2, b);
			System.out.println("Matrislerin farkı:");
			print(3, subtract(a, b));
			System.out.println("---------------------------------------------------");
		}
	}

	public static void main(String [] args)
	{
		run();
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir matrisin tüm elemanlarını ikinci parametresi ile aldığı int
	türden değer ile toplayan addBy, çıkartan subtractBy ve çarpan multiplyBy isimli metotları MatrixUtil isimli
	sınıf içerisinde yazınız ve aşağıdaki kodlar ile test ediniz
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.matrix.test;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.print;
import static org.csystem.util.matrix.MatrixUtil.addBy;
import static org.csystem.util.matrix.MatrixUtil.getRandomMatrix;

class AddByTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		for (int i = 0; i < count; ++i) {
			int [][] a = getRandomMatrix(r, r.nextInt(4, 10), r.nextInt(4, 10), 0, 99);
			int val = r.nextInt(2, 7);
			System.out.println("---------------------------------------------------");
			print(2, a);
			System.out.printf("Value:%d%n", val);
			System.out.println("Sonuç:");
			addBy(a, val);
			print(3, a);
			System.out.println("---------------------------------------------------");
		}
	}

	public static void main(String [] args)
	{
		run();
	}
}

package org.csystem.util.matrix.test;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.print;
import static org.csystem.util.matrix.MatrixUtil.getRandomMatrix;
import static org.csystem.util.matrix.MatrixUtil.subtractBy;

class SubtractByTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		for (int i = 0; i < count; ++i) {
			int [][] a = getRandomMatrix(r, r.nextInt(4, 10), r.nextInt(4, 10), 0, 99);
			int val = r.nextInt(2, 7);
			System.out.println("---------------------------------------------------");
			print(2, a);
			System.out.printf("Value:%d%n", val);
			System.out.println("Sonuç:");
			subtractBy(a, val);
			print(3, a);
			System.out.println("---------------------------------------------------");
		}
	}

	public static void main(String [] args)
	{
		run();
	}
}

package org.csystem.util.matrix.test;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.print;
import static org.csystem.util.matrix.MatrixUtil.getRandomMatrix;
import static org.csystem.util.matrix.MatrixUtil.multiplyBy;

class MultiplyByTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		for (int i = 0; i < count; ++i) {
			int [][] a = getRandomMatrix(r, r.nextInt(4, 10), r.nextInt(4, 10), 0, 99);
			int val = r.nextInt(2, 7);
			System.out.println("---------------------------------------------------");
			print(2, a);
			System.out.printf("Value:%d%n", val);
			System.out.println("Sonuç:");
			multiplyBy(a, val);
			print(3, a);
			System.out.println("---------------------------------------------------");
		}
	}

	public static void main(String [] args)
	{
		run();
	}
}

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden iki matrisin çarpımından oluşan matrise geri dönen multiply
	isimli metoddu MatrixUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz.

	Açıklamalar: Metotlar matrislerle o işlemlerin yapılıp yapılamayacağı kontrolünü yapmayacaktır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.matrix.test;

import java.util.Random;
import java.util.Scanner;

import static org.csystem.util.array.ArrayUtil.print;
import static org.csystem.util.matrix.MatrixUtil.getRandomMatrix;
import static org.csystem.util.matrix.MatrixUtil.multiply;

class MultiplyTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		for (int i = 0; i < count; ++i) {
			int m = r.nextInt(4, 10);
			int n = r.nextInt(4, 10);
			int k = r.nextInt(4, 10);
			int [][] a = getRandomMatrix(r, m, n, 0, 99);
			int [][] b = getRandomMatrix(r, n, k, 0, 99);

			System.out.println("---------------------------------------------------");
			print(2, a);
			System.out.println();
			print(2, b);
			System.out.println("Matrislerin çarpımı:");
			print(3, multiply(a, b));
			System.out.println("---------------------------------------------------");
		}
	}

	public static void main(String [] args)
	{
		run();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Bir okulda Fizik sınavı ortak olarak yapılıyor olsun. Kaç şube olduğu ve herbir şubede kaç öğrenci
	olduğu bilgileri klavyeden alınsın. Öğrencilerin notları rasgele olarak belirlensin. Tüm bu işlemlerden sonra Fizik
	sınavı için herbir şubenin ayrı ayrı not ortalamaları ile okulun not ortalamasını bulan simülasyonu yazınız.
	Açıklamalar:
		- Notlar int türü ile tutulacaktır
		- Programı mümkün olduğuca nesne yönelimkli ve genel düşünerek yazınız
	Not: İleride daha iyisi yazılacaktır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.simulation.exam.ExamSimulationApp;

class App {
	public static void main(String [] args)
	{
		ExamSimulationApp.run();
	}
}

package org.csystem.app.simulation.exam;

public class ExamSimulationApp {
    public static void run()
    {
        ExamSimulation physicsSimulation = new ExamSimulation("Fizik");
        ExamSimulation mathSimulation = new ExamSimulation("Matematik");

        physicsSimulation.run();
        physicsSimulation.printReport();
        mathSimulation.run();
        mathSimulation.printReport();
    }
}

package org.csystem.app.simulation.exam;

import org.csystem.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

public class ExamSimulation {
    public String lectureName;
    public int [][] grades;
    public double [] averages;
    public double average;

    public void fillGrades()
    {
        Random r = new Random();
        Scanner kb = new Scanner(System.in);

        System.out.printf("%s sınavına giren şube sayısını giriniz:", lectureName);
        grades = new int[Integer.parseInt(kb.nextLine())][];
        averages = new double[grades.length];

        for (int i = 0; i < grades.length; ++i) {
            System.out.printf("%d.şubenin öğrenci sayısı?", i + 1);
            grades[i] = ArrayUtil.getRandomArray(r, Integer.parseInt(kb.nextLine()), 0, 101);
        }
    }

    public void calculateResults()
    {
        int totalNumberOfStudents = 0;
        int totalGrades = 0;

        for (int i = 0; i < grades.length; ++i) {
            int total = ArrayUtil.sum(grades[i]);

            averages[i] = (double)total / grades[i].length;
            totalGrades += total;
            totalNumberOfStudents += grades[i].length;
        }
        average = (double)totalGrades / totalNumberOfStudents;
    }

    public ExamSimulation(String name)
    {
        lectureName = name;
    }

    public void run()
    {
        fillGrades();
        calculateResults();
    }

    public void printAverages()
    {
        System.out.printf("%s dersi için not ortalamaları:%n", lectureName);
        System.out.println("----------------------------------------------------------------------------------------");
        for (int i = 0; i < averages.length; ++i)
            System.out.printf("%d.şube not ortalaması:%f%n", i + 1, averages[i]);

        System.out.printf("Okul ortalaması:%f%n", average);
        System.out.println("----------------------------------------------------------------------------------------");
    }

    public void printGrades()
    {
        System.out.println("----------------------------------------------------------------------------------------");
        System.out.printf("%s dersi sınav notları:%n", lectureName);
        for (int i = 0; i < grades.length; ++i) {
            System.out.printf("%d.şube sınav notları:", i + 1);
            ArrayUtil.print(2, grades[i]);
        }
        System.out.println("----------------------------------------------------------------------------------------");
    }

    public void printReport()
    {
        System.out.println("###########################################################################################");
        printGrades();
        printAverages();
        System.out.println("###########################################################################################");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Diziler ile ilgili karmaşık bildirimler
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		int [][][] a;
		int [][][][] b;

		a = new int[3][6][2];
		b = new int[3][7][6][9];
		//...
	}
}

/*----------------------------------------------------------------
	FILE		: ArrayUtil.java
	AUTHOR		: Java-Aug-2022 Group
	LAST UPDATE	: 04.03.2023

	Utility class for array operations

	Copyleft (c) 1993 C and System Programmers Association
	All Rights Free
----------------------------------------------------------------*/
package org.csystem.util.array;

import java.util.Random;

import static java.lang.Math.*;

public class ArrayUtil {
    public static void bubbleSortAscending(int [] a)
    {
        for (int i = 0; i < a.length - 1; ++i)
            for (int k = 0; k < a.length - 1 - i; ++k)
                if (a[k + 1] < a[k])
                    swap(a, k, k + 1);
    }

    public static void bubbleSortDescending(int [] a)
    {
        for (int i = 0; i < a.length - 1; ++i)
            for (int k = 0; k < a.length - 1 - i; ++k)
                if (a[k] < a[k + 1])
                    swap(a, k, k + 1);
    }

    public static void selectionSortAscending(int [] a)
    {
        int min, minIndex;

        for (int i = 0; i < a.length - 1; ++i) {
            min = a[i];
            minIndex = i;

            for (int k = i + 1; k < a.length; ++k)
                if (a[k] < min) {
                    min = a[k];
                    minIndex = k;
                }
            a[minIndex] = a[i];
            a[i] = min;
        }
    }

    public static void selectionSortDescending(int [] a)
    {
        int max, maxIndex;

        for (int i = 0; i < a.length - 1; ++i) {
            max = a[i];
            maxIndex = i;

            for (int k = i + 1; k < a.length; ++k)
                if (max < a[k]) {
                    max = a[k];
                    maxIndex = k;
                }
            a[maxIndex] = a[i];
            a[i] = max;
        }
    }

    public static void bubbleSort(int [] a)
    {
        bubbleSort(a, false);
    }

    public static void bubbleSort(int [] a, boolean descending)
    {
        if (descending)
            bubbleSortDescending(a);
        else
            bubbleSortAscending(a);
    }

    public static void drawHistogram(int [] data, int count, char ch)
    {
        int maxVal = max(data);

        for (int i = 0; i < data.length; ++i) {
            int charCount = (int)floor(data[i] * count / (double)maxVal);

            while (charCount-- > 0)
                System.out.print(ch);

            System.out.println();
        }
    }

    public static void fillRandomArray(Random random, int [] a, int min, int bound)
    {
        for (int i = 0; i < a.length; ++i)
            a[i] = random.nextInt(min, bound);
    }

    public static void fillRandomArray(Random random, double [] a, double min, double bound)
    {
        for (int i = 0; i < a.length; ++i)
            a[i] = random.nextDouble(min, bound);
    }

    public static int [] getHistogramData(int [] a, int n)
    {
        int [] counts = new int[n + 1];

        for (int i = 0; i < a.length; ++i)
            ++counts[a[i]];

        return counts;
    }

    public static int [] getRandomArray(Random random, int count, int min, int bound)
    {
        int [] a = new int[count];

        fillRandomArray(random, a, min, bound);

        return a;
    }

    public static double [] getRandomArray(Random random, int count, double min, double bound)
    {
        double [] a = new double[count];

        fillRandomArray(random, a, min, bound);

        return a;
    }



    public static int [] join(int [] a, int [] b)
    {
        int [] result = new int[a.length + b.length];
        int idx = 0;

        for (int i = 0; i < a.length; ++i)
            result[idx++] = a[i];

        for (int i = 0; i < b.length; ++i)
            result[idx++] = b[i];

        return result;
    }

    public static int min(int [] a)
    {
        int result = a[0];

        for (int i = 1; i < a.length; ++i)
            if (a[i] < result)
                result = a[i];

        return result;
    }

    public static int max(int [] a)
    {
        int result = a[0];

        for (int i = 1; i < a.length; ++i)
            if (result < a[i])
                result = a[i];

        return result;
    }



    public static int partition(int [] a, int threshold)
    {
        int partitionIndex = 0;

        while (partitionIndex != a.length && a[partitionIndex] < threshold)
            ++partitionIndex;

        if (partitionIndex == a.length)
            return partitionIndex;

        for (int i = partitionIndex + 1; i < a.length; ++i)
            if (a[i] < threshold)
                swap(a, i, partitionIndex++);

        return partitionIndex;
    }

    public static void print(double [] a)
    {
        for (int i = 0; i < a.length; ++i)
            System.out.printf("%f%n", a[i]);
    }

    public static void print(int [] a)
    {
        print(1, a);
    }

    public static void print(int n, int [] a)
    {
        String fmt = String.format("%%0%dd ", n);

        for (int i = 0; i < a.length; ++i)
            System.out.printf(fmt, a[i]);

        System.out.println();
    }


    public static void print(String [] s)
    {
        for (int i = 0; i < s.length; ++i)
            System.out.println(s[i]);
    }

    public static void print(int [][] a)
    {
        print(1, a);
    }

    public static void print(int n, int [][] a)
    {
        for (int i = 0; i < a.length; ++i)
            print(n, a[i]);
    }

    public static void reverse(int [] a)
    {
        for (int i = 0; i < a.length / 2; ++i)
            swap(a, i, a.length - 1 - i);
    }

    public static void reverse(double [] a)
    {
        for (int i = 0; i < a.length / 2; ++i)
            swap(a, i, a.length - 1 - i);
    }

    public static void reverse(char [] chars)
    {
        for (int i = 0; i < chars.length / 2; ++i)
            swap(chars, i, chars.length - 1 - i);
    }

    public static void selectionSort(int [] a)
    {
        selectionSort(a, false);
    }

    public static void selectionSort(int [] a, boolean descending)
    {
        if (descending)
            selectionSortDescending(a);
        else
            selectionSortAscending(a);
    }

    public static int sum(int [] a)
    {
        int total = 0;

        for (int i = 0; i < a.length; ++i)
            total += a[i];

        return total;
    }

    public static void swap(int [] a, int i, int k)
    {
        int temp = a[i];

        a[i] = a[k];
        a[k] = temp;
    }

    public static void swap(double [] a, int i, int k)
    {
        double temp = a[i];

        a[i] = a[k];
        a[k] = temp;
    }

    public static void swap(char [] a, int i, int k)
    {
        char temp = a[i];

        a[i] = a[k];
        a[k] = temp;
    }
}

/*----------------------------------------------------------------
	FILE		: MatrixUtil.java
	AUTHOR		: Java-Aug-2022 Group
	LAST UPDATE	: 05.03.2023

	Utility class for matrix operations

	Copyleft (c) 1993 C and System Programmers Association
	All Rights Free
----------------------------------------------------------------*/
package org.csystem.util.matrix;

import org.csystem.util.array.ArrayUtil;

import java.util.Random;

public class MatrixUtil {
    public static int [][] add(int [][] a, int [][] b)
    {
        int [][] result = new int[a.length][a[0].length];

        for (int i = 0; i < a.length; ++i)
            for (int j = 0; j < a[i].length; ++j)
                result[i][j] = a[i][j] + b[i][j];

        return result;
    }

    public static void addBy(int [][] a, int val)
    {
        for (int i = 0; i < a.length; ++i)
            for (int j = 0; j < a[i].length; ++j)
                a[i][j] += val;
    }

    public static int [][] getRandomMatrix(Random random, int m, int n, int min, int bound)
    {
        int [][] result = new int[m][];

        for (int i = 0; i < m; ++i)
            result[i] = ArrayUtil.getRandomArray(random, n, min, bound);

        return result;
    }

    public static int [][] getRandomSquareMatrix(Random random, int n, int min, int bound)
    {
        return getRandomMatrix(random, n, n, min, bound);
    }

    public static boolean isMatrix(int [][] a)
    {
        for (int i = 1; i < a.length; ++i)
            if (a[0].length != a[i].length)
                return false;

        return true;
    }

    public static boolean isSquareMatrix(int [][] a)
    {
        return isMatrix(a) && a.length == a[0].length;
    }

    public static int [][] multiply(int [][] a, int [][] b)
    {
        int [][] result = new int[a.length][b[0].length];

        //TODO:

        return result;
    }

    public static void multiplyBy(int [][] a, int val)
    {
        for (int i = 0; i < a.length; ++i)
            for (int j = 0; j < a[i].length; ++j)
                a[i][j] *= val;
    }

    public static int [][] subtract(int [][] a, int [][] b)
    {
        int [][] result = new int[a.length][a[0].length];

        for (int i = 0; i < a.length; ++i)
            for (int j = 0; j < a[i].length; ++j)
                result[i][j] = a[i][j] - b[i][j];

        return result;
    }

    public static void subtractBy(int [][] a, int val)
    {
        addBy(a, -val);
    }

    public static long sumDiagonal(int [][] a)
    {
        long total = 0;

        for (int i = 0; i < a.length; ++i)
            total += a[i][i];

        return total;
    }

    public static void swap(int [][] a, int i1, int j1, int i2, int j2)
    {
        int temp = a[i1][j1];

        a[i1][j1] = a[i2][j2];
        a[i2][j2] = temp;
    }

    public static int [][] transpose(int [][] a)
    {
        int [][] t = new int[a[0].length][a.length];

        for (int i = 0; i < a.length; ++i)
            for (int j = 0; j < a[i].length; ++j)
                t[j][i] = a[i][j];

        return t;
    }

    //...
}

/*----------------------------------------------------------------
	FILE		: NumberUtil.java
	AUTHOR		: Java-Aug-2022 Group
	LAST UPDATE	: 26.02.2023

	Utility class for numeric operations

	Copyleft (c) 1993 C and System Programmers Association
	All Rights Free
----------------------------------------------------------------*/
package org.csystem.util.numeric;

import static java.lang.Math.abs;
import static java.lang.Math.log10;
import static java.lang.Math.pow;

public class NumberUtil {
	public static String [] onesTR = {"", "bir", "iki", "üç", "dört", "beş", "altı", "yedi", "sekiz", "dokuz"};
	public static String [] tensTR = {"", "on", "yirmi", "otuz", "kırk", "elli", "altmış", "yetmiş", "seksen", "doksan"};

	public static int [] getDigits(long val, int n)
	{
		int [] values = new int[val == 0 ? 1 : (int)(log10((val = abs(val))) / n) + 1];
		int powOfTen = (int)pow(10, n);

		for (int i = values.length - 1; i >= 0; values[i] = (int)(val % powOfTen), val /= powOfTen, --i)
			;

		return values;
	}

	public static int getDigitsPowSum(int val)
	{
		int n = countDigits(val);
		int total = 0;

		while (val != 0) {
			total += pow(val % 10, n);
			val /= 10;
		}

		return total;
	}

	public static int countDigits(long val)
	{
		return (val != 0) ? ((int)log10(abs(val)) + 1) : 1;
	}

	public static long factorial(int n)
	{
		long result = 1;

		for (int i = 2; i <= n; ++i)
			result *= i;

		return result;
	}

	public static int [] getDigits(long val)
	{
		return getDigits(val, 1);
	}

	public static int [] getDigitsInTwos(long val)
	{
		return getDigits(val, 2);
	}

	public static int [] getDigitsInThrees(long val)
	{
		return getDigits(val, 3);
	}

	public static int getFibonacciNumber(int n)
	{
		if (n <= 2)
			return n - 1;

		int prev1 = 1, prev2 = 0, val = prev1 + prev2;

		for (int i = 3; i < n; ++i) {
			prev2 = prev1;
			prev1 = val;
			val = prev1 + prev2;
		}

		return val;
	}

	public static int getNextFibonacciNumber(int val)
	{
		if (val < 0)
			return 0;

		int prev1 = 1, prev2 = 0, next;

		for (;;) {
			next = prev1 + prev2;

			if (next > val)
				return next;

			prev2 = prev1;
			prev1 = next;
		}
	}

	public static long getPrime(int n)
	{
		long val = 2;
		int count = 0;

		for (;;) {
			if (isPrime(val))
				++count;

			if (count == n)
				return val;

			++val;
		}
	}

	public static boolean isArmstrong(int val)
	{
		return val >= 0 && getDigitsPowSum(val) == val;
	}

	public static boolean isEven(int val)
	{
		return val % 2 == 0;
	}

	public static boolean isOdd(int val)
	{
		return !isEven(val);
	}

	public static boolean isPrime(long val)
	{
		if (val <= 1)
			return false;

		if (val % 2 == 0)
			return val == 2;

		if (val % 3 == 0)
			return val == 3;

		if (val % 5 == 0)
			return val == 5;

		if (val % 7 == 0)
			return val == 7;

		for (long i = 11; i * i <= val; i += 2)
			if (val % i == 0)
				return false;

		return true;
	}

	public static double max(double a, double b, double c)
	{
		return Math.max(Math.max(a, b), c);
	}

	public static int mid(int a, int b, int c)
	{
		if (a <= b && b <= c || c <= b && b <= a)
			return b;

		if (b <= a && a <= c || c <= a && a <= b)
			return a;

		return c;
	}

	public static double min(double a, double b, double c)
	{
		return Math.min(Math.min(a, b), c);
	}

	public static String numToTextTR(long val)
	{
		if (val == 0)
			return "sıfır";

		String text = val < 0 ? "eksi" : "";

		val = abs(val);

		int a = (int)(val / 100);
		int b = (int)(val / 10 % 10);
		int c = (int)(val % 10);

		if (a != 0) {
			if (a != 1)
				text += onesTR[a];
			text += "yüz";
		}

		if (b != 0)
			text += tensTR[b];

		if (c != 0)
			text += onesTR[c];

		return text;
	}

	public static int reverse(int val)
	{
		int result = 0;

		while (val != 0) {
			result = result * 10 + val % 10;
			val /= 10;
		}

		return result;
	}

	public static int sumDigits(int val)
	{
		int sum = 0;

		while (val != 0) {
			sum += val % 10;
			val /= 10;
		}

		return abs(sum);
	}
}

/*----------------------------------------------------------------
	FILE		: StringUtil.java
	AUTHOR		: Java-Aug-2022 Group
	LAST UPDATE	: 04.03.2023

	Utility class for string operations

	Copyleft (c) 1993 C and System Programmers Association
	All Rights Free
----------------------------------------------------------------*/
package org.csystem.util.string;

import org.csystem.util.array.ArrayUtil;

import java.util.Random;

public class StringUtil {
	public static String alphabetTR = "abcçdefgğhıijklmnoöprsştuüvyz";
	public static String alphabetEN = "abcdefghijklmnopqrstuwvxyz";
	public static String alphabetCapitalTR = "ABCÇDEFGĞHIİJKLMNOÖPRSŞTUÜVYZ";
	public static String alphabetCapitalEN = "ABCDEFGHIJKLMNOPQRSTUWVXYZ";
	public static String alphabetAllTR = alphabetTR + alphabetCapitalTR;
	public static String alphabetAllEN = alphabetEN + alphabetCapitalEN;

	public static String capitalize(String s)
	{
		return s.isEmpty() ? "" : Character.toUpperCase(s.charAt(0)) + s.substring(1).toLowerCase();
	}

	public static String changeCase(String s)
	{
		char [] chars = new char[s.length()];

		for (int i = 0; i < chars.length; ++i) {
			char c = s.charAt(i);

			chars[i] = Character.isUpperCase(c) ? Character.toLowerCase(c) : Character.toUpperCase(c);
		}

		return String.valueOf(chars);
	}

	public static int countString(String s1, String s2)
	{
		int count = 0;

		for (int i = -1; (i = s1.indexOf(s2, i + 1)) != -1; ++count)
			;

		return count;
	}

	public static int countStringIgnoreCase(String s1, String s2)
	{
		return countString(s1.toLowerCase(), s2.toLowerCase());
	}


	public static void fillRandomTexts(Random r, String [] texts, int n, String sourceText)
	{
		for (int i = 0; i < texts.length; ++i)
			texts[i] = getRandomText(r, n, sourceText);
	}

	public static void fillRandomTexts(Random r, String [] texts, int min, int bound, String sourceText)
	{
		for (int i = 0; i < texts.length; ++i)
			texts[i] = getRandomText(r, r.nextInt(min, bound), sourceText);
	}

	public static void fillRandomTextsTR(Random r, String [] texts, int n)
	{
		fillRandomTexts(r, texts, n, alphabetAllTR);
	}

	public static void fillRandomTextsTR(Random r, String [] texts, int min, int bound)
	{
		fillRandomTexts(r, texts, min, bound, alphabetAllTR);
	}

	public static void fillRandomTextsEN(Random r, String [] texts, int n)
	{
		fillRandomTexts(r, texts, n, alphabetAllEN);
	}

	public static void fillRandomTextsEN(Random r, String [] texts, int min, int bound)
	{
		fillRandomTexts(r, texts, min, bound, alphabetAllEN);
	}

	public static String getRandomText(Random r, int n, String sourceText)
	{
		char [] c = new char[n];
		int len = sourceText.length();

		for (int i = 0; i < n; ++i)
			c[i] = sourceText.charAt(r.nextInt(len));

		return String.valueOf(c);
	}

	public static String [] getRandomTexts(Random r, int count, int min, int bound, String sourceText)
	{
		String [] texts = new String[count];

		fillRandomTexts(r, texts, min, bound, sourceText);

		return texts;
	}

	public static String [] getRandomTexts(Random r, int count, int n, String sourceText)
	{
		String [] texts = new String[count];

		fillRandomTexts(r, texts, n, sourceText);

		return texts;
	}

	public static String getRandomTextEN(int n)
	{
		return getRandomTextEN(new Random(), n);
	}

	public static String getRandomTextEN(Random r, int n)
	{
		return getRandomText(r, n, alphabetAllEN);
	}

	public static String getRandomTextTR(int n)
	{
		return getRandomTextTR(new Random(), n);
	}

	public static String getRandomTextTR(Random r, int n)
	{
		return getRandomText(r, n, alphabetAllTR);
	}

	public static String [] getRandomTextsTR(Random r, int count, int min, int bound)
	{
		return getRandomTexts(r, count, min, bound, alphabetAllTR);
	}

	public static String [] getRandomTextsTR(Random r, int count, int n)
	{
		return getRandomTexts(r, count, n, alphabetAllTR);
	}

	public static String [] getRandomTextsEN(Random r, int count, int min, int bound)
	{
		return getRandomTexts(r, count, min, bound, alphabetAllEN);
	}

	public static String [] getRandomTextsEN(Random r, int count, int n)
	{
		return getRandomTexts(r, count, n, alphabetAllEN);
	}

	public static String getShortestPangramEN(String s)
	{
		String result = s;

		int end = s.length();

		while (end != 0) {
			int begin = 0;

			while (begin != end) {
				String str = s.substring(begin++, end);

				if (str.length() >= 26 && isPangramEN(str) && str.length() < result.length())
					result = str;
			}

			--end;
		}

		return result;
	}

	public static String getShortestPangramTR(String s)
	{
		String result = s;

		int end = s.length();

		while (end != 0) {
			int begin = 0;

			while (begin != end) {
				String str = s.substring(begin++, end);

				if (str.length() >= 29 && isPangramTR(str) && str.length() < result.length())
					result = str;
			}

			--end;
		}

		return result;
	}

	public static boolean isIdentifier(String s)
	{
		if (s.isBlank() || s.equals("_"))
			return false;

		if (!Character.isJavaIdentifierStart(s.charAt(0)))
			return false;

		int len = s.length();

		for (int i = 1; i < len; ++i)
			if (!Character.isJavaIdentifierPart(s.charAt(i)))
				return false;

		return true;
	}

	public static boolean isPalindrome(String s)
	{
		int left = 0;
		int right = s.length() - 1;
		boolean cLeftSelected = false, cRightSelected = false;
		char cLeft = '\0', cRight;

		while (left < right) {
			if (!cLeftSelected) {
				cLeft = Character.toLowerCase(s.charAt(left));

				if (!Character.isLetter(cLeft)) {
					++left;
					continue;
				}
				cLeftSelected = true;
			}

			if (!cRightSelected) {
				cRight = Character.toLowerCase(s.charAt(right));

				if (!Character.isLetter(cRight)) {
					--right;
					continue;
				}

				if (cLeft != cRight)
					return false;

				cRightSelected = true;
			}

			++left;
			--right;

			cLeftSelected = cRightSelected = false;
		}

		return true;
	}

	public static boolean isPangram(String s, String alphabet)
	{
		int len = alphabet.length();

		for (int i = 0; i < len; ++i)
			if (s.indexOf(alphabet.charAt(i)) == -1)
				return false;

		return true;
	}

	public static boolean isPangramEN(String s)
	{
		return isPangram(s.toLowerCase(), "abcdefghijklmnopqrstuwxvyz");
	}

	public static boolean isPangramTR(String s)
	{
		return isPangram(s.toLowerCase(), "abcçdefgğhıijklmnoöprsştuüvyz");
	}

	public static String join(String [] s, char delimiter)
	{
		return join(s, delimiter + "");
	}

	public static String join(String [] s, String delimiter)
	{
		String result = "";

		for (int i = 0; i < s.length; ++i)
			result += s[i] + delimiter;

		return result.substring(0, result.length() - delimiter.length());
	}

	public static String padLeading(String s, int len, char ch)
	{
		int length  = s.length();

		return len <= length ? s : repeat(len - length, ch) + s;
	}

	public static String padLeading(String s, int len)
	{
		return padLeading(s, len, ' ');
	}

	public static String padTrailing(String s, int len, char ch)
	{
		int length  = s.length();

		return len <= length ? s : s + repeat(len - length, ch);
	}

	public static String padTrailing(String s, int len)
	{
		return padTrailing(s, len, ' ');
	}

	public static String repeat(int count, char ch)
	{
		return String.format("%0" + count + "d", 0).replace('0', ch);
	}

	public static String reverse(String s)
	{
		char [] c = s.toCharArray();

		ArrayUtil.reverse(c);
		return String.valueOf(c);
	}

	public static String [] split(String str, String delimiters)
	{
		return split(str, delimiters, false);
	}

	public static String [] split(String str, String delimiters, boolean removeEmptyEntries)
	{
		String pattern = "[";

		int len = delimiters.length();

		for (int i = 0; i < len; ++i) {
			char c = delimiters.charAt(i);
			pattern += (c == '[' || c == ']') ? ("\\" + c) : c;
		}

		pattern += "]" + (removeEmptyEntries ? "+" : "");

		return str.split(pattern);
	}

	public static String squeeze(String s1, String s2)
	{
		String str = "";
		int len = s1.length();

		for (int i = 0; i < len; ++i) {
			char c = s1.charAt(i);

			if (!s2.contains(c + ""))
				str += c;
		}

		return str;
	}

	public static String trimLeading(String s)
	{
		int i;
		int len = s.length();

		for (i = 0; i < len && Character.isWhitespace(s.charAt(i)); ++i)
			;

		return s.substring(i);
	}

	public static String trimTrailing(String s)
	{
		int i;

		for (i = s.length() - 1; i >= 0 && Character.isWhitespace(s.charAt(i)); --i)
			;

		return s.substring(0, i + 1);
	}

	public static String wrapWith(String s, char prefix, char suffix)
	{
		return wrapWith(s, prefix + "", suffix + "");
	}

	public static String wrapWith(String s, String prefix, String suffix)
	{
		return String.format("%s%s%s", prefix, s, suffix);
	}

	public static String wrapWithStrip(String s, char prefix, char suffix)
	{
		return wrapWithStrip(s, prefix + "", suffix + "");
	}

	public static String wrapWithStrip(String s, String prefix, String suffix)
	{
		return wrapWith(s.strip(), prefix, suffix);
	}

	public static String wrapWithBracesStrip(String s)
	{
		return wrapWithStrip(s, '(', ')');
	}

	public static String wrapWithBraces(String s)
	{
		return wrapWith(s, '(', ')');
	}

	public static String wrapWithCurlyBracesStrip(String s)
	{
		return wrapWithStrip(s, '{', '}');
	}

	public static String wrapWithCurlyBraces(String s)
	{
		return wrapWith(s, '{', '}');
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	for-each döngü deyiminin genel biçimi:
	for (<tür> <değişken> : <dolaşılabilir türe ilişkin referans>)
		<deyim>
	Dolaşılabilir (iterable) tür kavramının detayları "Java ile Uygulama Geliştirme 1 ve Android Programlama" kurslarında
	ele alınacaktır. Diziler de dolaşılabilir türler olduğundan for-each döngü deyimi ile kullanılabilirler

	for-each döngü deyimi ile kod daha yalın hale gelir. Bu durumda for-each döngü deyimi yalınlığı ve okunabilirliği
	bozmadığı sürece kesinlikle kullanılmalıdır. for-each döngü deyimi okunabililiği/algılanabilirliği artırır. Kodu okuyan
	kişi, örneğin bir dizi için klasik for döngü deyimi gördüğünde "for-each ile yazmamasının bir gerekçesi vardır. Aksi
	durumda for-each döngüsü ile yazardı" biçiminde anlar. Yani programcının for-each döngü deyimini kullanması, kullanmadığı
	durumların okunabilirliğini artırır. Bu durumda aslında programcının for-each döngü deyimini kullanmaması için bir
	gerekçesi olmalıdır. Ayrıca derleyici for-each döngü deyimi için çeşitli optimizasyonlar da yapabilmektedir
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	for-each döngü deyiminin dizi ile kullanımında döngü değişkenine her adımda o anki elemanın değeri atanır. Bu işlem
	dizinin başından sonuna kadar yinelenir. Örnekteki for-each döngü deyiminin yaklaşık karşılığı şu şekildedir

	{
		int val;

		for (int i = 0; i < a.length; ++i) {
			val = a[i];
			System.out.printf("%d ", val);
		}
	}
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		int [] a = {10, 20, 33, 48, 5};

		for (int val : a)
			System.out.printf("%d ", val);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	for-each döngü deyiminde döngü değişkenine atama doğrudan (implicit) yapılır. Aşağıdaki for-each döngü deyimi geçerlidir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		int [] a = {10, 20, 33, 48, 5};

		for (long val : a)
			System.out.printf("%d ", val);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	for-each döngü deyiminde döngü değişkenine atama doğrudan (implicit) yapılır. Aşağıdaki for-each döngü deyimi geçersizdir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		int [] a = {10, 20, 33, 48, 5};

		for (short val : a) //error
			System.out.printf("%d ", val);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	for-each döngü deyiminde döngü değişkeninin faaliyet alanı (scope) döngü deyimi boyuncadır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		int [] a = {10, 20, 33, 48, 5};

		for (int val : a)
			System.out.printf("%d ", val);

		System.out.println();
		System.out.printf("val = %d%n", val); //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	for-each döngü deyiminde döngü değişkenin değeri değiştirilebilir. Şüphesiz döngü değişkeninin değerini değiştirmek
	dizi elemanlarını değiştirmez. Bu durumun pratikte çok anlamı yoktur
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		int [] a = {10, 20, 33, 48, 5};

		for (int val : a) {
			++val;
			System.out.printf("%d ", val);
		}

		System.out.println();

		for (int val : a)
			System.out.printf("%d ", val);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte dizinin elemanları değiştirilirken for-each kullanılmış olsa da kod okunabilir olmaz.  Bu durumda
	programcının klasik for döngü deyimini kullanması daha uygundur
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		int [] a = {10, 20, 33, 48, 5};

		int idx = 0;

		for (int val : a)
			++a[idx++];

		for (int val : a)
			System.out.printf("%d ", val);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örneğin aşağıdaki biçimde yazılması daha okunabilirdir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		int [] a = {10, 20, 33, 48, 5};

		for (int i = 0; i < a.length; ++i)
			++a[i];

		for (int val : a)
			System.out.printf("%d ", val);

		System.out.println();
	}
}
/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Klavyeden aşağıdaki formatta girilen bilgiyi ayrıştırarak ekrana sonuçları yazdıran programı yazınız:
		<ad soyad>:<ders adı>:<gg/aa/yyyy>:<gg/aa/yyyy>:<arasınav notu>:<final notu>
		Oğuz Karan:Programlamaya Giriş:31/12/2022:15/01/2023:97:98
		Ali Erdem Güngör:Felsefe:29/12/2022:16/01/2023:65:64
		Bengisu Uzun Yenigün:Java ile Uygulama Geliştirme:23/12/2022:10/01/2023:89:100
		Cemil Aksel:Abap Programlama:22/12/2022:17/01/2023:89:90
		Oğuz Karan:Genel Topoloji:31/12/2022:15/01/2023:34:40

		Açıklamalar:
			- Format geçerlilik kontrolü yapılmayacaktır

			- Formatta vize ve final notlarına göre vize * 0.4 + final * 0.6 formülü ile geçme notu hesaplanacak ve sınav
			tarihleri hangi güne geldiği de eklenerek ekrana yazdırılacaktır

			- Ekran çıktısında "Geçti" ya da "Kaldı" bilgisi de olacaktır. Geçme notu 50 ve üstünde ise öğrenci dersi
			geçmiş sayılacaktır

			- Geçme notu round işlemi ile tam sayı olarak elde edilecektir

			- İleride daha iyisi yazılacaktır

			Örnek Çıktı:
				-----------------------------------------------------------------------
				Ad Soyad: Oğuz Karan
				Ders Adı: Programlamaya giriş
				Arasınav Tarihi: 31 Aralık 2022 Cumartesi
				Final Tarihi: 15 Ocak 2023 Pazar
				Arasınav Notu: 97
				Final Notu: 98
				Geçme Notu: 98
				Sonuç: Geçti
				-----------------------------------------------------------------------

		Not: Örnekte parse işlemi için ayrı bir sınıf yazılmış ve bu sınıfın ctor'u içerisinde parse işlemi yapılmıştır.
		Bu bir yaklaşımdır. Başka yaklaşımlar da söz konusu olabilir. Dikkat edilirse örnek bir uygulamanın parçası
		olacak şekilde düşünülerek yazılmıştır. Şüphesiz bazı detaylar göz ardı edilmiştir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.school.student.lecture.test;


import org.csystem.app.school.student.lecture.LectureInfoParser;
import org.csystem.app.school.student.lecture.LectureParserAppConsoleUtil;

import java.util.Scanner;

public class LectureInfoParserTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);

        for (;;) {
            System.out.print("Formatlı yazıyı giriniz:");
            String str = kb.nextLine();

            if ("elma".equals(str))
                break;

            LectureInfoParser parser = new LectureInfoParser(str);

            LectureParserAppConsoleUtil.printLectureInfo(parser.lectureInfo);
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }

    public static void main(String[] args)
    {
        run();
    }
}

package org.csystem.app.school.student.lecture;

public class LectureInfo {
    public String studentName;
    public String name;
    public String midtermDate;
    public String finalDate;
    public int midtermGrade;
    public int finalGrade;

    //...

    public int getGrade()
    {
        return (int)Math.round(midtermGrade * 0.4 + finalGrade * 0.6);
    }

    //...
}
package org.csystem.app.school.student.lecture;

import org.csystem.app.date.DateUtil;

public class LectureInfoParser {
    public LectureInfo lectureInfo;

    public static String getDateStr(String str)
    {
        String [] dateInfo = str.split("[/]");

        return DateUtil.getDateStrTR(Integer.parseInt(dateInfo[0]), Integer.parseInt(dateInfo[1]), Integer.parseInt(dateInfo[2]));
    }

    public LectureInfoParser(String str)
    {

        String [] lectureInfoStr = str.split("[:]+");

        //...

        lectureInfo = new LectureInfo();
        lectureInfo.studentName = lectureInfoStr[0];
        lectureInfo.name = lectureInfoStr[1];
        lectureInfo.midtermDate = getDateStr(lectureInfoStr[2]);
        lectureInfo.finalDate = getDateStr(lectureInfoStr[3]);
        lectureInfo.midtermGrade = Integer.parseInt(lectureInfoStr[4]);
        lectureInfo.finalGrade = Integer.parseInt(lectureInfoStr[5]);
    }
}

package org.csystem.app.school.student.lecture;

public class LectureParserAppConsoleUtil {
    public static void printLectureInfo(LectureInfo lectureInfo)
    {
        int grade = lectureInfo.getGrade();

        System.out.printf("Ad Soyad:%s%n", lectureInfo.studentName);
        System.out.printf("Ders Adı:%s%n", lectureInfo.name);
        System.out.printf("Arasınav Tarihi:%s%n", lectureInfo.midtermDate);
        System.out.printf("Final Tarihi:%s%n", lectureInfo.finalDate);
        System.out.printf("Arasınav Notu:%d%n", lectureInfo.midtermGrade);
        System.out.printf("Final Notu:%d%n", lectureInfo.finalGrade);
        System.out.printf("Geçme Notu:%d%n", grade);
        System.out.printf("Sonuç:%s%n", grade >= 50 ? "Geçti" : "Kaldı");
    }

    //...
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Elemanlarının Temel Erişim belirleyicileri
	Sınıf elemanlarının (metoti, veri elemanı, ctor'lar vb.) erişim belirleyiciler 4 tanedir ve bir eleman bunlardan
	yalnızca birine sahip olabilir: public, protected, no-modifier, private

	Erişim belirleyici anlamında sınıf 4 bölüme ayrılmıştır. Yani örneğin sınıfın public bir elemanı, sınıfın public
	bölümüne ait olur. Erişim belirleyiciler sınıf dışından erişimde anlamlıdır. Sınıfın içinde erişim belirleyici anlamında,
	bir kısıt yoktur. Yani sınıfın içerisinde her bölüme erişilebilir.

	Anahtar Notlar: Sınıfın no-modifier bölümü (yani erişim belirleyici yazılmamış elemanların oluşturduğu bölüm) Java'da
	erişim belirleyici anlamında public, protected ve private bölümlerden farklıdır. Bazı dillerde olduğu gibi no-modifier
	bir eleman default olarak diğerlerinden biri anlamına gelmez.

	Sınıfın public ve private bölümlerinin anlamları erişen sınıfın elemanına erişilen sınıf ile aynı pakette veya farklı paketlerde
	olmasına göre değişmemektedir. Ancak sınıfın protected ve no-modifier bölümlerinin anlamları erişen sınıfın elemanına
	erişilen sınıf ile aynı pakette veya farklı paketlerde olmasına göre değişmektedir.
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın public bölümüne sınıf dışından erişilebilir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;


class A {
	public int x;

	public A()
	{
		//...
	}

	public void foo()
	{
		//...
	}
}

class B {
	public void bar()
	{
		A a = new A();

		a.x = 10;
		a.foo();
	}
}




/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın public bölümüne sınıf dışından erişilebilir
-----------------------------------------------------------------------------------------------------------------------*/

package csd;

public class A {
	public int x;

	public A()
	{
		//...
	}

	public void foo()
	{
		//...
	}
}


package msd;

import csd.A;

class B {
	public void bar()
	{
		A a = new A();

		a.x = 10;
		a.foo();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın private bölümüne sınıf dışından erişilemez
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class A {
	private int x;
	private A()
	{
		//...
	}

	private void foo()
	{
		//...
	}
}


class B {
	public void bar()
	{
		A a = new A(); //error

		a.x = 10; //error
		a.foo(); //error
	}
}



/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın private bölümüne sınıf dışından erişilemez
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

public class A {
	private int x;

	private A()
	{
		//...
	}

	private void foo()
	{
		//...
	}
}

package msd;

import csd.A;

class B {
	public void bar()
	{
		A a = new A(); //error

		a.x = 10; //error
		a.foo(); //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    Görüldüüğü gibi public ve private bölümlerinin anlamları aynı pakette olan (friendly) sınıflar ve farklı paketlerde olan
    sınıflar açısından değişiklik göstermez
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın no-modifier bölümü aynı paketteki diğer sınıflar için public anlamındadır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class A {
	int x;
	A()
	{
		//...
	}

	void foo()
	{
		//...
	}
}

class B {
	public void bar()
	{
		A a = new A();

		a.x = 10;
		a.foo();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın no-modifier bölümü farklı paketlerdeki diğer sınıflar için private anlamındadır
-----------------------------------------------------------------------------------------------------------------------*/
package csd;

public class A {
	int x;

	A()
	{
		//...
	}

	void foo()
	{
		//...
	}
}

package msd;

import csd.A;

class B {
	public void bar()
	{
		A a = new A(); //error

		a.x = 10; //error
		a.foo(); //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın protected bölümü aynı paketteki diğer sınıflar için public anlamındadır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{

	}
}

class A {
	protected int x;
	protected A()
	{
		//...
	}

	protected void foo()
	{
		//...
	}
}

class B {
	public void bar()
	{
		A a = new A();

		a.x = 10;
		a.foo();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın protected bölümü farklı paketlerdeki diğer sınıflar için "türetme/kalıtım (inheritance)" söz konusu değilse
	private anlamındadır. Farklı pakette ancak "türemiş sınıf (sub/derived class)" kendisine ait protected bölüme
	erişebilir. Türetme ve protected bölümün anlamı detaylı olarak ileride ele alınacaktır
-----------------------------------------------------------------------------------------------------------------------*/

package csd;

public class A {
	protected int x;

	protected A()
	{
		//...
	}

	protected void foo()
	{
		//...
	}
}

package msd;

import csd.A;

class B {
	public void bar()
	{
		A a = new A(); //error

		a.x = 10; //error
		a.foo(); //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    Sınıf bölümlerine erişilebilirlik tablosu:
    Erişim Belirleyici  Kendisi     Friendly sınıflar   Farklı paketlerdeki sınıflar    Türemiş Sınıf
    public                 T               T                        T                         T
    protected              T               T                        F                         T
    no-modifier            T               T                        F                         F
    private                T               F                        F                         F
-----------------------------------------------------------------------------------------------------------------------*/




/*----------------------------------------------------------------------------------------------------------------------
	Nesne yönelimli programlama tekniğinde, sınıfların özellikle veri elemanlarının gizlenmesine uani diğer sınıflardan
	erişilebilmesinin engellenmesine "kapsülleme/sınıfsal temsil (encapsulation)" denir. Bu kavramın geneline
	"veri/bilgi gizleme (data/information hiding)" denir. Burada temel amaç, sınıf dışını ilgilendirmeyecek verilerin
	ve/veya bilgilerin dışarıya verilmemesidir. Örneğin televizyon izlerken kumandayı kullanan kişi kumandanın televizyon
	nasıl ve hangi veriler ile haberleştiğini bilmek zorunda değildir. İşte bu gerçek hayattaki "encapsulation"'dır.

	Bu anlamda sınıfı yazan (server) ve sınıfı kullanan (client) bakış açısı farklıdır. Sınıfı yazan için iki bakış açısı da
	önemlidir. Sınıfı yazan kişi sınıfa ilişkin detayları bilmeldir, aynı zamanda kullanan bakış açısına göre de sınıfı
	tasarlamalı ve yazmalıdır. Sınıfı kullanan bakış açısı (müşteri kodlar) içsel detayların çok fazla hatta belki de hiç
	önemi yoktur
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Programlamada isimlendirmede bazı teknikler kullanılabilmektedir. Bu teknikler dışında da isimlendirme
	yapılabilir. Burada anlatılanlar çok kullanılan ve bilinen tekniklerden bazılardır:
	1. Unix stili (snake case): Bu isimlendirmede karakterlerin tamamı küçük harf ile yazılır ve birden fazla kelimeden
	oluşuyorsa aralarına alttire karakteri yerleştirilir. Örneğin:
		number_of_devices usb_port
	Bu isimlendirme Java'da doğrudan tercihe edilmez.

	2. Camel case (lower camel case): Bu isimlendirmede kelimeler bitişik olarak yazılır. İlk kelimenin baş harfi küçük
	diğer kelimelerin baş harfleri büyük olarak, geri kalan tüm karakterler küçük harf olacak şekilde yazılır. Örneğin:
		numberOfDevices usbPort parseInt, nextInt, changeCase
	Bu isimlendirme genel olarak Java'da metot isimleri, değişken isimleri ve parametre değişken isimlerinde tercih edilir.

	3. Pascal case (upper camel case): Bu isimlendirmede kelimeler bitişik olarak yazılır. Tüm kelimelerin baş harfleri
	büyük, geri kalan tüm karakterler küçük harf olacak şekilde yazılır. Örneğin:
		Random, String, System, StringUtil, DataBindingUtil, TimeUnit
	Bu isimlerndirme Java'da genel olarak UDT'lerde tercih edilir.

	İsimlendirmede bunlardan biri ya da birden fazlası kullanılabilir. Kullanılmak zorunda da değildir.  Örneğin Java'da
	paket isimlerinin tamamı küçük harf olacak şekilde isimlendirme yapılır ve kelimeler bitişik olarak yazılır. Örneğin
	    java.util, org.csystem.util.math, com.springframework
    Burada anlatılan teknikler tamamen geneldir ve bir şekilde isimlendirilmiştir. Hatta bazen bir ya da birden fazla
	teknik biraz değiştirilerek de kullanılabilir
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Nesne yönelimli programlamada sınıfın özellikle private bölümündeki veri elemanlarının isimlendirilmesine yönelik
	bazı teknikler kullanılabilmektedir. Örneğin bazı programcılar private veri elemanları için "m_", "d_", "_", "m"
	gibi önekler kullanırlar. Biz private ve non-static veri elemanları için "m_", private ve static veri elemanlarıo için de
	"ms_" önekini kullanacağız. Bazı programcılar sınıfın private bölümündeki veri elemanları için önek ya da sonek
	koymazlar. Bu da bir tekniktir
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    12.03.2023
-----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Bir veri elemanı dgizlendiğinde sınıfın müşteri kodlarının bu elemanın değerine erişmesi (access) veya bu elemanın
	değerini değiştirmesi (mutate) gerekebilir. Bu durumda sınıfın bu veri elemanlarına erişen public metotları yazılır.
	Veri elemanına erişip değerini veren metotlara "get metotları (getters)" ya da "accessors" denir. Veri elemanına erişip
	değerini değiştiren metotlara da "set metotları (setters)" ya da "mutators" denir. Aslında get veya set metotlarının
	bir veri elemanına karşılık gelmesi gerekmez. Her ne şekilde olursa olsun bu metotlar müşteri kodlar açısından "accessor" ve
	"mutator" metotlardır.

	Sınıfın set metotlarının isimleri genel olarak "set" ile başlatılır. get metotları ise "get" ile başlatılır. Eğer bir
	get metodu boolean bir değere geri dönecekse ismi genel olarak "is" ile başlatılır. Sınıfı yazan programcı özel
	durumlar dışında bu isimlendirmeye dikkat etmelidir. Uygulamada kullanılan bazı ortamlar (framework) ve kütüphaneler (libraries)
	programcı tarafından yazılmış sınıflar için bu metotlar bu şekilde isimlendirilirse default olarak bazı işlemleri
	yapabilirler
-----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte Date sınıfının veri elemanları gizlenmiş ve onlara erişen get ve set metotları yazılmıştır. m_dayOfWeek
	elemanı için set metodunun yazılmadığına dikkat ediniz. Bu sınıf ileride yazılacaktır. Şu an detaylar gözardı edilmiştir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		Date birthDate = new Date(10, 9, 1976);

		System.out.printf("%02d/%02d/%04d%n", birthDate.getDay(), birthDate.getMonth(), birthDate.getYear());
		birthDate.setDay(11);
		birthDate.setMonth(7);
		birthDate.setYear(1983);
		System.out.printf("%02d/%02d/%04d%n", birthDate.getDay(), birthDate.getMonth(), birthDate.getYear());
	}
}

class Date {
	private int m_day, m_month, m_year;
	private int m_dayOfWeek;

	//...

	public Date(int day, int month, int year)
	{
		//...
		m_day = day;
		m_month = month;
		m_year = year;
		//Calculate day of week
	}

	public int getDay()
	{
		return m_day;
	}

	public void setDay(int day)
	{
		//...
		m_day = day;
		//Calculate day of week
	}

	public int getMonth()
	{
		return m_month;
	}

	public void setMonth(int month)
	{
		//...
		m_month = month;
		//Calculate day of week
	}

	public int getYear()
	{
		return m_year;
	}

	public void setYear(int year)
	{
		//...
		m_year = year;
		//Calculate day of week
	}

	public int getDayOfWeek()
	{
		return m_dayOfWeek;
	}

	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte Person sınıfının m_married veri elemanı için get metodu "is" başlatılmıştır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class Person {
	private String m_name;
	private String m_citizenId;
	private boolean m_married;

	//...


	public String getName()
	{
		return m_name;
	}

	public void setName(String name)
	{
		//...
		m_name = name;
	}

	public String getCitizenId()
	{
		return m_citizenId;
	}

	public void setCitizenId(String citizenId)
	{
		//...
		m_citizenId = citizenId;
	}

	public void setMarried(boolean married)
	{
		//...
		m_married = married;
	}

	public boolean isMarried()
	{
		return m_married;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki durumlardan en az biri varsa veri elemanı gizlenmelidir:
	- Sınıfın geliştirilmesinde versiyon ilerledikçe bir veri elemanının isminin hatta türünün değişmesi durumu ile
	çok sık karşılaşılır. Bu durumda daha önmce yazılmış müşteri kodların bu değişimden etkilenmemesi için veri elemanı
	gizlenmelidir

	- Bir veri elemanının sınır değerleri olabilir. Bu değerlerin kontrollü olarak değiştirilebilmesi için veri elemanı
	gizlenmelidir

	- Bir veri elemanının değeri değiştiğinde başka bir veri elemanının da değerinin değişen elemana göre yeniden
	hesaplanması gerekebilir. Bu durumda da bu iki veri elemanı da gizlenmelidir

	- Bir veri elemanının değeri değiştiğinde yeni değere göre bazı işlemlerin yapılması gerekebilir. Örneğin dosya
	yol bilgisi (path) değiştiğinde o nesne için eski dosyanın kapatılıp yeni yol ifadesine ilişkin dosyanın açılması
	gerekebilir. Bu durumda da veri elemanı gizlenmelidir

	- Bazen bir veri elemanının yukarıdaki durumlar dolayısıyla gizlenmesi gerekemeyebilir. Ancak özel durumlar dolayısıyla,
	programcı o veri elemanını gizleyebilir. Bu durumlar çok çeşitli olabilir. Programcı buna karar verecektir.


	Yukarıda maddelerden ilk 4 tanesi kesinlikle dikkat edilmesi gerek durumlardır. Son madde de sınıfın tasarımı yani
	kabaca senaryosu önemlidir olur. Bu durumlar dışında (%3 ile %5 arası) sınıfın veri elemanları public yapılabilir
-----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte Date sınıfının içsel tasarımı ve algoritması değişmesine rağmen daha önce yazılmış müşteri kodlar
	bundan etkilenmemiştir. Detayları gözardı ederek yalnızca değiştikten sonra müşteri kodların etkilenmemesine
	odaklanınız
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		Date birthDate = new Date(10, 9, 1976);

		System.out.printf("%02d/%02d/%04d%n", birthDate.getDay(), birthDate.getMonth(), birthDate.getYear());
		birthDate.setDay(11);
		birthDate.setMonth(7);
		birthDate.setYear(1983);
		System.out.printf("%02d/%02d/%04d%n", birthDate.getDay(), birthDate.getMonth(), birthDate.getYear());
	}
}

class Date {
	private String m_dateStr;
	private int m_dayOfWeek;

	//...

	public Date(int day, int month, int year)
	{
		//...
		m_dateStr = String.format("%02d/%02d/%04d", day, month, year);
		//Calculate day of week
	}

	public int getDay()
	{
		return Integer.parseInt(m_dateStr.substring(0, 2));
	}

	public void setDay(int day)
	{
		//...
		m_dateStr = String.format("%02d/%02d/%04d", day, getMonth(), getYear());
		//Calculate day of week
	}

	public int getMonth()
	{
		return Integer.parseInt(m_dateStr.substring(3, 5));
	}

	public void setMonth(int month)
	{
		//...
		m_dateStr = String.format("%02d/%02d/%04d", getDay(), month, getYear());
		//Calculate day of week
	}

	public int getYear()
	{
		return Integer.parseInt(m_dateStr.substring(6));
	}

	public void setYear(int year)
	{
		//...
		m_dateStr = String.format("%02d/%02d/%04d", getDay(), getMonth(), year);
		//Calculate day of week
	}

	public int getDayOfWeek()
	{
		return m_dayOfWeek;
	}

	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Bazı durumlarda sınıfın public bölümüne ilişkin metotların isminin hatta yapısının da değiştirilmesi
	gerekebilir. Bu durumda sınıfı yazan programcı eski metodu hemen silmez. Metodu "deprecated" duruma getirir ve bunu
	dökumantasyona da yansıtır. Bu durumda eski kodlar derleme anlamında doğrudan etkilenmez. Hatta bazı araçlar ile
	deprecated elemanlar için derleyicinin "warning" vermesi sağlanabilir. Deprecated olmanın gerekçesine göre eski
	kodlar da gerekirse değiştirilir
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Circle sınıfı ve test kodu
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.math.geometry.test;

import org.csystem.util.math.geometry.Circle;

import java.util.Random;
import java.util.Scanner;

public class CircleTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random random = new Random();

        System.out.print("Bir sayı giriniz:");
        int count = kb.nextInt();

        while (count-- > 0) {
            System.out.println("---------------------------------------------------");
            double radius = random.nextDouble(-23.34, 23.34);
            System.out.printf("Generated Radius:%f%n", radius);
            Circle c = new Circle(radius);

            System.out.printf("Radius: %f%n", c.getRadius());
            System.out.printf("Area: %f%n", c.getArea());
            System.out.printf("Perimeter: %f%n", c.getPerimeter());
            System.out.println(c.toString());
            System.out.println("---------------------------------------------------");
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }

    public static void main(String[] args)
    {
        run();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    İlk versiyon
-----------------------------------------------------------------------------------------------------------------------*/


/*----------------------------------------------------------------
	FILE		: Circle.java
	AUTHOR		: Java-Aug-2022 Group
	LAST UPDATE	: 12.03.2023

	Circle class that represents a circle

	Copyleft (c) 1993 C and System Programmers Association
	All Rights Free
----------------------------------------------------------------*/
package org.csystem.util.math.geometry;

public class Circle {
    private double m_radius;
    private double m_area, m_perimeter;

    private void calculateArea()
    {
        m_area = Math.PI * m_radius * m_radius;
    }

    private void calculatePerimeter()
    {
        m_perimeter = 2 * Math.PI * m_radius;
    }

    public Circle()
    {
    }

    public Circle(double radius)
    {
        setRadius(radius);
    }

    public double getRadius()
    {
        return m_radius;
    }

    public void setRadius(double radius)
    {
        m_radius = Math.abs(radius);
        calculateArea();
        calculatePerimeter();
    }

    public double getArea()
    {
        return m_area;
    }

    public double getPerimeter()
    {
        return m_perimeter;
    }

    public String toString()
    {
        return String.format("Radius: %f, Area: %f, Perimeter: %f", m_radius, m_area, m_perimeter);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Bir sonraki versiyon
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------
	FILE		: Circle.java
	AUTHOR		: Java-Aug-2022 Group
	LAST UPDATE	: 12.03.2023

	Circle class that represents a circle

	Copyleft (c) 1993 C and System Programmers Association
	All Rights Free
----------------------------------------------------------------*/
package org.csystem.util.math.geometry;

public class Circle {
    private double m_radius;

    public Circle()
    {
    }

    public Circle(double radius)
    {
        setRadius(radius);
    }

    public double getRadius()
    {
        return m_radius;
    }

    public void setRadius(double radius)
    {
        m_radius = Math.abs(radius);
    }

    public double getArea()
    {
        return Math.PI * m_radius * m_radius;
    }

    public double getPerimeter()
    {
        return 2 * Math.PI * m_radius;
    }

    public String toString()
    {
        return String.format("Radius: %f, Area: %f, Perimeter: %f", m_radius, getArea(), getPerimeter());
    }
}

/*----------------------------------------------------------------
	FILE		: Complex.java
	AUTHOR		: Java-Aug-2022 Group
	LAST UPDATE	: 12.03.2023

	Complex class that represents complex number

	Copyleft (c) 1993 C and System Programmers Association
	All Rights Free
----------------------------------------------------------------*/
package org.csystem.util.math;

import static java.lang.Math.sqrt;

public class Complex {
	private double m_real;
	private double m_imaginary;

	private static Complex add(double re1, double im1, double re2, double im2)
	{
		return new Complex(re1 + re2, im1 + im2);
	}

	private static Complex subtract(double re1, double im1, double re2, double im2)
	{
		return add(re1, im1, -re2, -im2);
	}

	private static Complex multiply(double re1, double im1, double re2, double im2)
	{
		return new Complex(re1 * re2 - im1 * im2, re1 * im2 + re2 * im1);
	}

	private static Complex divide(double re1, double im1, double re2, double im2)
	{
		Complex z = multiply(re1, im1, re2, -im2);
		double divider = re1 * re1 + im1 * im2;

		z.m_real /= divider;
		z.m_imaginary /= divider;

		return z;
	}

	public Complex()
	{
	}

	public Complex(double real)
	{
		m_real = real;
	}

	public Complex(double real, double imaginary)
	{
		m_real = real;
		m_imaginary = imaginary;
	}

	public double getReal()
	{
		return m_real;
	}

	public void setReal(double real)
	{
		m_real = real;
	}

	public double getImaginary()
	{
		return m_imaginary;
	}

	public void setImaginary(double imaginary)
	{
		m_imaginary = imaginary;
	}

	public double getLength()
	{
		return sqrt(m_real * m_real + m_imaginary * m_imaginary);
	}

	public double getNorm()
	{
		return getLength();
	}

	public Complex getConjugate()
	{
		return new Complex(m_real, -m_imaginary);
	}

	public static Complex add(double val, Complex z)
	{
		return add(val, 0, z.m_real, z.m_imaginary);
	}

	public Complex add(Complex other)
	{
		return add(m_real, m_imaginary, other.m_real, other.m_imaginary);
	}

	public Complex add(double val)
	{
		return add(m_real, m_imaginary, val, 0);
	}

	public static Complex subtract(double val, Complex z)
	{
		return subtract(val, 0, z.m_real, z.m_imaginary);
	}

	public Complex subtract(Complex other)
	{
		return subtract(m_real, m_imaginary, other.m_real, other.m_imaginary);
	}

	public Complex subtract(double val)
	{
		return subtract(m_real, m_imaginary, val, 0);
	}

	public static Complex multiply(double val, Complex z)
	{
		return multiply(val, 0, z.m_real, z.m_imaginary);
	}

	public Complex multiply(Complex other)
	{
		return multiply(m_real, m_imaginary, other.m_real, other.m_imaginary);
	}

	public Complex multiply(double val)
	{
		return multiply(m_real, m_imaginary, val, 0);
	}

	public static Complex divide(double val, Complex z)
	{
		return divide(val, 0, z.m_real, z.m_imaginary);
	}

	public Complex divide(Complex other)
	{
		return divide(m_real, m_imaginary, other.m_real, other.m_imaginary);
	}

	public Complex divide(double val)
	{
		return divide(m_real, m_imaginary, val, 0);
	}

	public String toString()
	{
		return String.format("(%f, %f)", m_real, m_imaginary);
	}
}

/*----------------------------------------------------------------
	FILE		: Point.java
	AUTHOR		: Java-Aug-2022 Group
	LAST UPDATE	: 12.03.2023

	Point class that represents 2 dimensional point in
	Cartesian plane

	Copyleft (c) 1993 C and System Programmers Association
	All Rights Free
----------------------------------------------------------------*/
package org.csystem.util.math.geometry;

import static java.lang.Math.pow;
import static java.lang.Math.sqrt;

public class Point {
	private double m_x;
	private double m_y;

	public Point()
	{
	}

	public Point(double x)
	{
		m_x = x;
	}

	public Point(double x, double y)
	{
		m_x = x;
		m_y = y;
	}

	public double getX()
	{
		return m_x;
	}

	public void setX(double x)
	{
		m_x = x;
	}

	public double getY()
	{
		return m_y;
	}

	public void setY(double y)
	{
		m_y = y;
	}

	public double distance()
	{
		return distance(0, 0);
	}

	public double distance(Point other)
	{
		return distance(other.m_x, other.m_y);
	}

	public double distance(double x, double y)
	{
		return sqrt(pow(m_x - x, 2) + pow(m_y - y, 2));
	}

	public void offset(double dxy)
	{
		offset(dxy, dxy);
	}

	public void offset(double dx, double dy)
	{
		m_x += dx;
		m_y += dy;
	}

	public String toString()
	{
		return String.format("(%f, %f)", m_x, m_y);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte dizinin elemanlarının değiştirilmesi engellenmemiştir. Burada gizlenen dizinin adresini tutan
	referans değişkendir. Yani sınıfın veri elemanı olan değişkendir. Dizinin adresi getNumbers metodu ile
	dışarıya verildiğinden artık sınıf dışından da diziye (yani dizi nesnesine) erişilip değiştirilebilir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.generator.random.array.RandomArrayGeneratorApp;

class App {
	public static void main(String [] args)
	{
		RandomArrayGeneratorApp.run();
	}
}

package org.csystem.app.generator.random.array;

import org.csystem.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

public class RandomArrayGeneratorApp {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();
        System.out.print("Bir sayı giriniz:");
        RandomArrayGenerator generator = new RandomArrayGenerator(r, kb.nextInt(), 0, 99);

        int [] a = generator.getNumbers();

        ArrayUtil.print(2, a);
        ArrayUtil.addBy(1, a);
        ArrayUtil.print(2, a);
        ArrayUtil.print(2, generator.getNumbers());
    }
}

package org.csystem.app.generator.random.array;

import org.csystem.util.array.ArrayUtil;

import java.util.Random;

public class RandomArrayGenerator {
    private int [] m_numbers;

    public RandomArrayGenerator(Random random, int count, int min, int bound)
    {
        m_numbers = ArrayUtil.getRandomArray(random, count, min, bound);
    }

    public int[] getNumbers()
    {
        return m_numbers;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte getNumbers metodu içsel olarak tutulan dizinin elemanlarından oluşan yeni bir diz döndürmektedir.
	Bu durumda içsel olarak tutulan dizinin elemanları dışarıdan değiştirilemez. Bu sınıfın dökumantasyonunda belirtilir.

	Anahtar Notlar: java.util.Arrays sınıfının copyOf metotları birinci parametresi ile aldığı dizinin, ikinci parametresi
	ile aldığı uzunluk kadar elemanlarından oluşan yeni bir dizinin referansına geri döner. Bu durumda ikinci parametre
	için dizinin uzunluğu verildiğinde dizinin tamamının kopyası çıkartılmış olur
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.generator.random.array.RandomArrayGeneratorApp;

class App {
	public static void main(String [] args)
	{
		RandomArrayGeneratorApp.run();
	}
}
package org.csystem.app.generator.random.array;

import org.csystem.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

public class RandomArrayGeneratorApp {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();
        System.out.print("Bir sayı giriniz:");
        RandomArrayGenerator generator = new RandomArrayGenerator(r, kb.nextInt(), 0, 99);

        int [] a = generator.getNumbers();

        ArrayUtil.print(2, a);
        ArrayUtil.addBy(1, a);
        ArrayUtil.print(2, a);
        ArrayUtil.print(2, generator.getNumbers());
    }
}

package org.csystem.app.generator.random.array;

import org.csystem.util.array.ArrayUtil;

import java.util.Arrays;
import java.util.Random;

public class RandomArrayGenerator {
    private int [] m_numbers;

    public RandomArrayGenerator(Random random, int count, int min, int bound)
    {
        m_numbers = ArrayUtil.getRandomArray(random, count, min, bound);
    }

    public int[] getNumbers()
    {
        return Arrays.copyOf(m_numbers, m_numbers.length);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte hem dizi referansı hem de mantıksal oalrak dizi nesnesi gizlenmiştir. Bu durumda yine içsel olarak
	tutulan dizide değişiklik yapılamaz. Örnekte dikkat edilirse müşteri kod açısından içeride dizi tutulup tutulmadığının
	bir önemi yoktur
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.app.generator.random.array.RandomArrayGeneratorApp;

class App {
	public static void main(String [] args)
	{
		RandomArrayGeneratorApp.run();
	}
}

package org.csystem.app.generator.random.array;

import org.csystem.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

public class RandomArrayGeneratorApp {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();
        System.out.print("Bir sayı giriniz:");
        RandomArrayGenerator generator = new RandomArrayGenerator(r, kb.nextInt(), 0, 99);
        int [] a = new int[generator.getCount()];

        for (int i = 0; i < a.length; ++i)
            a[i] = generator.get(i);

        ArrayUtil.print(2, a);
        ArrayUtil.addBy(1, a);
        ArrayUtil.print(2, a);

        int count = generator.getCount();

        for (int i = 0; i < count; ++i)
            System.out.printf("%d ", generator.get(i));

        System.out.println();
    }
}


package org.csystem.app.generator.random.array;

import org.csystem.util.array.ArrayUtil;

import java.util.Arrays;
import java.util.Random;

public class RandomArrayGenerator {
    private int [] m_numbers;

    public RandomArrayGenerator(Random random, int count, int min, int bound)
    {
        m_numbers = ArrayUtil.getRandomArray(random, count, min, bound);
    }

    public int getCount()
    {
        return m_numbers.length;
    }

    public int get(int index)
    {
        return m_numbers[index];
    }
}




/*----------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------*/

