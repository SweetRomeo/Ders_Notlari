Programlama Dilleri

     1-)Nesne Yönelimli Programlama(Object Oriented):tek bir kelime ile açıklanamasa da
     kısaca class yapısını destekleyen ve Polimorfizm(Polymorphism)'i de
     destekleyen programlama dillerine verilen isimdir.
     Örnek:Java,Kotlin(Android),C#,C++,Python

     2-)Nesne Tabanlı(Object Base): Polimorfizm'i desteklememesi dışında
     nesne yönelimli programlama ile aynı olarak görülebilir.
     Örnek:Swift(IOS),C++

     3-)Prosedürel:class yapısını desteklemeyip programların C++ deyimiyle sadece
     free function olarak yazılmasına dayalı programlama dillerine prosedürel
     programlama dilleri denir. bu dillere fonksiyon programlama programlama
     dilleri de denilmektedir. Bu diller makine dili ve insan diline
     eşit yakınlıkta olması ile bilinmektedir.
     Örnek:C,C++

     C'nin tarihsel gelişimi:

     Programlama dilleri birbirinden etkilenerek geliştirilmiştir. Bu etkilenme genel olarak bir dilden alıntı yaparak ona yeni
     özellikler ekleme şeklinde olmaktadır. Programlama dilleri bir ağaç olarak düşünülürse ağacın en tepesinde Fortran
     bulunmaktadır. (1954-1957). Fortran dünyanın ilk yüksek seviyeli programlama dilidir. Fortran'ı Algol ve Cobol dilleri
     izlemiştir. C programlama dili 1970 yılında Bell laboratuarlarında Dennis Ritchie tarafından tasarlanmıştır.

     C dilinin Kullanım alanları:
     C dili günümüzde oldukça yaygın bir dil olmakla birlikte pek çok sektörde kullanılmaktadır.
     Ayrıca günümüzde kullandığımız pek çok yüksek seviyeli dilin tasarımı C ile gerçekleştirilmiştir.
     C'nin kullanıldığı başlıca alanlar ise:
     1-Masaüstü sistemlerdeki uygulamalar
     2-Masaüstü işletim sistemleri(Windows,Linux,MacOS)
     3-Database(Veri tabanı) tasarımlarında
     4-Derleyici tasarımlarında
     5-Gömülü sistemler(Arduino,STM32F4)

     alanlar sadece bunların bazılarıdır.
     Temel Kavramlar
     Tokens(Atomlar)

     1-Anahtar Sözcükler(Keywords):Dil için bir anlamı sözcüklere anahtar sözcük nedir.
     örn:static,if,while,switch
     2-Operatörler(Operators):bir iş yapan atomlara denir.
     örn:+,-,=,*=,->,<<,>>,&
     3-Sabitler(Constants)
     örn:100,20.5,'a',-920,10.6F
     4-Değişkenler(Variables)
     örn:sum,count,value,func,isPrime
     5-Stringler(String literals)
     örn:"İzmir","Ankara","İstanbul","Java"
     6-Özel karakterler(Special Characters)
     örn:"{ }","( )","[ ]",",","#"

    C'deki hata mesajları

    runtime
    compile time
    main.c
    main.exe
    optimizasyon
    Uyarı mesajları(Warnings):Programın derlenmesine engel olmayan programcının mantık hataları konusunda bilgilendirilmesine dayalı
    hatalardır. Programcı bu hataları dikkate almalıdır ve mümkünse programı 0 uyarı mesajı ile derlemelidir.

    Gerçek Hatalar(Errors):Dilin sentaks ve semantik kurallarına uyulmamasından kaynaklanan hatalardır. Bir programda
    tek bir gerçek hata olsa bile byte kod üretilmez. Şüphesiz programcı tüm gerçek hataları düzelttiğinde programı
    derleyebilir ve ara kod üretilebilir.

    Ölümcül Hatalar (Fatal Errors): Derleme işleminin bitirilmesini dahi engelleyecek ciddi hatalardır. Programcının kod
    olarak yapabileceği bir şey yoktur. Genellikle sistemdeki problemler yüzünden ortaya çıkmaktadır. Örneğin: diskte
    boş alan olmaması, işletim sisteminde bir problem, bellekte yer olmaması gibi.

    Undefined Behavior(Tanımsız davranış):Bu aslında bir hata mesajı değildir bu hata programcı tarafından
    anlaşılması gereken bir hatadır. Programın derlenmesi ve çalışmasına engel olmaz ancak runtime aşamasında
    ne yaşanacağı tahmin edilemeyen durumlara undefined behavior yani tanımsız davranış denir.
    (Örneğin program her çalıştırdığınızda farklı bir ekran çıktısı elde edilmesi buna
    örnek verilebilir.)
    cppreference.com

    Unspecified behavior(implimention defined/belirsiz davranış):Programın çalışma zamanında ne olucağı
    kestirilemeyen bazı durumlardır tanımzsız davranışlara göre çoğunlukla tehlikeli durumlar değildir.
    Örneğin bir deyim içerisinde iki tane fonksiyon çağrısı varsa fonksiyonların çağrılma sırası
    programcı tarafında kestirilemez bu duruma Unspecified behavior denir.

    IDE nedir?

    Integrated Development Environment(entegre edilmiş geliştirme ortamı)
    Programcı kod yazarken programcıya kısa yollar sunup kolaylıklar sağlayan
    editörlere ide denir. Bir programcı kodu notepadte yazabilecek kadar
    söz konusu programlama dilini bilmeli ancak o programlama dilini
    bildiği kadar da ideyi iyi kullanabilmelidir.

    Derleyici nedir?

    Söz konusu .c .java .cpp .py dosyalarını makine koduna çevirerek
    çalışmaya hazır .exe dosyası  haline getiren programlara derleyici denir.
    C programlama dili için en yaygın kullanılan derleyici gcc(Linux) dir.
    gcc derleyicisinin Windowsdaki karşılığı MinGW dir.

    Derleme Zamanı(Compile Time) Nedir?

    Programın derleme zamanında .exe dosyası elde edilir program çalışmaya
    hazır hale getirilir kodda debug(hata ayıklama) yapılır. Eğer hata varsa
    .exe dosyası elde edilemez. Bu duruma Compile time error denir.

    Çalışma Zamanı(Runtime) Nedir?

    Makine koduna çevrilmiş olan programın .exe dosyasının çalışması ile çalışma
    zamanı başlamış olur. Çalışma zamanı sırasında oluşan hatalara Runtime error denir.
    Çoğu dilde bu tür hatalar exception ismi verilen bir ifade ile isimlendirilebilir
    ancak C dilinde exception diye bir kavram söz konusu değildir.

    Bir C dosyası nasıl derlenir?

    1-)Preprocessor(Ön işlemci Program)
    a-)Yorum satırları atılır.
    b-)include edilen header file yani başlık dosyaları ana programa
    dahil edilir.
    c-)define edilen macrolar ana programa dahil edilir.

    2-)Compiler(Derleyici)
    Bu adımda derleyici çalıştırılır ve .c dosyasından .s uzantılı bir dosya
    elde edilir.

    3-)Assembler
    Bu aşamada söz konusu program makine koduna çevrilir bu sonucunda elde
    edilen koda binary kod denir bu ancak makinelerin anlayabileceği bir
    kod olup sadece 1 ve 0 lardan oluşmaktadır. .o uzantılı bir dosya elde edilir.

    4-)Linker
    .o uzantılı dosya ile 3.parti kütüphaneler bağlanır ve derleme tamamlanmış olur.
/*------------------------------------------------------------------------------
    C de Hello world programı
--------------------------------------------------------------------------*/
#include <stdio.h>

int main()
{
    printf("Hello world");
}

/*------------------------------------------------------------------------------
    bir C programının genel biçimi:

    <# özel karakteri> <include ön işlemci komutu> <eklenecek kütüphane ismi>

    <geri dönüş değeri türü> <fonksiyon ismi>(){

    //yapılacak işlemler
    }
--------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------
C de atomlar arasında istenildiği kadar boşluk bırakılabilir.(Kütüphane include ederken alt satıra geçilirse
error oluşur!)
--------------------------------------------------------------------------*/
#include                   <stdio.h>

int



main(){

    printf



    (                  "Hello world");

}

/*------------------------------------------------------------------------------
Hello world programının atomları:
include:ön işlemci komutu
stdio.h:printf fonksiyonunun bulunduğu kütüphane
int:Anahtar sözcük
main:değişken
()(Parametre bildirimi yapılan parantez):Ayıraç
printf:Değişken
()(printf fonskiyonunun parantezi):operatör(fonksiyon çağrı operatörü)
"Hello world":String literali
1-) -> . [] ()
-------------------------------------------------------------------------------*/
//------------------------------------------------------------------------------------------
/*------------------------------------------------------------------------------
Fonksiyon Cağırma:
<Fonksiyon ismi>(<Argümanlar>);
Not1:Fonksiyonun Argümanları değişken veya sabit olabilir.
int foo(int a,double b);
foo(10,20.5);
foo(a,b);
Not2:Fonksiyonların cağrısı ile fonksiyon bildirimleri
kesinlikle karıştırılmamalıdır. Birinde argüman ismi verilen diğerinde
parametre değişkeni olarak adlandırılır.
--------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------
Fonksiyonların genel yapısı

<geri dönüş değerinin türü> <Fonksiyon ismi>(<Parametre değişkenleri>)
{
//code
}
------------------------------------------------------------------------------*/
#include <stdio.h>

int main(){

    func();
    foo();
}
void func(){
    printf("Func called.");
}
void foo(){
    printf("foo called.");
}
/*------------------------------------------------------------------------------
Aşağıdaki örnekte main içerisinde bildirilen a ve b otomatik ömürlü nesneleriyle
func ve foo içerisinde bildirilen a ve b parametre değişkenleri(parametre değişkenleri
 de otomatik ömürlü nesnelerdir.) birbirinden tamamen farklıdır. func çağrısı
 sırasında argümanlar parametrelere bir aktarım gerçekleşmektedir.
 Scope(Faaliyet Alanı):Bir değişkenin etkin olduğu bloğa scope denir.
------------------------------------------------------------------------------*/
#include <stdio.h>

int func(int a);
int foo(int b);

int main()
{

    int a=10,b=34;
    func(a);
    foo(b);
}
int func(int a){ //int a = a;

    printf("Func called.");
}
int foo(int b){

    printf("foo called.");
}
//------------------------------------------------------------------------------
#include <stdio.h>

void func(int a);
void foo(int b);

int main()
{

    int x = 10, y = 34;
    func(x);
    foo(y);
}
void func(int a){ //int a = x;

    printf("Func called.");
    //Non-void function does not return a value
}
void foo(int b){ //int b = y;

    printf("foo called.");
}

/*------------------------------------------------------------------------------
Nesnelerin Ömürleri:
1-)Otomatik ömürlü nesneler
2-)statik ömürlü nesneler
3-)Dinamik Ömürlü nesneler
------------------------------------------------------------------------------*/
#include <stdio.h>

void func(int a);
void foo(int b);

int c = 25; //statik ömürlü nesneler

int main()
{
    int x = 10, y = 34;
    func(x);
    foo(y);
    foo(y);
    foo(y);
}
void func(int a){ //int a = x;

    printf("Func called.");
    //Non-void function does not return a value
}
void foo(int b){ //int b = y;

    printf("foo called.");
    static int x = 25;//statik ömürlü
    x++;
    printf("%d ",x);
}
/*------------------------------------------------------------------------------
Aşağıdaki örnekte main içerisinde bildirilen a ve b otomatik ömürlü nesneleriyle
func ve foo içerisinde bildirilen a ve b parametre değişkenleri(parametre değişkenleri
 de otomatik ömürlü nesnelerdir.) birbirinden tamamen farklıdır. func çağrısı
 sırasında argümanlar parametrelere bir aktarım gerçekleşmektedir.
 stack
------------------------------------------------------------------------------*/
#include <stdio.h>

int func(int a);
int foo(int b);

int main() {
    {
    int x = 10, y = 34;
    func(x);
    foo(y);
    }//x ve y otelden çıktı
    int x = 45;

    {
        //blok
    }
}
int func(int a){ //int a = a;

    printf("Func called.");
    return a;
}
int foo(int b)
{
    printf("foo called.");
    return b;
}
//-----------------------------------------------------------------------------
#include <stdio.h>

int func(int a);
int foo(int b);

int main() {
    {
        int x = 10, y = 34;
        printf("%d ",func(x));
        printf("%d ",foo(y));
    }//x ve y otelden çıktı
    int x = 45;
    {
        printf("%d ", x + 5); //blok
    }
}

int func(int a){ //int a = a;

    printf("Func called.");
    return a * a;
}
int foo(int b)
{
    printf("foo called.");
    return b * b;
}
/*------------------------------------------------------------------------------
C de temel türler(Primitive types)
Tam Sayı türleri
1 byte = 8 bit 0000 0000
Tür                 Uzunluk                                            Sınır değerleri
*char               1 byte = 8 bit                                     [-128,127]
unsigned char      1 byte                                                [0,255]
signed char            1 byte                                           [-128,127]
*int               2 veya 4 bytes                                   [-2147483648,+2147483647]
unsigned int   2 veya 4 bytes                                            [0,+4294967295]
short              2 bytes                                              [-32768,+32767]
unsigned short     2 bytes                                                   [0,+65535]
long               4 veya 8 bytes                     [-9223372036854775808,9223372036854775807]
unsigned long      8 bytes                                                   [0,18446744073709551615]
long long           8 byte
unsigned long long  8 byte
--------------------------------------------------------------------------*/
------------------------------------------------------------------------------*/
Gerçek Sayı türleri

Tür                Uzunluk                                             Sınır değerleri

float              4 byte                                             [1.2E-38,3.4E+38]
*double            8 byte                                             [2.3E-308 to 1.7E+308]
long double       16 byte                                             [3.4E-4932 to 1.1E+4932]

//------------------------------------------------------------------------------
#include <stdio.h>

int main() {
    int x,y;
    printf("iki sayi giriniz\n");
    scanf("%d%d",&x,&y);
    printf("Girdiginiz sayilar: %d %d",x,y);
}
/*------------------------------------------------------------------------------
int türden klavyeden sayı isteme kalıbı
------------------------------------------------------------------------------*/
#include <stdio.h>

int main(){

    int value;
    printf("Bir sayi giriniz?\n"); //output
    scanf("%d",&value); //input
    printf("%d",value);
}
--------------------------------------------------------------------------*/
türe bağlı scanf fonksiyonunun yüzde(%) karakteri ile kullanma kalıpları:

int,unsigned,unsigned int,short,unsigned short,char,unsigned char->%d
char,unsigned char->%c
long->%ld
float->%f
double->%lf
unsigned long long->%llu
unsigned long->%lu
long double->%Lf
Ascii
Not:char ve unsigned char türlerinde sayı şeklinde yazmak için %d kullanılırken
karakter(harf sayı,noktalama işareti veya özel karakter) yazdırmak için %c ile
kullanılmalıdır.
A -> 65
Not:Yüzde(%) özel karakteri ile kullanma kalıpları printf fonksiyonu ile
yazdırma yapmak için de aynı şekilde gerçekleşmektedir.Ancak scanf
fonksiyon değişkenin adresini alırken printf fonksiyonu değişkenin
kendisini kullanmaktadır.
/*------------------------------------------------------------------------------
//Aşağıdaki örneği inceleyiniz.
#include <stdio.h>

int main(){

    int day,month,year;
    printf("Gun?\n");
    scanf("%d",&day);
    printf("Month?\n");
    scanf("%d",&month);
    printf("Year?\n");
    scanf("%d",&year);
    printf("%02d.%02d.%04d",day,month,year);
}
--------------------------------------------------------------------------*/
double türden klavyeden sayı isteyip yazdırma kalıbı
Bu kod float değişkenler için de bu şekilde çalışmaktadır.
Ancak float türü yuvarlama hatalarına daha az dirençli olduğu için
bilgi kaybı oluşur.
/*------------------------------------------------------------------------------
#include <stdio.h>

int main(){

    double value;
    printf("Bir sayi giriniz?\n"); //standart output buffer
    scanf("%lf",&value); //standart input buffer
    printf("Girilen sayi:%lf",value);

}

--------------------------------------------------------------------------*/
short türünden klavyeden sayı isteme ve yazdırma kalıbı
/*------------------------------------------------------------------------------

#include <stdio.h>

int main()
{
    short value;
    printf("Bir sayi giriniz?");
    scanf("%hd",&value);
    printf("Girilen sayi:%d",value);
}

--------------------------------------------------------------------------*/
long türden klavyeden sayı isteyip yazdırma kalıbı
/*------------------------------------------------------------------------------
#include <stdio.h>

int main()
{
    long value;
    printf("Bir sayi giriniz?");
    scanf("%ld",&value);
    printf("Girilen sayi:%ld",value);
}

--------------------------------------------------------------------------*/
char türden klavyeden sayı isteyip iki türlü yazdırma kalıbı
/*------------------------------------------------------------------------------
#include <stdio.h>

int main()
{
    char value;
    printf("Bir sayi giriniz?");
    scanf("%d",&value);
    printf("Girilen sayi:%d\n",value);
    printf("Karakter:%c",value);
}
--------------------------------------------------------------------------*/
unsigned long long->%llu
unsigned long long türden klavyeden sayı isteme ve yazdırma kalıbı
/*------------------------------------------------------------------------------

#include <stdio.h>

int main()
{
    unsigned long  long value;
    printf("Bir sayi giriniz?");
    scanf("%llu",&value);
    printf("Girilen sayi:%llu",value);
}
--------------------------------------------------------------------------*/
unsigned long->%lu
unsigned long türden klavyeden sayı isteme ve yazdırma kalıbı
/*------------------------------------------------------------------------------
#include <stdio.h>

int main()
{
    unsigned long value;
    printf("Bir sayi giriniz?");
    scanf("%lu",&value);
    printf("Girilen sayi:%lu",value);
}



--------------------------------------------------------------------------*/
long double->%Lfl
long double türden klavyeden sayı isteme ve yazdırma kalıbı
/*------------------------------------------------------------------------------
#include <stdio.h>

int main()
{
    long double value;
    printf("Bir sayi giriniz?");
    scanf("%Lfl",&value);
    printf("Girilen sayi:%Lfl",value);
}
/*-------------------------------------------------------------------------
limits.h standart kütüphanesiyle temel türlerin maksimum ve minimum değerleri
elde edilebilir.
------------------------------------------------------------------------*/
#include <stdio.h>
#include <limits.h>

int main()
{
    int max = INT_MAX;
    int min = INT_MIN;
    long long ll_max = LLONG_MAX;
    long long ll_min = LLONG_MIN;
    printf("int max : %d\n",max);
    printf("int min : %d\n",min);
    printf("long long max : %lld\n",ll_max);
    printf("long long min : %lld\n",ll_min);
}
--------------------------------------------------------------------------*/
return deyiminin genel yapısı:
return bir kontrol deyimi(control statement)
<return anahtar sözcüğü> <geri dönüş değeri>;
Not:Fonksiyonda bildirilen geri dönüş değerinin türü ile return deyiminde
belirtilen değer türü aynı olmalıdır aksi durumda veri veya bilgi kaybı olabilir.
<geri dönüş değeri türü> <fonksiyon ismi>(<parametre değişkenleri>(varsa))
iki tip fonksiyon vardır:
1-)bir iş yapan(void fonksiyonlar)
2-)bir iş yapıp bi de değer döndüren(geri dönüş değeri olan fonksiyonlar)
#include <stdio.h>

int foo(){
    return 10.4; //narrowing conversion double 8 byte int 4 byte
}

int main()
{


}

#include <stdio.h>

void printHello()
{
    printf("Hello");
    return;
    //bu deyimler yürültülmeyecek
}

int main(void)
{
    printHello();
}
/*------------------------------------------------------------------------------
Geri dönüş değeri olan fonksiyonlar geri dönüş değeri yokmuş gibi kullanılabilir
ancak geri dönüş değeri olmayan fonksiyonlar geri dönüş değeri varmış gibi
kullanılamaz.
--------------------------------------------------------------------------*/
#include <stdio.h>


void foo()
{
    printf("foo called\n");
    return;
    //code
}
int func()
{
    printf("func called\n");
    return 10;
}

int main(){
    int a=foo();//error(illegal)
    func();//legal
    foo();//legal
    int b=func();//legal
}
--------------------------------------------------------------------------*/
Geri dönüş değeri olmayan fonksiyonlar için return tek başına kullanılabilir ancak
bir değişken ,macro veya bir sabit ile kullanılamaz.(ifadeyle)
Anahtar Notlar:return deyimi akışı sonlandırır ve ondan sonraki deyimler yürütülmez.
/*------------------------------------------------------------------------------
#include <stdio.h>
#define A 10

void foo(){

    return;
    //çalıştırılmıycak
    printf("foo");
}
void func(){
    int x = 10;
    return A;//error
}

int main(){



}
/*----------------------------------------------------------------------------
Geri dönüş değeri olan bir fonksiyonun her noktada bir geri dönüş değeri
olmalıdır bu error değildir ama if e girmediği durumlar için fonksiyon bir çöp değer döndüreceğinden
kodda ciddi sıkıntılar olabilir.
------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------
Geri dönüş değeri olan fonksiyonlar geri dönüş değeri yokmuş gibi kullanılabilir
ancak geri dönüş değeri olmayan fonksiyonlar geri dönüş değeri varmış gibi
kullanılamaz.Bu kodda tanımsız davranış(undefined behaviour) söz konusudur.
--------------------------------------------------------------------------*/
#include <stdio.h>

int func(int a){

    if(a==5)
        return 10;

}

int main(){
    int val;
    printf("Bir sayi giriniz?\n");
    scanf("%d",&val);
    printf("%d",func(val));
}

/*---------------------------------------------------------------------------
Sabitler(Constants)
1-)Bir sayı nokta içermiyorsa, int sınırları içerisindeyse ve son ek almamışsa
int türdendir.
2-)C de short türden sabit yoktur ancak int sabitleri short sınırları içerisinde olmak kaydı
ile short sahibiymiş gibi kullanılabilir.
3-)char en küçük tamsayı türüdür. [-128,127]
4-)long long türü en uzun tam sayı türüdür.
5-)long double türü en uzun gerçek sayı türüdür.
6-)C de javadaki benzer son ek kullanımı vardır.
7-)Sayı nokta içeriyorsa ve son ek almamışsa otomatik olarak double türden kabul edilir.
8-)Sayı nokta içeriyorsa ve son ek olarak büyük veya küçük f,F almış ise
float türdendir.
------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------
 double -> 8 byte
 float -> 4 byte
 Narrowing conversion(Daraltıcı dönüşüm)
------------------------------------------------------------------------------*/
#include <stdio.h>

int main(){

    float f = 20.6;
}
//Yukarıdaki problemin çözümü
#include <stdio.h>

int main()
{
    float f = 20.6F;
}
/*-----------------------------------------------------------------------------
 Aşağıdaki örnekte integral promotion kuralı söz konusudur.
------------------------------------------------------------------------------*/
#include <stdio.h>

int main(){

    printf("Hello world");
    short s1 = 100;
    short s2 = 234;
    short s3 = s1 + s2;
    return 0;
}
//Aşağıdaki örneği inceleyiniz.
#include <stdio.h>

int main(){

    short s1 = 100;
    short s2 = 234;
    int ival = s1 + s2;
    return 0;
}
/*-----------------------------------------------------------------------------
 Büyük türlerden küçük türlere atamalarda narrowing conversion(daraltıcı dönüşüm)
 söz konusudur ancak küçük türlerden büyük türlere için warning durumu söz konusu
 değildir.
------------------------------------------------------------------------------*/
#include <stdio.h>

int main() {

    printf("Hello world");
    short s = 100;
    float f1 = 20.4;//narrowing conversion
    float f2 = 102.3F;//yapılması gereken
    long long ll=189l;
    return 0;
}
/*--------------------------------------------------------------------------
Gerçek sayı sabitlerinin tam sayı sabitlerine atanması durumunda sayının noktadan
sonraki kısmı atılır herhangi bir yuvarlama söz konusu değildir.
int a = 20.99999999;
/*------------------------------------------------------------------------------
----------------------------------------------------------------------------*/
Aşağıdaki örnek error oluşturmaz.Bu örnekte anlatılmak istenen
her sabitin her türe atanabileceğini gösterir ancak sınırlar dışında kalınması
durumunda bilgi kaybı oluşabilir.
Not:Her türden her türe atama geçerlidir. ancak narrowing conversion durumlarına
dikkat edilmelidir.
------------------------------------------------------------------------------*/

int main() {

    float f = 100;
    double d = 100;
    long l = 100;
    unsigned long lu = 100;
    unsigned long long llu = 100;
    long long ll = 100;
    unsigned u = 100;
    int a = 100;
    char c = 'A';
    unsigned char ch = 129;
    long double ld = 100;
    short s = 100;
    short int si = 100;
    long int li = 100;

    printf("float:%d\n", sizeof(f));//float:4
    printf("long:%d\n", sizeof(l));//long:4
    printf("int:%d\n", sizeof(100));//int:4
    printf("unsigned int:%d\n", sizeof(u));//unsigned int:4
    printf("double:%d\n", sizeof(d));//double:8
    printf("unsigned long:%d\n", sizeof(lu));//unsigned long:4
    printf("unsigned long long:%d\n", sizeof(llu));//unsigned long long:8
    printf("long long:%d\n", sizeof(ll));//long long:8
    printf("int:%d\n", sizeof(a));//int:4
    printf("char:%d\n", sizeof(c));//char:1
    printf("unsigned char:%d\n", sizeof(ch));//unsigned char:1
    printf("long double:%d\n", sizeof(ld));//long double:12
    printf("short:%d\n", sizeof(s));//short:2
    printf("short int:%d\n", sizeof(si));//short int:2
    printf("long int:%d", sizeof(li));//long int:4
}
----------------------------------------------------------------------------*/
char sabitleri tek tırnak('') içerisinde kullanılır veya int sabitleri de
kullanılabilir. Tek tırnak içerisinde birden fazla karakter kullanımı
 legeldir ancak derleyici uyarı mesajı verir çünkü bilgi kaybına sebep olur çünkü
 örneğin aşağıdaki örnek için 'aa' ifadesi int türden kabul edilmektedir.
 intten chara dönüşüm de narrowing yani daraltıcı dönüşüm olduğu için bu durum
 warninge sebep olur.
 Not: Bu warning ve bilgi kaybı durumu escape sequence karakterler için
 geçerli değildir.
/*------------------------------------------------------------------------------
#include <stdio.h>

int main(){

    char ch='a';
    char c1=120;
    char c2='as';//warning!!
    printf("%c",c2);
}

/*--------------------------------------------------------------------------
Escape sequence(Kaçış) karakterler:
\n--->new line(line feed)
\t--->tab
\b--->backspace
\v--->vertical tab
\r--->carriage return
\'--->tek tırnak
\"--->çift tırnak
\?--->soru işareti
\0--->Null karakter
\x--->three hexadecimal
\\--->\
binary, octal(8 lik sistem), hexadecimal(1 2 3 4 5 6 7 8 9 A B C D E F)
0000 1101
0000 1110
------------------------------------------------------------------------------*/
//------------------------------------------------------------------------------
#include <stdio.h>

int main(){
    printf("https\\\\:www.google.com\\bilim_felsefesi");
}
//------------------------------------------------------------------------------
#include <stdio.h>

int main()
{
    printf("Good\tMorning");
    printf("Good\rMorning");
    printf("Good\nMorning");
}
/*----------------------------------------------------------------------------
C'de çift tırnak içerisinde çift tırnak ancak aşağıdaki gibi kullanılabilir.
 Doğrudan çift tırnak içerisinde çift tırnak kullanımı geçersizdir.
------------------------------------------------------------------------------*/
#include <stdio.h>
#include <string.h>

int main(void)
{
    printf("\"Mustafa\"");
}
/*----------------------------------------------------------------------------
C'de çift tırnak içerisinde tek tırnak kullanımı hem ters bölü kullanılarak
hem de doğrudan yapılabilir.
------------------------------------------------------------------------------*/
#include <stdio.h>

int main(){

    printf("'Mustafa'");
}
//------------------------------------------------------------------------------
/*------------------------------------------------------------------------------
C de input ve output işlemleri
printf fonksiyonunun geri dönüş değeri(return value)
printf fonksiyonunun geri dönüş değeri yazdırılan karakter sayısına eşittir.
örneğin "Merhaba" stringinin geri dönüş değeri 7 olur çünkü bu yazı 7 karakterden
oluşmaktadır.
------------------------------------------------------------------------------*/
#include <stdio.h>

int main() {

    printf("%d",printf("Merhaba"));//Merhaba7
}
/*------------------------------------------------------------------------------
Aşağıdaki örnekte ekran çıktısı 98131
------------------------------------------------------------------------------*/
#include <stdio.h>

int main() {

    printf("%d",printf("%d",printf("981")));
}
/*-------------------------------------------------------------------------------
scanf fonksiyonunun geri dönüş değeri:
scanf'in geri dönüş değeri bağımlı değişken sayısına eşittir.
scanf("%d",&val); ifadesinin geri dönüş değeri bir sayı girildiği
 takdirde 1 çünkü sadece bir adet değer giriliyor.
 Not: Yazı girilmesi durumunda geri dönüş değeri 0 dır.
-------------------------------------------------------------------------------*/
#include <stdio.h>

 int main() {

     int val;
     printf("%d",scanf("%d",&val));//giriş:12 ekran çıktısı:1
     //giriş:ankara ekran çıktısı:0
 }
/*------------------------------------------------------------------------------
aşağıdaki örnekte ilk bağımlı değişken yazı girildiği takdirde direk olarak geri
dönüş değeri 0 olur.
------------------------------------------------------------------------------*/
#include <stdio.h>

int main() {

    int a,b,c;
    printf("%d",scanf("%d %d %d",&a,&b,&c));//giriş:ankara 12 34 ekran çıktısı:0
    //giriş:12 ankara 34 ekran çıktısı:1
    //giriş:12 34 ankara ekran çıktısı:2

}
0001 0010
0000 1001
0010 0100

/*----------------------------------------------------------------------------
Category                       Operatör                               Associativity(Yapılma sırası)
1-)Postfix                 () [] -> .                                     Soldan sağa
2-)Unary(tekli)           + - ! ~ ++ -- (type) * & sizeof ()            Sağdan sola
3-)Multiplicative()              * / %                                        Soldan sağa
4-)Additive(ekleme)               + -                                     Soldan sağa
5-)Shift(Değiştirme)          << >>     0111 1111                            Soldan sağa
6-)Relational(ilişki)            < <= > >=                                Soldan sağa
7-)Equality(eşitlik)             == !=                                    Soldan sağa
8-)Bitwise AND                     &                                  Soldan sağa
9-)Bitwise XOR                     ^                                  Soldan sağa
10-)Bitwise OR(Bitsel veya)        |                                  Soldan sağa
11-)Logical AND(Mantıksal ve)      &&                                 Soldan sağa
12-)Logical OR(Mantıksal veya)     ||                                 Soldan sağa
13-)Conditional(Koşul)             ? : ternary operator               Sağdan sola
14-)Assignment(Atama)      = += -= *= /= %= >>= <<= &= ^= |=          Sağdan sola
15-)Comma(Virgül)               ,                                     Soldan sağa
------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------
Aritmetik 4 işlem operatörleri
------------------------------------------------------------------------------*/
#include <stdio.h>

int main()
{
    int a,b;
    scanf("%d%d",&a,&b);
    printf("%d+%d=%d\n",a,b,a+b);
    printf("%d-%d=%d\n",a,b,a-b);
    printf("%d/%d=%d\n",a,b,a/b);
    printf("%d*%d=%d\n",a,b,a*b);
}
/*------------------------------------------------------------------------------
Atama operatörünün ürettiği değer bu operatörün sağ operandıdır.
------------------------------------------------------------------------------*/
#include <stdio.h>

int main() {

    int a,b,c,d,e;

    (a = (b = (c = (d = (e = 10))));

    printf("%d=%d=%d=%d=%d",a,b,c,d,e);
}

/*-------------------------------------------------------------------------------
işaret + operatörü
-------------------------------------------------------------------------------*/
#include <stdio.h>

int main()
{
    int a=10,b;
    b=+a;
    printf("%d",b);//+10
}
/*------------------------------------------------------------------------------
işaret - operatörü
------------------------------------------------------------------------------*/

#include <stdio.h>

int main() {

    int a=10,b;
    b=-a;
    printf("%d",b);//-10
}

/*-----------------------------------------------------------------------------
Aşağıdaki kod legaldir.eksi(-) sayısı tekse sayı negatif çiftse sayı pozitif olur aynı
matematikte olduğu gibi
------------------------------------------------------------------------------*/

#include <stdio.h>

int main() {

    int a=10,b;
    b= - - - - - - - - - - - - - - -a;
    printf("%d",b);//-10
}

/*--------------------------------------------------------------------------
eşitlik operatörleri:==,!=
Not:Bu operatörlerin ürettiği değer 0 veya 1 dir. 0 false olarak kabul edilirken 0
dışında her değer true olarak kabul edilir.
------------------------------------------------------------------------------*/


#include <stdio.h>

int main() {

    int a=10,b;
    b=+a;
    printf("%d\n",a==b);//1
    printf("%d\n",a!=b);//0
}
/*--------------------------------------------------------------------------
İlişki operatörleri:
<=,>=
karşılaştırma operatörü:
==
Mantıksal değil(not)(!) operatörü:
!a
true -> non zero tüm değerler true
false -> 0
------------------------------------------------------------------------------*/

#include <stdio.h>

int main() {

    int a=10,b;
    b=a+2;
    printf("%d",a>=b);//0
    printf("%d",a<=b);//1
    printf("%d",a==b);//0
    printf("%d",a!=b);//1
}

/*----------------------------------------------------------------------------
Mod operatörü:(%) bir sayının diğer bir sayı ile bölümünden kalanı veren operatördür.
------------------------------------------------------------------------------*/
#include <stdio.h>

int main() {

    int a,b;
    printf("Bir sayi giriniz?\n");
    scanf("%d",&a);
    b = a % 3;
    printf("%d",b);//10 un 3 ile bölümünde kalan 1 dir.
}
/*------------------------------------------------------------------------------
Virgül operatörü(Comma operator):Virgül operatörünün ürettiği değer bu operatörün sağ operandıdır.
------------------------------------------------------------------------------*/

#include <stdio.h>

int main() {
    int a=10,b;
    b=2+(a,3+2);//3 önce 2 ile toplanıp sonra virgül operatörü ile 5 değeri elde edilip değer 2 ile toplanır
    printf("%d",b);//7
}

/*-----------------------------------------------------------------------------
++ operatörünün prefix(ön ek ++) kullanımı
------------------------------------------------------------------------------*/
#include <stdio.h>

int main() {

    int a=10;
    printf("%d",++a);//11
}


/*------------------------------------------------------------------------------
++ operatörünün postfix(son ek ++) kullanımı
------------------------------------------------------------------------------*/
#include <stdio.h>

int main() {

    int a=10;

   printf("%d",a++);//10
   printf("%d",a);//11
   printf("%d",++a);//12
}

/*----------------------------------------------------------------------------
-- operatörü
-----------------------------------------------------------------------------*/
#include <stdio.h>

int main() {

    int a=10;

    printf("%d",--a);//9
    printf("%d",a++);//9
    printf("%d",++a);//11
    printf("%d",a--);//11
    printf("%d",a);//10
}
/*----------------------------------------------------------------------------
Aşağıdaki ifadede bir tanımsız davranış söz konusudur.
-----------------------------------------------------------------------------*/

#include <stdio.h>

int main()
{
    int a = 10;

    a = ++a; //ub

    printf("a = %d\n", a);
}
/*-------------------------------------------------------------------------------
Maximal Munch kuralı(en uzun atom kuralı):Derleyici baştan başlayarak atomları
en uzun atomu oluşturacak şekilde ele almaktadır. Aşağıdaki örnek için
en uzun atom kuralından dolayı bu ifade x++ +y olarak ele alınmaktadır.
x+++y => x+ ++y, x++ +y
x+ ++y
x++ +y
------------------------------------------------------------------------------*/
#include <stdio.h>

int main()
{
    int x = 10,y = 3;
    int result = x+++y;//x++ +y
    printf("%d",result);
}
/*-----------------------------------------------------------------------------
Mantıksal operatörler:
Mantıksal Ve(&&) Operatörü:ikiside doğruysa doğru,en az biri yanlışsa yanlış.
Mantıksal Veya(||) Operatörü:herhangi biri doğruysa doğruysa doğru ikiside yanlışsa
yanlış.
------------------------------------------------------------------------------*/
#include <stdio.h>

int func(){
    printf("func called");
    return 1;
}
int foo()
{
    printf("foo called");
    return 0;
}

int main() {

    int a = foo() && func();
}

/*------------------------------------------------------------------------------
Mantıksal operatörlerin kısa devre davranışı:
Bu olay ancak bir fonksiyon çağırıldığında diğer fonksiyon çağrılsa da çağrılmasa da
sonucun etkilenmeyeceği durumlarda gerçekleşir.
Aşağıdaki örnekte yalnızca foo fonksiyonu çağrılmasının sebebi func fonksiyonunun değeri
ne gelirse gelsin sonucun 0 çıkmasından kaynaklanır.
------------------------------------------------------------------------------*/

#include <stdio.h>

int func(){
    printf("func");
    return 1;
}
int foo()
{
    printf("foo");
    return 0;

}

int main()
{

 int a = foo() && func();

}


/*--------------------------------------------------------------------------
And(veya) operatörünün kısa devre davranışı:
Aşağıdaki kodda sadece foo fonksiyonunun çağrılmasının sebebi diğer değerlerin
sonucu etkilememesinden kaynaklıdır.
------------------------------------------------------------------------------*/

#include <stdio.h>

int func(){
    printf("func");
    return 0;

}
int foo()
{
    printf("foo");
    return 1;

}
int bar(){

    printf("bar");
    return 0;

}

int main()
{
    int a = foo() || func() && bar();
    printf("%d",a);
}
/*----------------------------------------------------------------------------
Atama Operatörünün(=) genel kullanımı
Not atama operatörünün ürettiği değer bu operatörün sağ operandıdır.
------------------------------------------------------------------------------*/
#include <stdio.h>

int main()
{

        int a, b, c;

      c = 10;

      a = b = c;

      printf("a=%d%n", a);//10
      printf("b=%d%n", b);//10
      printf("c=%d%n", c);//10
}
/*--------------------------------------------------------------------------

    İşlemli atama operatörleri (augmented assignment operators)

   <operand1> <op>= <operand2>;
    a = a + 5;
    a += 5;
    a++;
    ++a;
    a = a /10;
    a /= 10;
    a = a + 1;
    a += 1;
   operand1 değişken olmalı
   Bu operatörlerin yaklaşık karşılığı (ileride tam karşılığını göreceğiz):
   <operand1> = <operand1> <op> <operand2>

   a += 2; -> a = a + 2;
------------------------------------------------------------------------------*/
#include <stdio.h>

         int main(){

              int a=10,b=5;


              a+=b;

              printf("a=%d%n", a);//15
              printf("b=%d%n", b);//5

              a*=b+1;//a=a*(b+1)

              printf("a=%d%n", a);//90


              }
/*---------------------------------------------------------------------------
C'de etkisiz ifadeler Warning oluşturur ancak java ve C# gibi dillerde
syntax hatasıdır. etkisiz ifadelerden sonra herhangi bir işlem yapılması geçerlidir.
------------------------------------------------------------------------------*/
#include <stdio.h>

int main()
{
    int a = 5, b = 10;

    a-b;//warning
    a += b;
    printf("%d\n",a);
}
/*---------------------------------------------------------------------------
    ;(noktalı virgül): Noktalı virgül sonlandırıcı özelliği vardır.
   Deyimler (Statements)
   1. Basit Deyimler (simple statements)
       exp;
       a = a + 10;
   2. Bileşik deyimler (compound statements)
       {
       exp1;
       exp2;
       }
       {
       a += 10;
       b *= 4;
       c %= 10;
       }
   3. Bildirim deyimleri (declaration statements)
       int a;
       char ch;
       char str[]="Ankara";
       void * i = malloc(sizeof(int)*10);
       char*str = "izmir";
   4. Kontrol deyimleri (control statements)
       return,break,continue,if,for,while,do-while, goto ve switch deyimlerinin kontrol deyimidir.
   5. Boş deyim (null statement)
       sadece noktalı virgülden oluşan deyimlere boş deyim denir.
       ;
----------------------------------------------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------
   if deyiminin genel biçimi:
   non zero -> true
   zero -> false
   if (<ifade>)
      <deyim>
   [
   else
      <deyim>
   ]
   if ile else tek bir deyimdir.
   Not:else kısmı olmayan bir if deyimi olabilir ancak if i olmayan
   bir else olması durumunda syntax hatası oluşur.(error:else without if)
   Not 2: if deyiminin parantezinin içi Java ve C# gibi dillerde boolean türden olmalıdır aksi durumda error oluşur.
   Ancak C dili için bu ifadenin boolean olması gibi bir zorunluluk yoktur. Bu ifadenin türü inttir.
   non-zero tüm değerler true ancak 0 değeri false
--------------------------------------------------------------------------*/
//1 ödev 1.soru bir çözümü
#include <stdio.h>
#include <stdlib.h>

void findRelationshipWithThreeNumbers(int number1,int number2,int number3)
{

    if (number1 < number2 && number2 < number3)
    {
        printf("%d < %d < %d ", number1, number2, number3);
    }
    else if (number1 < number3 && number3 < number2)
    {
        printf("%d < %d < %d ", number1, number3, number2);
    }

    else if (number2 < number1 && number1 < number3)
    {
        printf("%d < %d < %d ", number2, number1, number3);
    }
    else if (number2 < number3 && number3 < number1)
    {
        printf("%d < %d < %d ", number2, number3, number1);
    }

    else if (number3 < number1 && number1 < number2)
    {
        printf("%d < %d < %d ", number3, number1, number2);
    }
    else
        printf("%d < %d < %d ", number3, number2, number1);

}

void findRelationshipWithThreeNumbersTest()
{
    int number1,number2,number3;
    printf("3 sayı giriniz");
    scanf("%d %d %d", &number1, &number2, &number3);
    findRelationshipWithThreeNumbers(number1,number2,number3);
}
int main()
{
    findRelationshipWithThreeNumbersTest();
    return 0;
}
//1. ödev soru 2'nin bir çözümü
#include <stdio.h>


int signum(int val)
{
    if(val > 0)
        return 1;
    if(val < 0)
        return -1;
    return 0;

}
void signum_test()
{
    int val;
    printf("bir sayi giriniz\n");
    scanf("%d",&val);
    signum(val);
}

int main(){
   signum_test();
    return 0;
}



//1.ödev 3. sorunun bir çözümü

#include <stdio.h>

int mid(int number1,int number2,int number3) //int number1 = num1,int number2 = num2,
{
    if(number1 < number2 && number2 < number3 || number3 < number2 && number2 < number1)
        return number2;
    if(number2 < number1 && number1 < number3 || number3 < number1 && number1 < number2 )
        return number1;
    return number3;
}

void mid_test()
{
    int num1;
    int num2;
    int num3;


    printf("3 sayı giriniz");

    scanf("%d %d %d", &num1, &num2, &num3);

    printf("Ortanca deger %d\n", mid(num1,num2,num3));

}

int main()
{
    mid_test();
    return 0;
}

/*-------------------------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------------------------*/
#include <stdio.h>

int main()
{
    int a;
    //= -> atama
    //== -> karşılaştırma
    printf("Bir sayi giriniz?\n");
    scanf("%d",&a);
    if(10 == a) //if(a = 10) desek nolurdu?
        printf("sayi 10");
    else
        printf("sayi 10 degil");
}
/*-------------------------------------------------------------------------
Aşağıdaki örnekte her zaman false değer üretilir.
-------------------------------------------------------------------------*/
#include <stdio.h>

int main()
{
    int a;
    //= -> atama
    //== -> karşılaştırma
    printf("Bir sayi giriniz?\n");
    scanf("%d",&a);
    if(a = 0) //if(a = 10) desek nolurdu?
        printf("sayi 0");
    else
        printf("sayi 0 degil");
}
//------------------------------------------------------------------------
#include <stdio.h>

int main()
{

   int val;
   printf("Bir sayi giriniz?");
   scanf("%d",&val);
   if(val % 2 == 0)
       printf("sayi cift");
   else
       printf("sayi tek");
}

//aşağıdaki farklı bir çözümü
#include <stdio.h>

int main()
{

    int val;
    printf("Bir sayi giriniz?");
    scanf("%d",&val);
    if(!(val % 2))
        printf("sayi cift");
    else
        printf("sayi tek");
}
//Dikkat! aşağıdaki gibi bir kod asla yazmayınız.
#include <stdio.h>
#include <stdbool.h>

bool isEven(int val)
{
    if(val % 2 == 0)
        return true;
    else
        return false;
}



int main()
{

    int val;
    printf("Bir sayi giriniz?");
    scanf("%d",&val);

}
//Yukarıdaki kodun daha iyi hali
/*-------------------------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
-------------------------------------------------------------------------*/
#include <stdio.h>
#include <stdbool.h>

bool isEven(int val)
{
    return val % 2 == 0;
}

int main()
{

    int val;
    printf("Bir sayi giriniz?\n");
    scanf("%d",&val);
    if(isEven(val))
        printf("Sayi cift\n");
    else
        printf("Sayi tek\n");
}
/*------------------------------------------------------------------------------
else in tek başına kullanımı error oluşturur.
--------------------------------------------------------------------------*/
#include <stdio.h>

int main(){

    int val;
    printf("Bir sayi giriniz?");
    scanf("%d",&val);

    else//error:else without if!!
    printf("merhaba");

}
/*------------------------------------------------------------------------------
if deyiminden sonra yanlışlıkla noktalı virgül kullanımı
Aşağıdaki örnekte error oluşur çünkü else bu durumda ifsiz kalmış olur.
--------------------------------------------------------------------------*/
#include <stdio.h>

int main()
{
        int val;
        printf("Bir sayi giriniz?");
        scanf("%d",&val);
        if(val % 2 == 0);
            printf("sayi cift");
        else//error:else without if
            printf("sayi tek");
}
/*------------------------------------------------------------------------------
else kullanılmaması durumunda if ten sonra noktalı virgül konulursa programcı
error olmadığı için sorunun farkına varamayabilir.
--------------------------------------------------------------------------*/
#include <stdio.h>

int main()
{
        int val;
        printf("Bir sayi giriniz?");
        scanf("%d",&val);
        if(val % 2 == 0);//legal
            printf("sayi cift");
}

/*------------------------------------------------------------------------------
Örnek Soru:parametresiyle aldığı ikinci dereceden denklemin katsayıları(double türden) olan
a b c değerlerine göre denklemin köklerini bulan programı yazınız.
Not:delta(diskirminant)=b^2-4*a*c
x1=(-b+sqrt(delta))/(2*a)
x2=(-b-sqrt(delta))/(2*a)
delta > 0
iki tane reel kök var.
delta = 0
iki tane eşit kök var.
delta < 0
reel kök yok kompleks kök var.
------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------
else kullanılmaması durumunda if ten sonra noktalı virgül konulursa programcı
error olmadığı için sorunun farkına varamayabilir.
--------------------------------------------------------------------------*/
#include <stdio.h>
#include <math.h>

void findRoots(double a,double b,double c)
{
    double delta = pow(b,2) - 4 * a * c;
    if(delta > 0){
        double sqrt_delta = sqrt(delta);
        double x1 = (-b + sqrt_delta) / (2 * a);
        double x2 = (-b - sqrt_delta) / (2 * a);
        printf("x1 : %lf\n",x1);
        printf("x2 : %lf\n",x2);
    }
    else if(delta == 0){
        double x = -b / (2 * a);
        printf("x1 = x2 = %lf",x);
    }
    else {
        printf("Reel kok yok");
    }
}

int main()
{
    double a,b,c;
    printf("a? b? c?");
    scanf("%lf%lf%lf",&a,&b,&c);
    findRoots(a,b,c);
}
//-------------------------------------------------------
#include <stdio.h>
#include <math.h>

void findRoots(double a, double b, double c) {
    double delta = b * b - 4 * a * c, x1, x2;
    if (delta > 0) {
        x1 = (-b + sqrt(delta)) / (2 * a);
        x2 = (-b - sqrt(delta)) / (2 * a);
        printf("x1:%lf\n", x1);
        printf("x2:%lf\n", x2);
    } else if (delta == 0) {
        x1 = -b / (2 * a);
        printf("x1=x2=%lf", x1);
    } else
        printf("gercek kok yok\n");
}

int main() {
    double a, b, c;
    printf("a?\n");
    scanf("%lf", &a);
    printf("b?\n");
    scanf("%lf", &b);
    printf("c?\n");
    scanf("%lf", &c);
    findRoots(a, b, c);
}
//yukarıdaki örneğin başka bir çözümü
#include <stdio.h>
#include <math.h>

void findRoots(double a,double b,double c)
{
    double delta = pow(b,2) - 4 * a * c;
    if(delta > 0){
        double sqrt_delta = sqrt(delta);
        double x1 = (-b + sqrt_delta) / (2 * a);
        double x2 = (-b - sqrt_delta) / (2 * a);
        printf("x1 : %f\n", x1);
        printf("x2 : %f\n", x2);
        return;
    }
    else if(delta == 0){
        double x1 = -b / (2 * a);
        printf("x1 = x2 : %f",x1);
        return;
    }
    printf("reel kok yok");

}

void findRootsTest()
{
    double a,b,c;
    printf("a?\n");
    scanf("%lf",&a);
    printf("b?\n");
    scanf("%lf",&b);
    printf("c?\n");
    scanf("%lf",&c);
    findRoots(a,b,c);
}


int main()
{
    findRootsTest();
}
//Sorunun başka bir çözümü
#include <stdio.h>
#include <math.h>

void findRoots(double a,double b,double c)
{
    double delta = b * b - 4 * a * c;
    if(delta > 0){
        double sqrt_delta = sqrt(delta);
        double x1 = (-b + sqrt_delta)/ (2 * a);
        double x2 = (-b - sqrt_delta)/ (2 * a);
        printf("x1 : %lf\n  x2 : %lf\n",x1,x2);
    }
    else if(0 == delta){
        double x;
        x = -b/(2*a);
        printf("x1 = x2 : %lf\n",x);
    }
    else
        printf("Reel kok yok\n");
}


void findRootsTest()
{
    double a, b, c;
    printf("a?\n");
    scanf("%lf", &a);
    printf("b?\n");
    scanf("%lf", &b);
    printf("c?\n");
    scanf("%lf", &c);
    findRoots(a, b, c);
}

int main() {
    findRootsTest();
}
//-----------------------------------------------
#include <stdio.h>
#include <math.h>

void findRoots(double a,double b,double c)
{
    double delta = pow(b,2) - 4 * a * c;
    if(delta > 0){
        double sqrtDelta = sqrt(delta);
        double x1 = (-b + sqrtDelta) / (2 * a);
        double x2 = (-b - sqrtDelta) / (2 * a);
        printf("x1 : %lf\n",x1);
        printf("x2 : %lf\n",x2);
    }
    else if(delta == 0){
        double x = -b / (2*a);
        printf("x1 = x2 : %lf\n",x);
    }
    else{
        printf("Reel kok yok\n");
    }
}

void findRootsTest()
{
    double a,b,c;
    printf("a?");
    scanf("%lf",&a);
    printf("b?");
    scanf("%lf",&b);
    printf("c?");
    scanf("%lf",&c);
    findRoots(a,b,c);
}

int main()
{
    findRootsTest();
}
//math.h
//-----------------------------------------------
//Ödev 1 soru 2'nin bir çözümü
#include<stdio.h>

int signum(int val)
{
    if(val == 0)
        return 0;
    if(val > 0)
        return 1;
    return -1;
}

int main()
{
    int val;
    printf("bir sayi girin\n");
    scanf_s("%d", &val);
}
//Ödev 1 Soru 3'ün bir çözümü
#include<stdio.h>

int mid(int a,int b,int c)
{
    if(a < b && b < c)
        return b;
    if(b < a && a < c)
        return a;
    return c;
}

int main() {
    int a, b, c;

    printf("3 farkli sayi giriniz\n");
    printf("1. sayi girin\n");
    scanf_s("%d", &a);
    printf("2. sayi girin\n");
    scanf_s("%d", &b);
    printf("3. sayi girin\n");
    scanf_s("%d", &c);
    printf("ortanca sayi : %d", mid(a,b,c));
}
/*-----------------------------------------------

-----------------------------------------------*/
/*-----------------------------------------------
Döngü deyimleri:for(%50),while(%40),do-while(%10)
while deyiminin genel biçimi
while(ifade){
    deyim1;
    deyim2;
}
while deyimi için while parantezinin içi non-zero olduğu
sürece deyim1 ve deyim2 yürütülmeye devam eder.
-----------------------------------------------*/
/*-----------------------------------------------
n kez dönen while döngüsü
-----------------------------------------------*/
#include<stdio.h>

int main() {
    int n;
    printf("bir sayi giriniz?\n");
    scanf("%d",&n);
    while(n){
        printf("%d ",n);
        --n;
    }
}
/*-----------------------------------------------
n den -5 e kadar tüm sayıları yazdıran program
-----------------------------------------------*/
#include <stdio.h>


int main() {
    int n;
    printf("bir sayi giriniz?\n");
    scanf("%d",&n);
    while(n-- > -5){
        printf("%d ",n);
    }
}
/*-----------------------------------------------
Klavyeden 0 girilene kadar girilen sayıların toplamını
veren program
-----------------------------------------------*/
#include <stdio.h>

int main() {
    int sum = 0;
    int val;
    while(printf("Sayilari girmeye baslayiniz?")){
        scanf("%d",&val);
        if(val == 0)
            break;
        sum += val;
    }
    printf("Toplam : %d",sum);
}
/*-----------------------------------------------
Örnek:Klavyeden girilen bir sayının basamak sayısını
geri döndüren getDigitsCount isimli fonksiyonu yazınız
ve test ediniz.
123 -> 3
0 -> 1
100 -> 3
-----------------------------------------------*/
#include<stdio.h>

int getDigitsCount(int val)
{
    if(val == 0)
        return 1;
    int count = 0;
    while(val){
        count++;
        val /= 10;
    }
    return count;
}
int main()
{
    int val;
    printf("Bir sayi giriniz?\n");
    scanf("%d",&val);
    printf("%d'nin basamak sayisi : %d ",val, getDigitsCount(val));
}
//-----------------------------------------------
/*-----------------------------------------------
Örnek:Klavyeden girilen bir sayının rakamlarını toplamını
geri döndüren get_digits_sum isimli fonksiyonu yazınız
ve test ediniz.
Örnek Giriş:
123 -> 6
-----------------------------------------------*/
#include <stdio.h>
#include <math.h>

int getDigitsSum(int val)
{
    int sum = 0;
    while(val){
            sum += val % 10;
            val /= 10;
    }
    return abs(sum);
}

int main()
{
    int val;
    printf("Bir sayi giriniz?\n");
    scanf("%d",&val);
    printf("%d'nin rakamlari toplami : %d ",val, getDigitsSum(val));
}
/*-----------------------------------------------
Örnek: a sayının b. kuvvetini elde eden mypow isimli
fonksiyonu yazınız ve test ediniz.
-----------------------------------------------*/
#include <stdio.h>
#include <math.h>

int my_pow(int a,int b)
{
    int result = 1;
    while(b--){
        result *= a;
    }
    return result;
}

int main()
{
    int a,b;
    printf("Tabani giriniz?\n");
    scanf("%d",&a);
    printf("ustu giriniz?\n");
    scanf("%d",&b);
    printf("%d'nin %d. kuvveti : %d\n ", a,b, my_pow(a,b));
    printf("%d'nin %d. kuvveti : %f\n ",a,b,pow(a,b));
}
/*-----------------------------------------------
Örnek:Bir sayının basamaklarının sayı değerlerinin
basamak sayıncı kuvveti o sayının kendisine eşitse
bu sayıları Armstrong sayısı veya narsistik sayı denir.
Yukarıdaki açıklamaya göre 100000 e kadar olan tüm
Armstrong sayıları bulan programı yazınız ve test ediniz.
 Örneğin 371 sayısı bir Armstrong sayısıdır:
 371 = 3 ^ 3 + 7 ^ 3 + 1 ^ 3
-----------------------------------------------*/
#include <stdio.h>
#include <stdbool.h>

int getDigitsCount(int val)
{
    if(val == 0)
        return 1;
    int count = 0;
    while(val){
        count++;
        val /= 10;
    }
    return count;
}

int mypow(int a,int b)
{
    int result = 1;
    while(b--){
        result *= a;
    }
    return result;
}

bool isArmstrong(int val)
{
    int temp = val;
    int sum = 0;
    int count = getDigitsCount(val);
    while(val){
        sum += mypow(val % 10,count);
        val /= 10;
    }
    return temp == sum;
}

int main()
{
    for(int i = 0;i < 100000;++i){
        if(isArmstrong(i)){
            printf("%d ",i);
        }
    }
}
//başka bir çözüm
#include<stdio.h>
#include<stdbool.h>

int getDigitsCount(int val)
{
    if(val == 0)
        return 1;
    int count = 0;
    while(val){
        count++;
        val /= 10;
    }
    return count;
}

int mypow(int a,int b)
{
    int result = 1;
    while(b--){
        result *= a;
    }
    return result;
}

bool isArmstrong(int val)
{
    int temp = val;
    int result = 0,count = getDigitsCount(val);
    while(val){
        result += mypow(val % 10,count);
        val /= 10;
    }
    return temp == result;
}


int main()
{
    int n = 0;
    while(n++ < 100000){
        if(isArmstrong(n))
            printf("%d ", n);
    }
}
//başka bir çözüm
#include <stdio.h>


int getDigitsSum(int val)
{
    int sum = 0;
    while(val){
        sum += val % 10;
        val /= 10;
    }
    return sum;
}

int getDigitsCount(int val)
{
    if(val == 0)
        return 1;
    int count = 0;
    while(val){
        count++;
        val /= 10;
    }
    return count;
}

int mypow(int a,int b)
{
    int result = 1;
    while(b--){
        result *= a;
    }
    return result;
}
int isArmstrong(int val)
{
    int temp = val,sum = 0,count = getDigitsCount(val);
    while(val){
        sum += mypow(val % 10,count);
        val /= 10;
    }
    return temp == sum;
}

int main()
{
    for(int i = 1;i < 100000;++i)
        if(isArmstrong(i))
            printf("%d ",i);
}
//başka bir çözüm
#include <stdio.h>


int getDigitsSum(int val)
{
    int sum = 0;
    while(val){
        sum += val % 10;
        val /= 10;
    }
    return sum;
}

int getDigitsCount(int val)
{

    int count = 0;
    do{
        count++;
        val /= 10;
    }while(val);
    return count;
}

int mypow(int a,int b)
{
    int result = 1;
    while(b--){
        result *= a;
    }
    return result;
}
int isArmstrong(int val)
{
    int temp = val,sum = 0,count = getDigitsCount(val);
    while(val){
        sum += mypow(val % 10,count);
        val /= 10;
    }
    return temp == sum;
}

int main()
{
    for(int i = 1;i < 100000;++i)
        if(isArmstrong(i))
            printf("%d ",i);
}
//Başka bir çözüm

/*-----------------------------------------------
do-while döngü deyimi
while -> kontrolün önce yapıldığı while deyimi
do-while -> kontrolün sonda yapıldığı while deyimi
do-while döngüsünün bir defa döneceği while ve for deyiminden
farklı olarak garanti altındadır.
getDigitsCount fonksiyonunun do-while ile yazılması
-----------------------------------------------*/
#include<stdio.h>

int getDigitsCount(int val)
{
    int count = 0;
    do {
        count++;
        val /= 10;
    } while (val);

    return count;
}

int main()
{
    int val;
    printf("Bir sayi giriniz?\n");
    scanf("%d",&val);
    printf("%d", getDigitsCount(val));
}
/*-----------------------------------------------
Klavyeden 0 girilene kadar girilen sayıların toplamını
veren program
-----------------------------------------------*/
#include <stdio.h>

int main()
{
    int val;
    int sum = 0;
    printf("Sayilari girmeye baslayiniz\n");
    do {
        printf("Bir sayi giriniz?\n");
        scanf("%d",&val);
        if(val == 0)
            break;
        sum += val;
    } while(1);

    printf("Toplam : %d",sum);
}
/*-----------------------------------------------
do-while döngü deyimin n kez dönen döngü kalıbı
--------------------------------------------*/
#include <stdio.h>

int main()
{
    int n;
    printf("Bir sayi giriniz?\n");
    scanf("%d",&n);
    do{
        printf("%d ",n--);
    } while (n);
}
/*-----------------------------------------------
for döngü deyimi
for(alan1;alan2;alan3)
alan1: değişken bildirimleri(birden çok olabilir)
alan2: koşul ifadesi
alan3: artırma azaltma
int i = 10;
int f = 23;
double g = 45.67;
o notasyonu  1 döngü O(n) karmaşıklığı
iç içe 2 döngü kullanımı yapılırsa O(n^2) karmaşıkları
O (n log n)
linked list(bağlı liste)
for(int i = 0;i < 10;++i)

for(int i = 0;i < 10;i++)
-----------------------------------------------*/
/*-----------------------------------------------
n kez dönen for deyimleri
-----------------------------------------------*/
#include <stdio.h>

int main()
{
    int n;
    printf("n?\n");
    scanf("%d",&n);
    for(int i = 1; i <= n;++i){
        printf("%d ",i);
    }
}
//-----------------------------------------------
#include <stdio.h>

int main()
{
    int n;
    printf("n?\n");
    scanf("%d",&n);
    for(int i = 0; i < n;++i){
        printf("%d ",i);
    }
}
/*-----------------------------------------------
Sonsuz döngü sanılan ama sonsuz döngü olmayan
for deyimi.
-----------------------------------------------*/
#include <stdio.h>

int main()
{
    for(int i = -1 ;i < 0;--i){

    }
    printf("main devam ediyor");
}
/*-----------------------------------------------
Sonsuz döngü sanılan ama sonsuz döngü olmayan
for deyimi.
-----------------------------------------------*/
#include <stdio.h>
#include <limits.h>

int main()
{
    int i;
    for(i = -1 ;i < 0;--i){

    }
    printf("donguden sonra i degeri : %d\n",i);
    printf("int max value : %d\n",INT_MAX);
    printf("main devam ediyor\n");
}
/*-----------------------------------------------
Asal sayıları bulan algoritma: kendinden ve 1 den
böleni olmayan sayılara asal sayı denir. Buna göre
bir sayının asal sayı olup olmadığını geri döndüren
isPrime isimli fonksiyonu yazınız ve test ediniz.
isPrime yavaş versiyon
-----------------------------------------------*/
#include <stdio.h>
#include <stdbool.h>

bool isPrime(int val)
{
    if(val <= 1)
        return false;
    int half_val = val / 2;
    for(int i = 2;i <= half_val; ++i)
        if(val % i == 0)
            return false;
    return true;
}

int main()
{
    for(int i = -10;i < 100 ;++i)
        if(isPrime(i))
            printf("%d ",i);
}
//başka bir çözüm
#include <stdio.h>
#include <stdbool.h>

bool isPrime(int val)
{
    if(val <= 1)
        return false;
    int half_val = val / 2;
    for(int i = 2; i < half_val;++i){
        if(val % i == 0)
            return false;
    }
    return true;
}


int main()
{
    for(int i = -1000;i < 100 ;++i)
        if(isPrime(i))
            printf("%d ",i);
}
/*-----------------------------------------------
Teorem: Eğer bir sayı karekökünden küçük olan sayıların
tamamına bölünemiyorsa asaldır.
-----------------------------------------------*/
#include <stdio.h>
#include <stdbool.h>

bool isPrime(int val)
{
    if(val <= 1)
        return false;
    if(val % 2 == 0)
        return val == 2;
    if(val % 3 == 0)
        return val == 3;
    if(val % 5 == 0)
        return val == 5;
    if(val % 7 == 0)
        return val == 7;
    for(int i = 11;i * i < val;i += 2)
        if(val % i == 0)
            return false;
    return true;
}

int main()
{
    for(int i = -10;i < 100 ;++i)
        if(isPrime(i))
            printf("%d ",i);
}

//başka bir çözüm
#include <stdio.h>
#include <stdbool.h>

bool isPrime(int val)
{
    if(val <= 1)
        return false;
    if(val % 2 == 0)
        return val == 2;
    if(val % 3 == 0)
        return val == 3;
    if(val % 5 == 0)
        return val == 5;
    if(val % 7 == 0)
        return val == 7;
    if(val % 11 == 0)
        return val == 11;
    for(int i = 13;i * i < val;i += 2){
        if(val % i == 0)
            return false;
    }
    return true;
}

int main()
{
    for(int i = -100;i < 100 ;++i)
        if(isPrime(i))
            printf("%d ",i);
}
break continue ve goto deyimleri
/*-----------------------------------------------
L value expr
R value expr
goto deyimi kullanılarak tek seferde iki döngüden çıkılabilir.
-----------------------------------------------*/
#include <stdio.h>

int main()
{
    int i = 10, k = 4;
    while(k--) {
        while (i--) {
            if (5 == i)
                goto jump;
            printf("Merhaba\n");
        }
    }
    jump:
    printf("main devam ediyor\n");
}
/*-----------------------------------------------
continue deyimi o ifadeden sonraki deyimlerin yürütülmemesine
 sebep olur.
 while(1){
    deyim1;
    deyim2;
    continue;
    deyim3;
    deyim4;
 }
-----------------------------------------------*/
#include <stdio.h>

int main()
{
    int i = 6, k = 1;
    while(k--) {
        while (i--) {
            if (i == 5)
                continue;
            printf("Merhaba\n");
        }
    }
    printf("main devam ediyor\n");
}
/*-----------------------------------------------
break deyimi en içteki döngüyü kırar.
-----------------------------------------------*/
#include <stdio.h>

int main()
{
    int i = 10;
    while (i--) {
        if (i == 5)
            break;
        printf("Merhaba\n");
        printf("%d\n",i);
    }
    printf("main devam ediyor\n");
}
/*-----------------------------------------------
switch deyimi genel biçimi:
switch(<değişken ifadesi>){
    case <sabit ifadesi>:
            deyim1;
            break;
    case <sabit ifadesi>:
            deyim2;
            break;
    default:
        deyim3;
}
Anahtar: Aynı ifadeyi belirten koşul ifadeleri farklı caselerde olamaz.
-----------------------------------------------*/
#include <stdio.h>

int main()
{
    int val;
    printf("Bir sayi giriniz?\n");
    scanf("%d",&val);
    switch (val) {
        case 1:
            printf("sayi 1\n");
            break;
        case 1 + 1:
            printf("sayi 1 + 1");
            break;
        case 2:
            printf("sayi 2\n");
            break;
        case 3:
            printf("sayi 3\n");
            break;
        default:
            printf("baska bir deger\n");
    }
}
/*------------------------------------------------
switch deyiminde break deyiminin unutulması durumu
------------------------------------------------*/
#include <stdio.h>

int main()
{
    int val;
    printf("Bir sayi giriniz?\n");
    scanf("%d",&val);
    switch (val) {
        case 1:
            printf("sayi 1\n");
        case 2:
            printf("sayi 2\n");
        case 3:
            printf("sayi 3\n");
        default:
            printf("baska bir deger\n");
    }
}
/*-----------------------------------------------
switch deyimi
-----------------------------------------------*/
#include <stdio.h>

int main()
{
    int val;
    printf("bir sayi giriniz?\n");
    scanf("%d",&val);

    switch (val) {
        case 1:
            printf("sayi 1\n");
            break;
        case 2:
            printf("sayi 2\n");
            break;
        default:
            printf("farkli bir sayi");
            break;
    }
}
/*-----------------------------------------------
switch deyimiyle char türünden harf kontrolü yapılabilir.
-----------------------------------------------*/
#include <stdio.h>

int main()
{
    char ch;
    printf("Bir sayi giriniz?\n");
    scanf("%c",&ch);
    switch (ch) {
        case 'a':
            printf("a harfi\n");
            break;
        case 'b':
            printf("b harfi\n");
            break;
        default:
            printf("baska bir harf\n");
    }
}
/*-----------------------------------------------
switch deyimiyle char türünden harf kontrolü yapılabilir.
-----------------------------------------------*/
#include <stdio.h>

int main()
{
    char ch;
    printf("Bir sayi giriniz?\n");
    scanf("%c",&ch);
    switch (ch) {
        case 'a':
        case 'A':
            printf("A harfi\n");
            break;
        case 'b':
        case 'B':
            printf("B harfi\n");
            break;
        default:
            printf("baska bir harf\n");
    }
}
/*-----------------------------------------------
switch deyimiyle gerçek sayi türleri için kontrol
 yapılamaz.
-----------------------------------------------*/
#include <stdio.h>

int main()
{
    double dval;
    printf("Bir sayi giriniz?\n");
    scanf("%lf",&dval);
    switch (dval) {
        case 1.7:
            printf("deger 1.7 \n");
            break;
        case 20.4:
            printf("deger 20.4 \n");
            break;
        default:
            printf("baska bir gercek sayi\n");
    }
}
/*-----------------------------------------------
Not:switch deyiminin parantezinin içindeki değişkenin
türü double türden olamaz. kısacası double türden
değerlerle switch deyimi kullanımı doğrudan syntax
hatasıdır.
-----------------------------------------------*/
#include <stdio.h>

int main()
{
    double val;
    printf("bir sayi giriniz?\n");
    scanf("%lf",&val);

    switch (val) {
        case 0.4:
            printf("sayi 0.4\n");
            break;
        case 0.7:
            printf("sayi 0.7\n");
            break;
        default:
            printf("farkli bir sayi");
            break;
    }
}
#include <stdio.h>

int main()
{
    char ch;
    printf("Bir sayi giriniz?\n");
    scanf("%c",&ch);
    switch (ch) {
        case 'a':
            printf("a harfi\n");
            break;
        case 'b':
            printf("b harfi\n");
            break;
        default:
            printf("baska bir harf\n");
    }
    if(ch == 'a')
        printf("a harfi");
    else if(ch == 'b')
        printf("b harfi\n");
    else
        printf("baska bir harf\n");
}
/*-----------------------------------------------
switch deyiminin parantezinin içerisi char türden olabilir.
-----------------------------------------------*/
#include <stdio.h>

int main()
{
    char ch;
    printf("bir harf giriniz?\n");
    scanf("%c",&ch);

    switch (ch) {
        case 'a':
            printf("a\n");
            break;
        case 'b':
            printf("b\n");
            break;
        default:
            printf("farkli bir harf");
            break;
    }
}
/*-----------------------------------------------
switch deyiminin case kısmında int türden bir değer olması
durumunda char türünden karakterin ascii tablosundaki
değerine göre karşılaştırma yapılır.
-----------------------------------------------*/
#include <stdio.h>

int main()
{
    char ch;
    printf("bir harf giriniz?\n");
    scanf("%c",&ch);

    switch (ch) {
        case 'a':
            printf("a\n");
            break;
        case 65:
            printf("A\n");
            break;
        default:
            printf("farkli bir harf");
            break;
    }
}
/*-----------------------------------------------
Örnek soru: klavyeden girilen dün ay ve yıl değerlerine
 göre girilen tarihin geçerli bir tarih olup olmadığını
 geri döndüren isValidDate isimli fonksiyonu yazınız ve test ediniz.
-----------------------------------------------*/
#include <stdio.h>
#include <stdbool.h>

bool isLeapYear(int year)
{
    return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
}

bool isValidDate(int day,int month,int year)
{
    if(day > 31 || year < 1 || month < 1 || day < 1 || month > 12 || year > 9999)
        return false;
    int days = 31;
    switch (month) {
        case 4:
        case 6:
        case 9:
        case 11:
            days--;
            break;
        case 2:
            if(isLeapYear(year))
                days = 29;
            else
                days = 28;
    }
    return day <= days;
}


void isValidDateTest()
{
    int day,month,year;
    printf("day?\n");
    scanf("%d",&day);
    printf("month?\n");
    scanf("%d",&month);
    printf("year?\n");
    scanf("%d",&year);
    if(isValidDate(day,month,year))
        printf("%02d.%02d.%04d",day,month,year);
    else
        printf("Gecersiz tarih\n");
}

int main()
{
    isValidDateTest();
}
//Başka bir çözüm
#include <stdio.h>
#include <stdbool.h>

bool isLeapYear(int year)
{
    return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
}

bool isValidDate(int day,int month,int year)
{
    if(day > 31 || day < 0 || month < 0 || month > 12 || year < 0)
        return false;
    int days = 31;
    switch (month) {
        case 4:
        case 6:
        case 9:
        case 11:
            days = 30;
            break;
        case 2: if(isLeapYear(year))
                    days = 29;
                else
                    days = 28;
    }
    return  days >= day;
}


void isValidDateTest()
{
    int day,month,year;
    printf("day?\n");
    scanf("%d",&day);
    printf("month?\n");
    scanf("%d",&month);
    printf("year?\n");
    scanf("%d",&year);
    if(isValidDate(day,month,year))
        printf("%02d.%02d.%04d tarihi gecerlidir.",day,month,year);
    else
        printf("%02d.%02d.%04d tarihi gecersizdir.",day,month,year);
}

int main()
{
    isValidDateTest();
}
/*-----------------------------------------------
Bundan sonraki konular:
1-)Döngü deyimleri Okay
2-)Örnek algoritma soruları Okay
3-)continue ve break deyimleri
4-)goto deyimler
5-)switch deyimi
6-)isValidDate algoritması
-----------------------------------------------*/
/*-----------------------------------------------
break deyimi çalıştırıldıktan sonra ondan sonraki
deyimler yürütülmez ve döngüden çıkılır.
-----------------------------------------------*/
#include <stdio.h>

int main()
{
    int val, sum = 0;
    while(printf("Bir sayi giriniz?\n")){
        scanf("%d",&val);
        if(val == 0)
            break;
        sum += val;
        printf("Merhaba\n");
    }
    printf("main devam ediyor\n");
    printf("Toplam : %d\n", sum);
}
/*-----------------------------------------------
continue deyimi kendisinden sonraki deyimleri yürütmez
ve akışı otomatik olarak döngünün başına örneğin
aşağıdaki örnekte klavyeden -1 girildiğinde printf
fonksiyonları yürütülmez.
while(1){
    continue;
    deyim1;
    deyim2;
}
-----------------------------------------------*/
#include <stdio.h>

int main()
{
    int val, sum = 0;
        while (printf("Bir sayi giriniz?\n")) {
            scanf("%d", &val);
            if (val == 0)
                break;
            sum += val;
            if(val == -1)
                continue;
            printf("while devam ediyor\n");
            printf("Merhaba\n");
        }

    printf("main devam ediyor\n");
    printf("Toplam : %d\n", sum);
}
/*-----------------------------------------------
goto deyimi(goto statement): goto deyimi yürütüldüğü
zaman kendinden belirtilen noktada gelir. birden
fazla döngü goto deyimi pek de sık kullanılmaz.
Ama gereksiz değildir!
-----------------------------------------------*/
#include <stdio.h>

int main()
{
    int val, sum = 0;
    while(1) {
        while (printf("Bir sayi giriniz?\n")) {
            scanf("%d", &val);
            if (val == 0)
                goto jump;
            sum += val;
            printf("1 nolu while\n");
        }
        printf("2 nolu while\n");
    }
    printf("Merhaba\n");
    jump:
    printf("main devam ediyor\n");
    printf("Toplam : %d\n", sum);
}
/*-----------------------------------------------
switch deyimi(switch statement):if deyimine bir alternatif
olan koşul ifadesi olarak düşünülebilir.
Switch deyiminin genel biçimi:
switch(<değişken>){
    case <sabit ifadesi>:
            deyim1;
            break;
    case <sabit ifadesi>:
            deyim2;
            break;
    default:
        deyim3;
        break;
}
-----------------------------------------------*/
#include <stdio.h>

int main()
{
    int val;
    printf("Bir sayi giriniz?\n");
    scanf("%d",&val);
    switch (val) {
        case 1:
            printf("sayi 1");
            break;
        case 0:
            printf("sayi 0");
            break;
        case -1:
            printf("sayi -1");
            break;
        default:
            printf("baska bir sayi");
            break;
    }
}
/*-----------------------------------------------
switch deyiminde double değişken kullanımı syntax errore
sebep olur.
-----------------------------------------------*/
#include <stdio.h>

int main()
{
    double val;
    printf("Bir sayi giriniz?\n");
    scanf("%lf",&val);
    switch (val) {
        case 1.0:
            printf("sayi 1.0");
            break;
        case 0.0:
            printf("sayi 0.0");
            break;
        case -1.0:
            printf("sayi -1");
            break;
        default:
            printf("baska bir sayi");
            break;
    }
}
/*-----------------------------------------------
Örnek Soru: Klavyeden girilen bir tarhin geçerli bir
tarih olup olmadığını geri döndüren isValidDate
isimli fonksiyonu yazınız ve test ediniz.
-----------------------------------------------*/
#include <stdio.h>
#include <stdbool.h>

bool isLeapYear(int year)
{
    return year % 4 && year % 100 != 0 || year % 400 == 0;
}

bool isValidDate(int day,int month,int year){
    if(day < 1 || day > 31 || month < 1 || month > 12 || year < 0)
        return false;
    int days = 31;

    switch (month) {
        case 4:
        case 6:
        case 9:
        case 11:
            days = 30;
            break;
        case 2:
                days = 28;
                if(isLeapYear(year))
                    ++days;
    }
    return day <= days;
}

void isValidDateTest()
{
    int day,month,year;
    printf("Gunu giriniz?\n");
    scanf("%d",&day);
    printf("Ayi giriniz?\n");
    scanf("%d",&month);
    printf("Yili giriniz?\n");
    scanf("%d",&year);
    if(isValidDate(day,month,year))
        printf("%02d/%02d/%04d tarihi gecerli bir tarihtir.\n",day,month,year);
    else
        printf("Gecersiz tarih!\n");
}


int main()
{
    isValidDateTest();
}

/*-------------------------------------------------------
Örnek Soru:Parametresi ile aldığı int türden gün, ay ve yıl bilgilerine ilişkin tarihin aşağıdaki açıklamalara
	göre haftanın hangi gününe geldiğini döndüren getDayOfWeek isimli fonksiyonu yazınız ve aşağıdaki kod ile test ediniz
	Açıklamalar:
		- Metot geçersiz bir tarih durumunda -1 değerine geri dönecektir
		- Haftanın günü 1.1.1900 ile verilen tariharasındaki (verilen tarih dahil) gün sayısının 7(yedi) ile bölümünden
		elde edilen kalan ile bulunabilir. Değer 0(sıfır) ise "Cumartesi", 1(bir) ise "Pazar", ... 6(altı) ise "Cuma"
		günlerine karşılık gelir.
		- 1.1.1900 öncesindeki tarihler geçersizler kabul edilir
		- Parametresi ile aldığı gün, ay ve yıl bilgilerine ilişkin tarihin hafta sonu olup olmadığını test eden isWeekend
		ve hafta içi olup olmadığını test eden isWeekday metotlarını yazınız. Fonksiyonlar tarih geçerliliği kontrolü yapmayacaktır.
---------------------------------------------------------*/
#include <stdio.h>
#include <stdbool.h>

bool isLeapYear(int year)
{
    return year % 4 && year % 100 != 0 || year % 400 == 0;
}

bool isValidDate(int day,int month,int year){
    if(day < 1 || day > 31 || month < 1 || month > 12 || year < 0)
        return false;
    int days = 31;
    switch (month) {
        case 4:
        case 6:
        case 9:
        case 11:
            days = 30;
            break;
        case 2:
            days = 28;
            if(isLeapYear(year))
                ++days;
    }
    return day <= days;
}

int getDayOfYear(int day,int month,int year)
{
    if(!isValidDate(day,month,year))
        return -1;
    int totalDays = day;
    switch (month - 1) {
        case 11:
            totalDays += 30;
        case 10:
            totalDays += 31;
        case 9:
            totalDays += 30;
        case 8:
            totalDays += 31;
        case 7:
            totalDays += 31;
        case 6:
            totalDays += 30;
        case 5:
            totalDays += 31;
        case 4:
            totalDays += 30;
        case 3:
            totalDays += 31;
        case 2:
            totalDays += 28;
            if(isLeapYear(year))
                totalDays++;
        case 1:
            totalDays += 31;
    }
    return totalDays;
}

int getDayOfWeek(int day,int month,int year)
{
    int totalDays;

    if(year < 1900 || (totalDays = getDayOfYear(day,month,year)) == -1)
        return  -1;
    for(int y = 1900;y < year; ++y){
        totalDays += 365;
        if(isLeapYear(y))
            totalDays++;
    }
    return totalDays % 7;
}
void print_date(int day,int month,int year)
{
    int dayOfWeek = getDayOfWeek(day,month,year);

    if(dayOfWeek == -1){
        printf("gecersiz tarih");
        return;
    }
    switch(dayOfWeek){
        case 0:
            printf("%02d/%02d/%04d Cumartesi\n",day,month,year);
            break;
        case 1:
            printf("%02d/%02d/%04d Pazar\n",day,month,year);
            break;
        case 2:
            printf("%02d/%02d/%04d Pazartesi\n",day,month,year);
            break;
        case 3:
            printf("%02d/%02d/%04d Sali\n",day,month,year);
            break;
        case 4:
            printf("%02d/%02d/%04d Carsamba\n",day,month,year);
            break;
        case 5:
            printf("%02d/%02d/%04d Persembe\n",day,month,year);
            break;
        case 6:
            printf("%02d/%02d/%04d Cuma\n",day,month,year);
            break;
    }
}
bool isWeekend(int day,int month,int year)
{
    int dayOfWeek = getDayOfWeek(day,month,year);

    switch(dayOfWeek){
        case 0:
        case 1:
            return true;
        default:
            return false;
    }
}
bool isWeekday(int day,int month,int year)
{
    int dayOfWeek = getDayOfWeek(day,month,year);
    switch(dayOfWeek){
        case 0:
        case 1:
            return false;
        default:
            return true;
    }
}

int main()
{
    int day,month,year;
    printf("Gunu giriniz?\n");
    scanf("%d",&day);
    printf("Ayi giriniz?\n");
    scanf("%d",&month);
    printf("Yili giriniz?\n");
    scanf("%d",&year);
    print_date(day,month,year);

    if(isWeekend(day,month,year))
        printf("Hafta sonu\n");
    else
        printf("Hafta sonu degil\n");
    if(isWeekday(day,month,year))
        printf("Haftaici\n");
    else
        printf("Haftaici degil\n");
}

//Ödev 2 4.Sorunun bir çözümü
#include <stdio.h>
#include <stdbool.h>


void BallGame(int height,int width)
{
    int Ball_index = 0;
    for(bool location_flag = true;height--;){
        printf("|");
        for(int i = 0;i < Ball_index;++i)
            printf(" ");
        printf("*");
        for(int i = 0;Ball_index < width - 1 - i;++i)
            printf(" ");
        printf("|");
        if(Ball_index == width - 1 && location_flag)
            location_flag = false;
        else if(Ball_index == 0 && !location_flag)
            location_flag = true;
        if(location_flag)
            ++Ball_index;
        else
            --Ball_index;
        printf("\n");
    }
}

void BallGameTest()
{
    int height,width;
    printf("Height?\n");
    scanf("%d",&height);
    printf("Width?\n");
    scanf("%d",&width);
    BallGame(height,width);
}

int main()
{
    BallGameTest();
}

#include <stdio.h>

int main()
{
    int x = 12;
    switch (x) {
        case 12:
            printf("sayi 12\n");
            break;
        case 13:
            printf("sayi 13");
        default:
            printf("baska bir sayi");
    }
}
//Aşağıdaki örneği inceleyiniz
#include <stdio.h>

int main()
{
    int x;
    printf("Bir sayi giriniz?\n");
    scanf_s("%d",&x);
    if(x > 0)
            printf("%d sifirdan buyuk",x);
    if(x == 0)
            printf("%d sifir",x);
    if(x < 0)
            printf("%d sifir",x);

    /*
    if(x > 0)
        printf("%d sifirdan buyuk",x);
    else if(x == 0)
        printf("%d sifir",x);
    else if(x < 0)
        printf("%d sifir",x);
    */
}
//Ödev 2 1.Sorunun bir çözümü
#include <stdio.h>
#include <stdbool.h>

void printDiamond(int n)
{
    bool direction_flag = true;
    for(int i = 0;;){
        for(int k = 0; k < n - i - 1;++k)
            printf(" ");
        for(int p = 0; p < 2 * i + 1; ++p)
            printf("*");
        if(direction_flag && i == n - 1)
            direction_flag = false;
        if(direction_flag)
            ++i;
        else
            --i;
        if(i < 0)
            break;
        printf("\n");
    }
}

int main()
{
    int n;
    printf("n?\n");
    scanf_s("%d",&n);
    printDiamond(n);
}
//Ödev 2 4.sorunun çözümü
#include <stdio.h>
#include <stdbool.h>

void BallShape(int height,int width)
{
    int Ball_index = 0;
    for(bool direction_flag = true;height--;){
        printf("|");
        for(int i = 0;i < Ball_index;++i)
            printf(" ");
        printf("*");
        for (int i = 0; Ball_index < width - i - 1; ++i)
            printf(" ");
        printf("|");
        if(Ball_index == width - 1 && direction_flag)
            direction_flag = false;
        else if(Ball_index == 0 && !direction_flag)
            direction_flag = true;
        if(direction_flag)
            ++Ball_index;
        else
            --Ball_index;
        printf("\n");
    }
}

int main()
{
    int height,width;
    printf("Height?\n");
    scanf("%d",&height);
    printf("Width?\n");
    scanf("%d",&width);
    BallShape(height,width);
}
//Aşağıdaki örneği inceleyiniz.
#include <stdio.h>
#include <stdbool.h>

int main()
{
    char c = 178;
    if(c == 178)
        printf("evet dogru");
    else
        printf("hayir yanlıs");
    printf("%d",c);
}
//Aşağıdaki örneği inceleyiniz.
#include <stdio.h>

int x = 10;

int main()
{
    int x = x;
    printf("%d",x);
}
/*-----------------------------------------------
Bugünün konusu:
Tür dönüştürme operatörü
Bundan sonraki konular:
1-)rand ve srand fonksiyonları
tür dönüşümleri
2-)Tohum değeri ne demektir?
önişlemci komutları
tür dönüşümleri(type conversion)
3-)Stringler
4-)Diziler
5-)Pointerlar
6-)Pointer dizileri
7-)Fonksiyon pointerları
8-)Yer ve tür belirleyiciler(static const volatile, auto, typedef, )
9-)kullanıcının oluşturduğu türler(structures enums unions)
10-)dinamik bellek yönetimi(malloc, calloc, realloc)
11-)Dosya işlemleri
12-)Bitsel işlemler
>> << & ^ | ~
-----------------------------------------------*/
//rand fonksiyonu default olarak run yapıldığında hep aynı değerleri üretir.
#include <stdio.h>
#include <stdlib.h>

int main()
{
    for(int i = 0; i < 5; ++i){
        int r = rand();
        printf("%d",r);
        printf("\n");
    }
}
//----------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define randomize() srand(time(0))

int main()
{
    randomize();
    for(int i = 0; i < 5; ++i){
        int r = rand();
        printf("%d",r);
        printf("\n");
    }
}
/*-----------------------------------------------------
 Örnek Soru: Bir para 100000 kere atılıyor. Tura gelme olasığını
 hesaplayan programı yazınız.
 -----------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define randomize() srand(time(0))


int main()
{
    randomize();

    int number_of_plays = 100000,number_of_heads = 0;
    double ratio;

    for(int i = 0;i < number_of_plays; ++i){
        number_of_heads += rand() % 2; //[0,2)
    }
    ratio = (double) number_of_heads / number_of_plays;
    printf("%d tane tura\n",number_of_heads);
    printf("%d tane yazi\n",number_of_plays - number_of_heads);
    printf("Oran : %lf\n ",ratio);
}
//-----------------------------------------------
//Başka bir çözüm
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define randomize() srand(time(0))

int main()
{
    randomize();
    int number_of_heads = 0;
    int number_of_plays = 100000;
    for (int i = 0; i < number_of_plays; ++i) {
        number_of_heads += rand() % 2;
    }
    printf("%lf Oraninda tura geldi\n",(double)number_of_heads / number_of_plays);
    printf("%lf Oraninda yazi geldi\n",(double)(number_of_plays - number_of_heads) / number_of_plays);
    printf("%d tane tura geldi\n",number_of_heads);
    printf("%d tane yazi geldi\n",number_of_plays - number_of_heads);
}
/*-----------------------------------------------
Örnek Soru: İki zar atılıyor zarların ikisin de
1 gelme olasığı hesaplayınız.
-----------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define randomize() srand(time(0))

int main()
{
    randomize();

    int number_of_plays = 1000000;
    int number_of_evens = 0;
    for (int i = 0; i < number_of_plays; ++i) {
        int dice1 = rand() % 6 + 1;
        int dice2 = rand() % 6 + 1;
        if(dice1 == 1 && dice2 == 1)
            number_of_evens++;
    }
    printf("%d oyunda %d defa zarlar cift geldi",number_of_plays,number_of_evens);
    printf("cift gelme olasiligi : %f ",(float)number_of_evens / number_of_plays ); //1/36
}
//-------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define randomize() srand(time(0))

int main()
{
    randomize();
    int dice1,dice2;
    int number_of_wins = 0;
    int number_of_plays = 100000;
    for (int i = 0; i < number_of_plays; ++i) {
        dice1 = rand() % 6 + 1;
        dice2 = rand() % 6 + 1;
        if(dice1 == 1 && dice2 == 1)
            number_of_wins++;
    }
    printf("Kazanma Orani : %lf",(double)number_of_wins / number_of_plays);
}
/*-----------------------------------------------
Örnek Soru: İki zar atılıyor zarların ikisin de
1 gelme olasığı hesaplayınız.
-----------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define randomize() srand(time(0))


int main()
{
    randomize();
    int number_of_plays = 100000;
    int wins = 0;
    for (int i = 0; i < number_of_plays ; ++i) {
        int dice1 = rand() % 6 + 1;
        int dice2 = rand() % 6 + 1;
        if(dice1 == 1 && dice2 == 1)
            wins++;
    }
    printf("%lf",(double)wins / number_of_plays);
}
/*-----------------------------------------------
Örnek Soru: İki zar atılıyor zarların ikisinin de
 çift gelme olasılığını hesaplayınız.
-----------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define randomize() srand(time(0))


int main()
{
    randomize();
    int number_of_plays = 100000;
    int wins = 0;
    for (int i = 0; i < number_of_plays ; ++i) {
        int dice1 = rand() % 6 + 1;
        int dice2 = rand() % 6 + 1;
        if(dice1 % 2 == 0 && dice2 % 2 == 0)
            wins++;
    }
    printf("%lf",(double)wins / number_of_plays);
}
/*-----------------------------------------------
Örnek Soru: İki zar ve bir para atılıyor. paranın tura
 veya zarın ikisinin asal gelme olasılığı
-----------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define randomize() srand(time(0))
#include <stdbool.h>

bool isPrime(int val)
{
    if(val <= 1)
        return false;
    if(val % 2 == 0)
        return val == 2;
    if(val % 3 == 0)
        return val == 3;
    if(val % 5 == 0)
        return val == 5;
    if(val % 7 == 0)
        return val == 7;
    for(int i = 11;i * i < val;i += 2)
        if(val % i == 0)
            return false;
    return true;
}

int main()
{
    randomize();
    int number_of_plays = 100000;
    int wins = 0;
    for (int i = 0; i < number_of_plays ; ++i) {
        int dice1 = rand() % 6 + 1;
        int dice2 = rand() % 6 + 1;
        if(rand() % 2 || isPrime(dice1) && isPrime(dice2))
            wins++;
    }
    printf("%lf",(double)wins / number_of_plays);
}
//--------------------------------------------------------------------------------
//öDEV 3 Çözümü

/*----------------------------------------------------------------------------------------------------------------------
   T1 a;
   T2 b;
(<primitive type>)
   T2 -> source type(kaynak tür)
   T1 -> target type(hedef tür)
   C'de tür dönüşümleri 2 farklı şekilde yapılır:
   1-implicit(standard) conversion -> doğrudan dönüşüm (atama) : b nin içerisindeki değerin a nın türünde elde edilip
   a ya atanması demektir.
   a = b;
   2-explicit conversion-> tür dönüştürme operatörü ile yapılan dönüşüm.
   a=(<a'nın türü>)b;
   Tür dönüştürme operatörü operatör öncelik tablosunun 2. öncelik seviyesinde bulunmaktadır.
----------------------------------------------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------
Eğer operandlardan her ikisi de int türünden küçükse (örneğin char-char, char-short, short-short gibi)
Bu durumda önce her iki operand da bağımsız olarak int türüne dönüştürülür, sonuç int türünden çıkar.
Bu kurala "int türüne yükseltme kuralı (integral promotion)" denilmektedir.
Buna göre aşağıdaki kodu inceleyiniz.
--------------------------------------------------------------------------*/

#include <stdio.h>

int main() {
    short a;
    short b = 10000;
    short c = 10000;
    a = b + c; /* 20000, sonuç int türden */
    printf("%d\n", a);
    return 0;
}
//------------------------------------------------------------------------------
#include <stdio.h>

int main() {
    int a;
    short b = 30000;
    short c = 30000;
    a = b + c; /* 60000, sonuç int türden */
    printf("%d\n", a);
    return 0;
}
/*------------------------------------------------------------------------------
Operandlardan biri tamsayı türünden, diğeri gerçek sayı türündense dönüştürme her zaman gerçek sayı türüne
doğru yapılır. Örneğin long ile float işleme sokulursa sonuç float türden çıkar.
--------------------------------------------------------------------------*/

#include <stdio.h>

int main() {

    long b = 300;
    float c = 20.89;
    printf("%f\n", b+c); /* sonuç float türden o yüzden %f ile yazma yapılabilir.*/
    return 0;
}
//-----------------------------------------------------------------------------------

#include <stdio.h>

int main() {

    long b = 300;
    double dval = 20.89;
    printf("%.20lf\n", b+dval); /* sonuç float türden o yüzden %f ile yazma yapılabilir.*/
    return 0;
}
/*------------------------------------------------------------------------------
Aşağıdaki örneği inceleyiniz.
--------------------------------------------------------------------------*/
#include <stdio.h>

int main()
{
    long b = 300;
    long double c = 20.89;
    printf("%Lf\n", b+c); /* sonuç float türden o yüzden %f ile yazma yapılabilir.*/
    return 0;
}
/*------------------------------------------------------------------------------
Aşağıdaki örnekte 1. ifadesi double türden olduğu için işlem double türünde
yapılacaktır. Bu işlem tür dönüştürme operatörü kullanmaya bir alternatif olabilir.
--------------------------------------------------------------------------*/
#include <stdio.h>

int main()
{
    int ival = 4;
    double dval = 1./4;
    printf("%lf",dval);
    return 0;
}
/*------------------------------------------------------------------------------
Operandlar aynı tamsayı türünün işaretli ve işaretsiz biçimine ilişkinse dönüştürme her zaman işaretsiz türe
doğru yapılır. (örneğin int ile unsigned int işleme sokulsa sonuç unsigned int türünden çıkar.)
--------------------------------------------------------------------------*/
#include <stdio.h>

int main()
{
    int a=-10;
    unsigned b=20;
    printf("%u",a+b);//a+b unsigned türden olduğu için %u ifadesi ile yazma yapılabilmektedir.
    return 0;
}
/*------------------------------------------------------------------------------
Eğer aşağıdaki örnekte görüldüğü gibi sayıların toplamı negatifse bu durumda
bir undefined behaviour söz konusudur. Çünkü bu durumda sayının yüksek anlamlı byte değerleri
atılır ve bir değer elde edilir.
--------------------------------------------------------------------------*/
#include <stdio.h>

int main()
{
    int a=-100;
    unsigned b=20;
    printf("%u",a+b);//a+b unsigned türden olduğu için %u ifadesi ile yazma yapılabilmektedir.
    return 0;
}
/*------------------------------------------------------------------------------
Aşağıdaki kodda if deyimi içerisinde false değer üretilmesinin sebebi
178 char türü sınırının dışında olmasından dolayı değerini koruması için -78
haline getirilmesinden kaynaklıdır.
--------------------------------------------------------------------------*/

#include <stdio.h>

int main() {

    char ch=178;
    if (ch == 178)
        printf("Evet dogru");
    else
        printf("Hayir yanlis");
}
//char sınırları geçilmediğinden evet dogru ekrana basılır.
#include <stdio.h>

int main() {

    char ch=123;
    if (ch == 123)
        printf("Evet dogru");
    else
        printf("Hayir yanlis");
    printf("%d",ch);
}
/*------------------------------------------------------------------------------
explicit conversion-> tür dönüştürme operatörü ile yapılan dönüşüm.
   a=(<a'nın türü>)b;
Büyük tam sayı türlerinden küçük tam sayı türlerine yapılan atamalarda
hedef tür sınırları içerisinde kalınıyorsa bir problem oluşmaz ancak hedef tür sınırları
geçilirse bilgi kaybı oluşur. Ancak veri kaybı daima oluşur.
Örneğin aşağıdaki örnekte long long türü 8 byte olduğundan int türü de 4 byte olduğundan
burda bir veri kaybı her daim söz konusudur. Bu durumda yüksek anlamlı byte değerleri
atılır ve int türüne expiliict convervion gerçekleştirilir.
--------------------------------------------------------------------------*/
#include <stdio.h>

int main()
{
    long long a = 30000000000;
    int b = (int)a;
    printf("%d",b);
}
/*------------------------------------------------------------------------------
Aşadaki örnekte tür dönüştürme operatörü kullanmazsak bilgi kaybı oluşur.
--------------------------------------------------------------------------*/
#include <stdio.h>

int main() {

    int a,b;
    printf("a,b");
    scanf("%d %d",&a,&b);
    double d=(double)a/b;
    printf("%lf",d);
}
/*------------------------------------------------------------------------------
Aşadaki örnekte tür dönüşünü bölümden sonra yapılacağı için tür dönüştürme operatörü
aslında bir işe yaramaz.
--------------------------------------------------------------------------*/
#include <stdio.h>

int main() {

    int a,b;
    printf("a,b");
    scanf("%d %d",&a,&b);
    double d=(double)(a/b);
    printf("%f",d);
}
/*------------------------------------------------------------------------------
Gerçek sayı türlerinden tamsayı türlerine dönüşümler
Bu dönüşüm yapılırken önce sabitin noktadan sonraki kısmı atılır.
hedef sınırlar içerisinde ise bir sıkıntı oluşmaz.
hedef tür sınırları dışında ise bilgi kaybı oluşur.
Bu bilgi kaybı da yüksek anlamlı byte değerlerinin atılması ile olur.
--------------------------------------------------------------------------*/
#include <stdio.h>

int main()
{
    double a=100.7,c=30000000000;
    int b=(int)a;
    printf("%d",b);
    int d=(int)a;
    printf("%d",d);
}
/*------------------------------------------------------------------------------
Ödev 3'ün bir çözümü
--------------------------------------------------------------------------*/
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <stdbool.h>
#define randomize() srand(time(NULL))

bool crapsGame()
{
    int dice1 = rand() % 6 + 1;
    int dice2 = rand() % 6 + 1;
    int dice_sum = dice1 + dice2;
    if(dice_sum == 2 || dice_sum == 3 || dice_sum == 12)
        return false;
    if(dice_sum == 7 || dice_sum == 11)
        return true;
    int temp_dice = dice_sum;
    while(1){
        dice1 = rand() % 6 + 1;
        dice2 = rand() % 6 + 1;
        dice_sum = dice1 + dice2;
        if(dice_sum == 7)
            return false;
        if(dice_sum == temp_dice)
            return true;
    }
}

void crapsGameTest(const int number_of_plays)
{
    int number_of_wins = 0;
    for(int i = 0;i < number_of_plays;++i){
        if(crapsGame())
            number_of_wins++;
    }
    printf("%lf",(double)number_of_wins / number_of_plays);
}

int main()
{
    randomize();
    crapsGameTest(100000);
}

/*------------------------------------------------------------------------------
Ternary Operator(Koşul operatörü):
Koşul operatörü 3 operand alan tek operatördür bu operatör operatör öncelik
tablosunun 13.öncelik seviyesinde bulunmaktadır.
Koşul operatörünün genel kullanımı
13-)Conditional(Koşul)             ? : ternary operator               Sağdan sola
int result = <ifade1> ? <ifade2> : <ifade3> ;
Bu operatöre göre ifade1'in ürettiği değer non zero değer ise ifade2 elde edilir
ancak bu ifadenin ürettiği değer 0 ise ifade3 elde edilir.
Bu operatör bazı durumlarda if deyimine bir alternatif olabilir.
Aşağıdaki örnekte de a değişkeni b'den büyük ise result'a atanacak değer
a iken b'nin a dan büyük olması durumunda b değeri result'a atanacaktır.
--------------------------------------------------------------------------*/

#include <stdio.h>

int main () {

    int a,b;
    printf("a,b?");
    scanf("%d%d",&a,&b);
    int result = a > b ? a : b;
    printf("%d",result);
}


/*------------------------------------------------------------------------------
Not: Bu iki ifade aynı anlama gelmez eğer 200 sabitinin sonra eklenmesi hedefeleniyorsa
parantez kullanılmalıdır.
int result = (a > b ? a : b) + 200;
int result = a > b ? a + 100 : b + 200;

--------------------------------------------------------------------------*/
#include <stdio.h>

int main () {

    int a,b;
    printf("a,b?");
    scanf("%d%d",&a,&b);
    int result = (a > b ? a : b) + 200;
    printf("%d",result);

}

/*------------------------------------------------------------------------------
Koşul fonksiyona metotlara argüman olarak geçilebilir.
--------------------------------------------------------------------------*/
#include <stdio.h>


int max(int a,int b)
{
    return a > b ? a : b;
}

int main () {

    int a,b;
    printf("a,b?");
    scanf("%d%d",&a,&b);
    printf("max(%d, %d)=%d%n", a, b, max(a,b));
}
/*------------------------------------------------------------------------------
Ternary operatörü içerisinde bir gerçek sayı türünden bir ifadenin yer alması
sonuç ne çıkarsa çıksın o sonucun da o gerçek sayı türüne dönüşmesine sebep olur.
--------------------------------------------------------------------------*/
#include <stdio.h>

int main ()
{
    double b=20.5;
    int a=10;
    double result=(b > a ? a : b)/3;//10D/3
    double dval = 10 / 3;
    printf("%lf\n",dval); // dval = 3.00000
    printf("%lf",result);//result=3.333333
}
/*------------------------------------------------------------------------------
Aşağıdaki örnekte koşul operatörleri kullanılırken parantez konması gerekmez.
ancak okunabilirlik/algılanabilirlik açısından parantez konulması uygundur.
int max = (a > b) ? (a > c ? a : c) : (b > c ? b : c);
yani yukarıdaki şekilde yazılması sonucu etkilemese de okunabilirlik açısından
dah iyi bir  kullanımdır.
--------------------------------------------------------------------------*/

#include <stdio.h>

int Max(int a,int b,int c)
{
    return (a > b) ? (a > c ? a : c) : (b > c ? b : c);
}

int main () {

    int a, b, c;
    printf("a,b,c?");
    scanf("%d%d%d", &a, &b, &c);
    int max = a > b ? a > c ? a : c : b > c ? b : c;
    printf("max:%d\n", max);
    printf("max:%d", Max(a,b,c));
}
//Date'in koşul operatörüyle yazımı
#include <stdio.h>
#include <stdbool.h>

bool isLeapYear(int year)
{
    return year % 4 && year % 100 != 0 || year % 400 == 0;
}

bool isValidDate(int day,int month,int year){
    if(day < 1 || day > 31 || month < 1 || month > 12 || year < 0)
        return false;
    int days = 31;
    switch (month) {
        case 4:
        case 6:
        case 9:
        case 11:
            days = 30;
            break;
        case 2:
            days = isLeapYear(year) ? 29 : 28;
    }
    return day <= days;
}

int getDayOfYear(int day,int month,int year)
{
    if(!isValidDate(day,month,year))
        return -1;
    int totalDays = day;
    switch (month - 1) {
        case 11:
            totalDays += 30;
        case 10:
            totalDays += 31;
        case 9:
            totalDays += 30;
        case 8:
            totalDays += 31;
        case 7:
            totalDays += 31;
        case 6:
            totalDays += 30;
        case 5:
            totalDays += 31;
        case 4:
            totalDays += 30;
        case 3:
            totalDays += 31;
        case 2:
            totalDays += isLeapYear(year) ? 29 : 28;
        case 1:
            totalDays += 31;
    }
    return totalDays;
}

int getDayOfWeek(int day,int month,int year)
{
    int totalDays;

    if(year < 1900 || (totalDays = getDayOfYear(day,month,year)) == -1)
        return  -1;
    for(int y = 1900;y < year; ++y){
        totalDays += isLeapYear(y) ? 366 : 365;
    }
    return totalDays % 7;
}
void print_date(int day,int month,int year)
{
    int dayOfWeek = getDayOfWeek(day,month,year);

    if(dayOfWeek == -1){
        printf("gecersiz tarih");
        return;
    }
    switch(dayOfWeek){
        case 0:
            printf("%02d/%02d/%04d Pazar\n",day,month,year);
            break;
        case 1:
            printf("%02d/%02d/%04d Pazartesi\n",day,month,year);
            break;
        case 2:
            printf("%02d/%02d/%04d Sali\n",day,month,year);
            break;
        case 3:
            printf("%02d/%02d/%04d Carsamba\n",day,month,year);
            break;
        case 4:
            printf("%02d/%02d/%04d Persembe\n",day,month,year);
            break;
        case 5:
            printf("%02d/%02d/%04d Cuma\n",day,month,year);
            break;
        case 6:
            printf("%02d/%02d/%04d Cumartesi\n",day,month,year);
            break;
    }
}

int main()
{
    int day,month,year;
    printf("Gunu giriniz?\n");
    scanf("%d",&day);
    printf("Ayi giriniz?\n");
    scanf("%d",&month);
    printf("Yili giriniz?\n");
    scanf("%d",&year);
    print_date(day,month,year);
}
/*-----------------------------------------------
Tohum değeri: örneğin 100 değeri için
üretilen 5 değer aşağıdaki gibiyse:
12 34 56 78 90
100 tohum değeri için daima
12 34 56 78 90
-----------------------------------------------*/
//Ödev 4 Soru 1 bir çözümü
#include <stdio.h>

int Factorial(int n)
{
    if(n < 0)
        return -1;
    int result = 1;
    for (int i = 2; i <= n ; ++i) {
        result *= i;
    }
    return result;
}
void print_e_number()
{
    double e = 0.;
    for (int i = 0; i < 13; ++i) {
        e +=(double)1/Factorial(i);
    }
    printf("%lf",e);
}

int main()
{
    print_e_number();
}
//Ödev 4 başka bir çözüm
#include <stdio.h>

int Factorial(int n)
{
    if(n < 0)
        return -1;
    int result = 1;
    for (int i = 2; i <= n ; ++i) {
        result *= i;
    }
    return result;
}
void print_e_number()
{
    double e = 0.;
    for (int i = 0; i < 13; ++i) {
        e +=1./Factorial(i);
    }
    printf("%lf",e);
}

int main()
{
    print_e_number();
}
#include <stdbool.h>
#include <stdio.h>

int sumFactors(const int val)
{
    int sum = 0;
    for(int i = 1;i <= val/2;++i){
        if(val % i == 0){
            sum += i;
        }
    }
    return sum;
}

bool isPerfect(const int val)
{
    return sumFactors(val) == val;
}


int main (){
    for(int i = 1;i < 10000;++i)
        if(isPerfect(i))
            printf("%d ",i);
}
Ödev Soruları:
1-)
#include <stdio.h>
#include <stdbool.h>

int getOnesDigit(int val){ return  val % 10;}
int getTensDigit(int val){ return  val / 10 % 10;}
int getHundredsDigit(int val){ return  val / 100;}

bool isPrime(int val)
{
    if(val <= 1)
        return false;
    if(val % 2 == 0)
        return val == 2;
    if(val % 3 == 0)
        return val == 3;
    if(val % 5 == 0)
        return val == 5;
    if(val % 7 == 0)
        return val == 7;
    for (int i = 11; i * i < val; i += 2) {
        if(val % i == 0)
            return false;
    }
    return true;
}

int reverse_number(int val)
{
    int rev = 0;
    while(val){
        rev *= 10;
        rev += val % 10;
        val /= 10;
    }
    return rev;
}
bool isOk(int val)
{
    int a = getHundredsDigit(val),b = getTensDigit(val),c = getOnesDigit(val);
    int rev = reverse_number(val);
    if(rev <= val)
        return false;
    if(isPrime(rev) && isPrime(val) && isPrime(10 * a + b) && isPrime(10 * b + a) && isPrime(10 * b + c) && isPrime(10 * c + b))
        return true;
    return false;
}

int main() {

    for(int i = 100;i <= 999;++i){
        if(isOk(i))
            printf("%d ",i);
    }
}
2-)
#include <stdio.h>
#include <stdbool.h>

int getDigitsSum(int val)
{
    int sum = 0;
    while(val){
        sum += val % 10;
        val /= 10;
    }
    return sum;
}

bool isPrime(int val)
{
    if(val <= 1)
        return false;
    if(val % 2 == 0)
        return val == 2;
    if(val % 3 == 0)
        return val == 3;
    if(val % 5 == 0)
        return val == 5;
    if(val % 7 == 0)
        return val == 7;
    for (int i = 11; i * i < val; i += 2) {
        if(val % i == 0)
            return false;
    }
    return true;
}

bool isPrimeX(int val)
{
    while(1){
        if(!isPrime(val))
            return false;
        if(val / 10 == 0)
            return true;
        val = getDigitsSum(val);
    }
}


int main() {
    for(int i = 0;i <= 999; ++i){
        if(isPrimeX(i))
            printf("%d ",i);
    }
}
3-)
#include <stdio.h>
#include <stdbool.h>

int getDigitsSum(int val)
{
    int sum = 0;
    while(val){
        sum += val % 10;
        val /= 10;
    }
    return sum;
}

int calculateDigitalRoot(int val)
{
    while(1){
        val = getDigitsSum(val);
        if(val / 10 == 0)
            break;
    }
    return val;
}

int main()
{
    int val = 36987;
    printf("%d\n", calculateDigitalRoot(val));
}
4-)
#include <stdio.h>
#include <stdbool.h>

int calculateFactorial(int n)
{
    if(n < 0)
        return -1;
    int result = 1;
    for (int i = 2; i <= n; ++i) {
        result *= i;
    }
    return result;
}

bool isFactorian(int val)
{
    int sum = 0, temp = val;
    do{
        sum += calculateFactorial(temp % 10);
        temp /= 10;
    }while(temp);
    return val == sum;
}

int main()
{
    for(int i = 0;i < 100000;++i){
        if(isFactorian(i))
            printf("%d ",i);
    }
}
5-)
#include <stdio.h>
#include <stdbool.h>

bool isPrime(int val)
{
    if(val <= 1)
        return false;
    if(val % 2 == 0)
        return val == 2;
    if(val % 3 == 0)
        return val == 3;
    if(val % 5 == 0)
        return val == 5;
    if(val % 7 == 0)
        return val == 7;
    for (int i = 11; i * i < val; i += 2) {
        if(val % i == 0)
            return false;
    }
    return true;
}
int getPrimeIndex(int val)
{
    if(!isPrime(val))
        return -1;
    int idx = 1;
    for(int i = 0;i < val;++i){
        if(isPrime(i))
            ++idx;
    }
    return idx;
}
bool isSuperPrime(int val)
{
    return isPrime(getPrimeIndex(val)) && isPrime(val);
}

int main()
{
    for(int i = 0,idx = 0;i < 100;++i){
        if(isPrime(i)){
            printf("%d. asal sayi: %d\n",++idx,i);
        }
    }
    for(int i = 0,idx = 0;i < 100;++i){
        if(isSuperPrime(i))
            printf("%d ",i);
    }
}
6-)
#include <stdio.h>
#include <stdbool.h>
#include <math.h>

int getOnesDigit(int val){ return  val % 10;}
int getTensDigit(int val){ return  val / 10 % 10;}
int getHundredsDigit(int val){ return  val / 100;}
int getThousandDigit(int val){ return val / 1000;}

bool isHardyRamanujanNumber(int val)
{
    int d = getThousandDigit(val),c = getHundredsDigit(val),b = getTensDigit(val),a = getOnesDigit(val);
    if(a == b || a == c || a == d || b == c || b == d || c == d )
        return false;
    if(val == pow(a,3) + pow(b,3) && val == pow(c,3) + pow(d,3) && pow(a,3) + pow(b,3) == pow(c,3) + pow(d,3))
        return true;
    return false;
}
int main()
{
    for (int i = 1000; i <= 9999; ++i) {
        if(isHardyRamanujanNumber(i))
            printf("%d ",i);
    }
}
7-)
#include <stdio.h>
#include <stdbool.h>

int getDigitsSum(int val)
{
    int sum = 0;
    while(val){
        sum += val % 10;
        val /= 10;
    }
    return sum;
}

bool isDecimalHarshad(int val)
{
    return val % getDigitsSum(val) == 0;
}

int main()
{
    for (int i = 10; i < 100; ++i) {
        if(isDecimalHarshad(i))
            printf("%d ",i);
    }
}
8-)
#include <stdio.h>
#include <stdbool.h>


bool isEven(int val){ return val % 2 == 0; }

void displayCollatz(int n)
{
    while(n != 1){
        if(isEven(n))
            n /= 2;
        else
            n = 3 * n + 1;
        printf("%d ",n);
    }
}

int main()
{
    int n;
    printf("n?\n");
    scanf("%d",&n);
    displayCollatz(n);
}
Eklemeler:
mülakat sorusu 1:
//ekrana noktalı virgül kullanmadan Hello world nasıl yazılır?
//Bunu yapmanın üç tip yolu vardır.
#include <stdio.h>

int main()
{
    while(!printf("Hello world")){

    }
}
#include <stdio.h>

int main()
{
    switch (!printf("Hello world")) {

    }
}

#include <stdio.h>

int main()
{
    if (!printf("Hello world")) {

    }
}
mülakat sorusu 2:
//klavyeden girilen bir sayının unsigned long long sınırlarını geçse bile 3 ile
//tam bölünüp bölünmediğini tespit eden programı yazınız.
#include <stdio.h>

int main(void)
{

    int sum = 0;
    while(1){
        char ch;
        if((ch = getchar()) == '\n')
            break;
        sum += ch - '0';
    }
    if(sum % 3 == 0)
        printf("sayi 3 ile tam bolunebilir\n");
    else
        printf("sayi 3 ile tam bolunemez\n");
}
//----------------------------------------------
#include <stdio.h>


int main()
{
   int sum = 0;
   char ch;
   while(1){
       if((ch = getchar()) == '\n')
           break;
       sum += ch - '0';
   }
   if(sum % 3 == 0)
       printf("3 ile tam bolunur\n");
   else
       printf("3 ile tam bolunemez\n");
}
//-----------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define randomize() srand(time(NULL))

int main()
{
    randomize();
    for (int i = 0; i < 100; ++i) {
        printf("%d ",rand() % 100);
    }
}
/*-----------------------------------------------
C de 3 tip nesne ömürü vardır:
1-)otomatik ömürlü nesneler:fonksiyonların parametre
değişkenler ve yerel değişkenler(runtime dan önce yok edilir.)
2-)static ömürlü nesneler: static yerel değişkenler
veya global değişkenler(ömürleri = runtime)
3-)dinamik ömürlü nesneler:malloc calloc ve realloc
fonksiyonlarıyla elde edilen nesnelerdir. programcı
ne zaman free fonksiyonunu çağırırsa o zaman destroy edilirler.
-----------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>

int z = 23;
static int y = 10;

void foo(int x)
{
    static int t = 56;
    ++y;
    ++x;
    ++t;
    ++z;
    printf("x : %d\n",x);
    printf("t : %d\n",t);
    printf("y : %d\n",y);
    printf("z : %d\n",z);
}

int main()
{
    int a = 10;
    foo(a);
    foo(a);
    foo(a);
    foo(a);
    foo(a);
}
//-----------------------------------------------
#include <stdio.h>
#include <stdlib.h>

int z = 23;
static int y;

void foo(int x)
{
    static int t = 56;
    ++y;
    ++x;
    ++t;
    ++z;
    printf("x : %d\n",x);
    printf("t : %d\n",t);
    printf("y : %d\n",y);
    printf("z : %d\n",z);
}

int main()
{
    int a = 10;
    foo(a);
    foo(a);
    foo(a);
    foo(a);
    foo(a);
}
//-----------------------------------------------
#include <stdio.h>

int a = 10;//static ömürlü
static int c = 56;//static ömürlü

int main(void)
{
    int sum = 0;//otomatik ömürlü
}

void foo(int val)//otomatik ömürlü
{
    static int  b = 34;//static ömürlü
}
/*-----------------------------------------------
Stringler
string str = "Oya";
const char* str = "Oya"; //array decay
*str = 'b'; //ub
char str[] = "Oya";
str[0] = 'b';
\0
*(str+2) yazmakla
str[2] yazmak arasında bir fark
char* türünden bir karakteri değiştirme girişimi
C dilinde tanımsız davranıştır.
char[] türünden bir stringin değiştirilirmesi
geçerlidir. Bu yüzden char* türünden stringlerin
const yapılması gerekir. çünkü bu durumda tanımsız
değil syntax hatası olucağından bu durum kolaylıkla önlenebilir.
-----------------------------------------------*/
/*-----------------------------------------------
const yerel değişkenler veya parametre değişkenleri
 herhangi bir şekilde değiştirelemez.
-----------------------------------------------*/
#include <stdio.h>

void foo(const int a)
{
    ++a;
}

int main()
{
    const int x = 34;
    x = 67;
}
/*-----------------------------------------------
char* türü yerine const char* türü kullanılması
 daha mantıklıdır çünkü bu durumda artık durum
 tanımsız davranıştan syntax hatası durumuna gelmiştir.
-----------------------------------------------*/
#include <stdio.h>


int main()
{
    const char* s = "Ankara";
    *s = 'a';

}
/*-----------------------------------------------
char pointer türünden bir string literalinin herhangi
 bir karakterinin değiştirilme girişimi tanımsız davranışa
 sebep
-----------------------------------------------*/
#include <stdio.h>

int main()
{
    char* s1 = "Ankara";
    char s2[] = "izmir";
    s1++;
    s1++;
    *s1 = 'd';
    s2[0] = 'f';
    printf("%s\n",s1);
    printf("%s\n",s2);
}
//------------------------------------------------
#include <stdio.h>

int main()
{
    char* s1 = "Oya";
    char s2[4]="Oya";
    *s1 = 'b';
    printf("%s",s1);
    s2[0] = 'b';
    printf("%s",s2);
    char ch;
    printf("Aranacak karakter giriniz?\n");
    scanf("%c",&ch);
    for(int i = 0;s2[i] != '\0';++i){
        if(s2[i] == ch) {
            printf("Karakter var\n");
            return 0;
        }
    }
    printf("Karakter yok");
}
//----------------------------------------------
#include <stdbool.h>
#include <stdio.h>

int main ()
{
    char *str1 = "ankara";
    char str2[] = "Berlin";
    *(str2 + 2) = 'a'; //str2[2] = 'a'
    printf("%s",str2);
    str1[2] = 'B'; //*(str1 + 2) = 'B' ub
    printf("%s",str1);
}
/*-----------------------------------------------
Aşağıdaki örnekte programcı const anahtar sözcüğünü kullanarak
char* türden bir stringin değiştirilmesi girişimini syntax hatası
durumuna getirip tanımsız davranıştan korunmak istemiştir.
------------------------------------------------*/
#include <stdbool.h>
#include <stdio.h>

int main ()
{
    const char *str1 = "ankara";
    char str2[] = "Berlin";
    *(str2 + 2) = 'a'; //str2[2] = 'a'
    printf("%s",str2);
    str1[2] = 'B'; //error
    printf("%s",str1);
}
/*--------------------------------------------------
const ile belirtilen değişkenler değiştirilemez.
--------------------------------------------------*/
#include <stdbool.h>
#include <stdio.h>

int main ()
{
    const int a = 10;
    a = 30;
}
/*------------------------------------------
aşağıdaki örnekte *str const olduğundan
str = "Berke" ifadesi geçerlidir ancak
tanımsız davranış söz konusudur.
-----------------------------------------*/
#include <stdio.h>

int main(void)
{
    const char  *str = "oya"; //top level const
    *str = 'b';//error
    str = "Berke"; //ub
}

/*---------------------------------------------------
const aslında türe aittir mesela aşağıdaki örnekte val'in
türü const int türüdür. Bir fonksiyonda bir değişken salt okuma
amaçlı kullanılacaksa bu durumda const yapılmalıdır. const
yapmak ile yapmamak arasında bir fark yoktur gibi bir
mantık oldukça yanlıştır.
---------------------------------------------------*/
#include <stdbool.h>
#include <stdio.h>

void print(const int val)
{
    printf("%d",val);
}

int main ()
{
    int a = 10;
    print((const int)a);
}
/*-----------------------------------------------
Stringlerde input işlemleri
stringlerde input işlemleri yapılırken scanf fonksiyonu
boşluk karakterini new line olarak göreceğinden
stringin boşluktan sonraki kısmını almayacaktır.
Boşluktan sonraki kısmı almak için standart kütüphanenin
gets fonksiyonu kullanılabilir. Bu konu ilerde ele
alınacaktır.
-----------------------------------------------*/
#include <stdio.h>

int main()
{
    char str[20];
    printf("Bir yazi giriniz?");
    scanf("%s",str);
    printf("%s",str);
}
/*-----------------------------------------------
Standart kütüphanenin gets fonksiyonuyla scanf fonksiyonunu
 aksine arasında boşluk olan stringler de tam olarak alınabilir.
-----------------------------------------------*/
#include <stdio.h>

int main()
{
    char str[20];
    printf("Bir yazi giriniz?");
    gets(str);
    printf("%s",str);
}
/*-----------------------------------------------
standart kütüphanenin strchr fonksiyonu ve test kodu
-----------------------------------------------*/
#include <stdio.h>
#include <string.h>

int main()
{
    char str[20];
    printf("Bir yazi giriniz?");
    gets(str);
    char ch;
    printf("Aranacak karakteri giriniz?\n");
    scanf("%c",&ch);
    if(strchr(str,ch) != '\0'){
        printf("Karakter var\n");
    }
    else {
        printf("Karakter yok\n");
    }
}
/*-----------------------------------------------
standart kütüphanenin strcpy fonksiyonu ve test kodu
 strcpy fonksiyonu adından da anlaşılabileceği gibi
 2.argümanındaki stringi ilk argümanına kopyalar.
-----------------------------------------------*/
#include <stdio.h>
#include <string.h>

int main()
{
    char str1[20];
    printf("Bir yazi giriniz?");
    gets(str1);
    char str2[20];
    puts(str2);
    strcpy(str2,str1);
    puts(str2);
}
/*------------------------------------------------------------------------------
Yazıların char Türden Dizilerde Saklanması(String literali)
Aslında yazı dediğimiz şey karakterlerden oluşan bir dizidir. Bilindiği gibi karakterler de aslında karakter
tablosunda birer sayı belirtir. Bir yazının karakter numaralarını bir dizide saklarsak yazıyı saklamış oluruz.
Programa dili ne olursa olsun yazılar arka planda hep böyle saklanmaktadır. Şüphesiz yazıları saklamak için en iyi
tür char türüdür. char türü her sistemde 1 byte uzunluğundadır.
Genellikle yazılar char türden dizilerin başından başlarlar fakat onların sonuna kadar devam etmezler. Yani
genellikle yazılar yerleştirildikleri diziden küçük olurlar. Bu durumda yazının sonunu belirlemek gerekir. İşte C'de
bunun için null karakter kullanılmaktadır. null karakter '\0' ile temsil edilir. Karakter, tablonun sıfır numaralı
karakteridir ve sayısal değeri de sıfırdır. null karakterin bir görüntü karşılığı yoktur, zaten tabloya böyle bir amaç
için yerleştirilmiştir.
C'de bir char türden bir diziye yazı yerleştireceksek yazının sonuna (dizinin sonuna değil) '\0' karakteri koymalıyız.
Çünkü C'de herkes tarafından yapılan böyle bir anlaşma vardır. Bu durumda n elemanlı charf türden bir diziye en
fazla n - 1 elemanlı bir yazı yerleştirilebilir. Bu durum aşağıdaki örnekte gösterilmiştir.
s[2] = *(s + 2)
1-) -> . [] ()
2-) * + -
--------------------------------------------------------------------------*/
#include <stdio.h>

int main(void)
{
    char s[10];
    int i;
    s[0] = 'a';
    s[1] = 'l';
    s[2] = 'i';
    *(s+3) = '\0';
    for (i = 0; s[i] != '\0'; ++i)
        putchar(s[i]);
    putchar('\n');
    return 0;
}

//yazıların hepsinin sonunda null karakter vardır!!

#include <stdio.h>


int main(void)
{
    char s[] = "Ankara";
    for (int i = 0; s[i] != '\0'; ++i)
        putchar(s[i]);
    putchar('\n');
    return 0;
}
/*------------------------------------------------------------------------------
Aynı işlem ilkdeğer verilerek de yapılabilirdi.
----------------------------------------------------------------------------*/
#include <stdio.h>
int main(void)
{
    char s[10] = { 'a', 'l', 'i', '\0' };
    char s[10] = "ali";
    int i;
    for (i = 0; s[i] != '\0'; ++i)
        putchar(s[i]);
    putchar('\n');
    return 0;
}
/*------------------------------------------------------------------------------
gets Fonksiyonu
gets standart bir C fonksiyonudur. Aşağıdaki gibi kullanılır:
gets(<dizi ismi>);
gets fonksiyonu klavyeden bir yazı girilip ENTER tuşuna basılana kadar bekler. Girilen yazının karakterlerini tek
tek verdiğimiz char türden diziye yerleştirir, yazının sonuna '\0' karakterini de ekler.gets dizinin diğer elemanlarına
hiç dokunmaz.Bu fonksiyonun scanf fonksiyonundan farkı scanf te boşluk karakterinden sonraki karakterler
dikkate alınmaz ancak gets fonksiyonu boşluk karakterlerinde sonrasını da dikkate alır.
----------------------------------------------------------------------------*/
#include <stdio.h>
int main(void)
{
    char s[100];
    int i;
    gets(s);
    for (i = 0; s[i] != '\0'; ++i)
        putchar(s[i]);
    putchar('\n');
    return 0;
}

/*------------------------------------------------------------------------------
puts Fonksiyonu
puts fonksiyonu bir dizinin ismini (yani adresini) parametre olarak alır '\0' görene kadar tüm karakterleri yan yana
basar, en sonunda imleci aşağı satırın başına geçirerek orada bırakır.
--------------------------------------------------------------------------*/
#include <stdio.h>
int main(void)
{
    char s[100];
    int i;
    gets(s);
    puts(s);
    return 0;
}
/*------------------------------------------------------------------------------
printf Fonksiyonu İle Yazıların Yazdırılması
printf fonksiyonunda %s format karakterine karşılık char türden bir dizi ismi (aslında adres) gelmelidir. Bu
durumda printf null karakter görene kadar karakterleri yazar.
--------------------------------------------------------------------------*/
#include <stdio.h>
int main(void)
{
    char s[100];
    printf("Yazi giriniz:");
    gets(s);
    printf("Girilen yazi: %s\n", s);
    return 0;
}
/*------------------------------------------------------------------------------
char Türden Dizilere İki Tırnak İfadesi ile İlkdeğer Vermek
C'de char türden bir diziye iki tırnak ile ilkdeğer verilebilir. Örneğin:
char s[10] = "ankara";
Burada yazının karakterleri tek tek diziye yerleştirilir, sonuna null karakter eklenir. Tabi dizinin geri akalan
elemanları da yine sıfırlanacaktır.
--------------------------------------------------------------------------*/
#include <stdio.h>
int main(void)
{
    char s[6] = "ankara";
    printf("%s\n", s);
    return 0;
}
/*------------------------------------------------------------------------------
İki tırnak ile ilkdeğer verilirken dizi uzunluğu yine belirtilmeyebilir. Örneğin:
char s[] = "ankara";
Burada derleyici null karakteri de hesaba katar. Yani dizi 7 uzunlukta açılmış olacaktır. Aşağıdaki ilkdeğer verme
geçersizdir:
char s[4] = "ankara"; /* geçersiz! */
Burada verilen ilkdeğerler dizi uzunluğundan fazladır. Aşağıdaki durum bir istisnadır:
char s[6] = "ankara"; /* geçerli, fakat null karakter eklenmeyecek */
Standartlara göre iki tırnak içerisindeki karakterlerin sayısı tam olarak dizi uzunluğu kadarsa bu durum geçerlidir.
Ancak '\0' karakter derleyici tarafından bu istisnai durumda diziye eklenmez.
İki tırnağın içi boş olabilir. Bu durumda yalnızca null karakter ataması yapılır. Örneğin:
char s[] = "\0"; /* geçerli */
Dizi tek elemanlıdır ve o elemanda da '\0' karakter vardır.
Standartlara göre '\0' karakteri kesinlikle hangi karakter dönüştürme tablosu kullanılıyor olursa olsun o tablonun
sıfır numaralı karakteridir. Yani null karakterin sayısal değeri sıfırdır. Başka bir deyişle:
s[n] = 0;
ile
s[n] = '\0';
tamamen aynı etkiyi yapar. Eğer char dizisi yazısal amaçlı kullanılıyorsa '\0' kullanmak iyi bir tekniktir.
char türden diziye iki tırnakla daha sonra değer atayamayız. Yalnızca ilkdeğer olarak bunu yapabiliriz. Örneğin:
char s[10];
s = "ankara"; /* geçersiz! */
------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------
aşağıdaki örnekte bir tanımsız davranış davranış söz konusudur. Bunun nedeni
string literalinin sonunda null karakter olamamasından kaynaklanmaktadır.
------------------------------------------------------------------------*/
#include <stdio.h>
#include <string.h>

int main(void)
{
    char s[5] = "Berke";
    printf("%zu",strlen(s));
    return 0;
}
//Aşağıdaki kod geçerlidir ancak sonunda null karakter yoktur.
#include <stdio.h>

int main(void)
{
   char s[4] = "anka";

   for(int i = 0;s[i] != '\0';++i){
           printf("%c",*(s+i));
       }
}
/*-----------------------------------------------
Standart kütüphanenin yazı işlemleri yapan fonksiyonları
-----------------------------------------------*/
#include <stdio.h>
#include <string.h>


int main()
{
    char* str = "ankara";
    printf("Aranacak karakteri giriniz");
    char ch;
    scanf("%c",&ch);
    if(strchr(str,ch)!= (void*)0){
        printf("Karakter var\n");
    }
    else{
        printf("Karakter yok\n");
    }
}
/*---------------------------------------------------
Aşağıdaki örnekte s1 ve s2 ye atanan değerler null
pointerdır.
-------------------------------------------------*/
#include <stdio.h>

int main(void)
{
    char* s1 = 0;
    char* s2 = NULL;
    return 0;
}
/*----------------------------------------------------------------------------
strchr fonksiyonunun geri değeri char* türündendir ve bulunan harf karakterinin
 bellek adresi elde edilir. Eğer bulunamazsa null karakter döndürülür.
------------------------------------------------------------------------------*/
#include <stdio.h>
#include <string.h>

int main(void)
{
    char s[7] = "ankara";
    char* idx = strchr(s,'k');
    printf("%p\n",idx);
    printf("%p\n",s);
    if(idx != NULL){
        printf("Karakter var\n");
        printf("%lld. karakter",idx - s + 1);
        printf("indeksi : %lld",idx - s);
    }
    else{
        printf("Karakter yok\n");
    }
}

/*----------------------------------------------------------------------------
strchr fonksiyonu aşağıdaki gibi yazılabilir ancak tabi ki bunu standart kütüphaneden
kullanmak daha iyi bir yöntemdir.
------------------------------------------------------------------------------*/
#include <stdio.h>

char* mystrchr(char* s,char ch)
{
    while(*s != '\0'){
        if(ch == *s)
            return s;
        s++;
    }
    return NULL;
}

int main(void)
{
    char s[7] = "ankara";
    char* idx = mystrchr(s,'k');
    if(idx != NULL){
        printf("Karakter var\n");
        printf("%lld. karakter",idx - s + 1);
    }
    else{

    }
}
/*-----------------------------------------------
strncpy ikinci stringdeki n elemanı ilk stringe kopyalar.
-----------------------------------------------*/
#include <stdio.h>
#include <string.h>

int main(void)
{
   char s1[20];
    printf("Bir yazi giriniz?\n");
    gets(s1);
    char s2[20];
    strncpy(s2,s1,5);
    puts(s2);
}
/*-----------------------------------------------
strcmp fonksiyonu eğer yazılar aynı ise bu durumda
0 döngüdür. Eğer yazıların ilki büyükse 1, yazıların
ikincisi büyükse -1 döndürür.
-----------------------------------------------*/
#include <stdio.h>
#include <string.h>

int main(void)
{
   char s1[20];
    printf("Bir yazi giriniz?");
    gets(s1);
    char s2[] = "ankara";
    if(!strcmp(s1,s2)){
        printf("Yazilar ayni\n");
    }
    else{
        printf("Yazilar farkli");
    }
}
/*-----------------------------------------------
stringler == operatörüyle karşılaştırılmamalıdır.
böyle bir karşılaştırmada yazıları değil yazıların
adresleri karşılaştırılır.
-----------------------------------------------*/
#include <stdio.h>
#include <string.h>

int main(void)
{
    char s1[20];
    printf("Bir yazi giriniz?");
    gets(s1);
    char s2[] = "ankara";
    if(s1 == s2){
        printf("Yazilar ayni\n");
    }
    else{
        printf("Yazilar farkli");
    }
}
/*------------------------------------------------------------
strcmp eğer 0'dan büyükse bu durumda ilk yazı ikinci
yazıdan büyüktür, tersi durumda 0 dan küçükse bu durumda
ikinci yazı büyüktür. Bu karşılaştırmaya göre masa
yazısı Masa yazısından büyüktür. Çünkü lexicographical compare
bu durumda küçük m(m) büyük m(M)'den büyüktür.
------------------------------------------------------------*/
#include <stdio.h>
#include <string.h>

int main(void)
{
    char s1[20];
    printf("Birinci yaziyi giriniz?\n");
    gets(s1);
    char s2[20];
    printf("ikinci yaziyi giriniz?\n");
    gets(s2);
    if(strcmp(s1,s2) > 0){
        printf("Birinci yazi buyuk\n");
        puts(s1);
    }
    else{
        printf("ikinci yazi buyuk");
        puts(s2);
    }
}
/*-----------------------------------------------
Örnek Soru:Bir yazı eğer bir dilin alfabesinde bulunan tüm
karakterleri içeriyorsa bu yazılara Pangram yazılar denir.
örneğin Türk alfabesi için aşağıdaki yazı bir Pangramdır:
Pijamalı hasta yağız Soföre çabucak güvendi.
İngilizce alfabede ise bu:
Quick brown fox jumps over the lazy dog.

Bu açıklamalara göre kendisine argüman olarak gönderilen
yazının Türkçe ve ingilizce diline göre Pangram olup
olmadığını geri döndüren isPangramTR ve isPangramEN
fonksiyonlarını yazınız ve test ediniz.
-----------------------------------------------*/
#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <ctype.h>

bool isPangramTR(const char* str)
{
    const char alphabetTR[] = "abcdefgğhıiljklmnoöpqrstuüvyz";

    for (int j = 0; alphabetTR[j] != '\0' ; ++j) {
        if(!strchr(str,alphabetTR[j]) && !strchr(str,toupper(alphabetTR[j])) )
            return false;
    }
    return true;
}

bool isPangramEN(const char* str)
{
    const char alphabetEN[] = "abcdefghiljklmnopqrstuvwxyz";

        for (int j = 0; alphabetEN[j] != '\0' ; ++j) {
            if(!strchr(str,alphabetEN[j]) && !strchr(str,toupper(alphabetEN[j])) )
                return false;
        }
    return true;
}

int main()
{
    const char str_EN[] = "Quick brown fox Jumps over the lazy dog.";
    const char str_TR[] = "Pijamalı hasta yağız Şoföre çabucak güvendi.";
    if(isPangramEN(str_EN))
        printf("Pangram\n");
    else
        printf("Not a Pangram\n");
    if(isPangramTR(str_TR))
        printf("Yazi Pangram\n");
    else
        printf("Pangram degil\n");
}
/*-----------------------------------------------
Örnek Soru:Bir yazının tersten yazdırılmasıyla
kendisi aynı yazıyı ifade ediyorsa bu yazı palindrome dur
denilir. Bu açıklamaya göre kendisine gönderilen yazının
Palindrome olup olmadığını geri döndüren isPalindrome
isimli fonksiyonu yazınız ve test ediniz.
ey edip adanada pide ye
at sahibi gibi hasta
-----------------------------------------------*/
#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <ctype.h>
#define SIZE 100

int mystrlen(char* str)
{
    int len = 0;
    for(int i = 0;str[i] != '\0';++i)
        len++;
    return len;
}

bool isPalindrome(char* str)
{
    int len = mystrlen(str);

    for(int i = 0; i < len / 2; ++i) {
        if (str[i] != str[len - i - 1]) {
            return false;
        }
    }
    return true;
}

int main()
{
    char str[SIZE];
    printf("Bir yazi giriniz?\n");
    gets(str);
    reverseString(str);
    if(isPalindrome(str))
        printf("Palindrome\n");
    else
        printf("Not a Palindrome\n");
}
/*----------------------------------------------
Tüm Palindrome stringleri için çalışan kod
---------------------------------------------*/

#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <ctype.h>
#define SIZE 100

int mystrlen(char* str)
{
    int len = 0;
    for(int i = 0;str[i] != '\0';++i)
        len++;
    return len;
}

bool isPalindrome(char* str)
{
    int len = mystrlen(str);
    int i = 0, j = len - 1;

    while (i < j) {
        // Skip non-alphabetic characters from the left side of the string
        while (i < len && !isalpha(str[i])) {
            i++;
        }
        // Skip non-alphabetic characters from the right side of the string
        while (j >= 0 && !isalpha(str[j])) {
            j--;
        }
        // If the alphabetic characters don't match, the string is not a palindrome
        if (i < j && tolower(str[i]) != tolower(str[j])) {
            return false;
        }
        i++;
        j--;
    }
    return true;
}

int main()
{
    char str[SIZE];
    printf("Bir yazi giriniz?\n");
    gets(str);
    if(isPalindrome(str))
        printf("Palindrome\n");
    else
        printf("Not a Palindrome\n");
}
/*-----------------------------------------------
Örnek Soru: Bir Stringi tersten yazdıran reverseString
isimli fonksiyonu yazınız ve test ediniz.
Not: strrev standart kütüphane fonksiyonunu kullanmayınız.
-----------------------------------------------*/

#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <ctype.h>
#define SIZE 100

int mystrlen(char* str)
{
    int len = 0;
    for(int i = 0;str[i] != '\0';++i)
        len++;
    return len;
}

void gSwap(void* vp1,void* vp2,size_t size)
{
          char*cp1 = vp1;
          char*cp2 = vp2;
          while(size--){
              char temp = *cp1;
              *cp1 = *cp2;
              *cp2 = temp;
          }
}


void reverseString(char* str)
{
    int len = mystrlen(str);

    for(int i = 0;i < len / 2;++i){
        gSwap(str + i,str + len - i - 1, sizeof(char));
    }
}
void printString(const char* str)
{
    for(int i = 0 ;str[i] != '\0';++i){
        putchar(str[i]);
    }
    printf("\n");
}

int main()
{
    char str[SIZE];
    printf("Bir yazi giriniz?\n");
    gets(str);
    reverseString(str);
    printString(str);
}
/*-----------------------------------------------

-----------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------
NULL Adres Kavramı (NULL Pointer)
NULL adres derleyici tarafından seçilmiş bir sayısal bileşene sahip olan özel bir adrestir. NULL adres C'de geçerli
bir adres kabul edilmez. Başarısızlığı anlatmak için kullanılır. NULL adresin sayısal değeri standartlara göre
derleyiciden derleyiciye değişebilir. Yaygın derleyicilerin hepsinde NULL adres 0 sayısal bileşenine sahip (yani
belleğin tepesini belirten) adrestir. Fakat NULL adres standartlara göre farklı sistemlerde farklı biçimde olabilir.
C'de 0 değerini veren tamsayı türlerine ilişkin sabit ifadeleri NULL adres sabiti olarak kullanılır. Örneğin:
5 - 5
0
1 - 1
gibi ifadeler aynı zamanda NULL adres sabiti anlamına gelmektedir. Biz bir göstericiye bu değerleri atadığımızda
derleyici o sistemde hangi sayısal bileşen NULL adres belirtiyorsa göstericiye onu atar. Yani buradaki 0, 0 adresini
temsil etmez. O sistemdeki NULL adresi temsil eder. Örneğin:
int *pi = 0;
Burada pi göstericisine int bir sıfır atanmıyor. O sistemde NULL adres neyse o değer atanıyor.
NULL adres sabitini (yani sıfır değerini) her türden göstericiye atayabiliriz. Bu durumda o göstericinin içerisinde
"NULL adres" bulunur. Örneğin:
char *pc = 0;
pc'nin içerisinde NULL adres vardır. NULL adres sabitinin türü yoktur. NULL adres sabiti (yani sıfır sayısı) her
türden göstericiye atanabilir. Yukarıdaki örnekte pc göstericisi char türündendir. Fakat içerisinde NULL adres
vardır.
Örneğin bir sistgemde NULL adresin sayısal bileşeni 0xFFFF olsun. Biz bu sistemde göstericiye NULL adres
atayabilmek için, göstericiye 0xFFFF atayamayız. Yine düz sıfır atarız. Bu düz sıfır zaten o sistemdeki NULL
adres anlamına gelir. Örneğin:
char *pc = (char*)0;
Burada pc'ye sıfır adresi atanmıyor, o sistemdeki NULL adres olan 0xFFFF sayısal bileşenine sahip olan adres
atanıyor.
Anahtar Notlar: Standartlara göre NULL adres sabiti aynı zamanda sıfır değerinin void * türüne dönüşsütülmüş biçimi de olabilir. Yani (void *)0 da
NULL adres anlamına gelir.
Bir adresin NULL olup olmadığı == ve != operatörleriyle öğrenilebilir. Örneğin:
if (pi == 0) {
...
}
Burada pi'nin içerisindeki adresin sayısal bileşeninin sıfır olup olmadığına bakılmamaktadır. O sistemdeki NULL
adres olup olmadığına bakılmaktadır. Örneğin ilgili sistemde NULL adres 0xFFFF sayısal değerine ilişkin olsun.
Ve pi'in içerisinde NULL adres olduğunu varsayalım:
if (pi == 0) {
...
}
Burada if deyimi doğrudan sapar.
if parantezinin içerisinde yalnızca bir adres ifadesi varsa bu adresin NULL adres olup olmadığına bakılır. Eğer
adres NULL adres ise if deyimi yanlıştan sapar, NULL adres değilse doğrudan sapar. Örneğin:
if (pi) {
...
}
else {
...
}
Bu örnekte ilgili sistemde NULL adresin 0xFFFF olduğunu düşünelim. Yukarıdaki if deyimi yanlıştan sapacaktır.
Çünkü bu özel durumda adresin sayısal bileşeninin sıfır olup olmadığına değil, NULL adres olup olmadığına
bakılmaktadır. Benzer biçimde C'de ! operatörünün operandı bir adres bilgisiyse bu operatör adres NULL adres ise
1 değerini, NULL adres değilse 0 değerini üretir.
* ya da köşeli parantez operatörleriyle NULL adresin içeriği elde edilmeye çalışılırsa bu durum tanımsız davranışa
(undefined behavior) yol açar.
C'de NULL adres sabiti daha okunabilir ifade edilsin diye NULL isimli bir sembolik sabitle temsil edilmiştir:
#define NULL 0
Programcılar genellikle NULL adres sabiti için düz sıfır kullanmak yerine NULL sembolik sabitini kullanırlar.
Örneğin:
if (pi == NULL) {
...
}
NULL sembolik sabiti <stdio.h> v e pek çok başlık dosyasında bulunmaktadır. NULL sembolik sabitini int türden
bir sıfır olarak değil, NULL adres sabiti olarak kullanmalıyız.
strchr Fonksiyonu
Bu fonksiyon bir yazı içerisinde bir karakteri aramak için kullanılır. Eğer karakter yazı içerisinde bulunursa
fonksiyon karakterin ilk bulunduğu yerin adresiyle geri döner. Eğer bulunamazsa NULL adresle geri döner. Bu
fonksiyon null karakteri de arayabilmektedir.
char *strchr(char *str, char ch);
------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <string.h>
int main(void)
{
    char s[] = "ankara";
    char *str;
    str = strchr(s, 'k');
    if (str == NULL)
        printf("karakter yok!..\n");
    else
        printf("Buldu:%s\n", str);
    return 0;
}

//strchr fonksiyonu şöyle yazılabilir:
#include <stdio.h>
char *mystrchr(char *str, char ch)
{
    while (*str != '\0') {
        if (*str == ch)
            break;
        ++str;
    }
    return NULL;
}
int main(void)
{
    char s[] = "ankara";
    char *str;
    str = mystrchr(s, 'k');
    if (str == NULL)
        printf("karakter yok!..\n");
    else
        printf("Buldu:%s\n", str);
    return 0;
}
/*-----------------------------------------
strrchr Fonksiyonu
Fonksiyon tamamen strchr fonksiyonu gibidir. Ancak ilk bulunan karakterin değil son bulunan karakterin adresiyle
geri döner.
-------------------------------------------*/
#include <stdio.h>
#include <string.h>
int main(void)
{
    char* s = "izmir";
    char *str;
    str = strrchr(s, 'i');
    if (str == NULL)
        printf("karakter yok!..\n");
    else
        printf("Buldu:%s\n", str);
    return 0;
}
//-------------------------------------
#include <stdio.h>
#include <string.h>
int main(void)
{
    char s[] = "ankara";
    char *str;
    char*idx = strrchr(s, 'a');
    if (idx == NULL)
        printf("karakter yok!..\n");
    else {
        printf("Bulundu\n");
        printf("%lld. karakter\n",idx - s + 1);
    }
    return 0;
}
//strchr fonksiyonu şöyle yazılabilir:
#include <stdio.h>
#include <string.h>
char *mystrchr(char *str, char ch)
{
    char *result = NULL;
    while (*str != '\0') {
        if (*str == ch)
            result = str;
        ++str;
    }
    return NULL;
}
int main(void)
{
    char s[] = "izmir";
    char *str;
    str = mystrchr(s, 'i');
    if (str == NULL)
        printf("karakter yok!..\n");
    else
        printf("Buldu:%s\n", str);
    return 0;
}
/*--------------------------------------------------
strncpy Fonksiyonu
Bu fonksiyon bir yazının ilk n karakterini başka bir diziye kopyalar. Prototipi şöyledir:
char *strncpy(char *dest, char *source, unsigned n);
Bu fonksiyonda eğer n değeri strlen(source) değerinden küçük ya da eşitse fonksiyon null karakteri hedef diziye
eklemez. Örneğin:
---------------------------------------------------*/
#include <stdio.h>
#include <string.h>
int main(void)
{
    char s[] = "izmir";
    char d[32] = "ankara";
    strncpy(d, s, 3);
    puts(d); /* izmara */
    return 0;
}
/*----------------------------------------------------------
Eğer n değeri strlen(source) değerinden büyükse ya da eşitse hedefe null karakter de kopyalanır. Üstelik geri kalan
miktar kadar null karakter kopyalanır.
----------------------------------------------------------*/
#include <stdio.h>
#include <string.h>

int main(void)
{
    char s[] = "izmir";
    char d[32] = "ankara";
    strncpy(d, s, 30);
    puts(d); /* izmir çıkacak fakat 24 tane null karakter d'ye eklenecek */
    return 0;
}
/*Fonksiyon yine strcpy de olduğu gibi, kopyalamanın yapıldığı hedef adrese geri döner.
strncpy fonksiyonu şöyle yazılabilir:*/
#include <stdio.h>

char *mystrncpy(char *dest, const char *source, unsigned n)
{
    char *temp = dest;
    while (n-- > 0) {
        *dest = *source;
        if (*source != '\0')
            ++source;
        ++dest;
    }
    return temp;
}
int main(void)
{
    char s[] = "izmir";
    char d[32] = "ankara";
    mystrncpy(d, s, 30);
    puts(d); /* izmir çıkacak fakat 24 tane null karakter d'ye eklenecek */
    return 0;
}
/*-----------------------------------------------
strrev fonksiyonu biz stringi tersten yazdırmak için kullanılır.
-----------------------------------------------*/
#include <stdio.h>
#include <string.h>

int main(void)
{
    char str[100] = "ey edip adanada pide ye";

    printf("%s\n",str);

    strrev(str);

    printf("%s\n",str);
}
/*-----------------------------------------------
strrev fonksiyonu ve test kodu
-----------------------------------------------*/

/*----------------------------------------------------------------------------
Polindrom:Eğer bir yazının tersten yazılmış hali normal haline eşit ise buna
 polindrom yazı adı verilir.
 Yukarıdaki açıklamaya göre klavyeden girilen bir yazının polindrom olup olmadığını
 geri döndüren isPolindrome isimli fonksiyonu yazınız.
------------------------------------------------------------------------------*/
#include <stdio.h>
#include <string.h>

int mystrlen(const char*str){
    int size = 0;
    while(*str++ != '\0'){
        size++;
    }
    return size;
}

void reverse_string(char* str)
{
    int len = mystrlen(str);
    for(int i = 0;i < len / 2;++i){
        char temp = *(str + len - i - 1);
        *(str + len - i - 1) = *(str + i);
        *(str + i) = temp;
    }
}

int main(void)
{
    char str[10] = "ankara";

    printf("%d", mystrlen(str));
    reverse_string(str);
    printf("%s",str);

}
//-----------------------------------------------
#include <stdio.h>
#include <string.h>

int mystrlen(const char*str){
    int size = 0;
    while(*str++ != '\0'){
        size++;
    }
    return size;
}

void reverse_string(char* str)
{
    int len = mystrlen(str);
    for(int i = 0;i < len / 2;++i){
        char temp = *(str + len - i - 1);
        *(str + len - i - 1) = *(str + i);
        *(str + i) = temp;
    }
}

int main(void)
{
    char str[25] = "ey edip adanada pide ye";
    char s[25];
    strcpy(s,str);

    printf("%d", mystrlen(str));
    reverse_string(str);
    if(!strcmp(s,str)){
        printf("Polindrom\n");
    }
    else{
        printf("Polindrom degil\n");
    }
}
/*-----------------------------------------------
standart kütüphanenin strcat fonksiyonu
-----------------------------------------------*/
#include <stdio.h>
#include <string.h>


int main(void)
{
    char str[20] = "oya";
    strcat(str,"can");
    puts(str);
}
/*-----------------------------------------------
strcat fonksiyonu cont
-----------------------------------------------*/
/*-----------------------------------------------
Standart kütüphanenin isalnum fonksiyonu
-----------------------------------------------*/
#include <stdio.h>
#include <ctype.h>


int main(void)
{
    char str[20] = "Yasasin!";
    int count = 0;
    for (int i = 0; str[i] != '\0'; ++i) {
        if (isalnum(str[i]))
            count++;

    }
    printf("Count : %d",count);
}
/*-----------------------------------------------
isalpha fonksiyonu ve test kodu
-----------------------------------------------*/
#include <stdio.h>
#include <ctype.h>

int main(void)
{
    char str[20] = "Tarih : 25.01.2023";
    int count = 0;
    for (int i = 0; str[i] != '\0'; ++i) {
        if (isalpha(str[i]))
            count++;

    }
    printf("%d tane harf karakteri var",count);
}
/*-----------------------------------------------
isspace fonksiyonu test kodu
-----------------------------------------------*/
#include <stdio.h>
#include <ctype.h>


int main(void)
{
    char str[30] = "Tarih : 25 . 01 . 2023";
    int count = 0;
    for (int i = 0; str[i] != '\0'; ++i) {
        if (isspace(str[i]))
            count++;

    }
    printf("%d tane bosluk karakteri var",count);
}
/*-----------------------------------------------
islower fonksiyonu ve test kodu
-----------------------------------------------*/
#include <stdio.h>
#include <ctype.h>

int main(void)
{
    char str[30] = "Tarih : 25 . 01 . 2023";
    int count = 0;
    for (int i = 0; str[i] != '\0'; ++i) {
        if (islower(str[i]))
            count++;

    }
    printf("%d tane buyuk harf karakteri var",count);
}
/*-----------------------------------------------
isupper fonksiyonu ve test kodu
-----------------------------------------------*/
#include <stdio.h>
#include <ctype.h>

int main(void)
{
    char str[30] = "Tarih : 25 . 01 . 2023";
    int count = 0;
    for (int i = 0; str[i] != '\0'; ++i) {
        if (isupper(str[i]))
            count++;

    }
    printf("%d tane buyuk harf karakteri var",count);
}
/*-----------------------------------------------
strstr fonksiyonu 1. argümanındaki string içerisinde
2.argümanındaki string literalini aratır. Bulunursa
char* türünden bir geri dönüş değeriyle elemanın bulunduğu
konumu döndürür eğer bulunamazsa bu durumda sonlandırılır.
-----------------------------------------------*/
#include <stdio.h>
#include <string.h>

int main(void)
{
    char s1[20],s2[20];
    printf("Birinci yaziyi giriniz?\n");
    gets(s1);
    printf("ikinci yaziyi giriniz?\n");
    gets(s2);
    char *pos = strstr(s1, s2);
    printf("%p\n",s1);
    printf("%p\n",pos);
    pos ? printf("found the string '%s' in '%s' at position %td\n",
                 s2, s1, pos - s1 + 1)
        : printf("the string '%s' was not found in '%s'\n",
                 s2, s1);
}
/*-----------------------------------------------
Macrolar
-----------------------------------------------*/
/*-----------------------------------------------
önişlemci komutları
#include ""
 #ifdef
 #ifndef(if not defined)
 #if
 #else
 #elif
 #endif
-----------------------------------------------*/
#include <stdio.h>
#include <stdbool.h>
#if
//code
#else
//code

int main(void)
{
    printf("%d",isPrime(31));
    if()
        //code
    else
        //code
}

/*-----------------------------------------------

-----------------------------------------------*/
/*-----------------------------------------------
önişlemci komutları
#include ""
 #ifdef
 #ifndef(if not defined)
 #if
 #else
 #elif
 #endif
 #define SIZE 100

-----------------------------------------------*/
#include <stdio.h>

#define Max(a,b) a > b ? a : b
#define Min(a,b) a > b ? b : a
#define Mid(a,b,c) ((a > b && b > c) ? b : ((b > a && a > c) ? a : c))

int main(void)
{
    int a,b,c;
    printf("uc sayi giriniz?\n");
    scanf("%d%d%d",&a,&b,&c);
    printf("%d\n", Max(a,b));
    printf("%d\n",Min(a,b));
    printf("%d\n", Mid(a,b,c));

}
//-----------------------------------------------
#define SIZE 100

int main(void)
{
    int arr[SIZE];
}

/*-----------------------------------------------
Aşağıdaki örnekte stm32f429 kartına özel bir kod yazılması
hedeflenmiştir.
-----------------------------------------------*/
#include <stdio.h>
#include <stdbool.h>
#if STM_32_F4
//code
#else


int main(void)
{

}
//-----------------------------------------------------------------------------
#include <stdio.h>

void print()
{
    static int y = 10;
    int z = 11;
    y++;
    z++;
    printf("y : %d\n",y);
    printf("z : %d\n ",z);
}

int main(void) {
    print();
    print();
    print();
    return 0;
}
/*------------------------------------------------------------------------------
Diziler(Arrays): Elemanları aynı türden olan ve bellekte ardışıl bir
şekilde tutulan veri yapılarına dizi denir.
Aşağıdaki örnekte dizinin tüm elemanlarını ekrana for döngüsü ile yazdırma
yöntemi gösterilmiştir.
int arr[] = {1,2,3};
--------------------------------------------------------------------------*/
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main() {

    int a[]={1,2,3,4,5};

    for (int i=0;i < sizeof a/sizeof(a[0]);++i){
        printf("%d ",a[i]);
    }
}
//---------------------------------------------------------------------------
#include <stdio.h>
#define SIZE 10


int main()
{
    int a[SIZE];
    for(int i =0;i < SIZE; ++i){
        a[i] = i;
    }
    for(int i =0;i < SIZE; ++i) {
        printf("%d ", a[i]);
    }
}
/*------------------------------------------------------------------------------
ilk örnekte olduğu gibi elemanlara ilk değer vermemek durumunda size ya uzunluk değeri
girilmelidir aksi durumda bellekte ne kadar yer ayrılacağı bilinmediği için
error oluşur. Eğer dizilerin uzunlukları çalışma zamanı içerisinde belli
olucaksa malloc,calloc veya realloc fonksiyonları kullanımlıdır. Bu fonksiyonlar ilerde ele alınacaktır.
1-)[] () -> .
int arr [] -> arr türü int[]
int* ptr;
int arr[];
int arr[];
--------------------------------------------------------------------------*/
#include <stdio.h>


int main() {

    int n;
    printf("dizinin uzunlugunu giriniz?\n");
    scanf("%d",&n);
    int a[n];
    a[0]= 1;
    a[1] = 2;
    a[2] = 3;
    a[3] = 4;
    for(int i = 0;i < n;++i){
        printf("%d ",a[i]);
    }
    long b[20];//legal
    double d[10];//legal
}
/*------------------------------------------------------------------------------
Dizi Elemanlarına Erişim ve [] Operatörü
Dizi elemanlarına [] operatörüyle erişilir. Köşeli parantezlerin içerisine tamsayı türlerine ilişkin bir indeks ifadesi
yazılmak zorundadır. Bu ifade sabit ifadesi olmak zorunda değildir. Dizinin ilk elemanı sıfırıncı indeks'li elemanıdır.
Bu durumda son eleman (n elemanlı bir dizide) n - 1'inci indeksteki eleman olur. Örneğin:
int a[10][20];
a[3] ifadesi int türdendir. a ifadesi ise int[10] türündendir.
--------------------------------------------------------------------------*/
#include <stdio.h>

int main(void) {
    int a[10];
    for (int i = 0; i < 10; ++i)
        a[i] = i * i;
    for (int i = 0; i < 10; ++i)
        printf("%d ", a[i]);
    printf("\n");
    return 0;
}
/*------------------------------------------------------------------------------
Dizi Elemanlarına İlkdeğer Verilmesi
Bir dizinin elemanlarına değer atanmamışsa elemanların içerisinde ne vardır? Dizi yerel ise dizinin tüm
elemanlarında çöp değer, globalsa sıfır bulunur. içine değer atanmamış local
değişkenlerin kullanımı tanımsız davranışa sebep olur.
--------------------------------------------------------------------------*/
#include <stdio.h>

int a[10];//global dizi(elemanları 0)

int main(void) {

    int b[20];//yerel dizi(elemanları çöp değer)
    int x;
    for(int i = 0;i < sizeof(b) / sizeof(b[0]);++i){
        printf("%d ",b[i]);
    }
    printf("-----------------\n");
    for(int i = 0;i < sizeof(a) / sizeof(a[0]);++i){
        printf("%d ",a[i]);
    }
    printf("-----------------\n");
    printf("%d\n",x);
    return 0;
}

/*------------------------------------------------------------------------------
Diziler fonksiyonlara parametre değişkeni olarak geçilebilir ancak bu durumlarda bazı
dikkat edilmesi gerekilen durumlar vardır. Bir fonksiyonun parametre değişkeni bir dizi
olduğu sanılsa da aslında bu parametre değişkeni bir pointer değişkendir. Bu sebeple
eğer bunu bir dizi sanıp sizeof değeri elde edilirse aslında pointer değişkenin sizeof
değeri elde edilir. Örneğin aşağıdaki örnekte get_size fonksiyonu aslında söz
 konusu dizinin sizeof değerini değil int türden bir pointerın size of değerini elde eder.
 Bu yüzden genelde dizi işlemi yapan fonksiyonları 2 parametre ile çağırmarıp
 onlara size değerini argüman olarak geçmek çok daha iyi bir yöntemdir.
-----------------------------------------------------------------------------*/
#include <stdio.h>

unsigned get_size(int arr[])
{
    return sizeof(arr);
}

int main()
{
    int arr[] = {1,2,3,4,5};
    printf("%u", get_size(arr));
    return 0;
}
/*------------------------------------------------------------------------------
Dizi elemanlarına ilkdeğer küme parantezleri ile verilir. Küme parantezlerinin içerisinde değerler ',' atomu ile
ayrılarak yazılır. Örneğin:
int a[3] = {1, 2, 3};
Dizinin uzunluğundan fazla elemanına değer veremeyiz. Örneğin:
int a[3] = {1, 2, 3, 4}; /* geçersiz! */
Fakat dizinin az sayıda elemanına ilkdeğer verebiliriz. Bu durumda geri kalan elemanlar dizi ister yerel yerel olsun,
ister global olsun derleyici tarafından sıfırlanır. Örneğin:
 int arr[<sabit ifadesi>];
int a[5] = {1, 2}; /* Dizinin 2, 3 ve 4'üncü indeksli elemanları sıfırdır */
İlkdeğer verirken küme parantezlerinin içi boş bırakılamaz. Örneğin:
int a[] = {};
Örneğin yerel bir dizinin tüm elemanlarını sıfırlamanın en kolay şöyledir:
int a[10] = {0};
--------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------
Diziye ilkdeğer verilirken küme parantezlerinin içi boş bırakılabilir. Bu durumda derleyici verilen ilkdeğerleri
sayar ve dizinin o uzunlukta açılmış olduğunu kabul eder. Örneğin:
int a[] = {1, 2, 3}; /* geçerli */
Burada a dizisi 3 elemanlıdır.
Tabi diziye ilkdeğer verilmiyorsa uzunluk belirtmek zorunludur. Örneğin:
int a[]; /* geçersiz! */
C'de virgüllerle ayrılmış listelerde genel olarak (ileride başka konularda da karşılaşılacak) son elemana sonra ','
atomu bulundurulabilir. Bu yasak değildir. Örneğin:
int a[3] = {1, 2, 3,}; /* geçerli */
int b[] = {1, 2, 3,}; /* geçerli */
C90'da dizinin istediğimiz bazı elemanlarına ilkdeğer veremeyiz. Böyle bir sentaks yoktur. Ancak C99'da bu
aşağıdaki sentaksla mümkündür:
int a[10] = {10, [4] = 100, 200, [9] = 300};
C99'a göre burada dizinin sıfırıncı indeksli elemanında 10, 4'üncü indeksil elemanında 100, 5',nci indeksli
elemanında 200 ve 9'uncu indeksli elemanında 300 vardır. Diğer elemanlarda sıfır bulunur. Bu özellik bazı C90
derleyicilerinde bir eklenti (extension) olarak desteklenmektedir.
--------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------
Anahtar Notlar: bir statik ömürlü diziye ilk değer verilmezse default olarak 0 değeri
tüm elemanlara atanır ancak tüm elemanlar 0 atama işlemi otomatik için aşağıdaki
gibi yapılabilir:
int b[200] = {0};(b bir otomatik ömürlü dizi olmak üzere)
-------------------------------------------------------------------------------*/
#include <stdio.h>

int main(void) {

    int a[5] = {1, 2};
    static int b[100];
    for (int i = 0; i < sizeof a / sizeof(a[0]); ++i) {
        printf("%d ",a[i]);
    }
    for (int i = 0; i < sizeof b / sizeof(b[0]); ++i) {
        printf("%d ",b[i]);
    }
    return 0;
}
/*-------------------------------------------------------------------------------
Dizilere rastgele değer üretilmesi aşağıdaki gibi yapılabilir.
-------------------------------------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define randomize() srand(time(NULL))
#define SIZE 20


void setRandomArray(int arr[] , int size)
{
    for(int i = 0;i < size;++i){
        arr[i] = rand() % 100;
    }
}
void print_array(int arr[],int size)
{
    for(int i = 0;i < size;++i)
        printf("%d ",arr[i]);
    printf("\n");
}

int main()
{
    randomize();
    int arr[SIZE];
    print_array(arr,SIZE);
    setRandomArray(arr,SIZE);
    print_array(arr,SIZE);
    return 0;
}
/*------------------------------------------------------------------------------
Bir Dizi İçerisindeki En Büyük (ya da En Küçük) elemanın Bulunması Algoritması
Bu problemin tek bir algoritmik çözümü vardır. Dizinin ilk elemanı enbüyük kabul edilip bir nesnede saklanır.
Sonra geri kalan tüm elemanlara bakılır, daha büyüğü varsa nesne içerisindeki değer yer değiştirilir.
--------------------------------------------------------------------------*/
#include <stdio.h>
#define SIZE 10
int main(void)
{
    int a[SIZE] = { 10, 4, 6, 34, 32, -34, 39, 21, 9, 22 };
    int i, max;
    max = a[0];
    for (i = 1; i < SIZE; ++i)
        if (a[i] > max)
            max = a[i];
    printf("Max = %d\n", max);
    return 0;
}
//Başka bir çözüm
#include <stdio.h>
#include <limits.h>

#define SIZE 10
int main(void)
{
    int a[SIZE] = { 123, 4, 6, 34, 32, -34, 39, 21, 9, 22 };
    int i, max;
    max = INT_MIN;
    for (i = 0; i < SIZE; ++i) {
        if (a[i] > max) {
            max = a[i];
        }
    }
    printf("Max = %d\n", max);
    return 0;
}

//Örnek Soru: int türden bir diziyi ters yüz ediniz ve elemanları yazdırınız

#include <stdio.h>

#define SIZE 10

int main(void)
{
    int a[SIZE] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    int i, temp;
    for (i = 0; i < SIZE / 2; ++i) {
        temp = a[SIZE - i - 1];
        a[SIZE - i - 1] = a[i];
        a[i] = temp;
    }
    for (i = 0; i < SIZE; ++i)
        printf("%d ", a[i]);
    printf("\n");
    return 0;
}
//Daha güzel bir çözüm
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define randomize() srand(time(NULL))

#define SIZE 10

void setRandomArray(int arr[] , int size)
{
    for(int i = 0;i < size;++i){
        arr[i] = rand() % 100;
    }
}

void reverse_array(int arr[],int size)
{
    for(int i = 0;i < size / 2;++i){
        int temp = arr[size- i - 1];
        arr[size- i- 1]= arr[i];
        arr[i] = temp;
    }
}

void print_array(int arr[],int size)
{
    for(int i = 0;i < size;++i)
        printf("%d ",arr[i]);
    printf("\n");
}

int main(void)
{
    int arr[SIZE];
    setRandomArray(arr,SIZE);
    print_array(arr,SIZE);
    reverse_array(arr,SIZE);
    print_array(arr,SIZE);
    return 0;
}
/*------------------------------------------------------------------------------
Dizilerin sıraya dizilmesine İngilizce "sorting" denilmektedir ve 20'den fazla sıraya dizme yöntemi vardır.
Bunlardan en popüler denilebilecek bazı algoritmalar aşağıdaki gibidir:
1-)Selection Sort(O n^2)
2-)Bubble Sort(O n^2)
3-)Quick Sort (O n log n)
4-)Merge Sort (O n log n)
5-)Insertion Sort (O n log n)
En basit yöntemlerden biri kabarcık sıralaması (bubble sort) yöntemidir. Bu yöntemde dizinin yan yana elemanları
karşılaştırılır, duruma göre yer değiştirilir. Tabi bu işlem bir kez yapılmaz. Bu işlem bir kez yapıldığında en büyük
eleman sona gider. Örneğin:
Adım 1:8 6 3 5 4
Adım 2:6 8 3 5 4
Adım 3:6 3 8 5 4
Adım 4:6 3 5 8 4
Adım 5:6 3 5 4 8
Bu işlemi ikinci yaptığımızda sona kadar değil, bir önceye kadar gitmemiz yeterli olur. Böylece iç içe iki döngüyle
algoritma gerçekleştirilebilir. Bu algoritmanın karmaşıklığı da 2 döngü sebebiyle o n^2 karmaşıklığıdır.
--------------------------------------------------------------------------*/
#include <stdio.h>
#define SIZE 10
int main(void)
{
    int a[SIZE] = { 10, 23, -5, 34, 77, 100, 32, 87, 22, 44};
    int i, k;
    int temp;
    for (i = 0; i < SIZE - 1; ++i)
        for (k = 0; k < SIZE - 1 - i; ++k) {
            if (a[k] > a[k + 1]) {
                temp = a[k];
                a[k] = a[k + 1];
                a[k + 1] = temp;
            }
        }
    for (i = 0; i < SIZE; ++i)
        printf("%d ", a[i]);
    printf("\n");
    return 0;
}
//-------------------------------------------------------------------------------
//Büyükten küçüğe ve küçükten büyüğe sıralayan bubble sort algoritmaları

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define randomize() srand(time(NULL))

#define SIZE 10

void setRandomArray(int arr[] ,size_t size)
{
    for(int i = 0;i < size;++i){
        arr[i] = rand() % 100;
    }
}

void bubble_sort_D(int arr[],size_t size)
{
    for(int i = 0;i < size - 1;++i){
        for(int k = 0;k < size - i - 1;++k){
            if(arr[k] > arr[k + 1]){
                int temp = arr[k];
                arr[k] = arr[k + 1];
                arr[k + 1] = temp;
            }
        }
    }
}
void bubble_sort_I(int arr[],size_t size)
{
    for(int i = 0;i < size - 1;++i){
        for(int k = 0;k < size - i - 1;++k){
            if(arr[k] < arr[k + 1]){
                int temp = arr[k];
                arr[k] = arr[k + 1];
                arr[k + 1] = temp;
            }
        }
    }
}

void print_array(int arr[],size_t size)
{
    for(int i = 0;i < size;++i)
        printf("%d ",arr[i]);
    printf("\n");
}

int main(void)
{
    int a[SIZE];
    int b[SIZE];
    setRandomArray(b,SIZE);
    setRandomArray(a,SIZE);
    print_array(a,SIZE);
    print_array(b,SIZE);
    bubble_sort_D(a,SIZE);
    bubble_sort_I(b,SIZE);
    print_array(a,SIZE);
    print_array(b,SIZE);
    return 0;
}
/*------------------------------------------------------------------------------
Örnek soru:bir diziyi tersten yazdıran reverse_array isimli fonksiyonu yazınız ve
test ediniz.
-------------------------------------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define randomize() srand(time(NULL))
#define SIZE 20

void setRandomArray(int arr[] , int size)
{
    for(int i = 0;i < size;++i){
        arr[i] = rand() % 100;
    }
}
void print_array(int arr[],int size)
{
    for(int i = 0;i < size;++i)
        printf("%d ",arr[i]);
    printf("\n");
}

void reverse_array(int arr[],int size)
{
    for(int i = 0;i < size / 2;++i){
        int temp = arr[i];
        arr[i] = arr[size - i - 1];
        arr[size - i - 1] = temp;
    }
}

int main()
{
    randomize();
    int arr[SIZE];
    print_array(arr,SIZE);
    setRandomArray(arr,SIZE);
    print_array(arr,SIZE);
    reverse_array(arr,SIZE);
    print_array(arr,SIZE);
    return 0;
}
/*------------------------------------------------------------------------------
Örnek Soru: Selection Sort algoritması
-------------------------------------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define randomize() srand(time(NULL))
#define SIZE 20


void setRandomArray(int arr[] , int size)
{
    for(int i = 0;i < size;++i){
        arr[i] = rand() % 100;
    }
}
void print_array(int arr[],int size)
{
    for(int i = 0;i < size;++i)
        printf("%d ",arr[i]);
    printf("\n");
}

void selectionSort(int arr[], int size) {
    int i, j, minIndex, temp;
    for (i = 0; i < size-1; i++) {
        minIndex = i;
        for (j = i+1; j < size; j++)
            if (arr[j] < arr[minIndex])
                minIndex = j;
        temp = arr[minIndex];
        arr[minIndex] = arr[i];
        arr[i] = temp;
    }
}

int main()
{
    randomize();
    int arr[SIZE];
    print_array(arr,SIZE);
    setRandomArray(arr,SIZE);
    print_array(arr,SIZE);
    selectionSort(arr,SIZE);
    print_array(arr,SIZE);
    return 0;
}
int arr[]-> arr türü int[]
int matrix[][] -> matrix türü int[][]
int* ptr -> ptr türü int*
int** ptrptr -> ptrptr türü int**
/*------------------------------------------------------------------------------
Pointerlar:Pointerlar bellekteki değişkenlerin adreslerini tutan değişkenlerdir.
bir pointerın genel biçimi:
<tür bildirimi><*deklaratörünü>(diğer bir değişle asterisk atomu) <değişken ismi>
Not:Pointer değişkenler tanımlanırken kullanılan * bir deklatördür. Bu deklatörün
diğer bir adı akteriks atomudur.dereferencing denilen * operatörü ile karıştırılmamalıdır.
geçerli pointer'lar:
a) eğer pointer hayatta olan bir nesnenin adresini tutuyor ise:int* ptr=&x;
b) eğer pointer bir dizinin bittiği yerin adresini tutuyor ise:int* ptr=a;(a bir dizi olmak üzere)
int* ptr = &a[0];
c) eğer pointer NULL pointer değerinde ise:int* ptr = NULL;
2-) *(içerik operator dereferecing operator)
--------------------------------------------------------------------------*/
#include <stdio.h>

int main() {
    int*ptr;//pointer tanımlanması
}
/*--------------------------------------------
 1-)primitive types
 2-)user defined types
 a-)structures
 b-)unions
 c-)enums
 1-). -> () []
 2-) * &
 -------------------------------------------*/

#include <stdio.h>

enum Color{
    red,Blue = 2,Purple
};

//typedef struct book book; datentypen umbenenen
struct book { //neuen datentyp deklariert, der aus 2 integer und 2 character pointer entsteht
    int isbn;
    char *author;
    char *title;
    int page_number;
    struct book* bptr;
    void (*fptr)(int);
};

union myunion{
    int number;
    char name[24];
    char surname[32];
};

void setName(struct book* sptr)
{
    printf("Bir yazi giriniz\n");
    char str[24];
    gets(str);
    sptr->author = str;
}

void setBookNumber(struct book* sptr)
{
    printf("Kitap numarasini giriniz?\n");
    int book_num;
    scanf("%d",&book_num);
    (*sptr).isbn = book_num;//sptr->isbn = book_num;
}

int main(){
    // int <name>
    struct book book;
    union myunion myunion;
    book.isbn = 4;
    book.author = "Author";
    book.title = "Titel";
    book.page_number = 200;
    printf("%zu\n",sizeof(book));
    struct book *b_ptr = &book;
    printf("%zu\n",sizeof(myunion));
    printf("%d\n", (*b_ptr).isbn);//b_ptr->isbn
    setBookNumber(&book);
    setName(&book);
}

/*------------------------------------------------------------------------------
adres operatörü(ampersand(&)):bitsel and operatörü ile aynı görülse de unary
binary kuralından dolayı derleyici tarafından ayırt edilir. Bu operatör unary
kullanımı gerektirirken bitsel and binary kullanım gerekir.Bu operatör bir değişkenin adresinin
elde edilmesini sağlar.
normal değişkenlerin Pointer nesnelerine  atanması
Not:int*ptr=&a demek ptr aslında a nın adresini gösteren bir değişken demektir.
ptr'nin derefencing operatörü ile işleme sokulması ile a'nın kendi değeri olan
10 elde edilebilir.
a & b
--------------------------------------------------------------------------*/
#include <stdio.h>

int main(){
    int a = 10; //0000 0000 0000 0000 0000 0000 0000 1010
    int b = 11; //0000 0000 0000 0000 0000 0000 0000 1011
    int c = a & b;//0000 0000 0000 0000 0000 0000 0000 1010
    int d = a | b;//0000 0000 0000 0000 0000 0000 0000 1011
    printf("c : %d\n",c);
    int result = a * b;
    int*ptr = &result;
    *ptr = 34;
}
//-------------------------------------------------------------------------------
#include <stdio.h>

int main() {

    int a=10;
    int*ptr=&a;//Not:bu ifadenin anlamı ptr'nin değeri 10 demek değil *ptr'nin değeri 10 demektir!
    printf("%p\n",&x);
    printf("%p\n",p2);
    printf("%p\n",&p2);
}
//------------------------------------------------------------------------------
#include <stdio.h>

int main() {

    int x = 34;
    int*p2 = &x;
    int y = *p2;
    printf("%p\n",&x);
    printf("%p\n",p2);
    printf("%p\n",&p2);
    printf("%d\n",y);
    printf("%d\n",x);
    printf("%d\n",*p2);
}
//------------------------------------------------------------------------------
#include <stdio.h>

int main() {

    int x=34;
    int*p2=&x;
    int y = 19;
    printf("&x   : %p\n",&x);
    printf("p2   : %p\n",p2);
    printf("&p2  : %p\n",&p2);
    printf("y : %d\n",y);
    printf("x : %d\n",x);
    printf("*p2 : %d\n",*p2);
    printf("&y : %p\n",&y);
    printf("----------------------\n");
    p2 = &y;
    printf("&x   : %p\n",&x);
    printf("p2   : %p\n",p2);
    printf("&p2  : %p\n",&p2);
    printf("y : %d\n",y);
    printf("x : %d\n",x);
    printf("*p2 : %d\n",*p2);
    printf("&y : %p\n",&y);
}
//--------------------------------------------------------------------------
#include <stdio.h>

int main(){
    int arr[] = {1,2,3};
    for(int i = 0;i < sizeof(arr) / sizeof(arr[0]);++i)
        printf("%d",i[arr]);// *(i + arr)
}
/*------------------------------------------------------------------------------
Not:int*ptr tanımlamasında ptr'nin türü pek çok programcının düşündüğü gibi int değil
int* türündedir.
--------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------
Pointer nesnelerinin normal düz değişkenlere atanması geçerlidir çünkü *ptr demek
x demektir.
--------------------------------------------------------------------------*/
#include <stdio.h>

int main() {

    int a=10;
    int*ptr=&a;
    int b=*&*&*ptr;
    printf("b : %d",b);
}
//-------------------------------------------------------------------------
/*------------------------------------------------------------------------------
Pointer nesnelerinin normal düz değişkenlere atanması geçerlidir çünkü *ptr demek
x demektir.
--------------------------------------------------------------------------*/
#include <stdio.h>

int main() {

    int x=34;
    int*p2=&x;
    int y= 14;
    printf("&x  : %p\n",&x);
    printf("p2  : %p\n",p2);
    printf("&p2 : %p\n",&p2);
    printf("&y  : %p\n",&y);
    printf("------------------\n");
    p2 = &y;
    printf("&x  : %p\n",&x);
    printf("p2  : %p\n",p2);
    printf("&p2 : %p\n",&p2);
    printf("&y  : %p\n",&y);
}

/*------------------------------------------------------------------------------
Pointerlara diziler tarafından ilk değer verilebilir ancak dizinin olmayan bir
elemanın adresinin atanması tanımsız davranışa sebep olur.
&*(a + 0);
a
int* ptr1 = a + 3;
int* ptr1 = &a[0];
--------------------------------------------------------------------------*/
#include <stdio.h>

int main()
{
    int a[4] = { 0, 1, 2, 3 };
    int *ptr1 = &a[0];//&*a
    int *ptr2 = &a[2];//&*(a + 2)

    printf("%d\n", *ptr1);  //ub
    printf("%d\n", *ptr2);  //0(dizinin 0 indisli elemanı)
    printf("%p\n",ptr1);
    printf("%p\n",ptr2);
    ++ptr1;
    ++ptr2;
    printf("%d\n", *ptr1);  //ub
    printf("%d\n", *ptr2);  //0(dizinin 0 indisli elemanı)
    printf("%p\n",ptr1);
    printf("%p\n",ptr2);
    return 0;
}
//-----------------------------------------------------------------------------
#include <stdio.h>

void printArray(int *arr,size_t size)
{
    while(size--){
        printf("%d ",*arr);
        arr++;
    }
}

int main()
{
    int a[4] = { 0, 1, 2, 3 };
    double arr[] = {2.3,4.5,67.89,6.78};
    int *ptr1 = &a[0];
    int *ptr2 = &a[2];
    double* dptr1 = arr;
    double* dptr2 = arr + 2;
    printf("%d\n", *ptr1);  //ub
    printf("%p\n",ptr1);
    printf("%d\n", *ptr2);  //0(dizinin 0 indisli elemanı)
    printf("%p\n",ptr2);
    printf("%lf\n",*dptr1);
    printf("%p\n",dptr1);
    printf("%lf\n",*dptr2);
    printf("%p\n",dptr2);
    ++ptr1;
    ++ptr2;
    ++dptr1;
    ++dptr2;
    printf("*************\n");
    printf("%d\n", *ptr1);  //ub
    printf("%p\n",ptr1);
    printf("%d\n", *ptr2);  //0(dizinin 0 indisli elemanı)
    printf("%p\n",ptr2);
    printf("%lf\n",*dptr1);
    printf("%p\n",dptr1);
    printf("%lf\n",*dptr2);
    printf("%p\n",dptr2);
    return 0;
}
//------------------------------------------------------------------------------
#include <stdio.h>

int main()
{
    int a[4] = { 0, 1, 2, 3 };
    int *ptr1 = &a[0];
    int *ptr2 = &a[2];

    printf("%d\n", *ptr1);  //ub
    printf("%d\n", *ptr2);  //0(dizinin 0 indisli elemanı)
    ptr1++;
    ptr2++;
    printf("%d\n", *ptr1);  //ub
    printf("%d\n", *ptr2);  //0(dizinin 0 indisli elemanı)
    printf("%p\n",&a[0]);
    printf("%p\n",&a[1]);
    return 0;
}
/*------------------------------------------------------------------------------
Aşağıdaki örnekte ptr aslında  x i point eden bi değişkendir.
p1 ve p2 ise ptr ye dolaylı veya doğru atandığı için onlar da x i göstermektedir.
Bu sebepten *ptr,*p1 ve *p2 yi arttırmakla x i arttırmak arasında bir fark yoktur.
Buna göre ekran çıktısı 13 olarak elde edilir.
--------------------------------------------------------------------------*/
#include <stdio.h>

int main()
{
    int x=10;
    int *ptr=&x;
    ++*ptr;
    int *p1=ptr;
    ++*p1;
    int *p2=p1;
    ++*p2;
    printf("%d",x);
}
//------------------------------------------------------------------------------
#include <stdio.h>

int main()
{
    int x=34;
    int *ptr=&x;
    ++*ptr;
    int *p1=ptr;
    ++*p1;
    int *p2=p1;
    ++*p2;
    printf("%d\n",x);
    printf("%p\n",&x);
    printf("%p\n",p1);
    printf("%p\n",p2);
    printf("%p\n",ptr);
    ++ptr;
    printf("%p\n",ptr);
}
/*------------------------------------------------------------------------------
Aşağıdaki örnekte x'in değeri değiştiği için ptr'nin değeri de
değişmiştir. Bu olay pointer nesnesinin 10 adresinden koparılıp
20 adresini göstermesi gibi düşünülebilir.
--------------------------------------------------------------------------*/
#include <stdio.h>

int main(){

    int x=10;
    int *ptr=&x;
    printf("%d\n",x);
    printf("%p\n",&x);
    printf("%p\n",ptr);
    printf("%d\n",*ptr);
    printf("-------------------\n");
    x=20;

    printf("%d\n",x);
    printf("%p\n",&x);
    printf("%p\n",ptr);
    printf("%d\n",*ptr);
    printf("-------------------\n");
    *ptr = 34;
    printf("%d\n",x);
    printf("%p\n",&x);
    printf("%p\n",ptr);
    printf("%d\n",*ptr);
}
/*------------------------------------------------------------------------------
ptr yi arttırmak x in adresini arttırmak demektir. ptr nin değeri tür uzunluğuna
bağlı olarak artmaktadır. örneğin 32 bitlik derleyicilerde int türü 2 byte olduğu
için adres değeri 2 artarken 64 bitlik derleyicilerde int türü 4
byte olduğu için 4 artmaktadır.
--------------------------------------------------------------------------*/
#include <stdio.h>

int main(){

    int x=10;
    int *ptr=&x;
    printf("%p\n",ptr);
    ptr++;
    printf("%p\n",ptr);
    printf("%d\n",*ptr);
}
//----------------------------------------------------------------------------
#include <stdio.h>

int main()
{
    printf("%zu\n",sizeof(char*));
    printf("%zu\n", sizeof(double*));
    printf("%zu\n", sizeof(int*));
    printf("%zu\n", sizeof(long*));
    printf("%zu\n",sizeof(long double*));
}
/*-----------------------------------------------------------------------------
Sakın bir değişkeni kendisinden farklı türde bir pointer değişkene atamayın.
Bu syntax hatası değildir ancak bir tanımsız davranış(gönlünüz errorü)
------------------------------------------------------------------------------*/
#include <stdio.h>

int main(){
    int a = 34;
    double* dptr = &a;
    printf("%f",*dptr);
    char*cptr = &a;
    printf("%c",*cptr);
}
/*------------------------------------------------------------------------------
Aşağıdaki örnekte a'nın ptr ye eşitlenmesi ile &a[0] e eşitlenmesi aynı anlama
gelmektedir. a[0]'ın değerinin değişmesi ptr'nin de değerinin değişmesi anlamına
gelir.
--------------------------------------------------------------------------*/
#include <stdio.h>

int main(){

    int a[]={1,2,34,78};

    int *ptr = a;

    printf("%d\n",*ptr);
    printf("%d\n",a[0]);

    int x=10;

    ptr=&x;

    printf("%d\n",*ptr);
    printf("%d\n",a[0]);
}


/*------------------------------------------------------------------------------
Aşağıdaki örnekte dizilerin adreslerinin değiştirilemediği ancak
pointerların adreslerinin değiştirebildiği anlatılmak istenmiştir.
char* str = "Ankara"; //array decay
char str[] = "Ankara";
#include <stdio.h>
#include <string.h>

int main(){
    char str[4] = "Oya";
    printf("%zu", strlen(str));
}
--------------------------------------------------------------------------*/
#include <stdio.h>

int main()
{
    int a[]={1,2,3};
    int x=10;
    int *ptr=a;
    a=&x;//error
    ptr=&x;
    char *ch="";
    printf("%p\n",ch);
    printf("%d",*ch);
}
/*----------------------------------------------------------------------------
dereferencing operator (*):Adres tutan bir değişkenin adresinin içindeki
değere erişmemizi sağlayan operatöre dereferencing operatörü denir.
Not:Bir pointer değişken tanımlanırken kullanılan yıldız(*) dereferencing operatörü
değildir.

Not 2:Dereferencing operatörü ancak bi adres ile birlikte kullanılabilir aksi durumda
Warning veya error oluşur.
------------------------------------------------------------------------------*/

#include <stdio.h>

int main(){

    int a[]={1,2,3};
    int x=10;
    int *ptr=a;
    x=*ptr;//legal *&a[0]
    *ptr=*&x;//legal
    int**ptrptr = &ptr;
    int y=*a;//legal *&a[0] -> a[0]
    y= *x;//illegal(sabit ifadeleri adres belirtmez)
    y = *123;//illegal sabit ifadeleri deferencing operatorünün opreandı yapılamaz!
    y= *&ptr;//legal ancak çok kötü bir kullanım(burda erişilen ptr adresidir)
    y= *&a;//legal ancak çok kötü bir kullanım(burda atanan &a[0] adresidir.)
    **ptrptr = 56;
}
/*------------------------------------------------------------------------------
geçersiz pointer değerleri

a)  otomatik ömürlü ilk değer verilmemiş pointer'lar
b)  dangling pointer (gösterdiği nesnenin hayatı bitmiş ama pointer'in hayatı devam ediyor)
   Dinamik bellek yönetimi
--------------------------------------------------------------------------*/
#include <stdio.h>

int main()
{
   int *ptr;

   if (1) {
      int x = 20;
      ptr = &x;
   }
   //????? ptr bu noktada geçersiz (invalid) pointer
    printf("%d",*ptr);
   return 0;
}
//-------------------------------------------------------------------------------
#include <stdio.h>

int main()
{
    int *ptr;

    {
        int x = 20;
        ptr = &x;
    }
    printf("%p\n",ptr);
    printf("%d\n",*ptr);
    //????? ptr bu noktada geçersiz (invalid) pointer

    return 0;
}
/*------------------------------------------------------------------------
Otomatik nesnelerin adresini döndürmek tanımsız davranışa sebep olur.
---------------------------------------------------------------------------*/
#include <stdio.h>

int* foo()
{
    int x = 34;
    return &x;
}

int main()
{
    int *ptr = foo();

    printf("%p\n",ptr);
    printf("%d\n",*ptr);

    return 0;
}
/*------------------------------------------------------------------------
Yukarıdaki problemin çözümü aşağıdaki gibi yapılabilir.
---------------------------------------------------------------------------*/
#include <stdio.h>

int* foo()
{
    static int x = 34;
    return &x;
}

int main()
{
    int *ptr = foo();

    printf("%p\n",ptr);
    printf("%d\n",*ptr);

    return 0;
}
/*------------------------------------------------------------------------------
Pointerlar ne zaman aynı adresi tutarlar:

a) iki pointer da aynı nesnenin adresi değerinde ise
b) iki pointer da aynı dizinin bittiği yerin adresini tutuyor ise
c) iki pointer değişken de NULL pointer değerine sahip ise (ikisi de hiçbir nesneyi göstermiyor ise)
-----------------------------------------------------------------------------*/
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main()
{
   int x = 10;
   int *p1 = &x;
   int *p2 = NULL;

   printf("%d\n", p1 == p2);

   p1 = NULL;

   printf("%d\n", p1 == p2);


   return 0;
}
/*------------------------------------------------------------------------------
Pointer neden kullanılır?
Pointer'ın kullanılma sebebi geri dönüş değeri olmayan bir metot için bile
orda yapılan işlemlerin çağıran fonksiyonu etkilemesini sağlar. Bunu yapmak
4 işlemlerde çok faydalı olmasa da dizi değiştirme işlemlerinde return
kullanımı oldukça maliyetli bir iş olduğundan dolayı dizi işlemlerinde genellikle
pointer kullanımı tercih edilmelidir. Kısaca pointer ne işe yarıyor sorusunun
cevabı fonksiyonları call by reference yapmak için kullanılır.
Peki neden call by reference?
1-)Geri dönüş değeri yerine kullanımı
2-)Kopyalama maliyetinden kaçınmak
3-)Fonksiyon içerisinde değerleri değişen değişkenlerinin main fonksiyonu
etkilemesini sağlar.
4-)Bir fonksiyona bir dizi argümanı göndermek ancak bir pointer değişken ile
yapılabilir. Bu durumda kopyalama maliyetinden gene kaçınılmış olur.
Aşağıdaki kodda square ve square_p metotları aynı anlama gelmektedir ancak
bu gibi bir durumda return deyimini kullanmak daha iyi bir tekniktir.
--------------------------------------------------------------------------*/
#include <stdio.h>

void swap(int* a,int* b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}

void bubbleSort(int* arr,size_t size)
{
    for (int i = 0; i < size - 1; ++i) {
        for(int k = 0;k < size - i - 1;++k){
            if(*(arr + k) > *(arr + k + 1))
                swap(arr + k,arr + k + 1);
        }
    }
}

void printArray(int* arr,size_t size)
{
    for (int i = 0; i < size; ++i) {
        printf("%d ",*(arr + i));
    }
    printf("\n");
}

int main()
{
    int arr[] = {15,29,78,98,32,6,7,12};
    printArray(arr,sizeof(arr) / sizeof(arr[0]));
    bubbleSort(arr,sizeof(arr) / sizeof(arr[0]));
    printArray(arr,sizeof(arr) / sizeof(arr[0]));
}
//--------------------------------------------------------------------------

#include <stdio.h>
#include <math.h>

void square_p(int* p){

    *p=pow(*p,2);
}

int square(int x){

    return x*x;//int temp = x*x;
}

int main(){

    int a[]={1,2,3};
    int x=10;
    int *ptr=a;

    printf("%d\n",square(x));
    square_p(&x);
    printf("%d\n",x);
}
/*------------------------------------------------------------------------------
Bir fonksiyon içerisinde birden fazla değişkenin değerini değiştirmek hedefleniyorsa
pointer kullanmak gerekir aksi durumda fonksiyonun birden fazla geri dönüş değeri olması
mümkün olmadığından birden fazla değişkenin değeri değiştirilemez.
--------------------------------------------------------------------------*/
#include <stdio.h>

void swap(int* x,int* y);

int main(){

   int a=20,b=30;
   swap(&a,&b);
}
void swap(int* x,int* y){

    int temp=*x;
    *x=*y;
    *y=temp;
}
/*------------------------------------------------------------------------------
Adreslerle işlemler:
Adres bilgileri tamsayı türlerine ilişkin değerlerle toplama ve çıkartma işlemine sokulabilir. Yani, p bir adres
bilgisi n de bir tamsayı türünden olmak üzere p + n ve p - n ifadeleri geçerlidir (Ancak n - p ifadesi geçerli değildir).
Bir adres bilgisine bir tamsayıyı topladığımızda ya da bir adres bilgisinden bir tamsayı çıkarttığımızda elde edilen
ürün yine aynı türden bir adres bilgisi olur. Örneğin pi int türünden bir adres bilgisi (int *) olsun:
pi + 1
ifadesi int türden bir adres bilgisi belirtir. C'de bir adres bilgisi 1 artırıldığında ya da 1 eksiltildiğinde adresin
sayısal bileşeni o adresin türünün uzunluğu kadar artar ya da eksilir. Yani örneğin int türden bir göstericiyi 1
artırdığımızda içindeki adres 64 bit sistemlerde 4 artacaktır. char türden bir gösterici bir adtırdığımızda içindeki
adres 1 artacaktır.
Peki adreslerle hangi işlemler Yapılabilir?
1-)Bir tamsayı ile bir adres toplanabilir. Sonuç bir adres olur.
2-)Bir adresten bir adres çıkartılabilir. Sonuç bir tamsayı olur.
3-)Bir adresle bir adres toplanılamaz.
4-)Bir tamsayıdan bir adres çıkartılamaz.
--------------------------------------------------------------------------*/
#include <stdio.h>


int main()
{

    int a[]={1,2,3};
    int*p1 = a;
    int x = 10;
    int*p2 = &x;
    printf("%p",p1 + 2);
    printf("%d",p1 - p2);

}
//------------------------------------------------------------
#include <stdio.h>
#include <string.h>


int main(){

    int x = 10;
    int y = 34;
    int*ptr = &x;
    printf("%d",y - ptr);
}
//--------------------------------------------
#include <stdio.h>
#include <string.h>

int mystrlen(char*str)
{
    int len = 0;
    while(*str != '\0'){
        str++;
        len++;
    }
    return len;
}


int main(){

    char str[4] = "Oya";
    printf("%zu\n", strlen(str));
    printf("%d\n", mystrlen(str));
}
//---------------------------------------------------------------------------
#include <stdio.h>
#include <string.h>


int main(){

    int x = 10;
    int y = 34;
    int*p1 = &x;
    int*p2 = &y;
    printf("%d",p1 + p2);
}
//--------------------------------------------------------------------------
#include <stdio.h>
#include <string.h>

int main()
{
    char* str = "Ankara";
    char* cp = strchr(str,'j');
    int idx = cp - str;
    printf("%d",idx);
}
//-------------------------------------------------------------------------------
#include <stdio.h>
int main(void)
{
    int a[3] = { 10, 20, 30 };
    int *pi;
    int i;
    pi = a;
    printf("%d\n", *pi); /* 10 */
    ++pi;
    printf("%d\n", *pi); /* 20 */
    ++pi;
    printf("%d\n", *pi); /* 30 */
    return 0;
}
/*------------------------------------------------------------------------------
* operatörünün operandı adres türünden olmak zorundadır. Örneğin:
int a = 0x1Fc0;
*a = 10; /* geçersiz! */
--------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------
char türden bir dizinin adresini char türden bir göstericiye atadıktan sonra göstericiyi artıra artıra yazının tüm
karakterlerine erişebiliriz.
--------------------------------------------------------------------------*/
#include <stdio.h>
int main(void)
{
    char s[] = "ankara";
    char *pc;
    pc = s;
    while (*pc != '\0') {
        putchar(*pc);
        ++pc;
    }
    putchar('\n');
    return 0;
}
/*------------------------------------------------------------------------------
Köşeli parantez (Index) Operatörü("[]")
Köşeli parantez operatörü tek operandlı sonek bir operatördür. Köşeli parantezler içerisinde tamsayı türlerine iliikin
bir ifade bulunmak zorundadır. Köşeli parantez operatörü öncelik tablosunun tepe grubunda (..) operatörü ile
soldan sağa aynı gruptadır:
1.( ) [ ] -> .          Soldan-Sağa
2.+ - ++ -- ! sizeof & *  Sağdan-Sola
3.* / %                   Soldan-Sağa
4.+ -                     Soldan-Sağa
Köşeli parantez operatörünün operandı bir adres bilgisi olmak zorundadır. p bir adres belirten ifade olmak üzere:
p[n] ile *(p + n) aynı anlamdadır. p[n] ifadesi p adresinden n ilerideki nesneyi temsil eder.
Dizi isimleri dizilerin başlangıç adresini belirttiği için dizi elemanlarına köşeli parantez operatörü ile
erişilebilmektedir. Örneğin:

int a[3] = {10, 20, 30};
int*ptr=a;
int*ptr=&a[0];//&*(a+0)
a[2] ifadesi a adresinden 2 ilerinin (yani 2 * sizeof(*a) kadar byte ilerinin) içeriği anlamına gelir. Yani a[2] ile *(a
+ 2) aynı anlamdadır.
Pekiyi p[0] ne anlama gelir? Bu ifade p adresinden 0 ilerinin içeriği anlamına gelir. *(p + 0) ile ve dolayısyla *p ile
aynı anlamdadır.
Biz köşeli parantez operatörünü göstericilerle, dizi isimleriyle ve diğer adres belirten ifadelerle kullanabiliriz.
--------------------------------------------------------------------------*/
#include <stdio.h>
int main(void)
{
    char s[] = "ankara";
    char *pc;
    int i;
    pc = s;
    for (i = 0; pc[i] != '\0'; ++i)
        putchar(pc[i]);
    putchar('\n');
    return 0;
}
/*------------------------------------------------------------------------------
Köşeli parantez içerisindeki ifade negatif bir değer de belirtebilir.
--------------------------------------------------------------------------*/
#include <stdio.h>
int main(void)
{
    int a[3] = { 10, 20, 30 };
    int *pi;
    pi = a + 2;
    printf("%d\n", pi[-2]); /* 10 */
    return 0;
}
/*------------------------------------------------------------------------------
Göstericilere İlkdeğer Verilmesi
Göstericilere de bildirim sırasında '=' atomu ile ilkdeğer verebiliriz. Örneğin:
int *pi = (int *)0x1FC0;
Burada adres p'ye atanmaktadır. Bildirimdeki yıldız operatör görevinde değildir. Tür belirtmek için
kullanılmaktadır. Başka bir örnek:
int a = 123;
int *pi = &a;
--------------------------------------------------------------------------*/
#include <stdio.h>
int main(void)
{
    int a[3] = { 10, 20, 30 };
    int *pi = a; // p'ye dizinin başlangıç adresi atanıyor
    int i;
    for (i = 0; i < 3; ++i)
        printf("%d ", pi[i]);
    printf("\n");
    return 0;
}
/*------------------------------------------------------------------------------
Fonksiyon Parametresi Olarak Göstericilerin Kullanılması
Bir fonksiyonun parametresi bir gösterici olabilir. Örneğin:
void foo(int *pi)
{
...
}
Bir fonksiyonun parametresi bir gösterici ise biz o fonksiyonu aynı türden bir adres bilgisi ile çağırmalıyız.
Örneğin:
int a = 10;
...
foo(a); // geçersiz!
foo(&a); // geçerli
Burada foo fonksiyonuna a'nın içindeki değer değil, a'nın adresi geçirilmiştir. Böylece fonksiyon içerisinde *pi
dediğimizde aslında bu ifade main fonksiyonundaki a'ya erişir.
--------------------------------------------------------------------------*/
#include <stdio.h>
void foo(int *pi)
{
    *pi = 200;
}
int main(void)
{
    int a = 123;
    foo(&a);
    printf("%d\n", a);
    return 0;
}
/*-----------------------------------------------------------------------------
C'de bir fonksiyonun başka bir fonksiyonun yerel değişkenini değiştirebilmesi için onun adresini alması gerekir.
Bunun için de fonksiyonun parametre değişkeninin gösterici olması gerekir. (Aslında tüm dillerde böyledir. Çünkü
makinanın çalışma prensibinde durum böyledir.)
İki yerel nesnenin içerisindeki değerleri değiştiren swap isimli bir fonksiyon yazmak isteyelim. Acaba bu
fonksiyonu aşağıdaki gibi yazabilir miyiz?
Cevap: Hayır çünkü bu örnekte swap fonksiyonunun çağrısı call by valuedur.
Ancak bu işlem C++'ta parametre değişkeni olarak referans kullanılmasıyla
aşağıdaki gibi çağrı ile de yapılabilir.
--------------------------------------------------------------------------*/
#include <stdio.h>
void swap(int a, int b)
{
    int temp = a;
    a = b;
    b = temp;
}
int main(void)
{
    int x = 10, y = 20;
    swap(x, y);
    printf("x = %d, y = %d\n", x, y);
    return 0;
}

/*------------------------------------------------------------------------------
Yukarıdaki sorunun cevabını hayırdır elbette geçen derste de bundan bahsettik aslında
burada swap x ve y'nin içindekilerini değiştirmiyor, parametre değişkeni olan a ve b'nin
içindekileri değiştiriyor. Bunun sağlanabilmesi için yerel nesnelerin adreslerinin swap fonksiyonuna aktarılması
gerekir. Bu durumda swap fonksiyonunun paremetre değişkenleri birer gösterici olmalıdır.
Buna göre call by value her zaman bize yetmemektedir bazen call by reference'a başvurulmalıdır.
--------------------------------------------------------------------------*/
#include <stdio.h>
void swap(int *a, int *b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}
int main(void)
{
    int x = 10, y = 20;
    swap(&x, &y);
    printf("x = %d, y = %d\n", x, y);
    return 0;
}

//------------------------------------------------------------
void Adresler ve void Göstericiler
C'de void türden bir değişken tanımlanamaz. Ancak gösterici tanımlanabilir. Örneğin:
void a; /* geçersiz! */
void *pv; /* geçerli */
void göstericiler türsüz göstericilerdir. void göstericiler * ya da [] operatörleriyle kullanılamazlar. Çünkü bu
operatörler eriştiği yerdeki nesnenin türünü bilmek zorundadır. void göstericiler ya da void adresler artırılamazlar
ve eksiltilemezler. Çünkü derleyici bu işlemlerde göstericinin sayısal bileşenini kaç artırıp kaç eksilteceğini
bilememektedir. Peki void göstericiler ne işe yarar?
void bir göstericiye herhangi türden bir adres doğrudan atanabilir. Tür dönüştürme operatörüne hiç gerek yoktur.
void *pv;
char s[10];
int a[10];
pv = s; /* geçerli */
pv = a; /* geçerli */
Benzer biçimde void bir adres de herhangi bir türden göstericiye atanabilir. Örneğin:
void *pv;
int *pi;
char s[10];
pv = s; /* geçerli */
...
pi = pv; /* geçerli */
/*------------------------------------------------------------------------------------------
void pointerlarla pointer aritmetiği yapılamaz çünkü adresin ne kadar artacağı belirsizdir.
------------------------------------------------------------------------------------------*/
#include <stdio.h>

int main(void)
{
    int a[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    void*vp=a;
    v++;
    return 0;
}
/*------------------------------------------------------------------------------------------
void pointerlar dereferencing operatörünün operandı yapılamazlar çünkü bunlar birer incomplete
typetır. Ancak void pointerların adresleri ve kendileri ekrana yazdırılabilir.
------------------------------------------------------------------------------------------*/
#include <stdio.h>

int main(void)
{
    int a[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    void*vp=a;
    printf("%d",*vp);//error
    vp++;
    printf("%p\n",vp);//legal
    printf("%p",&vp);
    return 0;
}

/*------------------------------------------------------------------------------------------
void göstericilere neden gereksinim duyulduğunu açıklayabilmek için memcpy fonksiyonu iyi bir örnek olabilir.
memcpy fonksiyonu bir adresten bir adrese koşulsuz n byte kopyalamaktadır. Bu fonksiyon strcpy fonksiyonunu
andırmakla birlikte ondan farklıdır. memcpy null karaktere bakmaz. Koşulsuz n byte kopyalar. Örneğin herhangi
bir türden diziye aynı türden başka bir diziye memcpy ile kopyalayabiliriz. C'de başı memxxx biçiminde başlayan
fonksiyonların prototipleri de <string.h> içerisindedir.
------------------------------------------------------------------------------------------*/
#include <stdio.h>
#include <string.h>
int main(void)
{
    int a[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    int b[10];
    int i;
    memcpy(b, a, 10 * sizeof(int));
    for (i = 0; i < 10; ++i)
        printf("%d ", b[i]);
    printf("\n");
    return 0;
}
Biz memcpy fonksiyonuyla herhangi türden iki diziyi kopyalayabiliriz:
#include <stdio.h>
#include <string.h>
int main(void)
{
double a[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
double b[10];
int i;
memcpy(b, a, 10 * sizeof(double));
for (i = 0; i < 10; ++i)
printf("%f ", b[i]);
printf("\n");
return 0;
}
/*----------------------------------------------------------------------------------
Yukarıdaki örneklerde anlatılmak istenen aslında void pointerın fonksiyonun generic
yani tür bağımsız halde yazabilmemizi sağlamaktadır. dinamik bellek yönetiminde ele
alıcağımız malloc,calloc ve realloc gibi fonksiyonlarda void* türünden
faydalanmaktadır.
--------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------
İşte memcpy gibi bir fonksiyonun bizden her türlü adresi kabul edebilmesi için onun parametrelerinin void
gösterici olması gerekir. Gerçekten de memcpy fonksiyonunun prototipi şöyledir:
void *memcpy(void *dest, void *source, unsigned n);
Fonksiyon ikinci parametresiyle belirtilen adresten başlayarak birinci parametresiyle belirtilen adrese koşulsuz n
byte kopyalar. Birinci parametresiyle belirtilen adresin aynısına geri döner.
Peki biz memcpy gibi bir fonksiyonu nasıl yazabiliriz? void göstericiler artırılıp azaltılamadığına göre onların türü
belirli bir göstericiye atanması gerekir.
---------------------------------------------------------------------------*/
#include <stdio.h>
#include <string.h>
void *mymemcpy(void *dest, void *source, unsigned n)
{
    char *pcdest = dest;
    char *pcsource = source;
    while (n-- > 0)
        *pcdest++ = *pcsource++;
    return dest;
}
int main(void)
{
    double a[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    double b[10];
    int i;
    mymemcpy(b, a, 10 * sizeof(double));
    for (i = 0; i < 10; ++i)
        printf("%f ", b[i]);
    printf("\n");
    return 0;
}
/*---------------------------------------------
memcpy fonksiyonuyla yazı kopyalaması da yapabiliriz. Örneğin:
strcpy(d, s);
ile
memcpy(d, s, strlen(s) + 1);
işlevsel olarak eşdeğerdir.
---------------------------------------------*/
#include <stdio.h>
#include <string.h>
int main(void)
{
    char s[30] = "ankara";
    char d[30];
    strcpy(d, s);
    memcpy(d, s, strlen(s) + 1);
    return 0;
}
/*----------------------------------------------------------------------------------
memset isimli fonksiyon bir adresten başlayarak koşulsuz n byte'a belli bir değeri atar. Yani n tane byte'ı belli bir
değerle doldurur. Örneğin:
---------------------------------------------------------------------------*/
#include <stdio.h>
#include <string.h>
int main(void)
{
    int a[10];
    int i;
    memset(a, 0, 10 * sizeof(int));
    for (i = 0; i < 10; ++i)
        printf("%d ", a[i]);
    printf("\n");
    return 0;
}
Örneğin:
#include <stdio.h>
#include <string.h>
int main(void)
{
    char s[200];
    memset(s, 'a', 199);
    s[199] = '\0';
    printf("%s\n", s);
    return 0;
}
/*----------------------------------------------------------------------------------
memset fonksiyonunun prototipi şöyledir:
void *memset(void *dest, int val, unsigned n);
Fonksiyonun birinci parametresi doldurulacak yerin adresini, ikinci parametresi doldurulacak değeri ve üçüncü
parametresi kaç adet değerin doldurulacağını belirtir. memset fonksiyonunu şöyle yazabiliriz:
---------------------------------------------------------------------------*/
#include <stdio.h>
#include <string.h>
void *mymemset(void *dest, int val, unsigned n)
{
    unsigned char *pcdest = dest;
    while (n-- > 0)
        *pcdest++ = val;
    return dest;
}
int main(void)
{
    char s[200];
    mymemset(s, 'a', 199);
    s[199] = '\0';
    printf("%s\n", s);
    return 0;
}
/*----------------------------------------------------------------------------------
memset fonksiyonunun strset isimli bir kardeşi vardır. strset char türden bir diziyi null
karakter görene kadar belli bir karakterle doldurur:
char *strset(char *dest, char ch);
Aşadıdaki örnekte olduğu gibi
 ---------------------------------------------------------------------------*/
#include <stdio.h>
#include <string.h>
int main(void)
{
    char s[] = "ankara";
    strset(s, 'x');
    puts(s);
    return 0;
}
//--------------------------------------------------------------------------
Function Pointers(fonksiyon göstericileri)
Genel Biçimi:
<geri dönüş değer türü>(<asteriks atomu> <fonksiyon göstericisi ismi>) (<parametre değişkenleri>)
Not:Fonksiyon göstericisinin geri dönüş değer türü ve parametre değişkenlerinin
sayısı ve türü aynı olmalıdır aksi durumda warning oluşur. Bu error olmasa da
asla tavsiye edilmez.
/*--------------------------------------------------------------------------
func bir fonksiyon olmak üzere aşağıdaki gibi iki değişik fonksiyon
göstericisi bildirimi yapılabilir.
--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------
Aşağıdaki şekilde bir syntax ile fp ile f1 in çağrılması mümkün ayrıca
*fp ye f1 ve f1 in adresinin(&f1) atanması aynı anlama gelmektedir.
--------------------------------------------------------------------------*/
#include <stdio.h>

void f1(int a){

    printf("f1 cagrildi\n%d",a);

}

int main(){

    void (*fp)(int)=f1;
    fp(10);
    return 0;

}
/*------------------------------------------------------------------------------
func'ın adresinin fp ye atanması sonucu fp func fonksiyonunu çağırabilir.
--------------------------------------------------------------------------*/

#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

void func(int*x){

    *x=(*x)*(*x);

}

int main() {

    int x=10;
    void (*fp)(int*);
    fp=&func;
    fp(&x);
    printf("%d",x);
}

/*------------------------------------------------------------------------------
Aşağıdaki örnekte foo fonksiyonunun hangi fonksiyonu çağıracağına onu çağıran fonksiyon
karar vermektedir çünkü fonksiyonun argümandan parametreye aktarımı  söz konusudur.
----------------------------------------------------------------------------*/
#define _CRT_SECURE_NO_WARNINGS

#include "berke.h"
#include <stdio.h>
#include <string.h>
#include <ctype.h>


void f1(void){
    printf("f1 cagrildi.");

}
void f2(void){

    printf("f2 cagrildi.");
}
void f3(void){

    printf("f3 cagrildi.");

}
void foo(void(*fp) (void)){

    printf("foo!\n");
    fp();

}


int main() {
    foo(&f2);
}

/*------------------------------------------------------------------------------
Aşağıdaki örnekte fp'nin 3 defa çağrılması ilk görünüşte çok mantıklı gelmese de
 her çağrıda farklı bir fonksiyon çağrısı söz konusudur. Bu da fonksiyon
 göstericilerinin adres değişikliği ile göstericinin birden çok fonksiyonu
 aynı syntax ile çağırmasına olanak sağlamaktadır.
----------------------------------------------------------------------------*/

#define _CRT_SECURE_NO_WARNINGS

#include "berke.h"
#include <stdio.h>
#include <string.h>
#include <ctype.h>

typedef void (*FPTR) (void);

void f1(void){
    printf("f1 cagrildi.\n");

}
void f2(void){

    printf("f2 cagrildi.\n");
}
void f3(void){

    printf("f3 cagrildi.\n");

}

int main() {

    FPTR fp=&f1;
    fp();
    fp=&f2;
    fp();
    fp=&f3;
    fp();


}
/*------------------------------------------------------------------------------
Standart qsort() fonksiyonu:
Standart kütüphanelerden stdlib.h da bulunan qsort fonksiyonu
dizileri tür bağımsız(generic) şekilde gönderilen fonksiyon
adresine bağlı sıralayan bir fonksiyondur.
aslında qsort Quick Sort algoritmasından gelmektedir ve bu algoritma
O n log n karmaşıklığına sahip olduğundan dolayı Bubble sort(O n^2  karmaşıklığı)
algoritmasına göre daha verimli çalışmaktadır.
Standart qsort fonksiyonu 4 adet parametre değişkenine sahip bir standart fonksiyondur.
qsort algoritmasına gönderilmesi istenen argümanlar:
qsort(<dizinin ilk elemanının adresi veya kendisi>,<dizinin uzunluğu>,<dizinin bir elemanının size of u>,<dizinin sıralama kriterini belirleyen fonksiyonun adresi>)
--------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------
int türden değerlere sahip bir dizinin büyükten küçüğe aşağıdaki qsort çağrısına göre
yapılabilir.
--------------------------------------------------------------------------*/
#define _CRT_SECURE_NO_WARNINGS

#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#define randomize() srand(time(NULL));

void displayArray(const int *a, int size) {

    for (int i = 0; i < size; ++i)
        printf("%d ", *(a + i));

}

void setRandomArray(int *a, int size) {
    randomize();
    for (int i = 0; i < size; ++i)
        a[i] = rand() % 100 + 1;

}

int cmp(void*vp1,void*vp2){

    int*p1=vp1;
    int*p2=vp2;
    if(*p1>*p2)
        return 1;
    if (*p1<*p2)
        return -1;
    return 0;

}

int main() {

    int size;
    printf("Kac elemanli bir dizi yaratilsin?");
    scanf("%d",&size);
    int*arr=(int*)malloc(size* sizeof(int));
    setRandomArray(arr,size);
    displayArray(arr,size);
    printf("\n");
    qsort(arr,size, sizeof(int),&cmp);
    displayArray(arr,size);
    free(arr);

}

/*------------------------------------------------------------------------------
Function Pointer Arrays(Fonksiyon gösterici dizileri)

<geri dönüş değer türü>(<asteriks atomu><değişken ismi>[<eleman sayısı>])(<parametre değişkenleri>);

--------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------
Bir fonksiyon dizisinin tanımlanması için bir örnek
--------------------------------------------------------------------------*/
#define _CRT_SECURE_NO_WARNINGS

#include "berke.h"
#include <stdio.h>
#include <string.h>
#include <ctype.h>

char*f1(const char*,const char*);
char*f2(const char*,const char*);
char*f3(const char*,const char*);

int main() {

     char*(*fp[3])(const char *,const char *)={&f1,&f2,&f3};

}
/*------------------------------------------------------------------------------
Bir fonksiyon dizisinin herhangi bir elemanının dizinin geri dönüş değer türünden
farklı olması anlamlı değildir. Bu syntax hatası olmasa dahi asla yazılmaması
gereken bir koddur.Aynı durum parametre değişkenlerinin farklı olması veya
sayısının fazla olması durumunda da geçerlidir.
--------------------------------------------------------------------------*/
#define _CRT_SECURE_NO_WARNINGS



char*f1(const char*,const char*);
char*f2(const char*,const char*);
double*f3(const char*,const char*);

int main() {

    char*(*fp[3])(const char *,const char *)={&f1,&f2,&f3};


}
/*------------------------------------------------------------------------------
Aşağıdaki kod typedef bildirimi ile fonksiyon gösterici dizilerin nasıl kolay
yoldan tanımlanabileceğini gösteren önemli bir örnektir. typedef konusunda da
belirttiğimiz gibi typedef bildirimleri fonksiyon göstericilerinde ve
fonksiyon gösterici dizilerinde çok önemli bir yere sahiptir.
--------------------------------------------------------------------------*/
#define _CRT_SECURE_NO_WARNINGS

#include "berke.h"
#include <stdio.h>
#include <string.h>
#include <ctype.h>

typedef char* (*FPTR) (const char*,const char*);

char*f1(const char*,const char*);
char*f2(const char*,const char*);
char*f3(const char*,const char*);

int main() {

     FPTR fp[3]={&f1,&f2,&f3};
     FPTR fp1=f1;


}

/*------------------------------------------------------------------------------
ctype standart kütüphanesinin bazı fonksiyonların getchar fonksiyonu ile alınan
bir karaktere göre for döngüsü ile fonksiyon gösterici dizisini dolaşmasını anlatan
güzel bir örnek
--------------------------------------------------------------------------*/
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h>
#define asize(a) sizeof(a)/sizeof(a[0])

typedef int (*FPTR) (int);

int main() {

    FPTR fp[]={&islower,&isupper,&isalpha,&isdigit,&isalnum,&isxdigit,
               &isspace,&isblank,&iscntrl,&isgraph,&ispunct};

    const char *p[]={"islower","isupper","isalpha","isdigit","isalnum","isxdigit",
                     "isspace","isblank","iscntrl","isgraph","ispunct"};


    int ch;
    printf("Bir karakter giriniz?");
    ch=getchar();

    for (int i=0;i<asize(fp);++i){

        if(fp[i](ch))
            printf("%s test icin Ok ",p[i]);
        else
            printf("%s testi icin not Ok ",p[i]);
    }
}
//------------------------------------------------------------------------------
/*------------------------------------------------------------------------------
Storage class specifiers(Yer belirleyiciler)
1-)auto
2-)static
3-)register
4-)extern
5-)typedef

Type Qualifiers(Tür Belirleyiciler)
1-)const
2-)volatile
----------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------
auto anahtar sözcüğü:otomatik ömürlü nesneleri göstermek için kullanılan bir
anahtar sözcüktür ancak günümüzdeki C standartlarında nerdeyse hiç kullanılmamaktadır.
bunun sebebi yerel değişkenlerin defaultta zaten otomatik ömürlü olması global değişkenlerin
otomatik ömürlü olamayışı ve parametre değişkenlerinin otomatik ömürlü olmaktan
başka seçeneğinin bulunmayışı gibi durumlar sebep gösterilebilir.
Not:Global değişkenler auto anahtar sözcüğü ile kullanılamaz bunun neden
global değişkenlerin static ömürlü olmasından kaynaklanır.
Anahtar Notlar: auto anahtar sözcüğü C++ dilinde C dilinin yanı sıra C++11
güncellemesiyle birlikte bu anahtar sözcüğe artık farklı anlamlar yüklenmeye
başladı. Bu anahtar sözcük artık auto type deduction olarak adlandırılmaya
başladı.
--------------------------------------------------------------------------*/
#include <stdio.h>

auto int a=10;//error

int main(void){

    //kod
    auto int b=20;//normal kullanım

    return 0;
}


/*------------------------------------------------------------------------------
static keyword(static anahtar sözcüğü):static anahtar sözcüğü ile bildirilen
değişkenler static ömürlü fonksiyon içinde belirtilse dahi fonksiyon bitince
yok edilmezler ve runtime a kadar hayatta kalırlar.
Aşağıdaki örnekte static anahtar sözcüğünün ne işe yaradığı anlatılmak istemiştir.
--------------------------------------------------------------------------*/
//Normal şekilde belirtilmiş bir değişken
#include <stdio.h>
int main()
{
 printf("%d",func());
printf("\n%d",func());
 return 0;
}
int func()
{
    int count=0; // variable initialization
    count++; // incrementing counter variable
   return count;
   }
//static anahtar sözcüğü ile belirtilmiş bir değişken
#include <stdio.h>
int main()
{
   printf("%d",func());
   printf("\n%d",func());

    return 0;
}
int func()
{
    static int count=0;
    count++;
    return count;
}
/*------------------------------------------------------------------------------
register anahtar sözcüğü:register anahtar sözcüğü C'de gene auto gibi çok kullanımdan
düşmüş bir anahtar sözcüktür. Ancak bazı eski sistemlerde kod yazıyorsanız gene
kullanılabilir ancak günümüz derleyicileri oldukça gelişmiş olduğundan bu anahtar
sözcüktür. Bu anahtar sözcüğün görevi kısaca bir değeri bellek yani RAM yerine
CPU da tutması için talimat verir. Günümüz derleyicileri oldukça gelişmiş olduğundan
dolayı artık derleyiciler buna kullanıcının karar veremeyecek durumda olduğunu
söyler kullanımdan düşmesinin asıl nedeni de aslında budur.
--------------------------------------------------------------------------*/
#include <stdio.h>
int main() {
   register char x = 'S';
   register int a = 10;
   auto int b = 8;
   printf("The value of register variable b : %c\n",x);
   printf("The sum of auto and register variable : %d",(a+b));
   return 0;
}


/*------------------------------------------------------------------------------
extern anahtar sözcüğü:extern kod yazarken sıkça kullanılan bir anahtar
sözcüktür. Bu anahtar sözcük aslında bize bir dosyada bir yerlerle örneğin
x diye bir değişken var o değişkeni bul ve o dosyada kullanılır hale getir
demektir. Eğer o değişken bulunamazsa elbette kullanılamaz.
Not:Bir değişkenin extern ile yazılması bir bildirim gibi düşünülmemelidir.
Bunun en büyük kanıtı extern ile tanımlanan bir değişkene ilk değer verilememesidir.
----------------------------------------------------------------------------*/
#include <stdio.h>

extern int z;

int main() {

    printf("%d",z*z*z);
    return 0;
}
//main.c başka bir modüldeki z değişkenini istediği gibi kullanabilir ancak
//linkage olarak uygun olduğu sürece

int z=10;// Başka bir modüldeki z değişkeni

/*------------------------------------------------------------------------------
Linkage type(Bağlama Tipleri)
1-)External linkage(dışsal bağlama):Dışsal bağlamaya sahip değişkenler
başka dosyalardan erişime açıktır. Tüm değişkenler default olarak External
Linkage'a sahiptir.
2-)İnternal Linkage(İçsel Bağlama):İçsel bağlama ile belirtilen değişkenler ancak
bulunduğu dosya içinde kullanılabilen değişkenlerdir. Bir değişkenin içsel
bağlamaya sahip olabilmesi için başına static anahtar sözcüğü konulmalıdır.
bu durum Javadaki private a benzetilebilir.
3-)No Linkage(Bağlamasız Durum):C'de yerel değişkenlerin ve parametre değişkenlerinin
bağlaması yoktur. Kısacası bir değişkenin bir bağlamaya sahip olabilmesi için
o değişkenin static ömürlü olması gerekir.Otomatik ömürlü nesneler için Bağlama
durumu geçersizdir.
----------------------------------------------------------------------------*/
#include <stdio.h>

extern int z;

int main() {

    printf("%d",z*z*z);
    return 0;
}
//main.c başka bir modüldeki z değişkenini istediği gibi kullanabilir ancak
//linkage olarak uygun olduğu sürece

static int z=10;// Başka bir modüldeki z değişkeni
//Yukarıdaki kod geçersizdir çünkü static anahtar sözcüğü ile belirtilen
//bir değişken internal linkage a sahiptir.Bu yüzden başka bir modülde kullanılamaz.
/*------------------------------------------------------------------------------
typedef bildirimi:typedef bildirimi kodlarımızda sıkça karşımıza çıkmaktadır.
Fonksiyon göstericileri konusunda da bize çok yarıycak kolaylıklar
sağlamaktadır. Aynı durum structurelar konusu için de geçerlidir.
Peki ne işe yarıyor bu typedef?
kısacası kullanıcının kendi için yeni bir tür üretmesi gibi
düşünülebilir. Örneğin int türü yerine saniye yazısını kullanmak isteyebilirsiniz
bu durumda typedef bildirimi kullanılabilir ÖRN:

typedef int Second;
Bu durumda artık Second yazmak int yazmakla eşdeğer hale getirilmiş olur.
int current_speed;
int high_score;

void congratulate(int your_score) {
    if (your_score > high_score) {
        // ...
    }
}
Örneğin yukardaki kod typedef bildirimleri ile şu şekilde de
yazılabilir:
typedef int km_per_hour;
typedef int points;

// `km_per_hour` is synonymous with `int` here, and thus, the compiler treats
// our new variables as integers.
km_per_hour current_speed;
points high_score;

void congratulate(points your_score) {
    if (your_score > high_score) {
        // ...
    }
}
Bu kodu okunabilirlik algılanabilirlik açısından daha güzel bir hale getirir.
Aşağıdaki örnekte C'de String sınıfı olmamasına rağmen Java gibi bir yazım
izlemek isteyenler için typedef bildirimiyle String char* türü yerine kullanılabilir.
--------------------------------------------------------------------------*/
#include <stdio.h>

typedef char* String;

int main() {

    String str="Ankara";
    printf("%s",str);
}
/*------------------------------------------------------------------------------
typedef konusunu yapılar ve fonksiyon göstericileri konularında tekrardan görücez.
type qualifiers(Tür belirleyiciler):
->const
->volatile
--------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------
const anahtar sözcüğü:const anahtar sözcüğü Javadaki final anahtar sözcüğüne benzetilebilir
const ile bildirilen bir değişkenin değiştirilmesi syntax hatasıdır.
const ile belirtilen bir değişken daima ilk verildiği değeri korumalıdır.
--------------------------------------------------------------------------*/
#include <stdio.h>

int main() {

    const int a=20;
    a=30;//error
}
/*------------------------------------------------------------------------------
Dizilerin const olma durumu:
const ile tanımlanan bir dizinin hiçbir elemanı değiştirilemez değiştirme
girişimi errore sebep olur.
----------------------------------------------------------------------------*/
#include <stdio.h>

int main() {

    const int a[]={2,4,6,8};
    a[0]=10;//error
    a[1]=20;//error
    a[2]=90;//error
    a[3]=38;//error
}
/*------------------------------------------------------------------------------
Pointerların const olma durumu:
Pointerlarda const anahtar sözcüğü birden fazla şekilde kullanılabilir ve
anlamlar const anahtar sözcüğünün yerine göre değişiklik göstermektedir.
const int*p1=&a;
ile
int * const p2=&b;
aynı anlama gelmez.
Örneğin aşağıdaki durumda ptr const değildir. Const olan *ptr dir.
O sebepten ptr'nin arttırması legaldir ancak *ptr'nin arttırılması  syntax
hatasına sebep olur.
--------------------------------------------------------------------------*/
#include <stdio.h>

int main() {

    int a[]={2,4,6,8};
    const int*ptr=a;
    ptr++;//legal
    (*ptr)++;//illegal
}
/*------------------------------------------------------------------------------
Aşağıdaki örnekte ise const olan ptrdir ve onu değiştirme girişimi syntax hatasıdır.
Ancak *ptr'nin değiştirilmesi gayet normal bir durumdur.
--------------------------------------------------------------------------*/
#include <stdio.h>

int main() {

    int a[]={2,4,6,8};
    int* const ptr=a;
    ptr++;//illegal
    (*ptr)++;//legal
}
/*------------------------------------------------------------------------------
Aşağıdaki örnekte hem ptr hem de *ptr değiştirilemez çünkü ikisi de const durumundadır.
Değiştirme girişi errore sebep olur.
----------------------------------------------------------------------------*/
#include <stdio.h>

int main() {

    int a[]={2,4,6,8};
    const int* const ptr=a;
    ptr++;//illegal
    (*ptr)++;//legal
}
/*------------------------------------------------------------------------------
Not:Fonsiyonların const olması gibi bir durum söz konusu değildir. Bu syntax
hatası olmasa da constun bir fonksiyonla kullanımı anlamlı değildir.
----------------------------------------------------------------------------*/

const int main() {//legal

    int a[]={2,4,6,8};
    int*ptr=a;
    ptr++;
    (*ptr)++;
}
/*------------------------------------------------------------------------------
String literallerini tutarken char* türünü kullanıyorsak mutlaka
başına const anahtar sözcüğünü eklemeliyiz. Bu okunabilirliği arttırır çünkü
artık herhangi karakter değişimi syntax hatasına sebep olur.
string.h başlık dosyasının standart fonksiyonlarının kendisine gönderilen
string ifadelerinde değişiklik yapmayanlarında const char* her zaman kullanılmıştır.
eğer bir fonksiyona gönderilen bir string literalinde herhangi değişiklik
yapılmayacaksa o parametre değişkeninin her daim const char* yapılması okunabilirlik
açısından oldukça gereklidir.
--------------------------------------------------------------------------*/

int main() {

    const char*str="Ankara";
    str[1]='k';//error
}
/*------------------------------------------------------------------------------
Aşağıdaki mystrlen fonksiyonunda da bu geçerlidir. Çünkü fonksiyon içinde gönderilen
stringte herhangi bir değişiklik söz konusu değildir.Ancak sorting yani sıralama
algoritmalarında parametre değişkeni olan dizi const yapılmaz çünkü dizide bir değişim
söz konusudur.
--------------------------------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#define SIZE 100

int mystrlen(const char*str){

    int len=0;

    while (str[len]!='\0'){

     len++;


    }
    return len;

}



int main() {

    char*str=(char*)malloc(20*sizeof(char));
    gets_s(str,20);
    printf("%d",mystrlen(str));
    free(str);
}
/*------------------------------------------------------------------------------
Volatile anahtar sözcüğü:Volatile anahtar sözcüğü alt seviyede kod yazarken
çok kullanılmasa da üst seviyede sıkça kullanılmaktadır. Genel olarak
kodun çalışma zamanında istemsiz değişmesi mümkün olan değişkenlerin
güven altına alınmasını sağlar. Bir değişkenin bu anahtar sözcükle bildirimi
onun değerinin sürekli RAM'den alınmak üzere bir talimat niteliğindedir.
Örneğin bir döngüdeyken değerin istemsiz değişimine karşı kullanılabilir.
----------------------------------------------------------------------------*/
#include <stdio.h>

int main(void)
{
    const int local = 10;
    int *ptr = (int*) &local;

    printf("Initial value of local : %d \n", local);//10

    *ptr = 100;

    printf("Modified value of local: %d \n", local);//10

    return 0;
}
/*------------------------------------------------------------------------------
Yukarıdaki örnekte volatile anahtar sözcüğü kullanılmalıdır çünkü kullanılmaması
durumu değer değişikliği yan etkisini sebep olmaz öyle aşağıdaki gibi yazılsa
değer RAM'den alındığı için ekran çıktısı ikinci printf te 100 olacaktır.
--------------------------------------------------------------------------*/
#include <stdio.h>

int main(void)
{
    const volatile int local = 10;
    int *ptr = (int*) &local;

    printf("Initial value of local : %d \n", local);//10

    *ptr = 100;

    printf("Modified value of local: %d \n", local);//100

    return 0;
}
//--------------------------------------------------------------------------
User defined Types(Kullanıcıların oluşturduğu türler)
C'de kullanıcıların oluşturabileceği 3 farklı tür vardır bunlar syntax olarak
birbirlerine benzemektedir. Bu türler:
1-)Structures(Yapılar)

2-)Unions(Birlikler)

3-)Enums(numaralandırma)

1-) Yapılar (Structures)
Elemanları bellekte ardışıl biçimde tutulan fakat
farklı türlerden olabilen veri yapılarına "yapı (structure)" denilmektedir.Dizi ile yapılar birbilerine
çok benzerler.Her ikisinde de elemanları ardışıl olarak bellekte tutulmaktadır.
Fakat dizi elemanları aynı türden olduğu halde yapı elemanları farklı
türlerinden olabilmektedir. Yapılarla çalışırken önce yapıların
bir şablonu bildirilir. Buna "yapı bildirimi" denir.
Yapı bildirimi bellekte yer kaplamaz. Yani tanımlama değildir.
Yapı bildirimini gören derleyici yapı elemanlarının
türlerini ve isimlerini öğrenir.
Daha sonra bu yapı türünden gerçek nesneler tanımlanır.
Yapı bildiriminin genel biçimi şöyledir:
struct
<isim> {
<
eleman bildirimleri
>
};
Örneğin:
struct DATE {
    int day, month, year;
};
struct COMPLEX {
    double real;
    double imag;
};
struct SAMPLE {
    int a;
    long b;
    double c;
};
Not yapı bildirimleri kolaylık açısından genellikle typedef bildirimi ile
birlikte kullanılmaktadır.Örneğin yukarıdaki örnekler typedef ile tanımlanırsa:
typedef struct {
    int day, month, year;
}DATE;
typedef struct {
    double real;
    double imag;
}COMPLEX;
typedef struct {
    int a;
    long b;
    double c;
}SAMPLE;
Yapı isimlerini bazı programcılar büyük harflerle bazıları küçük harflerle harflendirmektedir.
Biz kurusumuzda yapı isimlerini büyük harflerle harflendireceğiz.
Yapı bildirimi ile derleyici yapı elemanlarının isimlerini ve türlerini öğrenir.
Yapı bildirimleri yerel ya da global düzeyde yapılabilir.
Eğer yapı bildirimi yerel düzeyde yapılmışsa o yapı
ismi ancak o blokta kullanılabilir.
Global olarak yapılmışsa her yerde kullanılabilir.
Yapı bildirimleri genellikle global düzeyde yapılmaktadır.
Çünkü çoğu kez yapıların farklı fonksiyonlarda kullanılması gerekmektedir.
Her yapı bildirimi aynı zamanda bir tür de belirtmektedir.
Yani bir yapı bildirimi ile biz bir tür de oluşturmuş oluruz.
Yapı bildirimleriyle oluşturulan türler struct anahtar sözcüğü ve yapı
ismiyle ifade edilir. Örneğin struct DATE gibi,
struct SAMPLE gibi olur.Yapı bildirimi yapıldıktan sonra artık o
yapı türünden nesneler tanımlanır.Örneğin:
struct DATE d;
struct SAMPLE s;
Burada d
"struct DATE" türünden,
s ise
"struct SAMPLE" türündendir.
Yapılar bileşik
nesnelerdir.
Yani parçalardan
oluşmaktadır. Örneğin:
struct SAMPLE {
    int a;
    long b;
    double c;
};
struct SAMPLE s;
Burada s
a, b,
ve c
parçalarından oluşan nesnein bütününü temsil eder.
Yapı nesneleri genellikle bütünsel olarak kullanılmaz.
Onların parçaalarına erişilip parçaları kullanılır.
Yapı elemanlarına erişmek için nokta operatörü kullanılmaktadır.
Nokta operatörü iki operandlı araek bir operatördür.
Nokta operatörünün sol tarafındaki operand yapı
nesnesinin bütünü, sağ taraftaki operand
onun bir elemanı olmak zorundadır.
Bu operatör sol taraftaki yapının sağ
taraftaki elemanına erişmekte kullanılır.
Örneğin:
----------------------------------------------------------------------*/
#include <stdio.h>

struct SAMPLE {
    int a;
    long b;
    double c;
};

int main(void) {
    struct SAMPLE s;
    s.a = 10;
    s.b = 20;
    s.c = 12.4;
    printf("%d, %ld, %f\n", s.a, s.b, s.c);
    return 0;
}
/*------------------------------------------------------------------------
Burada s nesnesi struct SAMPLE türündendir. s.a ifadesi int türdendir. s.a ifadesi
"s nesnesinin a parçası" anlamına gelir. s.b ifadesi
long türden, s.c ifadesi ise double türdendir.
C standartlarına göre yapı bildiriminde ilk
yazılan eleman düşük adreste bulunacak biçimde eleman ardışıllığı oluşturulur.
Yani örneğimizde s'in a parçası en düşük adrestedir. Bunu b parçası izler onu da c parçası izler.
Nokta operatörü öncelik tablosunun en yüksek düzeyinde soldan sağa grupta bulunur.
&s.a gibi
bir ifadede s.a'nın adresi alınmaktadır. Çünkü nokta operatörü & operatöründen daha yüksek
önceliklidir.
----------------------------------------------------------------------------------*/
#include <stdio.h>

typedef struct  {
    int a;
    long b;
    double c;
}SAMPLE;

int main(void) {
    SAMPLE s;
    printf("%p, %p, %p\n", &s.a, &s.b, &s.c);
    return 0;
}
/*------------------------------------------------------------------
Anahtar Notlar:Anımsanacağı gibi Kernighan & Ritchie yazım
tarzında iki operandlı operatörlerle operandlar arasında
birer boşluk karakteri bırakılıyordu.
Fakat nokta ve -> operatörleri iki operandlı olmasına
karşın bunlarla operandlar arasında boşluk karakteri
bırakılmamaktadır. Bir yapı nesnesinin elemanlarına henüz değer
atanmadıysa içerisinde ne vardır? İşte eğer yapı nesnesi
yerelse onun tüm elemanlarında çöp değerler, global ise sıfır
değerleri bulunur. Bir yapı nesnesine küme parantezleri içerisinde
ilkdeğer verebiliriz. (Tıpkı dizilerde olduğu gibi) Örneğin:
------------------------------------------------------------------*/
#include <stdio.h>

typedef struct  {
    int a;
    long b;
    double c;
}SAMPLE;

int main(void) {
    struct SAMPLE s = {10, 20, 20.5};
    printf("%d, %ld, %f\n", s.a, s.b, s.c);
    return 0;
}
/*-------------------------------------------
Tıpkı dizilerde olduğu gibi yapının az sayıda elemanına ilkdeğer verebiliriz.
Bu durumda geri kalan elemanlar derleyici tarafından sıfırlanır.
Fakat yapının fazla sayıda elemanına ilkdeğer
vermeye çalışırsak derleme aşamasında error oluşur.
Aynı türden iki yapı nesnesi birbirlerine atanabilir.
Bu durumda yapının karşılıklı elemanları birbirlerine atanmaktadır.
------------------------------------------------*/
#include <stdio.h>

typedef struct  {
    int a;
    long b;
    double c;
}SAMPLE;

int main(void) {
    SAMPLE s = {10, 20, 30.5};
    SAMPLE k;
    k = s;
    printf("%d, %ld, %f\n", s.a, s.b, s.c);
    printf("%d, %ld, %f\n", k.a, k.b, k.c);
    return 0;
}
/*-----------------------------------------------------------
Atama işleminde yapıların türlerinin aynı olması gerekir.
Tür ise isme bağlıdır. İçi aynı olan farklı isimli yapıları
birbirlerine atayamayız. Yapı Elemanı Olarak Diziler Bir dizi
bir yapının elemanı olabilir. Bu durumda yapının dizi
elemnanına erişildiğinde bu ifade dizinin tamamını
temsil eder, ifade içerisinde kullanıldığında ise yapı
içerisindeki dizinin başlangıç adresini
belirtir.
-----------------------------------------------------------*/

#include <stdio.h>

typedef struct  {
    char name[32];
    int no;
}PERSON;

int main(void) {
    PERSON per;
    printf("Adi soyadi:");
    gets(per.name);
    printf("No:");
    scanf("%d", &per.no);
    printf("%s, %d\n", per.name, per.no);
    return 0;
}
/*----------------------------------------------
Böyle yapı nesnesine ilkdeğer de verebiliriz:
PERSON per = {"Berke Sertel", 123};
Tabi buradaki iki tırnak ifadesi adres anlamına gelmez.
Karakterlerin name dizisine kopyalanacağı anlamına gelir.
Nokta operatörüyle[] operatörünün aynı grupta soldan sağa öncelikli
olduğuna dikkat ediniz. Örneğin: per.name[3] ifadesi per.name dizisinin 3.indeksli elemanı
anlamına gelir. Yani:
per ------->struct PERSON türündendir
per.name ------->char *türündendir
per.name[3] ------>char türündendir
Örneğin:
----------------------------------------------------*/
#include <stdio.h>

typedef struct {
    char name[32];
    int no;
}PERSON;

int main(void) {
    struct PERSON per = {"Berke Sertel", 123};
    char ch;
    ch = per.name[3];
    putchar(ch);
    return 0;
}
/*--------------------------------------
Yapı Elemanı Olarak Göstericilerin Kullanılması
Bir yapının elemanı bir gösterici olabilir. Örneğin:
typedef struct {
    char *name;
    int no;
}PERSON;
PERSON per;
Burada name elemanı bir göstericidir ve bu göstericinin
tahsis edilmiş bir alanı gösteriyor olması gerekir.
----------------------------------------------------*/
#include <stdio.h>

typedef struct {
    char *name;
    int no;
}PERSON;

int main(void) {
    PERSON per;
    per.name = "Berke Sertel";
    per.no = 123;
    printf("%s, %d\n", per.name, per.no);
    return 0;
}
/*---------------------------------------
Yapı Türünden Adresler ve Göstericiler
Bir yapı nesnesinin adresi alınabilir.
Bu durumda elde edilen adresin sayısal bileşeni tüm
yapı nesnesinin bellekteki başlangıç adresi,
tür bileşeni ise po yapı türündendir.
Bir yapı nesnesinin adresi aynı türden bir yapı
göstericisine atanabilir.Örneğin:
typedef struct {
    int a;
    long b;
    double c;
}SAMPLE;
SAMPLE s;
SAMPLE *ps;
ps = &s;
Bir yapı göstericisi ya da bir yapı türünden
adres *operatörüyle kullanılırsa yapı nesnesinin tamamına erişilir.
Yani yukarıdaki örnekte *ps ile s aynıdır.
Burada ps struct SAMPLE *türünden *ps ise struct SAMPLE türündedir.
Yapı Göstericisi Yoluyla Yapı elemanlarına Erişilmesi
p bir yapı türünden adres a da bu yapının bir elemanı olmak
üzere bu adresin gösterdiği yerdeki yapı nesnesinin a elemanına erişmek
için (*p).a ifadesi kullanılır. *p.a ifadesi geçersizdir.
Çünkü nokta operatörü *operatöründen daha yüksek
öncelikli olduğu için bu ifadede önce p.a yapılmaya çalışılır ki
nokta operatörünün solundaki operand geçersiz olur.
Çünkü nokta operatörünün solundaki operand yapı
nesnesinin kendisi olmalıdır, adresi olmamalıdır. Örneğin:
------------------------------------------------------------------*/
#include <stdio.h>

typedef struct {
    int a;
    long b;
    double c;
}SAMPLE;

int main(void) {
    SAMPLE s;
    SAMPLE *ps;
    ps = &s;
    (*ps).a = 10;
    (*ps).b = 20;
    (*ps).c = 30;
    printf("%d, %ld, %f\n", (*ps).a, (*ps).b, (*ps).c);
    return 0;
}
/*-----------------------------------------------------------
Ok (Arrow) Operatörü
Ok operatörü -> karakterleriyle elde edilir.
Ok operatörü iki operandlı ara ek bir operatördür.
Ok operatörünün solundaki operand bir yapı
türünden adres, sağındaki operand o yapının bir
elemanı olmak zorundadır. On operatörü sol taraftaki
operandla belirtilen adresteki yapı nesnesinin sağ
taraftaki operandla belirtilen elemanına erişmekte kullanılır.
Yani: p->a ile (*p).a tamamen eşdeğerdir.
Nokta operatörüyle ok operatörünün her ikisi
de yapı elemanlarına erişmekte kullanılır.
Nokta operatörü nesnenin kendisiyle ok operatörü
adresiyle erişim sağlar. Ok operatörü öncelik tablosunun
en üst düzeyinde soldan sağa grupta bulunur:
1.  ( ) [ ] . ->             Soldan-Sağa
2.  + - ++ -- ! sizeof & *   Sağdan-Sola
3.  * / %                    Soldan-Sağa
4.  + -                      Soldan-Sağa
        ... ...
Örneğin:
------------------------------------------------------------*/
#include <stdio.h>

typedef struct {
    int a;
    long b;
    double c;
}SAMPLE;

int main(void) {
    SAMPLE s;
    SAMPLE *ps;
    ps = &s;
    ps->a = 10;
    ps->b = 20;
    ps->c = 30;
    printf("%d, %ld, %f\n", ps->a, ps->b, ps->c);
    return 0;
}

//Örneğin:

#include <stdio.h>

typedef struct {
    int x, y;
}POINT;

int main(void)
{
    POINT pt;
    POINT *ppt;
    ppt = &pt;
    ppt->x = 10;
    ppt->y = 20;
    printf("(%d, %d)\n", ppt->x, ppt->y);
    return 0;
}
/*-------------------------------------------------------
s bir yapı türünden nesne a da bu
yapının bir elemanı olmak üzere &s->a ifadesi geçersizdir.
Çünkü & operatörü ->operatöründen daha düşük önceliklidir.
Ancak (&s)->a ifadesi geçerlidir ve s.a ile eşdeğerdir.
p bir yapı türünden adres ve a da
bu yapının bir elemanı olmak üzere &p->a ifadesi
geçerlidir ve bu ifade p göstericisinin gösterdiği yerdeki
nesnenin a parçasının adresi anlamına gelir.
-----------------------------------------------------------*/

#include <stdio.h>

typedef struct  {
    char name[32];
    int no;
}PERSON;

int main(void) {
    PERSON per = {"Ecem Elif Güngör", 234};
    PERSON *pper;
    pper = &per;
    printf("%s, %d\n", pper->name, pper->no);
    printf("%c\n", pper->name[2]);
    return 0;
}
/*--------------------------------------------------------------------
Yapıların Fonksiyonlara Parametre Yoluyla Aktarılması Yapıların
fonksiyonlara aktarılmasında iki teknik kullanılır.
Bunlardan birincisi nesnenin kopyalama yoluyla
aktarılması tekniği, diğeri ise adres yoluyla aktarma tekniğidir.
Nesnenin kendisinin aktarılması genel olarak kötü bir tekniktir.
Adres yoluyla aktarma iyi bir tekniktir.Gerçekten de
C'de yapı nesneleri hemen her zaman fonksiyonlara adres yoluyla aktarılır.
2)Yapı Nesnelerinin Fonksiyonlara Kopyalama Yoluyla Aktarılması
Bu yöntemde fonksiyonun parametre değişkeni bir yapı türünden yapı nesnesidir.
Fonksiyon da aynı yapı türünden bir nesneyle çağrılır.
Aynı türden iki yapı nesnesi atanabildiğine göre bu çağırma geçerlidir.
Ancak burada aktarım kopyalama yoluyla yapılmaktadır.Örneğin:
--------------------------------------------------------------------------*/

#include <stdio.h>

typedef struct  {
    char name[32];
    int no;
}PERSON;

void foo(PERSON per) {
    printf("%s, %d\n", per.name, per.no);
}

int main(void) {
    PERSON x = {"Batuhan Menküer", 234};
    foo(x);
    return 0;
}
/*-------------------------------------------------
Bu yöntem genel olarak kötü bir tekniktir.
Çünkü büyük bir yapının bu yöntemde tüm elemanlarını
tek tek aktarım sırasında fonksiyona kopyalanır.
Üstelik bu yöntemde fonksiyon içerisinde artık
biz orijinal nesneye erişemeyiz .Tabi eğer yapı çok
küçükse bu teknik kötü bir teknik olmaz. Bu durumda kullanılabilir.
2)Yapı Nesnelerinin Fonksiyonlara Adres Yoluyla Aktarılması:
Bu yöntemde fonksiyonun parametre değişkeni yapı türünden gösterici olur.
Fonksiyon da aynı türden bir yapı nesnesinin adresiyle çağrılır.
Bu kullanılması gereken doğru tekniktir. Örneğin:
-------------------------------------------------*/
#include <stdio.h>

typedef struct {
    char name[32];
    int no;
}PERSON;

void foo(struct PERSON *per) {
    printf("%s, %d\n", per->name, per->no);
}

int main(void) {
    PERSON x = {"Erişcan Melih Kırsoy", 234};
    foo(&x);
    return 0;
}

Örneğin:

#include <stdio.h>

typedef struct  {
    int day;
    int month;
    int year;
}DATE;

void get_date(DATE *date) {
    printf("Gun:");
    scanf("%d", &date->day);
    printf("Ay:");
    scanf("%d", &date->month);
    printf("Yil:");
    scanf("%d", &date->year);
}

void disp_date(DATE *date) {
    printf("%02d/%02d/%04d\n", date->day, date->month, date->year);
}

int main(void) {
    DATE date;
    get_date(&date);
    disp_date(&date);
    return 0;
}

//Örneğin:

#include <stdio.h>

typedef struct {
    double real, imag;
}COMPLEX;

void get_comp(COMPLEX *comp) {
    printf("Gercek Kisim:");
    scanf("%lf", &comp->real);
    printf("Sanal Kisim:");
    scanf("%lf", &comp->imag);
}

void disp_comp(COMPLEX *comp) {
    printf("%.0f+%.0fi\n", comp->real, comp->imag);
}

int main(void) {
    COMPLEX z;
    get_comp(&z);
    disp_comp(&z);
    return 0;
}
/*----------------------------------------------------------------
Yapılara Neden Gereksinim Duyulmaktadır?
1)Yapılar olgular için mantıksal bir kapı oluşturmaktadır.
Yani tarih gibi, sanal sayılar gibi,şahıs bilgileri gibi
birbirleriyle ilgili çok sayıda nesne bir yapıyla
ifade edilirse daha kolay bir temsil yeteneği el edilir.
Gerçekten de mantıksal bakımdan birbirleriyle bağlantılı
nesnelerin yapılarla temsil edilmesi okunabilirliği ve anlaşılabilirliği artırmaktadır.

2)Bir fonksiyona çok sayıda parametre aktarılacaksa onların tek
tek aktarılmaları hem yazılımsal olarak zordur.
Hem anlaşılır olmaktan çıkar hem de yavaştır.
Bunun yerine çok sayıda parametre bir yapında toplanım tek bir parametre
biçiminde fonksiyona geçirilebilir.

3)Bir fonksiyonun tek bir geri dönüş değeri vardır.
Eğer fonksiyon dış dünyaya çok sayıda
değer iletecekse bu yapılarla sağlanabilir.
Örneğin iletilecek değerler bir yapıyla ifade edilir.
Fonksiyona yapı nesnesinin adresi geçirilir.
Fonksiyon da bu nesnenin içini doldurur.
Fonksiyonların Geri Dönüş Değerlerinin Yapı Olması Durumu
Bir fonksiyonun geri dönüş değeri bir yapı türünden olabilir.
Bu durumda return ifadesi de aynı türden bir yapı nesnesi olmalıdır.
Aslında bu yöntem de C'de çoğu kez (yani yapı büyükse) iyi teknik kabul edilmez.
Çünkü burada return işlemi sırasında geçici nesneye
bir kopyalama yapılmakta ve geri dönüş değerinin atanması sırasında da
aynı sorun oluşmaktadır. Örneğin:
----------------------------------------------------------------------------*/

#include <stdio.h>

typedef struct  {
    double real, imag;
}COMPLEX;

void disp_compI(COMPLEX *comp) {
    printf("%.0f+%.0fi\n", comp->real, comp->imag);
}

COMPLEX add_comp(COMPLEX *z1, COMPLEX *z2) {
    COMPLEX result;
    result.real = z1->real + z2->real;
    result.imag = z1->imag + z2->imag;
    return result;
}

int main(void) {
    struct COMPLEX z1 = {3, 2};
    struct COMPLEX z2 = {1, 4};
    struct COMPLEX result;
    result = add_comp(&z1, &z2);
    disp_comp(&result);
    return 0;
}
/*---------------------------------------------------------------
Genellikle programcılar çoklu bilgiyi böyle almaktansa bir nesne
verip fonksiyonun onun içerisine yerleştirme yapmasını tercih ederler.
---------------------------------------------------------------*/

#include <stdio.h>

typedef struct  {
    double real, imag;
}COMPLEX;

void disp_comp(COMPLEX *comp) {
    printf("%.0f+%.0fi\n", comp->real, comp->imag);
}

void add_comp(COMPLEX *z1,COMPLEX *z2,COMPLEX *result) {
    result->real = z1->real + z2->real;
    result->imag = z1->imag + z2->imag;
}

int main(void) {
    COMPLEX z1 = {3, 2};
    COMPLEX z2 = {1, 4};
    COMPLEX result;
    add_comp(&z1, &z2, &result);
    disp_comp(&result);
    return 0;
}
/*---------------------------------------------
Yapılarda Hizalama(Alignment Kavramı)

Modern 32 işlemcilerde bellek bağlantısı bir
hamlede 4 byte bilgiyi çekecek biçimde yapılmıştır. Benzer biçimde 64 bit işlemcilerde
de bellek bağlantısı bir hamlede 8 byte bilgiyi çekecek biçimde yapılmıştır.
Böylece örneğin 32 bit işlemciler aslında 32
adres yoluna değil 30 adres yoluna sahiptir.
Tabi makine komutları yine aynı biçimde
byte adreslemeli çalışmaktadır. Aşağıda 32 bit bir
işlemcinin bellek erişimi resmedilmiştir:
Bu sistemlerde eğer 4 byte'lık bir bilgi (örneğin int türden bir bilgi) 4' ün katlarında
değilse makina komutları göreli olarak daha yavaş çalışmaktadır.
Çünkü bu 4 byte'ı işlemci iki bus erişimiyle elde eder:
Tabi bir byte bir bilgiye kaçın katlarında olursa
olsun tek bus hareketiyle erişilebilmektedir. Peki 2 byte'lık bilgiler?
Bunların da 2'nin katlarında olması gerekir. Örneğin 2'nin
katlarında olmayan 2 byte'lık (örneğin short türden bir nesne)
bir nesne aşağıdaki gibi gösterilebilir: İşte derleyiciler işlemcilerin böyle
çalıştıklarını bildiği için makine komutları daha hızlı çalışsın
diye 4 byte'lık 200 nesneleri 4'ün katlarına, 8 byte'lık nesneleri 8' in katlarına,
2 byte'lık nesneleri 2' nin katlarına, 1 byte'lık nesneleri 1'in
katlarına yerleştirmektedir.Derleyiciler bunlara yerel değişkenler
için ve global değişkenler için dikkat ederler. Yapı elemanları
bellekte ardışıl olacağından ve ilk yazılan elemanın düşük adreste olması gerekeceğinden
bu hizalama (alignement) yapılar için nasıl gerçekleştirilecektir?
İşte derleyiciler yapı elemanlarının arasına boşluklar koyarak o
elemanların belli adres katlarında olmasını sağlayabilmektedir.Örneğin:
struct SAMPLE {
    char a;
    int b;
    char c;
    int d;
};
struct SAMPLE s;
32 bit bir işlemcide bu yapı nesnesinin bellekte 10
byte yer kaplayacağı düşünülebilir.Ancak derleyiciler a ile b arasına
ve c ile d arasına 3'er byte boşluk bırakarak int olan kısımların 4'ün
katlarına gelmesini sağlayabilmektedir. Böylece bu yapı nesnesinin
sizeof değerinin 16 çıkması programcıyı şaşırtmamalıdır.
Aşağıdaki örnekte olduğu gibi
--------------------------------------------------------*/
#include <stdio.h>

typedef struct  {
    char a;
    int b;
    char c;
    int d;
}SAMPLE;

int main(void) {
    SAMPLE s;
    printf("%u\n", sizeof(s)); /* 16 */
    return 0;
}
/*------------------------------------------
Peki yukarıdaki yapıyı aşağıdaki gibi düzenleseydik ne olurdu?
----------------------------------*/
#include <stdio.h>

struct SAMPLE {
    char a;
    char b;
    int c;
    int d;
};

int main(void) {
    struct SAMPLE s;
    printf("%u\n", sizeof(s)); /* 12 */
    return 0;
}
/*----------------------------------------------------------
Hizalama pek çok derleyicide derleyici seçeneklerinden
yönetilebilmektedir. Örneğin Microsoft C derleyicilerinde hizalama Proje ayarlarında C-C++/
Code Generation /Struct Member Alignment ile değiştirilebilmektedir.
Eğer hizalama 1 byte hizalama moduna çekilirse derleyici
yapı elemanlarını 1'in katlarına yerleştirmeye çalışır.
Dolayısıyla elemanlar arasında hiç boşluk bırakmaz.
C standartlarına hizalama kavramı bir kurala
bağlanmamıştır. Standartlarda yalnızca derleyicinin yapı
elemanları arasında boşluk bırakabileceği belirtilmiştir.
Peki derleyicinin yapı elemanları arasında boşluk
bırakabilmesi erişimde bir soruna yol açar mı? Yanıt hayır.
Çünkü derleyici nerelere boşluk bıraktığını bildiği için ona
göre erişimi yapmaktadır.Örneğin aşağıdaki yapı için
derleyici 4 byte hizalama kullanmış olsun:
------------------------------------------------------------------------*/
#include <stdio.h>

typedef struct  {
    char a;
    int b;
    char c;
    int d;
}SAMPLE;

int main(void) {

    printf("%d", sizeof(SAMPLE));
    return 0;
}
/*-----------------------------------------------------------
Şimdi p göstericisinin bu yapıyı gösterdiğini düşünelim. Artık derleyici
p->b ifadesiyle p adresinden 1 byte sonraya değil 4 byte sonraya erişir.
Çünkü araya boşluk bıraktığını zaten kendisi bilmektedir.
Yani yukarıdaki yapıyı biz şöyle düşünebiliriz:
typedef struct {
    char a;
    char temp1, temp2, temp3;
    int b;
    char c;
    char temp4, temp5, temp6;
    int d;
}SAMPLE;

Yapılar İçin: Dinamik Tahsisat Yapılması Mademki yapı elemanları bellekte ardışıl bir biçimde tutulmaktadır.
O halde yapı nesneleri için de heap'te dinamik tahsisatlar yapılabilir.
Dinamik tahsisat yaparken hizalama olasılığını göz önüne almak gerekir.
Bu nedenle yapının byte uzunluğunun sizeof operatörü ile elde edilmesi uygun olur.
sizeof operatörü derleyicinin o anda uyguladığı hizalamayı da hesaba katmaktadır.
-----------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>

typedef struct  {
    char name[32];
    int no;
}PERSON;

int main(void) {
    PERSON *per = (PERSON *) malloc(sizeof(PERSON));
    if (per == NULL) {
        printf("cannot allocate memory!..\n");
        exit(EXIT_FAILURE);
    }
    printf("Adi soyadi:");
    gets(per->name);
    printf("No:");
    scanf("%d", &per->no);
    printf("%s, %d\n", per->name, per->no);
    free(per);
    return 0;
}
/*-------------------------------------
Yapı Dizileri
Her elemanıbir yapı nesnesi olan dizilere yapı dizileri (arrayof structures) denilmektedir.
Yapı dizileri de normal dizilerde olduğu gibi bildirilir.Örneğin:
struct PERSON persons[3];
------------------------------------*/

#include <stdio.h>
#include <string.h>

typedef struct {
    char name[32];
    int no;
}PERSON;

int main(void) {
    PERSON persons[3];
    int i;
    strcpy(persons[0].name, "Burak Yilmaz");
    persons[0].no = 123;
    strcpy(persons[1].name, "Cenk Tosun");
    persons[1].no = 234;
    strcpy(persons[2].name, "Hakan Calhanoglu");
    persons[2].no = 678;
    for (i = 0; i < 3; ++i)
        printf("%s, %d\n", persons[i].name, persons[i].no);
    return 0;
}
/*--------------------------------------------------------
Anımsanacağı gibi dizi isimleri tüm diziyi temsil etmektedir.
Ancak bunlar işleme sokulduğunda
derleyici tarafından dizinin başlangıç adresine dönüştürülürler.
Yani biz dizi isimlerini kullandığımızda aslında o dizilerin başlangıç adreslerini kullanıyor
oluruz. Dizi isimleri kullanıldığında nesne belirtmezler. Biz bir yapı dizisinin
ismini aynı yapı türünden bir yapı göstericisine atayabiliriz.
----------------------------------------------------*/

#include <stdio.h>
#include <string.h>

typedef struct  {
    char name[32];
    int no;
}PERSON;

int main(void) {
    PERSON persons[3], *per;
    int i;
    strcpy(persons[0].name, "Burak Yilmaz");
    persons[0].no = 123;
    strcpy(persons[1].name, "Cenk Tosun");
    persons[1].no = 234;
    strcpy(persons[2].name, "Hakan Calhanoglu");
    persons[2].no = 678;
    per = persons;
    for (i = 0; i < 3; ++i) {
        printf("%s, %d\n", per->name, per->no);
        ++per;
    }
    return 0;
}
/*----------------------------------------------
Bir yapı göstericini bir artırdığımızda göstericinin
içerisindeki adres yapı uzunluğu kadar artmaktadır.
Yapı dizilerine de küme parantezleri ile ilkdeğer verilebilir.
Bu durumda eleman olan her yapı nesnesi için de ayrı bir küme
parantezi kullanılır.
---------------------------------------------------*/
struct PERSON persons[3] = {
        {"Kaya Sertel",   123},
        {"Batuhan Menkuer",    345},
        {"Erişcan Kırsoy", 654}
};
/*-----------------------------------------------
Aslında bu tür durumlarda, İçteki küme parantezleri zorunlu değildir.
Örneğin yukarıdaki ilk değer verme şöyle yapılabilirdi:
struct PERSON persons[3] = {
        "Kaya Sertel", 123, "Batuhan Menkuer", 345, "Erişcan Kırsoy", 654
};
Fakat bu biçimde ilkdeğer verme hem okunabilirliği azaltmakta hem de aradaki bir
değer unutulduğunda diğer tüm değerlerin yanlış elemanlara atanması gibi bir soruna yol
açabilmektedir. Örneğin:
------------------------------------------------------------------------------------*/
struct POINT {
    int x;
    int y;
};
struct POINT points[5] = {
        {1, 2},
        {4, 7},
        {6, 8},
        {7, 9},
        {3, 4}
};
//Burada 2 değerinin yazılmadığını düşünelim:
struct POINT points[5] = {
        {1},
        {4, 7},
        {6, 8},
        {7, 9},
        {3, 4}
};
/*----------------------------------------------------------
Artık dizinin ilk elemanının y değeri sıfır olacaktır.Ancak:
struct POINT points[5] = {1, 4, 7, 6, 8, 7, 9, 3, 4};
Burada tamamen bir kaydırma oluşmaktadır.
-------------------------------------------------------------*/
#include <stdio.h>

struct POINT {
    int x;
    int y;
};

int main(void) {
    struct POINT points[5] = {
            {1, 2},
            {4, 7},
            {6, 8},
            {7, 9},
            {3, 4}
    };
    int i;
    for (i = 0; i < sizeof(points) / sizeof(*points); ++i)
        printf("(%d, %d)\n", points[i].x, points[i].y);
    return 0;
}
/*-----------------------------------------------------------
Bir yapı dizisini de fonksiyona parametre yoluyla aktarabiliriz.
Bunun için yine onun başlangıç adresini ve uzunluğunu fonksiyona geçiririz.
------------------------------------------------------------*/
#include <stdio.h>
#include <string.h>

struct PERSON {
    char name[32];
    int no;
};
void sort_persons_byname(struct PERSON *per, int size);

void sort_persons_byno(struct PERSON *per, int size);

void disp_persons(struct PERSON *per, int size);

int main(void) {
    struct PERSON persons[] = {
            {"Mustafa Ömer Gül",      123},
            {"İrem İpek",              523},
            {"Beyza Batılı",           323},
            {"Beril Kaya",             654},
            {"Erişcan Melih Kırsoy",             234}
    };
    sort_persons_byname(persons, 5);
    disp_persons(persons, 5);
    printf("-----------\n");
    sort_persons_byno(persons, 5);
    disp_persons(persons, 5);
    return 0;
}

void sort_persons_byname(struct PERSON *per, int size) {
    int i, k;
    struct PERSON temp;
    for (i = 0; i < size - 1; ++i)
        for (k = 0; k < size - 1 - i; ++k)
            if (strcmp(per[k].name, per[k + 1].name) > 0) {
                temp = per[k];
                per[k] = per[k + 1];
                per[k + 1] = temp;
            }
}

void sort_persons_byno(struct PERSON *per, int size) {
    int i, k;
    struct PERSON temp;
    for (i = 0; i < size - 1; ++i)
        for (k = 0; k < size - 1 - i; ++k)
            if (per[k].no > per[k + 1].no) {
                temp = per[k];
                per[k] = per[k + 1];
                per[k + 1] = temp;
            }
}

void disp_persons(struct PERSON *per, int size) {
    int i;
    for (i = 0; i < size; ++i)
        printf("%s, %d\n", per[i].name, per[i].no);
}
/*---------------------------------------------
Yapı Bildirimiyle Nesne Tanımlamasının Birlikte Yapılması Bir yapı
bildirilirken bildirim ';' ile kapatılmayıp bir değişken listesi de
yazılırsa aynı zamanda o yapı türünden nesneler de tanımlanmış olur.
Örneğin:
struct POINT {
    int x, y;
} pt1, pt2;
Bu bildirimin aşağıdakinden hiçbir farkı yoktur.
struct POINT {
    int x, y;
};
struct POINT pt1, pt2;
Örneğin:
struct PERSON {
    char name[32];
    int no;
};
per = {"Berke Sertel", 123}, *pper, persons[] = {{"Kaya Sertel", 123},
                                                   {"Erişcan Melih", 345} };

Burada "per" struct PERSON türünden bir nesnedir, "pper" struct PERSON türünden bir göstericidir. persons ise
struct PERSON türünden bir dizidir. Bu biçimde bildirilmiş değişkenler yapı global olarak bildirildiyse global,
yerel olarak bildirildiyse yerel biçimdedir.
C standartlarına göre eğer yapı bildirimi ile aynı zamanda o yapı türünden nesne tanımlanıyorsa bu durumda
yapıya isim verilmeyebilir. Örneğin:
struct {
      char name[32];
      int no;
        } x, y;
Ancak eğer yapı türündne değişken tanımlanmıyorsa yapıya isim verilmek zorundadır. Örneğin:
struct { //geçersiz
      char name[32];
      int no;
        };
//İsimsiz yapıların hepsi farklı bir tür kabul edilir. Yani örneğin:
struct {
      char name[32];
      int no;
        } x;
struct {
      char name[32];
      int no;
        } y;
Burada x ve y derleyici tarafından aynı türden kabul edilmemektedir. Bu nedenle biz örneğin bunları birbirlerine
atayamayız.
İç İçe Yapı Bildirimleri
Bir yapının elemanları başka yapı türünden olabilir. Bu tür durumlara "iç içe yapı bildirimleri" denilmektedir.
-------------------------------------------------*/

struct DATE {
            int day, month, year;
        };

struct PERSON {
            char name[32];
            struct DATE bdate;
            int no;
        };
        //Örneğin:

#include <stdio.h>


    typedef struct {
            int day, month, year;
        }DATE;
    typedef struct {
            char name[32];
            struct DATE bdate;
            int no;
        }PERSON;
    int main(void)
        {
            PERSON per = {"Batuhan Menküer", {12, 10, 1970}, 2000};
            printf("%s, %d/%d/%d, %d\n", per.name, per.bdate.day, per.bdate.month, per.bdate.year, per.no);
            return 0;

        }
/*-----------------------------------------------------------
İç içe yapılarda ilkdeğer verilirken iç yapı ayrıca küme parantezine alınabilir ya da alınmayabilir. Ancak
okunabilirlik bakımından iç yapıya ilişkin değerlerin küme parantezleri içerisine alınması tavsiye edilir.
İç içe yapıların alternatif bildirim biçimi de vardır. Bu biçimde iç yapı dış yapının fiziksel olarak içerisinde
bildirilir. Örneğin:
struct PERSON {
     char name[32];
     struct DATE {
         int day, month, year;
          } bdate;
         int no;
        };
Burada dış yapı bildirimi içerisinde hem iç yapı bildirilmiş hem de o yapı türünden değişken bildirimi yapılmıştır.
Bu biçimdeki bildirimde içeride bildirilen yapı (örneğimizde struct DATE) ayrıca dış yapıdan bağımsız olarak da
kullanılabilir. Örneğin:
   struct PERSON per;
   struct DATE date;  //geçerli
Yani bu iki iç içe yapı bildirim biçimi semantik olarak tamamen eşdeğerdir. Genel olarak birinci biçimin daha
okunabilir olduğu söylenebilir.
---------------------------------------------------------*/
/*------------------------------------------------------------
Structurelarla ilgili ilginç mülakat sorusu:
Find the size of a structure without using sizeof operator in C?
(sizeof operatörünü kullanmadan bir structure'ın size of değeri nasıl bulunur.)
-----------------------------------------------------------------------*/
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

typedef struct{

    long long id;
    char str[20];
    int age;

}Data;


int main() {

    Data*dp=NULL;
    dp++;
    printf("%u",dp);
}
unions
enums
//------------------------------------------------------------------------------
Bitsel işlemler(Bitwise Operations)
->Bitsel Operatörler ve Öncelik sıraları:
2-)~ -> bitwise not(Bitsel değil) operator
........
5-)>> << ->right shift and left shift(Bitsel kaydırma operatörleri)
........
8-)& -> Bitwise and operator(Bitsel and operatörü)
9-)^ -> Bitwise XOR (Bitsel Exor)
10-)| ->Bitwise or(Bitsel veya)
........
14-)<<=  >>= &= ^= |= -> Bitwise operative assignment operator(Bitsel işlemli atama operatörleri)
........
->Bitsel değil(Bitwise Not(~))
Bir değişkenin binary yani 2'lik sistemdeki karşılığında 1 olan bitleri
0, 0 olan bitleri bir yapan operatöre bitsel değil operatörü denir.
Bir sayının binary sistemdeki değerini gösteren standart _itoa fonksiyonu
ile yazımı aşağıdaki gibidir:
void bitprint(int val){

    static char buffer[200];

    _itoa(val,buffer,2);

    printf("%032s\r",buffer);

}
/*------------------------------------------------------------------------------
Bitsel değil operatörünün örnek kullanımı
Bitsel değil operatörü bir değişkenin tüm bitlerini ters çevirir yani
0 olan bitsel 1, 1 olan bitler 0 olur.
--------------------------------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>

void bitprint(int val){

    static char buffer[200];

    _itoa(val,buffer,2);

    printf("%032s\r",buffer);

}

int main(){

    int val=10;

    bitprint(val);

    printf("\n");

    bitprint(~val);

}
//Not bitsel değil operatörünün yan etkisi yoktur.
/*------------------------------------------------------------------------------
Bitsel kaydırma operatörleri
1-)Bitsel sola kaydırma operatörü(<<)
2-)Bitsel sağa kaydırma operatörü(>>)

Önemli notlar:
1-)Bitsel sola kaydırma işleminde sağ operandın negatif değer olması tanımsız davranış
2-)Bitsel sola kaydırma işleminde sağ operandın tamsayı türünün bit sayısından büyük olması tanımsız davranış
3-)Sağdan yapılacak besleme sol operandın türünden bağımsız olarak 0

x<<y
yukarıdaki ifade x sayısının bitlerini y kadar sola kaydır demektir.
--------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>

void bitprint(int val){

    static char buffer[200];

    _itoa(val,buffer,2);

    printf("%032s\r",buffer);

}

int main(){

    int val=10;

    bitprint(val);//0000 0000 0000 0000 0000 0000 0000 1010

    printf("\n");

    bitprint(val<<2);//0000 0000 0000 0000 0000 0000 0010 1000

    printf("\n");

    bitprint(val);//0000 0000 0000 0000 0000 0000 0000 1010(yan etki söz konusu değildir.)

}

/*------------------------------------------------------------------------------
val değişkenini değiştirmek için sağa kaydırma operatörü işlemli atama
operatörü ile kullanılmalıdır.
--------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>

void bitprint(int val){

    static char buffer[200];

    _itoa(val,buffer,2);

    printf("%032s\r",buffer);

}

int main(){

    int val=10;

    bitprint(val);//0000 0000 0000 0000 0000 0000 0000 1010

    printf("\n");

    val<<=2;

    bitprint(val);//0000 0000 0000 0000 0000 0000 0010 1000



}
/*------------------------------------------------------------------------------
Önemli notlar:
işaretsiz tamsayı türleri için her zaman besleme(feeding) 0 ile yapılır.
işaretli tamsayı türleri için :
    ->sol operand pozitif değerde ise:
        her zaman besleme(feeding) 0 ile yapılır.
    ->sol operand negatif değerde ise:
        derleyiciye bağlı olarak besleme 0 ya da 1 biti ile yapılır.
        (sign extension)
--------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>

void bitprint(int val){

    static char buffer[200];

    _itoa(val,buffer,2);

    printf("%032s\r",buffer);

}

int main(){

    int val=-1;

    bitprint(val);

    printf("\n");

    val<<=-2;

    bitprint(val);



}
/*------------------------------------------------------------------------------
Sağa kaydırma operatörünün özellikleri de sola kaydırma operatörüyle genel olarak aynıdır.
tek fark adından da anlaşılacağı gibi sayının bitlerini sola değil sağa
kaydırır. beslemeler sağ operandın pozitif olması durumunda daima 0 ile
yapılır.
Önemli Not:Bitsel sağa kaydırma operatörüyle bir sayı 2 kaydırmak
o sayıyı 4 e bölmeye eşittir. Kısacası iki üzeri kaydırma sayısı gibi
bir genel formül düşünülebilir. Aynı durumun tersi sola kaydırma için de
geçerlidir yani bir sayıyı 2 sola kaydırmak 4 ile çarpmak anlamına gelmektedir.
#include <stdio.h>

int main() {
    int val = 10;
    printf("%d\n", val / 4 == val >> 2);
    printf("%d\n", val * 4 == val << 2);
}
--------------------------------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>

void bitprint(int val){

    static char buffer[200];

    _itoa(val,buffer,2);

    printf("%032s\r",buffer);

}

int main(){

    int val=10;

    bitprint(val);//0000 0000 0000 0000 0000 0000 0000 1010

    printf("\n");

    val>>=2;

    bitprint(val);//0000 0000 0000 0000 0000 0000 0000 0010

}
/*------------------------------------------------------------------------------
Bitsel and(ve(&)) operatörü:
Bu operatör adres operatörü ile karıştırılmamalıdır. Ayırt etmenin ek basit
yolu adres operatörü unary kullanıma gerek duyarken bitsel and her zaman
binary kullanılmalıdır. Çalışması Logical and operator(Mantıksal ve operatörü)
benzemektedir.
Bitsel and in işlemlerdeki genel davranışı:
en az bir bit 0 ise sonuç olarak 0,2 bit de 1 se 1 biti üreten operatöre
bitsel and denir.
Aşağıdaki örnekte bitsel and için örnek bir kullanım
gösterilmiştir.
10 ve 20 sayılarının farklı bitleri 1 olduğu için bütün bitler sıfırlanmıştır!
--------------------------------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>

void bitprint(int val){

    static char buffer[200];

    _itoa(val,buffer,2);

    printf("%032s\r",buffer);

}

int main(){


    int val1=20,val2=10;

    bitprint(val1);//0000 0000 0000 0000 0000 0000 0001 0100

    printf("\n");

    bitprint(val2);//0000 0000 0000 0000 0000 0000 0000 1010

    printf("\n");

    if (val1 && val2)
        printf("True for logical and\n");
    if (val1 & val2)
        printf("True for bitwise and");
    else
        printf("False for bitwise and");


}
/*------------------------------------------------------------------------------
Bitsel or(veya(|)) operatörü
Bu operatörün özellik elbette mantıksal veya operatörüne(Logical or operator)
benzemektedir. Ondan farklı olarak işi sayıların kendileri ile değil
sayıların bitleriyledir. Tahmin edileceği gibi çalışması bitsel üzerinde
mantıksal veya ile aynıdır yani işlem yapılan o aynı sıradaki bitlerden
en az biri doğruyla(1 se) doğru(1) değer üreten , ikiside yanlışsa(0 ise)
yanlış(0) üreten bir operatördür.
--------------------------------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>

void bitprint(int val){

    static char buffer[200];

    _itoa(val,buffer,2);

    printf("%032s\r",buffer);

}

int main(){


    int val1=20,val2=10;

    bitprint(val1);//0000 0000 0000 0000 0000 0000 0001 0100

    printf("\n");

    bitprint(val2);//0000 0000 0000 0000 0000 0000 0000 1010

    printf("\n");

    bitprint(val1 | val2);//0000 0000 0000 0000 0000 0000 0001 1110

}
/*------------------------------------------------------------------------------
Bitsel özel veya(Bitwise ex-or veya Bitwise exclusive or(^))
aynı numaralı bitler eğer farklı ise 1, aynı ise 0 değerini üreten
bitsel operatöre bitsel özel veya operatörü denir.
--------------------------------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>

void bitprint(int val){

    static char buffer[200];

    _itoa(val,buffer,2);

    printf("%032s\r",buffer);

}

int main(){


    int val1=20,val2=10;

    bitprint(val1);//0000 0000 0000 0000 0000 0000 0001 0100

    printf("\n");

    bitprint(val2);//0000 0000 0000 0000 0000 0000 0000 1010

    printf("\n");

    bitprint(val1 | val2);//0000 0000 0000 0000 0000 0000 0001 1110

}
/*------------------------------------------------------------------------------
Bitsel özel veya kullanılarak iki değişkeni geçici değişken olmadan
takas etmek mümkündür.Bu soru mülakatların en klasik sorularından bir tanesidir.
--------------------------------------------------------------------------*/
#include <stdio.h>

int main() {

    int a=30,b=20;

    a^=b;
    b^=a;
    a^=b;

    printf("a:%d b:%d",a,b);
}
/*------------------------------------------------------------------------------
Aynı sorunun macro haline getirilmiş biçimi
--------------------------------------------------------------------------*/
#include <stdio.h>

#define xor_swap(a,b)  ((a)^=(b),(b)^=(a),(a)^=(b));

int main() {

    int a=30,b=20;

    xor_swap(a,b);

    printf("a:%d b:%d",a,b);
}
/*------------------------------------------------------------------------------
Bitsel operatörlerin kullanılmasıyla yapılan tipik işlemler

bitwise manipulations

Bit sayının n'inci bitini birlemek
(to set the bit veya to turn the bit on)
Bunun en basit yolu 1'i n kadar sola kaydırıp söz konusu sayı ile or işlemine sokmaktır.
Aşağıdaki gibi:
x |= (1<<n);
--------------------------------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>

void bitprint(int val){

    static char buffer[200];

    _itoa(val,buffer,2);

    printf("%032s\r",buffer);

}

int main(){


    int val=20;
    int n;
    printf("Kacinci bit 1 yapilsin?");
    scanf("%d",&n);//6 giriliyor
    bitprint(val);//0000 0000 0000 0000 0000 0000 0001 0100
    printf("\n");
    val|=1<<n;
    bitprint(val);//0000 0000 0000 0000 0000 0000 0101 0100



}
/*------------------------------------------------------------------------------
Bir sayının n. bitini 0 yapmak
(to reset the bit veya to turn the bit off veya to clear the bit)
Bu işlem bir sayısını x kadar sola kaydırıp o sayının bitsel
değilini alıp sayıyı bitsel and işlemine sokarak
yapılabilir yani:
val &= ~(1<<n);
--------------------------------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>

void bitprint(int val){

    static char buffer[200];

    _itoa(val,buffer,2);

    printf("%032s\r",buffer);

}

int main(){


    int val=20;
    int n;
    printf("Kacinci bit 0 yapilsin?");
    scanf("%d",&n);//2 giriliyor
    bitprint(val);//0000 0000 0000 0000 0000 0000 0001 0100
    printf("\n");
    val&=~(1<<n);
    bitprint(val);//0000 0000 0000 0000 0000 0000 0001 0000

}
/*------------------------------------------------------------------------------
Bir sayının n.bitini değiştirmek
(to switch the bit veya to toggle the bit):
Bu işlem için 1 sayısını n kadar sola kaydırıp
özel veya operatörü ile işleme alınırsa o bit
değiştirilmiş olur yani aşağıdaki gibi:
val^=1<<n;
--------------------------------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>

void bitprint(int val){

    static char buffer[200];

    _itoa(val,buffer,2);

    printf("%032s\r",buffer);

}

int main(){


    int val=20;
    int n;
    printf("Kacinci bit 0 yapilsin?");
    scanf("%d",&n);//2 giriliyor
    bitprint(val);//0000 0000 0000 0000 0000 0000 0001 0100
    printf("\n");
    val&=~(1<<n);
    bitprint(val);//0000 0000 0000 0000 0000 0000 0001 0000

}
/*------------------------------------------------------------------------------
Soru:Bir tamsayının bitlerini bitsel operatörleri kullanarak yazdıran myBitPrint
isimli fonksiyon standart itoa fonksiyonunu kullanmadan yazınız.
--------------------------------------------------------------------------*/
#include <stdio.h>

void myBitPrint(){

    for(int i=(int)(sizeof(x)*CHAR_BIT-1);i>=0;--i)
        putchar((x>>i) & 1 ? '1':'0');
    putchar('\n');

}

int main(){

    int x;
    printf("Bir tamsayi giriniz?");
    scanf("%d",&x);

}
/*------------------------------------------------------------------------------
mod operatörü olmadan sayının tek mi çift mi olduğunu anlamak için güzel
bir yöntem
aşağıdaki örneğe göre if(x % 2 != 0) demek ile
if(x & 1) demek aynı anlama gelmektedir çünkü birinci bitin bir olması demek
o sayının 1 olması anlamına gelir.
--------------------------------------------------------------------------*/
#include <stdio.h>

int main(){


    int val;
    printf("Bir sayi giriniz?");
    scanf("%d",&val);

    if(val & 1)
        printf("Sayi tek");
    else
        printf("Sayi cift");

}
/*------------------------------------------------------------------------------
little endian bir sistemi big endian yapan veya big endian bir sistemi
little endian haline getiren Swap4Bytes isimli macroyu yazınız ve test ediniz?
little endian ve big endian kavramlarını kısaca hatırlarsak:
örneğin 0x12345678 sayısını iki farklı şekilde
--------------------------------------------------------------------------*/
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <inttypes.h>
#include <stdbool.h>


int main(){

    bool b=true;
    uint32_t x = 0x11223344;
    uint8_t* ptr;

    ptr = (uint8_t *)&x;

    if( *ptr == 0x11 ){
        printf("big endian\n");
    }
    else if( *ptr == 0x44){
        printf("little endian");
    }
    return 0;

}
/*------------------------------------------------------------------------------
bu durumdan da alaşılacağı gibi 0x11 most significant bytetır.
0x44 ise least significant bytedır. eğer sistemde bunlar tutulurken
most significant byte ilk baştaki adreste tutuluyorsa buna big endian
eğer least significant byte ilk adres tutuluyorsa buna little endian denir.
Bunu bir macro olarak yazmak gerekirse aşağıdaki yöntem kullanılabilir:

#define Swap4Bytes(x)  ((((x)>>24)& 0x000000FF) | \
                        (((x)>>8)& 0x0000FF00)  |  \
                        (((x)<<8)& 0x00FF0000)  |   \
                        ((x) <<24))
--------------------------------------------------------------------------*/
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <inttypes.h>
#include <stdbool.h>
#define Swap4Bytes(x)  ((((x)>>24)& 0x000000FF) | \
                        (((x)>>8)& 0x0000FF00)  |  \
                        (((x)<<8)& 0x00FF0000)  |   \
                        ((x) <<24))


int main(){

    bool b=true;
    uint32_t x = 0x11223344;
    uint8_t* ptr;

    ptr = (uint8_t *)&x;

    if( *ptr == 0x11 ){
        printf("big endian\n");
    }
    else if( *ptr == 0x44){
        printf("little endian\n");
    }
    x=Swap4Bytes(x);
    ptr = (uint8_t *)&x;
    if( *ptr == 0x11 ){
        printf("big endian\n");
    }
    else if( *ptr == 0x44){
        printf("little endian\n");
    }
    return 0;

}

//------------------------------------------------------------
/*--------------------------------------------------------------
Dosya işlemleri (file operations)
C programlama dilinde, dosya açma işlemleri için kullanılan birkaç farklı dosya açma modu vardır.
Bu modlar, dosyanın açılma amacına ve okuma/yazma işlemlerine izin verip vermemelerine göre değişir.
İşte C'de kullanılan dosya açma tiplerinin birkaç örneği:

1-) "r" (read): Bu mod, bir dosyayı okumak için kullanılır.
Dosya varsa açılır ve okunabilir, aksi halde bir hata oluşur.

2-) "w" (write): Bu mod, bir dosyaya yazmak için kullanılır.
Eğer dosya varsa içeriği silinir ve dosya yazılamazsa bir hata oluşur. Dosya yoksa oluşturulur.

3-) "a" (append): Bu mod, bir dosyaya yazmak için kullanılır.
Eğer dosya varsa dosyanın sonuna ekleme yapılır, yoksa dosya oluşturulur.

4-) "rb" (read binary): Bu mod, ikili dosyaları okumak için kullanılır.
Dosya varsa açılır ve okunabilir, aksi halde bir hata oluşur.

5-) "wb" (write binary): Bu mod, ikili dosyalara yazmak için kullanılır.
Eğer dosya varsa içeriği silinir ve dosya yazılamazsa bir hata oluşur.
Dosya yoksa oluşturulur.

6-) "ab" (append binary): Bu mod, ikili dosyalara yazmak için kullanılır.
Eğer dosya varsa dosyanın sonuna ekleme yapılır, yoksa dosya oluşturulur.

Bu modlar, dosya açma fonksiyonu fopen() içinde kullanılır.
Örneğin, "r" modunda bir dosya açmak için şu şekilde kullanılır:

FILE *dosya;
dosya = fopen("dosya.txt", "r");
if (dosya == NULL) {
  printf("Dosya açılamadı.");
}
else {
  // Dosya açıldı ve okuma işlemleri yapılabilir.
}

Dosyadan okuma yapmak için fprintf fonksiyonu aşağıdaki gibi kullanılır:

fprintf(<dosya>,<format>,<yazdırılacak ifade>);

sprintf fonksiyonu kullanılarak istenilen bir buffera yazma gerçekleştirilebilir.


---------------------------------------------------------------*/

#include <stdio.h>
#include <stdbool.h>
#include <string.h>

int isPrime(int val)
{
    if(val <= 1)
        return false;
    if(val % 2 == 0)
        return val == 2;
    if(val % 3 == 0)
        return val == 3;
    if(val % 5 == 0)
        return val == 5;
    if(val % 7 == 0)
        return val == 7;
    for (int i = 11; i * i < val ; ++i) {
        if(val % i == 0)
            return false;
    }
    return true;
}


int main(void)
{
    FILE* f = fopen("Primes.txt","w");
    for (int i = 0; i < 200; ++i) {
        if (isPrime(i))
            fprintf(f, "%d ",i);
    }
}